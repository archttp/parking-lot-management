package com.cf.forward.dh.lib;

import com.cf.forward.dh.lib.enumeration.EM_FILTER_IMAGE_TYPE;
import com.cf.forward.dh.lib.structure.*;
import com.sun.jna.*;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.win32.StdCallLibrary.StdCallCallback;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
/**
 * NetSDK JNA接口封装
 */
public interface NetSDKLib extends Library {

    NetSDKLib NETSDK_INSTANCE = Native.load(LibraryLoad.getLoadLibrary("dhnetsdk"), NetSDKLib.class);

    NetSDKLib CONFIG_INSTANCE = Native.load(LibraryLoad.getLoadLibrary("dhconfigsdk"), NetSDKLib.class);

    //NetSDKLib CONFIG_JNI = (NetSDKLib)Native.loadLibrary(util.getLoadLibrary("JNI1.dll"), INetSDK.class);
    class LLong extends IntegerType {
        private static final long serialVersionUID = 1L;

        /** Size of a native long, in bytes. */
        public static int size;
        static {
            size = Native.LONG_SIZE;
            if (Utils.getOsPrefix().equalsIgnoreCase("linux-amd64")
                    || Utils.getOsPrefix().equalsIgnoreCase("win32-amd64")
                    || Utils.getOsPrefix().equalsIgnoreCase("mac-64")) {
                size = 8;
            } else if (Utils.getOsPrefix().equalsIgnoreCase("linux-i386")
                    || Utils.getOsPrefix().equalsIgnoreCase("win32-x86")) {
                size = 4;
            }
        }

        /** Create a zero-valued LLong. */
        public LLong() {
            this(0);
        }

        /** Create a LLong with the given value. */
        public LLong(long value) {
            super(size, value);
        }
    }
    public static class SdkStructure extends Structure {
        @Override
        protected  List<String> getFieldOrder(){
            List<String> fieldOrderList = new ArrayList<String>();
            for (Class<?> cls = getClass();
                 !cls.equals(SdkStructure.class);
                 cls = cls.getSuperclass()) {
                Field[] fields = cls.getDeclaredFields();
                int modifiers;
                for (Field field : fields) {
                    modifiers = field.getModifiers();
                    if (Modifier.isStatic(modifiers) || !Modifier.isPublic(modifiers)) {
                        continue;
                    }
                    fieldOrderList.add(field.getName());
                }
            }
            //            System.out.println(fieldOrderList);

            return fieldOrderList;
        }

        @Override
        public int fieldOffset(String name){
            return super.fieldOffset(name);
        }
    }

    /************************************************************************
     ** 常量定义
     ***********************************************************************/
    public static final int NET_SERIALNO_LEN                      = 48;             // 设备序列号字符长度
    public static final int NET_CFG_Max_VideoColor                = 24;             // 每个通道最大视频输入颜色配置数量
    public static final int NET_CFG_Custom_Title_Len              = 1024;           // 自定义标题名称长度(扩充到1024)
    public static final int NET_CFG_Custom_TitleType_Len          = 32;             // 自定义标题类型长度
    public static final int NET_CFG_Max_Video_Widget_Cover        = 16;             // 编码区域覆盖最大数量
    public static final int NET_CFG_Max_Video_Widget_Custom_Title = 8;              // 编码物件自定义标题最大数量
    public static final int NET_CFG_Max_Video_Widget_Sensor_Info  = 2;              // 编码物件叠加传感器信息的最大数目
    public static final int NET_CFG_Max_Description_Num           = 4;              // 叠加区域描述信息的最大个数

    // 错误类型代号，对应CLIENT_GetLastError接口的返回值, 十进制

    // CLIENT_StartListenEx报警事件
    public static final int NET_ALARM_ALARM_EX 					= 0x2101;     		// 外部报警，数据字节数与设备报警通道个数相同，每个字节表示一个报警通道的报警状态，1为有报警，0为无报警。
    public static final int NET_MOTION_ALARM_EX                	= 0x2102;          	// 动态检测报警，数据字节数与设备视频通道个数相同，每个字节表示一个视频通道的动态检测报警状态，1为有报警，0为无报警。
    public static final int NET_VIDEOLOST_ALARM_EX 				= 0x2103; 			// 视频丢失报警，数据字节数与设备视频通道个数相同，每个字节表示一个视频通道的视频丢失报警状态，1为有报警，0为无报警。
    public static final int NET_SHELTER_ALARM_EX 				= 0x2104;   		// 视频遮挡报警，数据字节数与设备视频通道个数相同，每个字节表示一个视频通道的遮挡(黑屏)报警状态，1为有报警，0为无报警。
    public static final int NET_DISKFULL_ALARM_EX 				= 0x2106;  			// 硬盘满报警，数据为1个字节，1为有硬盘满报警，0为无报警。
    public static final int NET_DISKERROR_ALARM_EX 				= 0x2107; 			// 坏硬盘报警，数据为32个字节，每个字节表示一个硬盘的故障报警状态，1为有报警，0为无报警。
    public static final int NET_TRAF_CONGESTION_ALARM_EX        = 0x211A;           // 交通阻塞报警(车辆出现异常停止或者排队)(对应结构体 ALARM_TRAF_CONGESTION_INFO)
    public static final int NET_ALARM_ACC_POWEROFF              = 0x211E;           // ACC断电报警，数据为 DWORD 0：ACC通电 1：ACC断电
    public static final int NET_ALARM_3GFLOW_EXCEED             = 0x211F;          // 3G流量超出阈值报警(对应结构体 DHDEV_3GFLOW_EXCEED_STATE_INFO)
    public static final int NET_ALARM_ENCLOSURE                 = 0x2126;           // 电子围栏报警(对应结构体 ALARM_ENCLOSURE_INFO)
    public static final int NET_ALARM_RAID_STATE				= 0x2128;           // RAID异常报警(对应结构体 ALARM_RAID_INFO)
    public static final int NET_ALARM_TRAFFIC_FLUX_STAT         = 0x212E;           // 交通流量统计报警(对应结构体ALARM_TRAFFIC_FLUX_LANE_INFO)
    public static final int NET_ALARM_FRONTDISCONNECT           = 0x2132;           // 前端IPC断网报警(对应结构体 ALARM_FRONTDISCONNET_INFO)
    public static final int NET_ALARM_BATTERYLOWPOWER 			= 0x2134;      		// 电池电量低报警(对应结构体 ALARM_BATTERYLOWPOWER_INFO)
    public static final int NET_ALARM_TEMPERATURE 				= 0x2135;  			// 温度过高报警(对应结构体 ALARM_TEMPERATURE_INFO)
    public static final int NET_ALARM_STORAGE_FAILURE_EX        = 0x2163;           // 存储错误报警(对应结构体 ALARM_STORAGE_FAILURE_EX)
    public static final int NET_ALARM_TALKING_INVITE            = 0x2171;           // 设备请求对方发起对讲事件(对应结构体  ALARM_TALKING_INVITE_INFO)
    public static final int NET_ALARM_ALARM_EX2 				= 0x2175;    		// 本地报警事件(对应结构体ALARM_ALARM_INFO_EX2,对NET_ALARM_ALARM_EX升级)
    public static final int NET_ALARM_IPC                       = 0x218c;           // IPC报警,IPC通过DVR或NVR上报的本地报警(对应结构体 ALARM_IPC_INFO)
    public static final int NET_EVENT_VIDEOABNORMALDETECTION    = 0x218e;           // 视频异常事件(对应ALARM_VIDEOABNORMAL_DETECTION_INFO)
    public static final int NET_CONFIG_RESULT_EVENT_EX          = 0x3000;           // 修改配置的返回码；返回结构见 DEV_SET_RESULT
    public static final int NET_START_LISTEN_FINISH_EVENT           = 0x300c;           // 订阅事件接口完成异步通知事件, 信息为 START_LISTEN_FINISH_RESULT_INFO
    public static final int NET_ALARM_STORAGE_NOT_EXIST         = 0x3167;           // 存储组不存在事件(对应结构体 ALARM_STORAGE_NOT_EXIST_INFO)
    public static final int NET_ALARM_SCADA_DEV_ALARM           = 0x31a2;           // 检测采集设备报警事件(对应结构体 ALARM_SCADA_DEV_INFO)
    public static final int NET_ALARM_PARKING_CARD				= 0x31a4;			// 停车刷卡事件(对应结构体  ALARM_PARKING_CARD)
    public static final int NET_ALARM_VEHICLE_ACC               = 0x31a6;           // 车辆ACC报警事件(对应结构体 ALARM_VEHICLE_ACC_INFO)
    public static final int NET_ALARM_HEATIMG_TEMPER            = 0x31aa;           // 热成像测温点温度异常报警事件(对应结构体 ALARM_HEATIMG_TEMPER_INFO)
    public static final int NET_ALARM_NEW_FILE                  = 0x31b3;           // 新文件事件(对应 ALARM_NEW_FILE_INFO)
    public static final int NET_ALARM_HUMAM_NUMBER_STATISTIC    = 0x31cc;           // 人数量/客流量统计事件 (对应结构体 ALARM_HUMAN_NUMBER_STATISTIC_INFO)
    public static final int NET_ALARM_ARMMODE_CHANGE_EVENT      = 0x3175;			// 布撤防状态变化事件(对应结构体 ALARM_ARMMODE_CHANGE_INFO)
    public static final int NET_ALARM_ACCESS_CTL_NOT_CLOSE      = 0x3177;           // 门禁未关事件(对应结构体 ALARM_ACCESS_CTL_NOT_CLOSE_INFO)
    public static final int NET_ALARM_ACCESS_CTL_BREAK_IN       = 0x3178;           // 闯入事件(对应结构体 ALARM_ACCESS_CTL_BREAK_IN_INFO)
    public static final int NET_ALARM_ACCESS_CTL_EVENT          = 0x3181;           // 门禁事件(对应结构体 ALARM_ACCESS_CTL_EVENT_INFO)
    public static final int NET_URGENCY_ALARM_EX2               = 0x3182;           // 紧急报警EX2(对 NET_URGENCY_ALARM_EX 的升级,对应结构体 ALARM_URGENCY_ALARM_EX2, 人为触发的紧急事件, 一般处理是联动外部通讯功能请求帮助
    public static final int NET_ALARM_ACCESS_CTL_STATUS         = 0x3185;           // 门禁状态事件(对应结构体 ALARM_ACCESS_CTL_STATUS_INFO)
    public static final int NET_ALARM_ALARMCLEAR                = 0x3187;           // 消警事件(对应结构体  ALARM_ALARMCLEAR_INFO )
    public static final int NET_ALARM_RCEMERGENCY_CALL          = 0x318b;  			// 紧急呼叫报警事件(对应结构体 ALARM_RCEMERGENCY_CALL_INFO)
    public static final int NET_ALARM_FINGER_PRINT              = 0x318d;           // 获取指纹事件(对应结构体 ALARM_CAPTURE_FINGER_PRINT_INFO)
    public static final int NET_ALARM_MODULE_LOST               = 0x3195;           // 扩展模块掉线事件(对应结构体 ALARM_MODULE_LOST_INFO)
    public static final int NET_ALARM_ENCLOSURE_ALARM      		= 0x319B;  			// 电子围栏事件(对应结构体 ALARM_ENCLOSURE_ALARM_INFO)
    public static final int NET_ALARM_BUS_SHARP_ACCELERATE      = 0x31ae;           // 车辆急加速事件(对应结构体 ALARM_BUS_SHARP_ACCELERATE_INFO)
    public static final int NET_ALARM_BUS_SHARP_DECELERATE      = 0x31af;           // 车辆急减速事件(对应结构体 ALARM_BUS_SHARP_DECELERATE_INFO)
    public static final int NET_ALARM_ACCESS_CARD_OPERATE       = 0x31b0;           // 门禁卡数据操作事件(对应结构体ALARM_ACCESS_CARD_OPERATE_INFO)
    public static final int NET_ALARM_FIREWARNING               = 0x31b5;           // 热成像着火点事件 (对应结构体 ALARM_FIREWARNING_INFO)
    public static final int NET_ALARM_WIFI_SEARCH               = 0x31c7;           // 获取到周围环境中WIFI设备上报事件(对应结构体 ALARM_WIFI_SEARCH_INFO)
    public static final int NET_ALARM_WIFI_SEARCH_EX			= 0x8000;          // 获取到周围环境中WIFI设备上报事件(对应结构体 ALARM_WIFI_SEARCH_INFO_EX)
    public static final int NET_ALARM_HOTSPOT_WARNING           = 0X31d8;           // 热成像热点异常报警(对应结构体 ALARM_HOTSPOT_WARNING_INFO)
    public static final int NET_ALARM_COLDSPOT_WARNING          = 0X31d9;           // 热成像冷点异常报警(对应结构体 ALARM_COLDSPOT_WARNING_INFO)
    public static final int NET_ALARM_FIREWARNING_INFO          = 0X31da;           // 热成像火情报警信息上报(对应结构体 ALARM_FIREWARNING_INFO_DETAIL)
    public static final int NET_ALARM_RADAR_HIGH_SPEED          = 0x31df;           // 雷达监测超速报警事件 智能楼宇专用 (对应结构体 ALARM_RADAR_HIGH_SPEED_INFO)
    public static final int NET_ALARM_RAID_STATE_EX             = 0x31fc;           // RAID异常报警(对应结构体 ALARM_RAID_INFO_EX)
    public static final int NET_ALARM_STORAGE_IPC_FAILURE       = 0x31fd;           // IPC的存储介质故障事件(IPC SD卡异常)(对应结构体 ALARM_STORAGE_IPC_FAILURE_INFO)
    public static final int NET_ALARM_POLLING_ALARM             = 0x31e0;           // 设备巡检报警事件 智能楼宇专用 (对应结构体 ALARM_POLLING_ALARM_INFO)
    public static final int NET_ALARM_TRAFFICSTROBESTATE        = 0x31e2;           // 道闸栏状态事件(对应结构体 ALARM_TRAFFICSTROBESTATE_INFO)
    public static final int NET_ALARM_WIFI_VIRTUALINFO_SEARCH   = 0x31ef;           // WIFI虚拟身份上报事件(对应结构体 ALARM_WIFI_VIRTUALINFO_SEARCH_INFO)
    public static final int NET_ALARM_GPS_NOT_ALIGNED           = 0x321d;           // GPS未定位报警(对应结构体 ALARM_GPS_NOT_ALIGNED_INFO)
    public static final int NET_ALARM_VIDEOBLIND                = 0x323e;           // 视频遮挡事件(对应结构体 ALARM_VIDEO_BLIND_INFO)
    public static final int NET_ALARM_DRIVER_NOTCONFIRM         = 0x323f;           // 司机未按确认按钮报警事件(对应结构体 ALARM_DRIVER_NOTCONFIRM_INFO)
    public static final int NET_ALARM_FACEINFO_COLLECT          = 0x3240;           // 人脸信息录入事件(对应 ALARM_FACEINFO_COLLECT_INFO)
    public static final int NET_ALARM_HIGH_SPEED	            = 0x3241;			// 车辆超速报警事件(对应 ALARM_HIGH_SPEED_INFO )
    public static final int NET_ALARM_VIDEO_LOSS                = 0x3242;			// 视频丢失事件(对应 ALARM_VIDEO_LOSS_INFO )
    public static final int NET_ALARM_DOWNLOAD_REMOTE_FILE		= 0x3301;			// 下载远程文件事件(对应 ALARM_DOWNLOAD_REMOTE_FILE_INFO)
    public static final int NET_ALARM_TRAFFIC_LINKAGEALARM		= 0x3353;			// 各种违章事件联动报警输出事件(对应结构体 ALARM_TRAFFIC_LINKAGEALARM_INFO)
    public static final int NET_ALARM_LABELINFO					= 0x3233;			// IPC新增(2017.4),RFID标签信息采集事件(对应结构体 ALARM_LABELINFO)
    public static final int NET_ALARM_FLOATINGOBJECT_DETECTION  = 0x3442;			// 漂浮物检测事件(对应结构体 ALARM_FLOATINGOBJECT_DETECTION_INFO)
    public static final int NET_ALARM_WATER_LEVEL_DETECTION		= 0x3443;			// 水位检测事件(对应结构体 ALARM_WATER_LEVEL_DETECTION_INFO)
    public static final int NET_ALARM_TRAFFIC_JUNCTION			= 0x3445;			// 交通路口事件(对应结构体 ALARM_TAFFIC_JUNCTION_INFO)
    public static final int NET_EVENT_CROSSLINE_DETECTION  		= 0x2188;  			// 警戒线事件( 对应结构体 ALARM_EVENT_CROSSLINE_INFO )
    public static final int NET_EVENT_CROSSREGION_DETECTION 	= 0x2189;  			// 警戒区事件( 对应结构体 ALARM_EVENT_CROSSREGION_INFO )
    public static final int NET_ALARM_POWERFAULT           		= 0x3172;  			// 电源故障事件(对应结构体ALARM_POWERFAULT_INFO)
    public static final int NET_ALARM_CHASSISINTRUDED      		= 0x3173;  			// 机箱入侵(防拆)报警事件(对应结构体ALARM_CHASSISINTRUDED_INFO)
    public static final int NET_ALARM_BYPASSMODE_CHANGE_EVENT 	= 0x3176;  			// 旁路状态变化事件(对应结构体ALARM_BYPASSMODE_CHANGE_INFO)
    public static final int NET_ALARM_ACCESS_CTL_REPEAT_ENTER 	= 0x3179;  			// 反复进入事件(对应结构体ALARM_ACCESS_CTL_REPEAT_ENTER_INFO)
    public static final int NET_ALARM_ACCESS_CTL_DURESS    		= 0x3180;  			// 胁迫卡刷卡事件(对应结构体ALARM_ACCESS_CTL_DURESS_INFO)
    public static final int NET_ALARM_INPUT_SOURCE_SIGNAL  		= 0x3183;  			// 报警输入源信号事件(只要有输入就会产生该事件, 不论防区当前的模式,无法屏蔽, 对应 ALARM_INPUT_SOURCE_SIGNAL_INFO )
    public static final int NET_ALARM_OPENDOORGROUP        		= 0x318c;  			// 多人组合开门事件(对应结构体ALARM_OPEN_DOOR_GROUP_INFO)
    public static final int NET_ALARM_SUBSYSTEM_STATE_CHANGE 	= 0x318f;  			// 子系统状态改变事件(对应结构体ALARM_SUBSYSTEM_STATE_CHANGE_INFO)
    public static final int NET_ALARM_PSTN_BREAK_LINE      		= 0x3196;  			// PSTN掉线事件(对应结构体ALARM_PSTN_BREAK_LINE_INFO)
    public static final int NET_ALARM_DEFENCE_ARMMODE_CHANGE 	= 0x31d2;  			// 防区布撤防状态改变事件(对应结构体 ALARM_DEFENCE_ARMMODECHANGE_INFO)
    public static final int NET_ALARM_SUBSYSTEM_ARMMODE_CHANGE 	= 0x31d3;  			// 子系统布撤防状态改变事件(对应结构体 ALARM_SUBSYSTEM_ARMMODECHANGE_INFO)
    public static final int NET_ALARM_SENSOR_ABNORMAL      		= 0x31dc;  			// 探测器异常报警(对应结构体 ALARM_SENSOR_ABNORMAL_INFO)
    public static final int NET_ALARM_CROWD_DETECTION			= 0x3305;			// 人群密度检测事件(对应结构体 ALARM_CROWD_DETECTION_INFO)
    public static final int NET_ALARM_CITIZEN_PICTURE_COMPARE   = 0x330d;           // 人证比对事件(对应结构体 ALARM_CITIZEN_PICTURE_COMPARE_INFO)
    public static final int NET_ALARM_MAN_NUM_DETECTION         = 0x3223;            // 立体视觉区域内人数统计报警(对应结构体ALARM_MAN_NUM_INFO)
    public static final int NET_ALARM_ENGINE_FAILURE_STATUS		= 0x344F;			// 发动机故障状态上报(对应 ALARM_ENGINE_FAILURE_STATUS_INFO)
    public static final int NET_ALARM_ANATOMY_TEMP_DETECT		= 0x3454;			// 人体温智能检测事件(对应结构体 ALARM_ANATOMY_TEMP_DETECT_INFO)
    public static final int NET_ALARM_REGULATOR_ABNORMAL		= 0x3455;			// 标准黑体源异常报警事件(对应结构体 ALARM_REGULATOR_ABNORMAL_INFO)
    public static final int NET_ALARM_QR_CODE_CHECK             = 0x335a;           // 二维码上报事件(对应结构体 ALARM_QR_CODE_CHECK_INFO)
    public static final int NET_ALARM_TRAFFIC_XINKONG			= 0x335f;		    // 交通态势报警事件（对接结构体 ALARM_TRAFFIC_XINKONG_INFO）

    public static final int NET_ALARM_TRAFFIC_PARKING_TIMEOUT	= 0x334C;			// 停车时长超限事件（对应的结构体 ALARM_TRAFFIC_PARKING_TIMEOUT_INFO）
    public static final int NET_ALARM_TRAFFIC_SUSPICIOUSCAR     = 0x31a7;           // 嫌疑车辆上报事件(对应结构体 ALARM_TRAFFIC_SUSPICIOUSCAR_INFO)
    public static final int NET_ALARM_PARKING_LOT_STATUS_DETECTION = 0x3451;        // 室外停车位状态检测事件 (对应结构体 ALARM_REGION_PARKING_TIMEOUT_INFO)
    public static final int NET_ALARM_REGION_PARKING_TIMEOUT	= 0x3460;   		// 区间车位停车超时（对应结构体 ALARM_REGION_PARKING_TIMEOUT_INFO）
    public static final int NET_ALARM_REGION_PARKING_NO_ENTRY_RECORD = 0x3461;  	// 区间车位停车，检测到车辆驶出区域时没有匹配到入场信息(对应结构体 ALARM_REGION_PARKING_NO_ENTRY_RECORD_INFO)
    public static final int NET_ALARM_TRAFFIC_LIGHT_STATE		= 0x3458;   		// 交通灯状态报警(对应 ALARM_TRAFFIC_LIGHT_STATE_INFO)
    public static final int NET_ALARM_VEHICLE_INOUT             = 0x346A;           // 车辆出入事件(对应结构体 ALARM_VEHICLE_INOUT_INFO)
    public static final int NET_ALARM_FIRE_DETECTION			= 0x343D;			// 火警事件（对于的结构体 ALARM_FIRE_DETECTION_INFO）
    

    // 订阅Bus状态对应事件上报(CLIENT_AttachBusState)
    public static final int NET_ALARM_BUS_PASSENGER_CARD_CHECK  = 0x0009;           // 乘客刷卡事件(对应结构体 ALARM_PASSENGER_CARD_CHECK )

    // 帧类型掩码定义
    public static final int FRAME_TYPE_MOTION                   = 0x00000001;       // 动检帧


    // CLIENT_RealLoadPictureEx 智能抓图事件
    public static final int EVENT_IVS_ALL                       = 0x00000001;       // 订阅所有事件
    public static final int EVENT_IVS_CROSSLINEDETECTION        = 0x00000002;       // 警戒线事件(对应 DEV_EVENT_CROSSLINE_INFO)
    public static final int EVENT_IVS_CROSSREGIONDETECTION      = 0x00000003;       // 警戒区事件(对应 DEV_EVENT_CROSSREGION_INFO)
    public static final int EVENT_IVS_LEFTDETECTION        		= 0x00000005;  		// 物品遗留事件(对应 DEV_EVENT_LEFT_INFO)
    public static final int EVENT_IVS_STAYDETECTION             = 0x00000006;       // 停留事件(对应 DEV_EVENT_STAY_INFO)
    public static final int EVENT_IVS_WANDERDETECTION           = 0x00000007;       // 徘徊事件(对应  DEV_EVENT_WANDER_INFO)
    public static final int EVENT_IVS_MOVEDETECTION        		= 0x00000009;  		// 移动事件(对应 DEV_EVENT_MOVE_INFO)
    public static final int EVENT_IVS_RIOTERDETECTION      		= 0x0000000B; 		// 聚众事件(对应 DEV_EVENT_RIOTERL_INFO)
    public static final int EVENT_IVS_FIGHTDETECTION            = 0x0000000E;       // 斗殴事件(对应 DEV_EVENT_FIGHT_INFO)
    public static final int EVENT_IVS_VIDEOABNORMALDETECTION    = 0x00000013;       // 视频异常事件(对应 DEV_EVENT_VIDEOABNORMALDETECTION_INFO)
    public static final int EVENT_IVS_TRAFFICJUNCTION           = 0x00000017;       // 交通路口事件----老规则(对应 DEV_EVENT_TRAFFICJUNCTION_INFO)
    public static final int EVENT_IVS_TRAFFICGATE               = 0x00000018;       // 交通卡口事件----老规则(对应 DEV_EVENT_TRAFFICGATE_INFO)
    public static final int EVENT_IVS_FACEDETECT                = 0x0000001A;       // 人脸检测事件 (对应 DEV_EVENT_FACEDETECT_INFO)(智能规则对应  EVENT_IVS_FACEDETECT)
    public static final int EVENT_IVS_TRAFFICJAM                = 0x0000001B;       // 交通拥堵事件(对应 DEV_EVENT_TRAFFICJAM_INFO)
    public static final int EVENT_IVS_TRAFFIC_RUNREDLIGHT       = 0x00000100;       // 交通违章-闯红灯事件(对应 DEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO)
    public static final int EVENT_IVS_TRAFFIC_OVERLINE          = 0x00000101;       // 交通违章-压车道线事件(对应 DEV_EVENT_TRAFFIC_OVERLINE_INFO)
    public static final int EVENT_IVS_TRAFFIC_RETROGRADE        = 0x00000102;       // 交通违章-逆行事件(对应  DEV_EVENT_TRAFFIC_RETROGRADE_INFO)
    public static final int EVENT_IVS_TRAFFIC_TURNLEFT          = 0x00000103;       // 交通违章-违章左转(对应 DEV_EVENT_TRAFFIC_TURNLEFT_INFO)
    public static final int EVENT_IVS_TRAFFIC_TURNRIGHT         = 0x00000104;       // 交通违章-违章右转(对应 DEV_EVENT_TRAFFIC_TURNRIGHT_INFO)
    public static final int EVENT_IVS_TRAFFIC_UTURN             = 0x00000105;       // 交通违章-违章掉头(对应 DEV_EVENT_TRAFFIC_UTURN_INFO)
    public static final int EVENT_IVS_TRAFFIC_OVERSPEED         = 0x00000106;       // 交通违章-超速(对应 DEV_EVENT_TRAFFIC_OVERSPEED_INFO)
    public static final int EVENT_IVS_TRAFFIC_UNDERSPEED        = 0x00000107;       // 交通违章-低速(对应 DEV_EVENT_TRAFFIC_UNDERSPEED_INFO)
    public static final int EVENT_IVS_TRAFFIC_PARKING           = 0x00000108;       // 交通违章-违章停车(对应 DEV_EVENT_TRAFFIC_PARKING_INFO)
    public static final int EVENT_IVS_TRAFFIC_WRONGROUTE        = 0x00000109;       // 交通违章-不按车道行驶(对应 DEV_EVENT_TRAFFIC_WRONGROUTE_INFO)
    public static final int EVENT_IVS_TRAFFIC_CROSSLANE         = 0x0000010A;       // 交通违章-违章变道(对应 DEV_EVENT_TRAFFIC_CROSSLANE_INFO)
    public static final int EVENT_IVS_TRAFFIC_OVERYELLOWLINE    = 0x0000010B;       // 交通违章-压黄线 (对应 DEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO)
    public static final int EVENT_IVS_TRAFFIC_YELLOWPLATEINLANE = 0x0000010E;       // 交通违章-黄牌车占道事件(对应 DEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO)
    public static final int EVENT_IVS_TRAFFIC_PEDESTRAINPRIORITY = 0x0000010F;      // 交通违章-斑马线行人优先事件(对应 DEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO)
    public static final int EVENT_IVS_TRAFFIC_NOPASSING         = 0x00000111;       // 交通违章-禁止通行事件(对应 DEV_EVENT_TRAFFIC_NOPASSING_INFO)
    public static final int EVENT_IVS_ABNORMALRUNDETECTION 		= 0x00000112;  		// 异常奔跑事件(对应 DEV_EVENT_ABNORMALRUNDETECTION_INFO)
    public static final int EVENT_IVS_RETROGRADEDETECTION       = 0x00000113;       // 人员逆行事件(对应 DEV_EVENT_RETROGRADEDETECTION_INFO)
    public static final int EVENT_IVS_TAKENAWAYDETECTION   		= 0x00000115;  		// 物品搬移事件(对应 DEV_EVENT_TAKENAWAYDETECTION_INFO)
    public static final int EVENT_IVS_PARKINGDETECTION     		= 0x00000116;  		// 非法停车事件(对应 DEV_EVENT_PARKINGDETECTION_INFO)
    public static final int EVENT_IVS_FACERECOGNITION           = 0x00000117;       // 人脸识别事件(对应 DEV_EVENT_FACERECOGNITION_INFO, (对应的智能规则配置  CFG_FACERECOGNITION_INFO)
    public static final int EVENT_IVS_TRAFFIC_MANUALSNAP        = 0x00000118;       // 交通手动抓拍事件(对应  DEV_EVENT_TRAFFIC_MANUALSNAP_INFO)
    public static final int EVENT_IVS_TRAFFIC_FLOWSTATE         = 0x00000119;       // 交通流量统计事件(对应 DEV_EVENT_TRAFFIC_FLOW_STATE)
    public static final int EVENT_IVS_TRAFFIC_VEHICLEINROUTE    = 0x0000011B;       // 有车占道事件(对应 DEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO)
    public static final int EVENT_ALARM_LOCALALARM         		= 0x0000011D;  		// 外部报警事件(对应 DEV_EVENT_ALARM_INFO)
    public static final int EVENT_IVS_PRISONERRISEDETECTION     = 0x0000011E;       // 看守所囚犯起身事件(对应 DEV_EVENT_PRISONERRISEDETECTION_INFO)
    public static final int EVENT_IVS_TRAFFIC_TOLLGATE          = 0x00000120;       // 交通违章--卡口事件----新规则(对应 DEV_EVENT_TRAFFICJUNCTION_INFO)
    public static final int EVENT_IVS_TRAFFIC_VEHICLEINBUSROUTE = 0x00000124;       // 交通违章--占用公交车道事件(对应 DEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO)
    public static final int EVENT_IVS_TRAFFIC_BACKING           = 0x00000125;       // 交通违章--违章倒车事件(对应 DEV_EVENT_IVS_TRAFFIC_BACKING_INFO)
    public static final int EVENT_IVS_AUDIO_ABNORMALDETECTION   = 0x00000126;       // 声音异常检测(对应 DEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO)
    public static final int EVENT_IVS_TRAFFIC_RUNYELLOWLIGHT    = 0x00000127;       // 交通违章-闯黄灯事件(对应 DEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO)
    public static final int EVENT_IVS_CLIMBDETECTION            = 0x00000128;       // 攀高检测事件(对应 DEV_EVENT_IVS_CLIMB_INFO)
    public static final int EVENT_IVS_LEAVEDETECTION            = 0x00000129;       // 离岗检测事件(对应 DEV_EVENT_IVS_LEAVE_INFO)
    public static final int EVENT_IVS_TRAFFIC_PARKINGONYELLOWBOX = 0x0000012A;      // 交通违章--黄网格线抓拍事件(对应 DEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO)
    public static final int EVENT_IVS_TRAFFIC_PARKINGSPACEPARKING = 0x0000012B;     // 车位有车事件(对应 DEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO )
    public static final int EVENT_IVS_TRAFFIC_PARKINGSPACENOPARKING = 0x0000012C;   // 车位无车事件(对应  DEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO )
    public static final int EVENT_IVS_TRAFFIC_PEDESTRAIN        = 0x0000012D;       // 交通行人事件(对应 DEV_EVENT_TRAFFIC_PEDESTRAIN_INFO)
    public static final int EVENT_IVS_TRAFFIC_THROW             = 0x0000012E;       // 交通抛洒物品事件(对应 DEV_EVENT_TRAFFIC_THROW_INFO)
    public static final int EVENT_IVS_TRAFFIC_OVERSTOPLINE      = 0X00000137;       // 交通违章--压停止线事件(对应 DEV_EVENT_TRAFFIC_OVERSTOPLINE)
    public static final int EVENT_IVS_TRAFFIC_WITHOUT_SAFEBELT  = 0x00000138;       // 交通违章--交通未系安全带事件(对应 DEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT)
    public static final int EVENT_IVS_TRAFFIC_DRIVER_SMOKING 	= 0x00000139;  		// 驾驶员抽烟事件(对应 DEV_EVENT_TRAFFIC_DRIVER_SMOKING)
    public static final int EVENT_IVS_TRAFFIC_DRIVER_CALLING 	= 0x0000013A;  		// 驾驶员打电话事件(对应 DEV_EVENT_TRAFFIC_DRIVER_CALLING)
    public static final int EVENT_IVS_TRAFFIC_PASSNOTINORDER    = 0x0000013C;       // 交通违章--未按规定依次通行(对应 DEV_EVENT_TRAFFIC_PASSNOTINORDER_INFO)
    public static final int EVENT_ALARM_VIDEOBLIND         		= 0x00000153;  		// 视频遮挡事件(对应 DEV_EVENT_ALARM_VIDEOBLIND)
    public static final int EVENT_IVS_TRAFFIC_JAM_FORBID_INTO	= 0x00000163;       // 交通违章--车辆拥堵禁入事件(对应 DEV_EVENT_ALARM_JAMFORBIDINTO_INFO)
    public static final int EVENT_IVS_TRAFFIC_FCC               = 0x0000016B;       // 加油站提枪、挂枪事件(对应  DEV_EVENT_TRAFFIC_FCC_INFO)
    public static final int EVENT_IVS_TUMBLE_DETECTION          = 0x00000177;       // 倒地报警事件(对应 DEV_EVENT_TUMBLE_DETECTION_INFO)
    public static final int EVENT_IVS_DISTANCE_DETECTION		= 0x0000024A; 	    // 异常间距事件 (对应 DEV_EVENT_DISTANCE_DETECTION_INFO)
    public static final int EVENT_IVS_ACCESS_CTL                = 0x00000204;       // 门禁事件 (对应 DEV_EVENT_ACCESS_CTL_INFO)
    public static final int EVENT_IVS_SNAPMANUAL                = 0x00000205;       // SnapManual事件(对应 DEV_EVENT_SNAPMANUAL)
    public static final int EVENT_IVS_TRAFFIC_TIREDPHYSIOLOGICAL = 0x00000207;  	// 生理疲劳驾驶事件(对应 DEV_EVENT_TIREDPHYSIOLOGICAL_INFO)
    public static final int EVENT_IVS_CITIZEN_PICTURE_COMPARE   = 0x00000209;       // 人证比对事件(对应  DEV_EVENT_CITIZEN_PICTURE_COMPARE_INFO )
    public static final int EVENT_IVS_TRAFFIC_TIREDLOWERHEAD 	= 0x0000020A;  		// 开车低头报警事件(对应DEV_EVENT_TIREDLOWERHEAD_INFO)
    public static final int EVENT_IVS_TRAFFIC_DRIVERLOOKAROUND 	= 0x0000020B;  		// 开车左顾右盼报警事件(对应DEV_EVENT_DRIVERLOOKAROUND_INFO)
    public static final int EVENT_IVS_TRAFFIC_DRIVERLEAVEPOST 	= 0x0000020C;  		// 开车离岗报警事件(对应DEV_EVENT_DRIVERLEAVEPOST_INFO)
    public static final int EVENT_IVS_MAN_STAND_DETECTION  		= 0x0000020D;  		// 立体视觉站立事件(对应DEV_EVENT_MANSTAND_DETECTION_INFO)
    public static final int EVENT_IVS_MAN_NUM_DETECTION         = 0x0000020E;       // 立体视觉区域内人数统计事件(对应DEV_EVENT_MANNUM_DETECTION_INFO)
    public static final int EVENT_IVS_TRAFFIC_DRIVERYAWN   		= 0x00000210;  		// 开车打哈欠事件(对应DEV_EVENT_DRIVERYAWN_INFO)
    public static final int EVENT_IVS_HUMANTRAIT                = 0x00000215;       // 人体特征事件(对应 DEV_EVENT_HUMANTRAIT_INFO)
    public static final int EVENT_IVS_FACEANALYSIS              = 0x00000217;       // 人脸分析事件 (暂未有具体事件)
    public static final int EVENT_IVS_HIGHSPEED            		= 0x0000022B;       // 车辆超速报警事件(对应 DEV_EVENT_HIGHSPEED_INFO)
    public static final int EVENT_IVS_CROWDDETECTION		    = 0x0000022C;		// 人群密度检测事件(对应结构体 DEV_EVENT_CROWD_DETECTION_INFO)
    public static final int EVENT_IVS_TRAFFIC_CARDISTANCESHORT  = 0x0000022D;		// 车间距过小报警事件(对应 DEV_EVENT_TRAFFIC_CARDISTANCESHORT_INFO)
    public static final int EVENT_IVS_PEDESTRIAN_JUNCTION		= 0x00000230;		// 行人卡口事件(对应 DEV_EVENT_PEDESTRIAN_JUNCTION_INFO)
    public static final int EVENT_IVS_VEHICLE_RECOGNITION       = 0x00000231;       // 车牌对比事件(中石化智慧加油站项目)(对应 DEV_EVENT_VEHICLE_RECOGNITION_INFO)
    public static final int EVENT_IVS_BANNER_DETECTION			= 0x0000023B;		// 拉横幅事件(对应 DEV_EVENT_BANNER_DETECTION_INFO)
    public static final int EVENT_IVS_ELEVATOR_ABNORMAL         = 0x0000023D;		// 电动扶梯运行异常事件 (对应DEV_EVENT_ELEVATOR_ABNORMAL_INFO)
    public static final int EVENT_IVSS_FACEATTRIBUTE            = 0x00000243;       // IVSS人脸检测事件 (暂未有具体事件)
    public static final int EVENT_IVSS_FACECOMPARE              = 0x00000244;       // IVSS人脸识别事件 (暂未有具体事件)
    public static final int EVENT_IVS_FIREWARNING				= 0x00000245;		// 火警事件(对应 DEV_EVENT_FIREWARNING_INFO)
    public static final int EVENT_IVS_SHOPPRESENCE				= 0x00000246;       // 商铺占道经营事件(对应 DEV_EVENT_SHOPPRESENCE_INFO)
    public static final int EVENT_IVS_FLOWBUSINESS				= 0x0000024E;       // 流动摊贩事件 (对应 DEV_EVENT_FLOWBUSINESS_INFO)
    public static final int EVENT_IVS_LANEDEPARTURE_WARNNING 	= 0X00000251;  		// 车道偏移预警(对应 DEV_EVENT_LANEDEPARTURE_WARNNING_INFO)
    public static final int EVENT_IVS_FORWARDCOLLISION_WARNNING = 0x00000252;  		// 前向碰撞预警(对应 DEV_EVENT_FORWARDCOLLISION_WARNNING_INFO)
    public static final int EVENT_IVS_FLOATINGOBJECT_DETECTION	= 0x00000257;		// 漂浮物检测事件 (对应 DEV_EVENT_FLOATINGOBJECT_DETECTION_INFO)
    public static final int EVENT_IVS_PHONECALL_DETECT			= 0x0000025A;       // 打电话检测事件(对应 DEV_EVENT_PHONECALL_DETECT_INFO)
    public static final int EVENT_IVS_SMOKING_DETECT        	= 0x0000025B;       // 吸烟检测事件(对应 DEV_EVENT_SMOKING_DETECT_INFO)
    public static final int EVENT_IVS_RADAR_SPEED_LIMIT_ALARM   = 0x0000025C;       // 雷达限速报警事件(对应 DEV_EVENT_RADAR_SPEED_LIMIT_ALARM_INFO)
    public static final int EVENT_IVS_WATER_LEVEL_DETECTION		= 0x0000025D;		// 水位检测事件 (对应 DEV_EVENT_WATER_LEVEL_DETECTION_INFO)
    public static final int EVENT_IVS_CITY_MOTORPARKING			= 0x0000024F;		// 城市机动车违停事件 (对应 DEV_EVENT_CITY_MOTORPARKING_INFO)
    public static final int EVENT_IVS_CITY_NONMOTORPARKING		= 0x00000250;		// 城市机非动车违停事件 (对应 DEV_EVENT_CITY_NONMOTORPARKING_INFO)
    public static final int EVENT_IVS_HOLD_UMBRELLA			    = 0x0000025E;		// 违规撑伞检测事件 (对应 DEV_EVENT_HOLD_UMBRELLA_INFO)
    public static final int EVENT_IVS_GARBAGE_EXPOSURE			= 0x0000025F;		// 垃圾暴露检测事件 (对应 DEV_EVENT_GARBAGE_EXPOSURE_INFO)
    public static final int EVENT_IVS_DUSTBIN_OVER_FLOW			= 0x00000260;		// 垃圾桶满溢检测事件 (对应 DEV_EVENT_DUSTBIN_OVER_FLOW_INFO)
    public static final int EVENT_IVS_DOOR_FRONT_DIRTY			= 0x00000261;		// 门前脏乱检测事件 (对应 DEV_EVENT_DOOR_FRONT_DIRTY_INFO)
    public static final int EVENT_IVS_QUEUESTAY_DETECTION		= 0X00000262;		// 排队滞留时间报警事件 (对应 DEV_EVENT_QUEUESTAY_DETECTION_INFO)
    public static final int EVENT_IVS_QUEUENUM_DETECTION		= 0X00000263;		// 排队人数异常报警事件（对应 DEV_EVENT_QUEUENUM_DETECTION_INFO）
    public static final int EVENT_IVS_GENERATEGRAPH_DETECTION	= 0X00000264;		// 生成图规则事件（对应 DEV_EVENT_GENERATEGRAPH_DETECTION_INFO）
    public static final int EVENT_IVS_TRAFFIC_PARKING_MANUAL	= 0x00000265;		// 交通违章-手动取证(对应  DEV_EVENT_TRAFFIC_PARKING_MANUAL_INFO)
    public static final int EVENT_IVS_HELMET_DETECTION      	= 0x00000266;		// 安全帽检测事件(对应 DEV_EVENT_HELMET_DETECTION_INFO)
    public static final int EVENT_IVS_DEPOSIT_DETECTION      	= 0x00000267;		// 包裹堆积程度检测事件(对应 DEV_EVENT_DEPOSIT_DETECTION_INFO)
    public static final int EVENT_IVS_HOTSPOT_WARNING			= 0x00000268;		// 热点异常报警事件(对应 DEV_EVENT_HOTSPOT_WARNING_INFO)
    public static final int EVENT_IVS_WEIGHING_PLATFORM_DETECTION =	0x00000269;		// 称重平台检测事件(对应 DEV_EVENT_WEIGHING_PLATFORM_DETECTION_INFO)
    public static final int EVENT_IVS_CLASSROOM_BEHAVIOR		= 0x0000026A;		// 课堂行为分析事件(对应 DEV_EVENT_CLASSROOM_BEHAVIOR_INFO)
    public static final int	EVENT_IVS_WORKCLOTHES_DETECT		= 0x0000026E;		// 工装(安全帽/工作服等)检测事件(对应 DEV_EVENT_WORKCLOTHES_DETECT_INFO)
    public static final int EVENT_IVS_STAY_ALONE_DETECTION      = 0x00000270;		// 单人独处事件(对应 DEV_EVENT_STAY_ALONE_DETECTION_INFO)
    public static final int EVENT_IVS_CAR_DRIVING_IN_OUT		= 0x0000027B;       // 车辆驶入驶出状态事件(对应 DEV_EVENT_CAR_DRIVING_IN_OUT_INFO)
    public static final int EVENT_IVS_VIOLENT_THROW_DETECTION	= 0x0000027D;		// 暴力抛物检测(对应 DEV_EVENT_VIOLENT_THROW_DETECTION_INFO)
    public static final int EVENT_IVS_GASSTATION_VEHICLE_DETECT = 0x00000283;       // 加油站车辆检测事件 (对应 DEV_EVENT_GASSTATION_VEHICLE_DETECT_INFO)
    public static final int EVENT_IVS_HIGH_TOSS_DETECT          = 0x0000028D;       // 高空抛物检测(对应DEV_EVENT_HIGH_TOSS_DETECT_INFO)
    public static final int EVENT_IVS_PARKING_LOT_STATUS_DETECTION = 0x00000297;    // 室外停车位状态检测 (对应 DEV_EVENT_PARKING_LOT_STATUS_DETECTION_INFO)
    public static final int EVENT_IVS_SMART_KITCHEN_CLOTHES_DETECTION=0x0000029D;	// 智慧厨房穿着检测事件（对不戴口罩、厨师帽以及颜色不符合规定的厨师服进行报警）（对应 DEV_EVENT_SMART_KITCHEN_CLOTHES_DETECTION_INFO）
    public static final int EVENT_IVS_ANATOMY_TEMP_DETECT		= 0x00000303;		// 人体温智能检测事件(对应 DEV_EVENT_ANATOMY_TEMP_DETECT_INFO)
    public static final int	EVENT_IVS_FOG_DETECTION				= 0x00000308;		// 起雾检测事件(对应 DEV_EVENT_FOG_DETECTION)
    public static final int EVENT_IVS_WATER_STAGE_MONITOR       = 0x0000030A;       // 水位监测事件
    public static final int EVENT_IVS_NONMOTOR_ENTRYING			= 0x0000030C;    // 非机动车进入电梯(对应 DEV_EVENT_NONMOTOR_ENTRYING_INFO) 
    public static final int EVENT_IVS_TRAFFIC_ROAD_ALERT        = 0x0000030E;       // 道路安全预警(对应 DEV_EVENT_TRAFFIC_ROAD_ALERT_INFO)
    public static final int EVENT_IVS_CAR_DRIVING_IN            = 0x00000330;       // 车辆驶入事件(对应 DEV_EVENT_CAR_DRIVING_IN_INFO)
    public static final int EVENT_IVS_CAR_DRIVING_OUT           = 0x00000331;       // 车辆驶出事件(对应 DEV_EVENT_CAR_DRIVING_OUT_INFO)
    public static final int EVENT_IVS_TRAFFIC_PARKINGSPACE_MANUALSNAP = 0x00000346; // 路侧停车位手动抓图 (对应 DEV_EVENT_PARKINGSPACE_MANUALSNAP_INFO )

    // CLIENT_GetNewDevConfig / CLIENT_SetNewDevConfig 配置项
    public static final String CFG_CMD_VIDEOWIDGET              = "VideoWidget";         // 视频编码物件配置(对应 NET_CFG_VideoWidget )
    public static final String CFG_CMD_ANALYSEGLOBAL            = "VideoAnalyseGlobal";  // 视频分析全局配置(对应 CFG_ANALYSEGLOBAL_INFO)
    public static final String CFG_CMD_ANALYSEMODULE            = "VideoAnalyseModule";  // 物体的检测模块配置(对应 CFG_ANALYSEMODULES_INFO)
    public static final String CFG_CMD_ANALYSERULE              = "VideoAnalyseRule";    // 视频分析规则配置(对应 CFG_ANALYSERULES_INFO)
    public static final String CFG_CMD_VIDEOINOPTIONS           = "VideoInOptions";      // 视频输入前端选项(对应CFG_VIDEO_IN_OPTIONS)
    public static final String CFG_CMD_RAINBRUSHMODE            = "RainBrushMode";       // 雨刷模式相关配置(对应CFG_RAINBRUSHMODE_INFO数组)
    public static final String CFG_CMD_RAINBRUSH                = "RainBrush";           // 雨刷配置(对应CFG_RAINBRUSH_INFO)
    public static final String CFG_CMD_ENCODE                   = "Encode";              // 图像通道属性配置(对应CFG_ENCODE_INFO)
    public static final String CFG_CMD_VIDEO_IN_ZOOM            = "VideoInZoom";         // 云台通道变倍配置(对应CFG_VIDEO_IN_ZOOM)
    public static final String CFG_CMD_REMOTEDEVICE				= "RemoteDevice";		 // 远程设备信息(对应  AV_CFG_RemoteDevice 数组, 通道无关)
    public static final String CFG_CMD_ANALYSESOURCE			= "VideoAnalyseSource";  // 视频分析资源配置(对应 CFG_ANALYSESOURCE_INFO)
    public static final String CFG_CMD_TRAFFICGLOBAL            = "TrafficGlobal";       // 智能交通全局配置(CFG_TRAFFICGLOBAL_INFO)
    public static final String CFG_CMD_RECORDMODE               = "RecordMode";          // 录像模式(对应  AV_CFG_RecordMode )
    public static final String CFG_CMD_ALARMLAMP                = "AlarmLamp";           // 警灯配置(对应 CFG_ALARMLAMP_INFO)
    public static final String CFG_CMD_ALARMOUT                 = "AlarmOut";            // 报警输出通道配置(对应  CFG_ALARMOUT_INFO )
    public static final String CFG_CMD_INTELLECTIVETRAFFIC      = "TrafficSnapshot";     // 智能交通抓拍(对应 CFG_TRAFFICSNAPSHOT_INFO )
    public static final String CFG_CMD_TRAFFICSNAPSHOT_MULTI    = "TrafficSnapshotNew" ; // 智能交通抓拍( CFG_TRAFFICSNAPSHOT_NEW_INFO )
    public static final String CFG_CMD_NTP       				= "NTP";     			 // 时间同步服务器(对应  CFG_NTP_INFO )
    public static final String CFG_CMD_ALARMINPUT               = "Alarm";               // 外部输入报警配置(对应 CFG_ALARMIN_INFO)
    public static final String CFG_CMD_DVRIP                    = "DVRIP";               // 网络协议配置(对应 CFG_DVRIP_INFO)
    public static final String CFG_CMD_NETWORK                  = "Network";             // 网络配置(对应 CFG_NETWORK_INFO)
    public static final String CFG_CMD_MONITORWALL              = "MonitorWall";         // 电视墙配置(对应  AV_CFG_MonitorWall 数组, 通道无关)
    public static final String CFG_CMD_RTMP                  	= "RTMP";             	 // RTMP配置(对应  CFG_RTMP_INFO)
    public static final String CFG_CMD_ACCESS_EVENT             = "AccessControl";       // 门禁事件配置(对应 CFG_ACCESS_EVENT_INFO 数组)
    public static final String CFG_CMD_ACCESSTIMESCHEDULE       = "AccessTimeSchedule";  // 门禁刷卡时间段(对应 CFG_ACCESS_TIMESCHEDULE_INFO)
    public static final String CFG_CMD_DEV_GENERRAL             = "General";             // 普通配置 (对应 CFG_DEV_DISPOSITION_INFO)
    public static final String CFG_CMD_VIDEODIAGNOSIS_PROFILE   = "VideoDiagnosisProfile";// 视频诊断参数表(CFG_VIDEODIAGNOSIS_PROFILE)
    public static final String CFG_CMD_VIDEODIAGNOSIS_TASK      = "VideoDiagnosisTask";   // 视频诊断任务表(CFG_VIDEODIAGNOSIS_TASK)
    public static final String CFG_CMD_VIDEODIAGNOSIS_TASK_ONE  = "VideoDiagnosisTask.x"; // 视频诊断任务表(CFG_VIDEODIAGNOSIS_TASK)
    public static final String CFG_CMD_VIDEODIAGNOSIS_PROJECT   = "VideoDiagnosisProject";// 视频诊断计划表(CFG_VIDEODIAGNOSIS_PROJECT)
    public static final String CFG_CMD_THERMO_GRAPHY			= "ThermographyOptions";  // 热成像摄像头属性配置(CFG_THERMOGRAPHY_INFO)
    public static final String CFG_CMD_THERMOMETRY_RULE         = "ThermometryRule";      // 热成像测温规则配置(对应 CFG_RADIOMETRY_RULE_INFO)
    public static final String CFG_CMD_TEMP_STATISTICS          = "TemperatureStatistics"; // 温度统计配置(CFG_TEMP_STATISTICS_INFO)
    public static final String CFG_CMD_THERMOMETRY              = "HeatImagingThermometry";// 热成像测温全局配置(CFG_THERMOMETRY_INFO)
    public static final String CFG_CMD_DEVRECORDGROUP			= "DevRecordGroup";        // 通道录像组状态(对应 CFG_DEVRECORDGROUP_INFO)
    public static final String CFG_CMD_STORAGEGROUP				= "StorageGroup";          // 存储组信息(对应 AV_CFG_StorageGroup数组, 通道无关)
    public static final String CFG_CMD_PTZTOUR					= "PtzTour";          	   // 云台巡航路径配置(对应 CFG_PTZTOUR_INFO)
    public static final String CFG_CMD_PTZ_PRESET               = "PtzPreset";             // 云台预置点配置(对应结构 PTZ_PRESET_INFO)
    public static final String CFG_CMD_VIDEOIN                  = "VideoIn";               // 输入通道配置(对应 CFG_VIDEO_IN_INFO)
    public static final String CFG_CMD_CHANNELTITLE             = "ChannelTitle";          // 通道名称(对应 AV_CFG_ChannelName)
    public static final String CFG_CMD_WIFI_SEARCH				= "AroudWifiSearch";       // 设备通过Wifi模块扫描周围无线设备配置(CFG_WIFI_SEARCH_INFO)
    public static final String CFG_CMD_RECORD                   =  "Record";               // 定时录像配置(对应 CFG_RECORD_INFO)
    public static final String CFG_CMD_SCADA_DEV              	= "SCADADev";  			   // 检测采集设备配置(CFG_SCADA_DEV_INFO)
    public static final String CFG_CMD_ALARM_SHIELD_RULE     	= "AlarmShieldRule";  	   // 告警屏蔽规则( CFG_ALARM_SHIELD_RULE_INFO)
    public static final String CFG_CMD_JUDICATURE             	= "Judicature";  		   // 司法刻录配置(对应 CFG_JUDICATURE_INFO)
    public static final String CFG_CMD_PTZ                      = "Ptz";                   // 云台配置(对应 CFG_PTZ_INFO)
    public static final String CFG_CMD_OPEN_DOOR_GROUP          = "OpenDoorGroup";         // 多人多开门方式组合配置(CFG_OPEN_DOOR_GROUP_INFO)
    public static final String CFG_CMD_PARKING_SPACE_LIGHT_GROUP= "ParkingSpaceLightGroup";// 车位指示灯本机配置(对应 CFG_PARKING_SPACE_LIGHT_GROUP_INFO_ALL)
    public static final String CFG_CMD_LIGHT                    = "Light";                 // 灯光设备配置 (对应结构体 CFG_LIGHT_INFO)
    public static final String CFG_CMD_LIGHTING                 = "Lighting";              // 灯光设置(CFG_LIGHTING_INFO)
    public static final String CFG_CMD_COMPOSE_CHANNEL          = "ComposeChannel";        // 合成通道配置(对应 CFG_COMPOSE_CHANNEL)
    public static final String CFG_CMD_PICINPIC                 = "PicInPic";              // 司法审讯画中画(对应 CFG_PICINPIC_INFO)改为数组方式，兼容以前单个配置，根据长度区分
    public static final String CFG_CMD_IDLEMOTION_INFO          = "IdleMotion";            // 空闲动作配置(CFG_IDLE_MOTION_INFO)
    /**
     * 扬声器播放能力(CFG_CAP_SPEAK)
     */
    public static final String CFG_CAP_CMD_SPEAK                = "speak.getCaps";
    // CLIENT_FileTransmit接口传输文件类型
    public static final int NET_DEV_BLACKWHITETRANS_START      = 0x0003;           // 开始发送黑白名单(对应结构体 NETDEV_BLACKWHITE_LIST_INFO)
    public static final int NET_DEV_BLACKWHITETRANS_SEND       = 0x0004;           // 发送黑白名单
    public static final int NET_DEV_BLACKWHITETRANS_STOP       = 0x0005;           // 停止发送黑白名单

    // 配置类型,对应CLIENT_GetDevConfig和CLIENT_SetDevConfig接口
    public static final int NET_DEV_DEVICECFG                   = 0x0001;           // 设备属性配置
    public static final int NET_DEV_NETCFG_EX                   = 0x005b;           // 网络扩展配置(对应结构体 NETDEV_NET_CFG_EX )
    public static final int NET_DEV_TIMECFG                     = 0x0008;           // DVR时间配置
    public static final int NET_DEV_AUTOMTCFG					= 0x000A;           // 自动维护配置(对应结构体NETDEV_AUTOMT_CFG)
    public static final int NET_DEV_ENCLOSURE_CFG               = 0x0066;           // 电子围栏配置(对应结构体 NETDEV_ENCLOSURE_CFG)
    public static final int NET_DEV_ENCLOSURE_VERSION_CFG       = 0x0067;           // 电子围栏版本号配置(对应结构体 NETDEV_ENCLOSURE_VERSION_CFG)
    public static final int NET_EM_CFG_RADIO_REGULATOR          = 11102;		    // 人体测温标准黑体配置, 对应结构体 NET_CFG_RADIO_REGULATOR，通道号不能为-1
    // 命令类型, 对应 CLIENT_QueryNewSystemInfo 接口
    public static final String CFG_CAP_CMD_DEVICE_STATE         = "trafficSnap.getDeviceStatus";   // 获取设备状态信息 (对应 CFG_CAP_TRAFFIC_DEVICE_STATUS)
    public static final String CFG_CAP_CMD_RECORDFINDER         = "RecordFinder.getCaps";          // 获取查询记录能力集, (对应结构体 CFG_CAP_RECORDFINDER_INFO)
    public static final String CFG_CMD_VIDEODIAGNOSIS_GETSTATE  = "videoDiagnosisServer.getState"; // 获取视频诊断进行状态(CFG_VIDEODIAGNOSIS_STATE_INFO)
    public static final String CFG_CAP_CMD_PTZ_ENABLE			= "ptz.factory.instance";		   // 获取云台支持信息(CFG_CAP_PTZ_ENABLEINFO)

    // 远程配置结构体相关常量
    public static final int NET_MAX_MAIL_ADDR_LEN              = 128;              // 邮件发(收)地址最大长度
    public static final int NET_MAX_MAIL_SUBJECT_LEN           = 64;               // 邮件主题最大长度
    public static final int NET_MAX_IPADDR_LEN                 = 16;               // IP地址字符串长度
    public static final int NET_MAX_IPADDR_LEN_EX              = 40;               // 扩展IP地址字符串长度, 支持IPV6
    public static final int NET_USER_NAME_LEN_EX               = 32;               // 用户名长度,用于新平台扩展
    public static final int NET_USER_PSW_LEN_EX                = 32;               // 用户密码长度,用于新平台扩展

    public static final int NET_MAX_DEV_ID_LEN                 = 48;               // 机器编号最大长度
    public static final int NET_MAX_HOST_NAMELEN               = 64;               // 主机名长度,
    public static final int NET_MAX_HOST_PSWLEN                = 32;               // 密码长度
    public static final int NET_MAX_ETHERNET_NUM               = 2;                // 以太网口最大个数
    public static final int NET_MAX_ETHERNET_NUM_EX            = 10;               // 扩展以太网口最大个数
    public static final int NET_DEV_CLASS_LEN                  = 16;               // 设备类型字符串（如"IPC"）长度
    public static final int NET_N_WEEKS                        = 7;                // 一周的天数
    public static final int NET_N_TSECT                        = 6;                // 通用时间段个数
    public static final int NET_N_REC_TSECT                    = 6;                // 录像时间段个数
    public static final int NET_N_COL_TSECT                    = 2;                // 颜色时间段个数
    public static final int NET_N_ENCODE_AUX                   = 3;                // 扩展码流个数
    public static final int NET_N_TALK                         = 1;                // 最多对讲通道个数
    public static final int NET_N_COVERS                       = 1;                // 遮挡区域个数
    public static final int NET_N_CHANNEL                      = 16;               // 最大通道个数
    public static final int NET_N_ALARM_TSECT                  = 2;                // 报警提示时间段个数
    public static final int NET_MAX_ALARMOUT_NUM               = 16;               // 报警输出口个数上限
    public static final int NET_MAX_AUDIO_IN_NUM               = 16;               // 音频输入口个数上限
    public static final int NET_MAX_VIDEO_IN_NUM               = 16;               // 视频输入口个数上限
    public static final int NET_MAX_ALARM_IN_NUM               = 16;               // 报警输入口个数上限
    public static final int NET_MAX_DISK_NUM                   = 16;               // 硬盘个数上限,暂定为16
    public static final int NET_MAX_DECODER_NUM                = 16;               // 解码器(485)个数上限
    public static final int NET_MAX_232FUNCS                   = 10;               // 232串口功能个数上限
    public static final int NET_MAX_232_NUM                    = 2;                // 232串口个数上限
    public static final int NET_MAX_232_NUM_EX                 = 16;               // 扩展串口配置个数上限
    public static final int NET_MAX_DECPRO_LIST_SIZE           = 100;              // 解码器协议列表个数上限
    public static final int NET_FTP_MAXDIRLEN                  = 240;              // FTP文件目录最大长度
    public static final int NET_MATRIX_MAXOUT                  = 16;               // 矩阵输出口最大个数
    public static final int NET_TOUR_GROUP_NUM                 = 6;                // 矩阵输出组最大个数
    public static final int NET_MAX_DDNS_NUM                   = 10;               // 设备支持的ddns服务器最大个数
    public static final int NET_MAX_SERVER_TYPE_LEN            = 32;               // ddns服务器类型,最大字符串长度
    public static final int NET_MAX_DOMAIN_NAME_LEN            = 256;              // ddns域名,最大字符串长度
    public static final int NET_MAX_DDNS_ALIAS_LEN             = 32;               // ddns服务器别名,最大字符串长度
    public static final int NET_MAX_DEFAULT_DOMAIN_LEN         = 60;               // ddns默认域名,最大字符串长度
    public static final int NET_MOTION_ROW                     = 32;               // 动态检测区域的行数
    public static final int NET_MOTION_COL                     = 32;               // 动态检测区域的列数
    public static final int NET_STATIC_ROW                     = 32;               // 静态检测区域的行数
    public static final int NET_STATIC_COL                     = 32;               // 静态检测区域的列数
    public static final int NET_FTP_USERNAME_LEN               = 64;               // FTP配置,用户名最大长度
    public static final int NET_FTP_PASSWORD_LEN               = 64;               // FTP配置,密码最大长度
    public static final int NET_TIME_SECTION                   = 2;                // FTP配置,每天时间段个数
    public static final int NET_FTP_MAX_PATH                   = 240;              // FTP配置,文件路径名最大长度
    public static final int NET_FTP_MAX_SUB_PATH               = 128;              // FTP配置,文件路径名最大长度
    public static final int NET_INTERVIDEO_UCOM_CHANID         = 32;               // 平台接入配置,U网通通道ID
    public static final int NET_INTERVIDEO_UCOM_DEVID          = 32;               // 平台接入配置,U网通设备ID
    public static final int NET_INTERVIDEO_UCOM_REGPSW         = 16;               // 平台接入配置,U网通注册密码
    public static final int NET_INTERVIDEO_UCOM_USERNAME       = 32;               // 平台接入配置,U网通用户名
    public static final int NET_INTERVIDEO_UCOM_USERPSW        = 32;               // 平台接入配置,U网通密码
    public static final int NET_INTERVIDEO_NSS_IP              = 32;              // 平台接入配置,中兴力维IP
    public static final int NET_INTERVIDEO_NSS_SERIAL          = 32;               // 平台接入配置,中兴力维serial
    public static final int NET_INTERVIDEO_NSS_USER            = 32;               // 平台接入配置,中兴力维user
    public static final int NET_INTERVIDEO_NSS_PWD             = 50;              // 平台接入配置,中兴力维password
    public static final int NET_MAX_VIDEO_COVER_NUM            = 16;               // 遮挡区域最大个数
    public static final int NET_MAX_WATERMAKE_DATA             = 4096;             // 水印图片数据最大长度
    public static final int NET_MAX_WATERMAKE_LETTER           = 128;              // 水印文字最大长度
    public static final int NET_MAX_WLANDEVICE_NUM             = 10;               // 最多搜索出的无线设备个数
    public static final int NET_MAX_WLANDEVICE_NUM_EX          = 32;               // 最多搜索出的无线设备个数
    public static final int NET_MAX_ALARM_NAME                 = 64;               // 地址长度
    public static final int NET_MAX_REGISTER_SERVER_NUM        = 10;               // 主动注册服务器个数
    public static final int NET_SNIFFER_FRAMEID_NUM            = 6;                // 6个FRAME ID 选项
    public static final int NET_SNIFFER_CONTENT_NUM            = 4;                // 每个FRAME对应的4个抓包内容
    public static final int NET_SNIFFER_CONTENT_NUM_EX         = 8;                // 每个FRAME对应的8个抓包内容
    public static final int NET_SNIFFER_PROTOCOL_SIZE          = 20;               // 协议名字长度
    public static final int NET_MAX_PROTOCOL_NAME_LENGTH       = 20;
    public static final int NET_SNIFFER_GROUP_NUM              = 4;                // 4组抓包设置
    public static final int NET_ALARM_OCCUR_TIME_LEN           = 40;               // 新的报警上传时间的长度
    public static final int NET_VIDEO_OSD_NAME_NUM             = 64;               // 叠加的名称长度,目前支持32个英文,16个中文
    public static final int NET_VIDEO_CUSTOM_OSD_NUM           = 8;               // 支持的自定义叠加的数目,不包含时间和通道
    public static final int NET_VIDEO_CUSTOM_OSD_NUM_EX        = 256;              // 支持的自定义叠加的数目,不包含时间和通道
    public static final int NET_CONTROL_AUTO_REGISTER_NUM      = 100;              // 支持定向主动注册服务器的个数
    public static final int NET_MMS_RECEIVER_NUM               = 100;              // 支持短信接收者的个数
    public static final int NET_MMS_SMSACTIVATION_NUM          = 100;              // 支持短信发送者的个数
    public static final int NET_MMS_DIALINACTIVATION_NUM       = 100;              // 支持拨号发送者的个数
    public static final int NET_MAX_ALARM_IN_NUM_EX            = 32;               // 报警输入口个数上限
    public static final int NET_MAX_IPADDR_OR_DOMAIN_LEN       = 64;               // IP地址字符串长度
    public static final int NET_MAX_CALLID                     = 32;               // 呼叫ID
    public static final int DH_MAX_OBJECT_NUM		       	   = 32;		   	   // 最大object个数
    public static final int NET_MAX_FENCE_LINE_NUM             = 2;                // 围栏最大曲线数
    public static final int MAX_SMART_VALUE_NUM                = 30;               // 最多的smart信息个数
    public static final int NET_INTERVIDEO_AMP_DEVICESERIAL    = 48;               // 平台接入配置,天地阳光 设备序列号字符串长度
    public static final int NET_INTERVIDEO_AMP_DEVICENAME      = 16;               // 平台接入配置,天地阳光 设备名称字符串长度
    public static final int NET_INTERVIDEO_AMP_USER            = 32;               // 平台接入配置,天地阳光 注册用户名字符串长度
    public static final int NET_INTERVIDEO_AMP_PWD             = 32;               // 平台接入配置,天地阳光 注册密码字符串长度
    public static final int MAX_SUBMODULE_NUM                  = 32;               // 最多子模块信息个数
    public static final int NET_MAX_CARWAY_NUM                 = 8;                // 交通抓拍,最大车道数
    public static final int NET_MAX_SNAP_SIGNAL_NUM            = 3;                // 一个车道的最大抓拍张数
    public static final int NET_MAX_CARD_NUM                   = 128;              // 卡号的最大个数
    public static final int NET_MAX_CARDINFO_LEN               = 32;               // 每条卡号最长字符数
    public static final int NET_MAX_CONTROLER_NUM              = 64;               // 最大支持控制器数目
    public static final int NET_MAX_LIGHT_NUM                  = 32;               // 最多控制灯组数
    public static final int NET_MAX_SNMP_COMMON_LEN            = 64;               // snmp 读写数据长度
    public static final int NET_MAX_DDNS_STATE_LEN             = 128;              // DDNS 状态信息长度
    public static final int NET_MAX_PHONE_NO_LEN               = 16;               // 电话号码长度
    public static final int NET_MAX_MSGTYPE_LEN                = 32;               // 导航类型或短信息类型长度
    public static final int NET_MAX_MSG_LEN                    = 256;              // 导航和短信息长度
    public static final int NET_MAX_GRAB_INTERVAL_NUM          = 4;                // 多张图片抓拍个数
    public static final int NET_MAX_FLASH_NUM                  = 5;                // 最多支持闪光灯个数
    public static final int NET_MAX_ISCSI_PATH_NUM             = 64;               // ISCSI远程目录最大数量
    public static final int NET_MAX_WIRELESS_CHN_NUM           = 256;              // 无线路由最大信道数
    public static final int NET_PROTOCOL3_BASE                 = 100;              // 三代协议版本基数
    public static final int NET_PROTOCOL3_SUPPORT              = 11;               // 只支持3代协议
    public static final int NET_MAX_STAFF_NUM                  = 20;               // 浓缩视频配置信息中标尺数上限
    public static final int NET_MAX_CALIBRATEBOX_NUM           = 10;               // 浓缩视频配置信息中标定区域数上限
    public static final int NET_MAX_EXCLUDEREGION_NUM          = 10;               // 浓缩视频配置信息中排除区域数上限
    public static final int NET_MAX_POLYLINE_NUM               = 20;               // 浓缩视频配置信息中标尺线数
    public static final int NET_MAX_COLOR_NUM                  = 16;               // 最大颜色数目
    public static final int MAX_OBJFILTER_NUM                  = 16;               // 最大过滤种类个数
    public static final int NET_MAX_SYNOPSIS_STATE_NAME        = 64;               // 视频浓缩状态字符串长度
    public static final int NET_MAX_SYNOPSIS_QUERY_FILE_COUNT  = 10;               // 视频浓缩相关原始文件按照路径查找时文件个数上限
    public static final int NET_MAX_SSID_LEN                   = 36;               // SSID长度
    public static final int NET_MAX_APPIN_LEN                  = 16;               // PIN码长度
    public static final int NET_NETINTERFACE_NAME_LEN          = 260;              // 网口名称长度
    public static final int NET_NETINTERFACE_TYPE_LEN          = 260;              // 网络类型长度
    public static final int NET_MAX_CONNECT_STATUS_LEN         = 260;              // 连接状态字符串长度
    public static final int NET_MAX_MODE_LEN                   = 64;               // 3G支持的网络模式长度
    public static final int NET_MAX_MODE_NUM                   = 64;               // 3G支持的网络模式个数
    public static final int NET_MAX_COMPRESSION_TYPES_NUM      = 16;               // 视频编码格式最多种类个数
    public static final int NET_MAX_CAPTURE_SIZE_NUM           = 64;               // 视频分辨率个数
    public static final int NET_NODE_NAME_LEN                  = 64;               // 组织结构节点名称长度
    public static final int MAX_CALIBPOINTS_NUM                = 256;              // 支持最大标定点数
    public static final int NET_MAX_ATTR_NUM                   = 32;               // 显示单元属性最大数量
    public static final int NET_MAX_CLOUDCONNECT_STATE_LEN     = 128;              // 云注册连接状态信息长度
    public static final int NET_MAX_IPADDR_EX_LEN              = 128;              // 扩展IP地址最大长度
    public static final int MAX_EVENT_NAME                     = 128;              // 最长事件名
    public static final int NET_MAX_ETH_NAME                   = 64;               // 最大网卡名
    public static final int NET_N_SCHEDULE_TSECT               = 8;                // 时间表元素个数
    public static final int NET_MAX_URL_NUM                    = 8;                // URL最大个数
    public static final int NET_MAX_LOWER_MITRIX_NUM           = 16;               // 最大下位矩阵数
    public static final int NET_MAX_BURN_CHANNEL_NUM           = 32;               // 最大刻录通道数
    public static final int NET_MAX_NET_STRORAGE_BLOCK_NUM     = 64;               // 最大远程存储区块数量
    public static final int NET_MAX_CASE_PERSON_NUM            = 32;               // 案件人员最大数量
    public static final int NET_MAX_MULTIPLAYBACK_CHANNEL_NUM  = 64;               // 最大多通道预览回放通道数
    public static final int NET_MAX_MULTIPLAYBACK_SPLIT_NUM    = 32;               // 最大多通道预览回放分割模式数
    public static final int NET_MAX_AUDIO_ENCODE_TYPE          = 64;               // 最大语音编码类型个数
    public static final int MAX_CARD_RECORD_FIELD_NUM          = 16;               // 卡号录像最大域数量
    public static final int NET_BATTERY_NUM_MAX                = 16;               // 最大电池数量
    public static final int NET_POWER_NUM_MAX                  = 16;               // 最大电源数量
    public static final int NET_MAX_AUDIO_PATH                 = 260;              // 最大音频文件路长度
    public static final int NET_MAX_DOORNAME_LEN               = 128;              // 最大门禁名称长度
    public static final int NET_MAX_CARDPWD_LEN                = 64;               // 最大门禁名称长度
    public static final int NET_MAX_FISHEYE_MOUNTMODE_NUM      = 4;                // 最大鱼眼安装模式个数
    public static final int NET_MAX_FISHEYE_CALIBRATEMODE_NUM  = 16;               // 最大鱼眼矫正模式个数
    public static final int NET_MAX_FISHEYE_EPTZCMD_NUM        = 64;               // 最大鱼眼电子云台操作个数
    public static final int POINT_NUM_IN_PAIR                  = 2;                // 标定点对中的点数量
    public static final int MAX_POINT_PAIR_NUM                 = 128;              // 标定点最大数量
    public static final int CHANNEL_NUM_IN_POINT_GROUP         = 2;                // 标定点中的视频通道数
    public static final int MAX_POINT_GROUP_NUM                = 32;               // 标定点组最大数量, 每两个通道进行拼接需要一组标定点
    public static final int MAX_LANE_INFO_NUM                  = 32;               // 最大车道信息数
    public static final int MAX_LANE_DIRECTION_NUM             = 8;                // 车道方向总数
    public static final int NET_MAX_MONITORWALL_NUM            = 32;               // 电视墙最大数量
    public static final int NET_MAX_OPTIONAL_URL_NUM           = 8;                // 备用url最大数量
    public static final int NET_MAX_CAMERA_CHANNEL_NUM         = 1024;             // 最大摄像机通道数
    public static final int MAX_FILE_SUMMARY_NUM               = 32;               // 最大文件摘要数
    public static final int MAX_AUDIO_ENCODE_NUM               = 64;               // 最大支持音频编码个数

    public static final int MAX_FLASH_LIGHT_NUM                = 8;                // 最大支持的爆闪灯(闪光灯)个数
    public static final int MAX_STROBOSCOPIC_LIGHT_NUM         = 8;                // 最大支持的频闪灯个数
    public static final int MAX_MOSAIC_NUM					   = 8;				   // 最大支持的马赛克数量
    public static final int MAX_MOSAIC_CHANNEL_NUM			   = 256;			   // 支持马赛克叠加的最多通道数量
    public static final int MAX_FIREWARNING_INFO_NUM           = 4;                // 最大热成像着火点报警信息个数
    public static final int MAX_AXLE_NUM                       = 8;                // 最大车轴数量
    public static final int MAX_ACCESSDOOR_NUM                 = 128;              // 最大门数量
    public static final int MAX_SIMILARITY_COUNT			   = 1024;			   // 最大人脸对比库阈值个数
    public static final int MAX_FEATURESTATE_NUM		       = 4;				   // 最大人脸组建模状态个数

    public static final int NET_MAX_BULLET_HOLES               = 10;               // 最大的弹孔数

    public static final int MAX_NTP_SERVER                     = 4;                // 最大备用NTP服务器地址
    public static final int MAX_PLATE_NUM                      = 64;               // 每张图片中包含的最大车牌个数
    public static final int MAX_PREVIEW_CHANNEL_NUM            = 64;               // 最大导播预览的通道数量
    public static final int MAX_ADDRESS_LEN                    = 256;              // 最大的地址长度
    public static final int MAX_DNS_SERVER_NUM                 = 2;                // DNS最大数量
    public static final int MAX_NETWORK_INTERFACE_NUM          = 32;               // 最大网卡数量

    public static final int MAX_EVENT_RESTORE_UUID			   = 36;			   // 事件重传uuid数组大小
    public static final int MAX_EVENT_RESTORE_CODE_NUM         = 8;			       // 最大事件重传类型个数
    public static final int MAX_EVENT_RESOTER_CODE_TYPE	       = 32;			   // 事件重传类型数组大小
    public static final int MAX_SNAP_TYPE                      = 3;                // 抓图类型数量
    public static final int MAX_MAINFORMAT_NUM                 = 4;                // 最大支持主码流类型数量

    public static final int CUSTOM_TITLE_LEN				   = 1024;			   // 自定义标题名称长度(扩充到1024)
    public static final int MAX_CUSTOM_TITLE_NUM    		   = 8;                // 编码物件自定义标题最大数量
    public static final int FORMAT_TYPE_LEN					   = 16;			   // 编码类型名最大长度

    public static final int MAX_CHANNEL_NAME_LEN			   = 256;     		   // 通道名称最大长度

    public static final int MAX_VIRTUALINFO_DOMAIN_LEN		   = 64;			   // 虚拟身份上网域名长度
    public static final int MAX_VIRTUALINFO_TITLE_LEN		   = 64;			   // 虚拟身份上网标题长度
    public static final int MAX_VIRTUALINFO_USERNAME_LEN	   = 32;			   // 虚拟身份用户名长度
    public static final int MAX_VIRTUALINFO_PASSWORD_LEN	   = 32;			   // 虚拟身份密码长度
    public static final int MAX_VIRTUALINFO_PHONENUM_LEN	   = 12;			   // 虚拟身份手机号长度
    public static final int MAX_VIRTUALINFO_IMEI_LEN	       = 16;			   // 虚拟身份国际移动设备标识长度
    public static final int MAX_VIRTUALINFO_IMSI_LEN	       = 16;			   // 虚拟身份国际移动用户识别码长度
    public static final int MAX_VIRTUALINFO_LATITUDE_LEN	   = 16;			   // 虚拟身份经度长度
    public static final int MAX_VIRTUALINFO_LONGITUDE_LEN	   = 16;			   // 虚拟身份纬度长度
    public static final int MAX_VIRTUALINFO_NUM				   = 1024;             // 最大虚拟身份信息个数
    public static final int MAX_SCREENTIME_COUNT			   = 8;				   // 诱导屏最大开关屏时间个数
    public static final int MAX_PLAYDATES_COUNT				   = 32;			   // 最大日期个数
    public static final int MAX_ELEMENTS_COUNT				   = 8;				   // 诱导屏窗口支持的最大元素个数
    public static final int MAX_ELEMENTTEXT_LENGTH			   = 512;			   // 文本元素最大文本长度
    public static final int MAX_NOTE_COUNT					   = 4;				   // 诱导屏窗口元素注释信息最大个数
    public static final int MAX_PROGRAMMES_COUNT			   = 32;			   // 最多支持的节目个数
    public static final int MAX_CALL_ID_LEN					   = 64;			   // 呼叫ID长度
    public static final int MAX_GD_COUNT					   = 170;
    public static final int MAX_SUNTIME_COUNT				   = 12;    		   // 日出日落时间个数
    public static final int MAX_DOOR_TIME_SECTION			   = 4;				   // 门禁每天分时时间段最大个数
    public static final int MAX_SCADA_POINT_LIST_INDEX     	   = 8;    			   // 最大SCADADev配置下标个数, 即最大通道
    public static final int MAX_SCADA_YX_NUM               	   = 128;  			   // 最大遥信个数
    public static final int MAX_SCADA_YC_NUM               	   = 128;  			   // 最大遥测个数
    public static final int MAX_SCADA_POINT_INFO_NUM       	   = 8;    			   // 最大点表个数
    public static final int MAX_NET_SCADA_CAPS_TYPE        	   = 16;
    public static final int MAX_NET_SCADA_CAPS_NAME        	   = 16;
    public static final int MAX_SCADA_ID_NUM               	   = 1024;  		   // 监测点位id的最大个数
    public static final int MAX_SCADA_ID_OF_SENSOR_NUM     	   = 128;  			   // 最大检测点位ID个数

    public static final int MAX_REMOTEDEVICEINFO_IPADDR_LEN    = 128;      		   // 远程设备IP地址最大长度
    public static final int MAX_REMOTEDEVICEINFO_USERNAME_LEN  = 128;              // 远程设备用户名最大长度
    public static final int MAX_REMOTEDEVICEINFO_USERPSW_LENGTH = 128;             // 远程设备密码最大长度

    public static final int MAX_MANUFACTURER_LEN               = 32;               // 最大的 MAC地址所属制造商长度
    public static final int MAX_MACHISTORY_SSID_LEN            = 24;               // 最大的历史SSID长度
    public static final int MAX_MACHISTORY_SSID_NUM	           = 5;	               // 历史SSID的最大个数

    public static final int CFG_MAX_SN_LEN					   = 32;			   // 最大设备序列号长度
    public static final int CFG_MAX_ACCESS_CONTROL_ADDRESS_LEN = 64;			   // 最大的地址长度

    public static final int MAX_MACADDR_NUM					   = 8;				   // 最大物理地址个数
    public static final int MAX_ADD_DEVICE_NUM                 = 16;               // 最大添加设备个数
    public static final int MAX_LINK_DEVICE_NUM                = 1024;             // 最大连接设备个数
    public static final int MAX_DEVICE_CHANNEL_NUM             = 1024;             // 设备最大通道个数
    public static final int NET_CFG_MAX_CTRLTYPE_NUM     	   = 16;               // 最大道闸控制方式
    public static final int NET_MAX_ALL_SNAP_CAR_COUNT	  	   = 32;			   // 所有车开闸种类个数
    public static final int NET_MAX_BURNING_DEV_NUM			   = 32;			   // 最大刻录设备个数
    public static final int NET_BURNING_DEV_NAMELEN			   = 32;			   // 刻录设备名字最大长度
    public static final int PTZ_PRESET_NAME_LEN				   = 64;			   // 云台预置点名称长度
    public static final int NET_RADIOMETRY_DOFIND_MAX		   = 32;			   // 热成像温度统计最大个数
    public static final int CFG_MAX_PTZTOUR_NUM          	   = 64;          	   // 巡航路径数量
    public static final int CFG_MAX_PTZTOUR_PRESET_NUM   	   = 64;          	   // 巡航路径包含的预置点数量
    public static final int MAX_PTZ_PRESET_NAME_LEN		 	   = 64;               // 云台预置点名称长度
    public static final int MAX_COMPANY_NAME_LEN			   = 200;              // 单位名称最大长度
    public static final int NET_MAX_PLAYAUDIO_COUNT        	   = 16;   			   // 最大播报内容数目
    public static final int MAX_TARGET_OBJECT_NUM          	   = 100;  			   // 最大目标物体信息个数
    public static final int MAX_CROWD_DETECTION_NAME_LEN	   = 128;			   // 最大人群密度检测事件名称长度
    public static final int MAX_CROWD_LIST_NUM				   = 5;				   // 最大全局拥挤人群密度列表个数
    public static final int MAX_REGION_LIST_NUM			       = 8;				   // 最大人数超限的报警区域ID列表个数
    public static final int MAX_CROWD_RECT_LIST                = 5;                // 矩形描述信息的最大个数
    public static final int RECT_POINT                         = 2;              // 表示矩形的2个点（左上角与右下角）

    public static final int MAX_OBJECT_NUM					   = 32;			// 最大物体个数
    // 查询类型,对应CLIENT_QueryDevState接口
    public static final int NET_DEVSTATE_COMM_ALARM            = 0x0001;           // 查询普通报警状态(包括外部报警,视频丢失,动态检测)
    public static final int NET_DEVSTATE_SHELTER_ALARM         = 0x0002;           // 查询遮挡报警状态
    public static final int NET_DEVSTATE_RECORDING             = 0x0003;           // 查询录象状态
    public static final int NET_DEVSTATE_DISK                  = 0x0004;           // 查询硬盘信息
    public static final int NET_DEVSTATE_RESOURCE              = 0x0005;           // 查询系统资源状态
    public static final int NET_DEVSTATE_BITRATE               = 0x0006;           // 查询通道码流
    public static final int NET_DEVSTATE_CONN                  = 0x0007;           // 查询设备连接状态
    public static final int NET_DEVSTATE_PROTOCAL_VER          = 0x0008;           // 查询网络协议版本号,pBuf = int*
    public static final int NET_DEVSTATE_TALK_ECTYPE           = 0x0009;           // 查询设备支持的语音对讲格式列表,见结构体NETDEV_TALKFORMAT_LIST
    public static final int NET_DEVSTATE_SD_CARD               = 0x000A;           // 查询SD卡信息(IPC类产品)
    public static final int NET_DEVSTATE_BURNING_DEV           = 0x000B;           // 查询刻录机信息,见结构体NET_BURNING_DEVINFO
    public static final int NET_DEVSTATE_BURNING_PROGRESS      = 0x000C;           // 查询刻录进度
    public static final int NET_DEVSTATE_PLATFORM              = 0x000D;           // 查询设备支持的接入平台
    public static final int NET_DEVSTATE_CAMERA                = 0x000E;           // 查询摄像头属性信息(IPC类产品),pBuf = NETDEV_CAMERA_INFO *,可以有多个结构体
    public static final int NET_DEVSTATE_SOFTWARE              = 0x000F;           // 查询设备软件版本信息  NETDEV_VERSION_INFO
    public static final int NET_DEVSTATE_LANGUAGE              = 0x0010;           // 查询设备支持的语音种类
    public static final int NET_DEVSTATE_DSP                   = 0x0011;           // 查询DSP能力描述(对应结构体NET_DEV_DSP_ENCODECAP)
    public static final int NET_DEVSTATE_OEM                   = 0x0012;           // 查询OEM信息
    public static final int NET_DEVSTATE_NET                   = 0x0013;           // 查询网络运行状态信息
    public static final int NET_DEVSTATE_TYPE                  = 0x0014;           // 查询设备类型
    public static final int NET_DEVSTATE_SNAP                  = 0x0015;           // 查询功能属性(IPC类产品)
    public static final int NET_DEVSTATE_RECORD_TIME           = 0x0016;           // 查询最早录像时间和最近录像时间
    public static final int NET_DEVSTATE_NET_RSSI              = 0x0017;           // 查询无线网络信号强度,见结构体NETDEV_WIRELESS_RSS_INFO
    public static final int NET_DEVSTATE_BURNING_ATTACH        = 0x0018;           // 查询附件刻录选项
    public static final int NET_DEVSTATE_BACKUP_DEV            = 0x0019;           // 查询备份设备列表
    public static final int NET_DEVSTATE_BACKUP_DEV_INFO       = 0x001a;           // 查询备份设备详细信息 NETDEV_BACKUP_INFO
    public static final int NET_DEVSTATE_BACKUP_FEEDBACK       = 0x001b;           // 备份进度反馈
    public static final int NET_DEVSTATE_ATM_QUERY_TRADE       = 0x001c;           // 查询ATM交易类型
    public static final int NET_DEVSTATE_SIP                   = 0x001d;           // 查询sip状态
    public static final int NET_DEVSTATE_VICHILE_STATE         = 0x001e;           // 查询车载wifi状态
    public static final int NET_DEVSTATE_TEST_EMAIL            = 0x001f;           // 查询邮件配置是否成功
    public static final int NET_DEVSTATE_SMART_HARD_DISK       = 0x0020;           // 查询硬盘smart信息
    public static final int NET_DEVSTATE_TEST_SNAPPICTURE      = 0x0021;           // 查询抓图设置是否成功
    public static final int NET_DEVSTATE_STATIC_ALARM          = 0x0022;           // 查询静态报警状态
    public static final int NET_DEVSTATE_SUBMODULE_INFO        = 0x0023;           // 查询设备子模块信息
    public static final int NET_DEVSTATE_DISKDAMAGE            = 0x0024;           // 查询硬盘坏道能力
    public static final int NET_DEVSTATE_IPC                   = 0x0025;           // 查询设备支持的IPC能力, 见结构体NET_DEV_IPC_INFO
    public static final int NET_DEVSTATE_ALARM_ARM_DISARM      = 0x0026;           // 查询报警布撤防状态
    public static final int NET_DEVSTATE_ACC_POWEROFF_ALARM    = 0x0027;           // 查询ACC断电报警状态(返回一个DWORD, 1表示断电,0表示通电)
    public static final int NET_DEVSTATE_TEST_FTP_SERVER       = 0x0028;           // 测试FTP服务器连接
    public static final int NET_DEVSTATE_3GFLOW_EXCEED         = 0x0029;           // 查询3G流量超出阈值状态,(见结构体 NETDEV_3GFLOW_EXCEED_STATE_INFO)
    public static final int NET_DEVSTATE_3GFLOW_INFO           = 0x002a;           // 查询3G网络流量信息,见结构体 NET_DEV_3GFLOW_INFO
    public static final int NET_DEVSTATE_VIHICLE_INFO_UPLOAD   = 0x002b;           // 车载自定义信息上传(见结构体 ALARM_VEHICLE_INFO_UPLOAD)
    public static final int NET_DEVSTATE_SPEED_LIMIT           = 0x002c;           // 查询限速报警状态(见结构体ALARM_SPEED_LIMIT)
    public static final int NET_DEVSTATE_DSP_EX                = 0x002d;           // 查询DSP扩展能力描述(对应结构体 NET_DEV_DSP_ENCODECAP_EX)
    public static final int NET_DEVSTATE_3GMODULE_INFO         = 0x002e;           // 查询3G模块信息(对应结构体NET_DEV_3GMODULE_INFO)
    public static final int NET_DEVSTATE_MULTI_DDNS            = 0x002f;           // 查询多DDNS状态信息(对应结构体NET_DEV_MULTI_DDNS_INFO)
    public static final int NET_DEVSTATE_CONFIG_URL            = 0x0030;           // 查询设备配置URL信息(对应结构体NET_DEV_URL_INFO)
    public static final int NET_DEVSTATE_HARDKEY               = 0x0031;           // 查询HardKey状态（对应结构体NETDEV_HARDKEY_STATE)
    public static final int NET_DEVSTATE_ISCSI_PATH            = 0x0032;           // 查询ISCSI路径列表(对应结构体NETDEV_ISCSI_PATHLIST)
    public static final int NET_DEVSTATE_DLPREVIEW_SLIPT_CAP   = 0x0033;           // 查询设备本地预览支持的分割模式(对应结构体DEVICE_LOCALPREVIEW_SLIPT_CAP)
    public static final int NET_DEVSTATE_WIFI_ROUTE_CAP        = 0x0034;           // 查询无线路由能力信息(对应结构体NETDEV_WIFI_ROUTE_CAP)
    public static final int NET_DEVSTATE_ONLINE                = 0x0035;           // 查询设备的在线状态(返回一个DWORD, 1表示在线, 0表示断线)
    public static final int NET_DEVSTATE_PTZ_LOCATION          = 0x0036;           // 查询云台状态信息(对应结构体 NET_PTZ_LOCATION_INFO)
    public static final int NET_DEVSTATE_MONITOR_INFO          = 0x0037;           // 画面监控辅助信息(对应结构体NETDEV_MONITOR_INFO)
    public static final int NET_DEVSTATE_SUBDEVICE             = 0x0300;           // 查询子设备(电源, 风扇等)状态(对应结构体CFG_DEVICESTATUS_INFO)
    public static final int NET_DEVSTATE_RAID_INFO             = 0x0038;           // 查询RAID状态(对应结构体ALARM_RAID_INFO)
    public static final int NET_DEVSTATE_TEST_DDNSDOMAIN       = 0x0039;           // 测试DDNS域名是否可用
    public static final int NET_DEVSTATE_VIRTUALCAMERA         = 0x003a;           // 查询虚拟摄像头状态(对应 NETDEV_VIRTUALCAMERA_STATE_INFO)
    public static final int NET_DEVSTATE_TRAFFICWORKSTATE      = 0x003b;           // 获取设备工作视频/线圈模式状态等(对应NETDEV_TRAFFICWORKSTATE_INFO)
    public static final int NET_DEVSTATE_ALARM_CAMERA_MOVE     = 0x003c;           // 获取摄像机移位报警事件状态(对应ALARM_CAMERA_MOVE_INFO)
    public static final int NET_DEVSTATE_ALARM                 = 0x003e;           // 获取外部报警状态(对应 NET_CLIENT_ALARM_STATE)
    public static final int NET_DEVSTATE_VIDEOLOST             = 0x003f;           // 获取视频丢失报警状态(对应 NET_CLIENT_VIDEOLOST_STATE)
    public static final int NET_DEVSTATE_MOTIONDETECT          = 0x0040;           // 获取动态监测报警状态(对应 NET_CLIENT_MOTIONDETECT_STATE)
    public static final int NET_DEVSTATE_DETAILEDMOTION        = 0x0041;           // 获取详细的动态监测报警状态(对应 NET_CLIENT_DETAILEDMOTION_STATE)
    public static final int NET_DEVSTATE_VEHICLE_INFO          = 0x0042;           // 获取车载自身各种硬件信息(对应 NETDEV_VEHICLE_INFO)
    public static final int NET_DEVSTATE_VIDEOBLIND            = 0x0043;           // 获取视频遮挡报警状态(对应 NET_CLIENT_VIDEOBLIND_STATE)
    public static final int NET_DEVSTATE_3GSTATE_INFO          = 0x0044;           // 查询3G模块相关信息(对应结构体NETDEV_VEHICLE_3GMODULE)
    public static final int NET_DEVSTATE_NETINTERFACE          = 0x0045;           // 查询网络接口信息(对应 NETDEV_NETINTERFACE_INFO)

    public static final int NET_DEVSTATE_PICINPIC_CHN          = 0x0046;           // 查询画中画通道号(对应DWORD数组)
    public static final int NET_DEVSTATE_COMPOSITE_CHN         = 0x0047;           // 查询融合屏通道信息(对应 NET_COMPOSITE_CHANNEL数组)
    public static final int NET_DEVSTATE_WHOLE_RECORDING       = 0x0048;           // 查询设备整体录像状态(对应BOOL), 只要有一个通道在录像,即为设备整体状态为录像
    public static final int NET_DEVSTATE_WHOLE_ENCODING        = 0x0049;           // 查询设备整体编码状态(对应BOOL), 只要有一个通道在编码,即为设备整体状态为编码
    public static final int NET_DEVSTATE_DISK_RECORDE_TIME     = 0x004a;           // 查询设备硬盘录像时间信息(pBuf = DEV_DISK_RECORD_TIME*,可以有多个结构体)
    public static final int NET_DEVSTATE_BURNER_DOOR           = 0x004b;           // 是否已弹出刻录机光驱门(对应结构体 NET_DEVSTATE_BURNERDOOR)
    public static final int NET_DEVSTATE_GET_DATA_CHECK        = 0x004c;           // 查询光盘数据校验进度(对应 NET_DEVSTATE_DATA_CHECK)
    public static final int NET_DEVSTATE_ALARM_IN_CHANNEL      = 0x004f;           // 查询报警输入通道信息(对应NET_ALARM_IN_CHANNEL数组)
    public static final int NET_DEVSTATE_ALARM_CHN_COUNT       = 0x0050;           // 查询报警通道数(对应NET_ALARM_CHANNEL_COUNT)
    public static final int NET_DEVSTATE_PTZ_VIEW_RANGE        = 0x0051;           // 查询云台可视域状态(对应 NET_OUT_PTZ_VIEW_RANGE_STATUS	)
    public static final int NET_DEVSTATE_DEV_CHN_COUNT         = 0x0052;           // 查询设备通道信息(对应NET_DEV_CHN_COUNT_INFO)
    public static final int NET_DEVSTATE_RTSP_URL              = 0x0053;           // 查询设备支持的RTSP URL列表,见结构体DEV_RTSPURL_LIST
    public static final int NET_DEVSTATE_LIMIT_LOGIN_TIME      = 0x0054;           // 查询设备登录的在线超时时间,返回一个BTYE,（单位：分钟） ,0表示不限制,非零正整数表示限制的分钟数
    public static final int NET_DEVSTATE_GET_COMM_COUNT        = 0x0055;           // 获取串口数 见结构体NET_GET_COMM_COUNT
    public static final int NET_DEVSTATE_RECORDING_DETAIL      = 0x0056;           // 查询录象状态详细信息(pBuf = NET_RECORD_STATE_DETAIL*)
    public static final int NET_DEVSTATE_PTZ_PRESET_LIST       = 0x0057;           // 获取当前云台的预置点列表(对应结构NET_PTZ_PRESET_LIST)
    public static final int NET_DEVSTATE_EXTERNAL_DEVICE       = 0x0058;           // 外接设备信息(pBuf = NET_EXTERNAL_DEVICE*)
    public static final int NET_DEVSTATE_GET_UPGRADE_STATE     = 0x0059;           // 获取设备升级状态(对应结构 NETDEV_UPGRADE_STATE_INFO)
    public static final int NET_DEVSTATE_MULTIPLAYBACK_SPLIT_CAP = 0x005a;         // 获取多通道预览分割能力( 对应结构体 NET_MULTIPLAYBACK_SPLIT_CAP )
    public static final int NET_DEVSTATE_BURN_SESSION_NUM      = 0x005b;           // 获取刻录会话总数(pBuf = int*)
    public static final int NET_DEVSTATE_PROTECTIVE_CAPSULE    = 0X005c;           // 查询防护舱状态(对应结构体ALARM_PROTECTIVE_CAPSULE_INFO)
    public static final int NET_DEVSTATE_GET_DOORWORK_MODE     = 0X005d;           // 获取门锁控制模式( 对应 NET_GET_DOORWORK_MODE)
    public static final int NET_DEVSTATE_PTZ_ZOOM_INFO         = 0x005e;           // 查询云台获取光学变倍信息(对应 NET_OUT_PTZ_ZOOM_INFO )

    public static final int NET_DEVSTATE_POWER_STATE           = 0x0152;           // 查询电源状态(对应结构体NET_POWER_STATUS)
    public static final int NET_DEVSTATE_ALL_ALARM_CHANNELS_STATE  = 0x153;        // 查询报警通道状态(对应结构体 NET_CLIENT_ALARM_CHANNELS_STATE)
    public static final int NET_DEVSTATE_ALARMKEYBOARD_COUNT   = 0x0154;           // 查询串口上连接的报警键盘数(对应结构体NET_ALARMKEYBOARD_COUNT)
    public static final int NET_DEVSTATE_EXALARMCHANNELS       = 0x0155;           // 查询扩展报警模块通道映射关系(对应结构体 NET_EXALARMCHANNELS)
    public static final int NET_DEVSTATE_GET_BYPASS            = 0x0156;           // 查询通道旁路状态(对应结构体 NET_DEVSTATE_GET_BYPASS)
    public static final int NET_DEVSTATE_ACTIVATEDDEFENCEAREA  = 0x0157;           // 获取激活的防区信息(对应结构体 NET_ACTIVATEDDEFENCEAREA)
    public static final int NET_DEVSTATE_DEV_RECORDSET         = 0x0158;           // 查询设备记录集信息(对应 NET_CTRL_RECORDSET_PARAM)
    public static final int NET_DEVSTATE_DOOR_STATE            = 0x0159;           // 查询门禁状态(对应NET_DOOR_STATUS_INFO)
    public static final int NET_DEVSTATE_ANALOGALARM_CHANNELS  = 0x1560;           // 模拟量报警输入通道映射关系(对应NET_ANALOGALARM_CHANNELS)
    public static final int NET_DEVSTATE_GET_SENSORLIST        = 0x1561;           // 获取设备支持的传感器列表(对应 NET_SENSOR_LIST)
    public static final int NET_DEVSTATE_ALARM_CHANNELS        = 0x1562;           // 查询开关量报警模块通道映射关系(对应结构体 NET_ALARM_CHANNELS)
    // 如果设备不支持查询扩展报警模块通道,可以用该功能查询扩展通道的逻辑通道号,并当做本地报警通道使用
    public static final int NET_DEVSTATE_GET_ALARM_SUBSYSTEM_ACTIVATESTATUS = 0x1563;  // 获取当前子系统启用状态( 对应 NET_GET_ALARM_SUBSYSTEM_ACTIVATE_STATUES)
    public static final int NET_DEVSTATE_AIRCONDITION_STATE    = 0x1564;           // 获取空调工作状态(对应 NET_GET_AIRCONDITION_STATE)
    public static final int NET_DEVSTATE_ALARMSUBSYSTEM_STATE  = 0x1565;           // 获取子系统状态(对应NET_ALARM_SUBSYSTEM_STATE)
    public static final int NET_DEVSTATE_ALARM_FAULT_STATE     = 0x1566;           // 获取故障状态(对应 NET_ALARM_FAULT_STATE_INFO)
    public static final int NET_DEVSTATE_DEFENCE_STATE         = 0x1567;           // 获取防区状态(对应 NET_DEFENCE_STATE_INFO, 和旁路状态变化事件、本地报警事件、报警信号源事件的状态描述有区别,不能混用,仅个别设备使用)
    public static final int NET_DEVSTATE_CLUSTER_STATE         = 0x1568;           // 获取集群状态(对应 NET_CLUSTER_STATE_INFO)
    public static final int NET_DEVSTATE_SCADA_POINT_LIST      = 0x1569;           // 获取点位表路径信息(对应 NET_SCADA_POINT_LIST_INFO)
    public static final int NET_DEVSTATE_SCADA_INFO            = 0x156a;           // 获取监测点位信息(对应 NET_SCADA_INFO)
    public static final int NET_DEVSTATE_SCADA_CAPS            = 0X156b;           // 获取SCADA能力集(对应 NET_SCADA_CAPS)
    public static final int NET_DEVSTATE_GET_CODEID_COUNT      = 0x156c;           // 获取对码成功的总条数(对应 NET_GET_CODEID_COUNT)
    public static final int NET_DEVSTATE_GET_CODEID_LIST       = 0x156d;           // 查询对码信息(对应 NET_GET_CODEID_LIST)
    public static final int NET_DEVSTATE_ANALOGALARM_DATA      = 0x156e;           // 查询模拟量通道数据(对应 NET_GET_ANALOGALARM_DATA)
    public static final int NET_DEVSTATE_VTP_CALLSTATE         = 0x156f;           // 获取视频电话呼叫状态(对应 NET_GET_VTP_CALLSTATE)
    public static final int NET_DEVSTATE_SCADA_INFO_BY_ID      = 0x1570;           // 通过设备、获取监测点位信息(对应 NET_SCADA_INFO_BY_ID)
    public static final int NET_DEVSTATE_SCADA_DEVICE_LIST     = 0x1571;           // 获取当前主机所接入的外部设备ID(对应 NET_SCADA_DEVICE_LIST)
    public static final int NET_DEVSTATE_DEV_RECORDSET_EX      = 0x1572;           // 查询设备记录集信息(带二进制数据)(对应NET_CTRL_RECORDSET_PARAM)
    public static final int NET_DEVSTATE_ACCESS_LOCK_VER       = 0x1573;           // 获取门锁软件版本号(对应 NET_ACCESS_LOCK_VER)
    public static final int NET_DEVSTATE_MONITORWALL_TVINFO    = 0x1574;           // 获取电视墙显示信息(对应 NET_CTRL_MONITORWALL_TVINFO)
    public static final int NET_DEVSTATE_GET_ALL_POS           = 0x1575;           // 获取所有用户可用Pos设备配置信息(对应 NET_POS_ALL_INFO)
    public static final int NET_DEVSTATE_GET_ROAD_LIST         = 0x1576;           // 获取城市及路段编码信息,哥伦比亚项目专用(对应 NET_ROAD_LIST_INFO)
    public static final int NET_DEVSTATE_GET_HEAT_MAP          = 0x1577;           // 获取热度统计信息(对应 NET_QUERY_HEAT_MAP)
    public static final int NET_DEVSTATE_GET_WORK_STATE        = 0x1578;           // 获取盒子工作状态信息(对应 NET_QUERY_WORK_STATE )
    public static final int NET_DEVSTATE_GET_WIRESSLESS_STATE  = 0x1579;           // 获取无线设备状态信息(对应 NET_GET_WIRELESS_DEVICE_STATE)
    public static final int NET_DEVSTATE_GET_REDUNDANCE_POWER_INFO = 0x157a;       // 获取冗余电源信息(对应 NET_GET_REDUNDANCE_POWER_INFO)


    // 查询设备信息类型, 对应接口 CLIENT_QueryDevInfo
    // 设备信息类型,对应CLIENT_QueryDevInfo接口
    public static final int NET_QUERY_DEV_STORAGE_NAMES                 = 0x01;                // 查询设备的存储模块名列表 , pInBuf=NET_IN_STORAGE_DEV_NAMES *, pOutBuf=NET_OUT_STORAGE_DEV_NAMES *
    public static final int NET_QUERY_DEV_STORAGE_INFOS                 = 0x02;                // 查询设备的存储模块信息列表, pInBuf=NET_IN_STORAGE_DEV_INFOS*, pOutBuf= NET_OUT_STORAGE_DEV_INFOS *
    public static final int NET_QUERY_RECENCY_JNNCTION_CAR_INFO         = 0x03;                // 查询最近的卡口车辆信息接口, pInBuf=NET_IN_GET_RECENCY_JUNCTION_CAR_INFO*, pOutBuf=NET_OUT_GET_RECENCY_JUNCTION_CAR_INFO*
    public static final int NET_QUERY_LANES_STATE                       = 0x04;                // 查询车道信息,pInBuf = NET_IN_GET_LANES_STATE , pOutBuf = NET_OUT_GET_LANES_STATE
    public static final int NET_QUERY_DEV_FISHEYE_WININFO               = 0x05;                // 查询鱼眼窗口信息 , pInBuf= NET_IN_FISHEYE_WININFO*, pOutBuf=NET_OUT_FISHEYE_WININFO *
    public static final int NET_QUERY_DEV_REMOTE_DEVICE_INFO            = 0x06;;               // 查询远程设备信息 , pInBuf= NET_IN_GET_DEVICE_INFO*, pOutBuf= NET_OUT_GET_DEVICE_INFO *
    public static final int NET_QUERY_SYSTEM_INFO                       = 0x07;                // 查询设备系统信息 , pInBuf= NET_IN_SYSTEM_INFO*, pOutBuf= NET_OUT_SYSTEM_INFO*
    public static final int NET_QUERY_REG_DEVICE_NET_INFO               = 0x08;                // 查询主动注册设备的网络连接 , pInBuf=NET_IN_REGDEV_NET_INFO * , pOutBuf=NET_OUT_REGDEV_NET_INFO *
    public static final int NET_QUERY_DEV_THERMO_GRAPHY_PRESET          = 0x09;                // 查询热成像预设信息 , pInBuf= NET_IN_THERMO_GET_PRESETINFO*, pOutBuf= NET_OUT_THERMO_GET_PRESETINFO *
    public static final int NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION       = 0x0a;                // 查询热成像感兴趣区域信息,pInBuf= NET_IN_THERMO_GET_OPTREGION*, pOutBuf= NET_OUT_THERMO_GET_OPTREGION *
    public static final int NET_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO      = 0x0b;                // 查询热成像外部系统信息, pInBuf= NET_IN_THERMO_GET_EXTSYSINFO*, pOutBuf= NET_OUT_THERMO_GET_EXTSYSINFO *
    public static final int NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER       = 0x0c;                // 查询测温点的参数值, pInBuf= NET_IN_RADIOMETRY_GETPOINTTEMPER*, pOutBuf= NET_OUT_RADIOMETRY_GETPOINTTEMPER *
    public static final int NET_QUERY_DEV_RADIOMETRY_TEMPER             = 0x0d;                // 查询测温项的参数值, pInBuf= NET_IN_RADIOMETRY_GETTEMPER*, pOutBuf= NET_OUT_RADIOMETRY_GETTEMPER *
    public static final int NET_QUERY_GET_CAMERA_STATE                  = 0x0e;                // 获取摄像机状态, pInBuf= NET_IN_GET_CAMERA_STATEINFO*, pOutBuf= NET_OUT_GET_CAMERA_STATEINFO *
    public static final int NET_QUERY_GET_REMOTE_CHANNEL_AUDIO_ENCODE   = 0x0f;                // 获取远程通道音频编码方式, pInBuf= NET_IN_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO*, pOutBuf= NET_OUT_GET_REMOTE_CHANNEL_AUDIO_ENCODEINFO *
    public static final int NET_QUERY_GET_COMM_PORT_INFO                = 0x10;                // 获取设备串口信息, pInBuf=NET_IN_GET_COMM_PORT_INFO* , pOutBuf=NET_OUT_GET_COMM_PORT_INFO*
    public static final int NET_QUERY_GET_LINKCHANNELS                  = 0x11;                // 查询某视频通道的关联通道列表,pInBuf=NET_IN_GET_LINKCHANNELS* , pOutBuf=NET_OUT_GET_LINKCHANNELS*
    public static final int NET_QUERY_GET_VIDEOOUTPUTCHANNELS           = 0x12;                // 获取解码通道数量统计信息, pInBuf=NET_IN_GET_VIDEOOUTPUTCHANNELS*, pOutBuf=NET_OUT_GET_VIDEOOUTPUTCHANNELS*
    public static final int NET_QUERY_GET_VIDEOINFO                     = 0x13;                // 获取解码通道信息, pInBuf=NET_IN_GET_VIDEOINFO*, pOutBuf=NET_OUT_GET_VIDEOINFO*
    public static final int NET_QUERY_GET_ALLLINKCHANNELS               = 0x14;                // 查询全部视频关联通道列表,pInBuf=NET_IN_GET_ALLLINKCHANNELS* , pOutBuf=NET_OUT_GET_ALLLINKCHANNELS*
    public static final int NET_QUERY_VIDEOCHANNELSINFO                 = 0x15;                // 查询视频通道信息,pInBuf=NET_IN_GET_VIDEOCHANNELSINFO* , pOutBuf=NET_OUT_GET_VIDEOCHANNELSINFO*
    public static final int NET_QUERY_TRAFFICRADAR_VERSION              = 0x16;                // 查询雷达设备版本,pInBuf=NET_IN_TRAFFICRADAR_VERSION* , pOutBuf=NET_OUT_TRAFFICRADAR_VERSION*
    public static final int NET_QUERY_WORKGROUP_NAMES                   = 0x17;                // 查询所有的工作目录组名,pInBuf=NET_IN_WORKGROUP_NAMES* , pOutBuf=NET_OUT_WORKGROUP_NAMES*
    public static final int NET_QUERY_WORKGROUP_INFO                    = 0x18;                // 查询工作组信息,pInBuf=NET_IN_WORKGROUP_INFO* , pOutBuf=NET_OUT_WORKGROUP_INFO*
    public static final int NET_QUERY_WLAN_ACCESSPOINT                  = 0x19;                // 查询无线网络接入点信息,pInBuf=NET_IN_WLAN_ACCESSPOINT* , pOutBuf=NET_OUT_WLAN_ACCESSPOINT*
    public static final int NET_QUERY_GPS_INFO							= 0x1a;				   // 查询设备GPS信息,pInBuf=NET_IN_DEV_GPS_INFO* , pOutBuf=NET_OUT_DEV_GPS_INFO*
    public static final int NET_QUERY_IVS_REMOTE_DEVICE_INFO            = 0x1b;                // 查询IVS的前端设备所关联的远程设备信息, pInBuf = NET_IN_IVS_REMOTE_DEV_INFO*, pOutBuf = NET_OUT_IVS_REMOTE_DEV_INFO*
    public static final int NET_QUERY_AUDIO_DECODE_CAPS					= 0x25;				   // 获取音频解码能力集, pInBuf = NET_IN_AUDIO_DECODE_CAPS*, pOutBuf = NET_OUT_AUDIO_DECODE_CAPS* 
    public static final int NET_QUERY_REMOTE_DEVICE_CAPS                = 0x27;                // 获取远程设备管理能力集, pInBuf = NET_IN_REMOTEDEVICE_CAP*， pOutBuf= NET_OUT_REMOTEDEVICE_CAP
    public static final int NET_QUERY_TRAFFIC_SNAP_RADAR                = 0x28;                // 获取智能交通雷达信息, pInfo = NET_IN_TRAFFIC_SNAP_RADAR_INFO*,  pOutBuf = NET_OUT_TRAFFIC_SNAP_RADAR_INFO* 
    public static final int NET_QUERY_TRAFFIC_SNAP_STROBE               = 0x29;                // 获取智能交通道闸信息, pInfo = NET_IN_TRAFFIC_SNAP_STROBE_INFO*, pOutBuf = NET_OUT_TRAFFIC_SNAP_STROBE_INFO*
    // 设备能力类型, 对应CLIENT_GetDevCaps接口
    public static final int NET_THERMO_GRAPHY_CAPS                 		= 0x06;                // 热成像摄像头属性能力,pInBuf=NET_IN_THERMO_GETCAPS*, pOutBuf=NET_OUT_THERMO_GETCAPS*
    public static final int NET_RADIOMETRY_CAPS                 		= 0x07;                // 热成像测温全局配置能力,pInBuf=NET_IN_RADIOMETRY_GETCAPS*, pOutBuf=NET_OUT_RADIOMETRY_GETCAPS*

    public static final int NET_QUERY_TRAFFIC_RADAR_GET_OBJECT		    = 0x35;			        // 获取雷达物体目标信息,pInBuf = NET_IN_TRAFFIC_RADAR_GET_OBJECT_INFO*,pOutBuf = NET_OUT_TRAFFIC_RADAR_GET_OBJECT_INFO*

    /////////////////////////////////// 矩阵 ///////////////////////////////////////

    public static final int NET_MATRIX_INTERFACE_LEN          			= 16;          // 信号接口名称长度
    public static final int NET_MATRIX_MAX_CARDS             			= 128;         // 矩阵子卡最大数量
    public static final int NET_SPLIT_PIP_BASE               			= 1000;        // 分割模式画中画的基础值
    public static final int NET_MAX_SPLIT_MODE_NUM           			= 64;          // 最大分割模式数
    public static final int NET_MATRIX_MAX_CHANNEL_IN        			= 1500;        // 矩阵最大输入通道数
    public static final int NET_MATRIX_MAX_CHANNEL_OUT       			= 256;         // 矩阵最大输出通道数
    public static final int NET_DEVICE_NAME_LEN              			= 64;          // 设备名称长度
    public static final int NET_MAX_CPU_NUM                  			= 16;          // 最大CPU数量
    public static final int NET_MAX_FAN_NUM                  			= 16;          // 最大风扇数量
    public static final int NET_MAX_POWER_NUM                			= 16;          // 最大电源数量
    public static final int NET_MAX_BATTERY_NUM              			= 16;          // 最大电池数量
    public static final int NET_MAX_RAID_DEVICE_NAME                   = 16;          // RAID异常信息-RAID设备名称
    public static final int NET_MAX_TEMPERATURE_NUM          			= 256;         // 最大温度传感器数量
    public static final int NET_MAX_ISCSI_NAME_LEN           			= 128;         // ISCSI名称长度
    public static final int NET_VERSION_LEN                  			= 64;          // 版本信息长度
    public static final int NET_MAX_STORAGE_PARTITION_NUM    			= 32;          // 存储分区最大数量
    public static final int NET_STORAGE_MOUNT_LEN            			= 64;          // 挂载点长度
    public static final int NET_STORAGE_FILE_SYSTEM_LEN      			= 16;          // 文件系统名称长度
    public static final int NET_MAX_MEMBER_PER_RAID          			= 32;          // RAID成员最大数量
    public static final int NET_DEV_ID_LEN_EX                			= 128;         // 设备ID最大长度
    public static final int NET_MAX_BLOCK_NUM                			= 32;          // 最大区块数量
    public static final int NET_MAX_SPLIT_WINDOW             			= 128;         // 最大分割窗口数量
    public static final int NET_FILE_TYPE_LEN                			= 64;          // 文件类型长度
    public static final int NET_DEV_ID_LEN                  			= 128;         // 设备ID最大长度
    public static final int NET_DEV_NAME_LEN                 			= 128;         // 设备名称最大长度
    public static final int NET_TSCHE_DAY_NUM                			= 8;           // 时间表第一维大小, 表示天数
    public static final int NET_TSCHE_SEC_NUM                			= 6;           // 时间表第二维大小, 表示时段数
    public static final int NET_SPLIT_INPUT_NUM              			= 256;         // 司法设备二级切换时第一级split支持的输入通道数

    public static final String NET_DEVICE_ID_LOCAL               		= "Local";     // 本地设备ID
    public static final String NET_DEVICE_ID_REMOTE              		= "Remote";    // 远程设备ID
    public static final String NET_DEVICE_ID_UNIQUE             		= "Unique";    // 设备内统一编号

    //其他定义
    public static final int NET_MAX_NAME_LEN                    = 16;   // 通用名字字符串长度
    public static final int NET_MAX_PERSON_ID_LEN               = 32;   // 人员id最大长度
    public static final int NET_MAX_PERSON_IMAGE_NUM            = 48;   // 每个人员对应的最大人脸图片数
    public static final int NET_MAX_PROVINCE_NAME_LEN           = 64;   // 省份名称最大长度
    public static final int NET_MAX_CITY_NAME_LEN               = 64;   // 城市名称最大长度
    public static final int NET_MAX_PERSON_NAME_LEN             = 64;   // 人员名字最大长度
    public static final int MAX_FACE_AREA_NUM                   = 8;    // 最大人脸区域个数
    public static final int MAX_PATH                            = 260;
    public static final int MAX_FACE_DB_NUM                     = 8;    // 最大人脸数据库个数
    public static final int MAX_GOURP_NUM                       = 128;  // 人脸库最大个数
    public static final int MAX_AGE_NUM						    = 2;	// 最大年龄个数
    public static final int MAX_EMOTION_NUM					    = 8;	// 最大表情条件的个数

    public static final int MAX_FIND_COUNT                      = 20;
    public static final int NET_MAX_POLYGON_NUM                 = 16;   // 多边形最大顶点个数
    public static final int NET_MAX_CANDIDATE_NUM               = 50;   // 人脸识别最大匹配数
    public static final int MAX_POLYGON_NUM                     = 20;   // 视频分析设备区域顶点个数上限
    public static final int MAX_CALIBRATEBOX_NUM                = 10;   // 智能分析校准框个数上限
    public static final int MAX_NAME_LEN                        = 128;  // 通用名字字符串长度
    public static final int MAX_EXCLUDEREGION_NUM               = 10;   // 智能分析检测区域中需要排除的区域个数上限
    public static final int MAX_SCENE_LIST_SIZE                 = 32;   // 视频分析设备支持的场景类型列表个数上限
    public static final int MAX_OBJECT_LIST_SIZE                = 16;   // 视频分析设备支持的检测物体类型列表个数上限
    public static final int MAX_RULE_LIST_SIZE                  = 128;  // 视频分析设备支持的规则列表个数上限
    public static final int MAX_ACTION_LIST_SIZE                = 16;   // 视频分析设备支持的规则的动作类型列表个数上限
    public static final int MAX_SPECIALDETECT_NUM               = 10;   // 智能分析特殊检测区域上限
    public static final int MAX_OBJECT_ATTRIBUTES_SIZE          = 16;   // 视频分析设备支持的检测物体属性类型列表个数上限
    public static final int MAX_CATEGORY_TYPE_NUMBER            = 128;  // 子类别类型数
    public static final int MAX_ANALYSE_MODULE_NUM              = 16;   // 视频分析设备最大检测模块个数
    public static final int MAX_LOG_PATH_LEN                    = 260;  // 日志路径名最大长度
    public static final int MAX_CHANNELNAME_LEN                 = 64;   // 最大通道名称长度
    public static final int MAX_VIDEO_CHANNEL_NUM               = 256;  // 最大通道数256
    public static final int MAX_PSTN_SERVER_NUM                 = 8;    // 最大报警电话服务器数
    public static final int MAX_TIME_SCHEDULE_NUM               = 8;    // 时间表元素个数
    public static final int MAX_REC_TSECT                       = 6;    // 录像时间段个数
    public static final int MAX_REC_TSECT_EX                    = 10;   // 录像时间段扩展个数
    public static final int MAX_NAS_TIME_SECTION                = 2;    // 网络存储时间段个数
    public static final int MAX_CHANNEL_COUNT                   = 16;
    public static final int MAX_ACCESSCONTROL_NUM               = 8;    // 最大门禁操作的组合数
    public static final int MAX_DBKEY_NUM                       = 64;   // 数据库关键字最大值
    public static final int MAX_SUMMARY_LEN                     = 1024; // 叠加到JPEG图片的摘要信息最大长度
    public static final int WEEK_DAY_NUM                        = 7;    // 一周的天数
    public static final int NET_MAX_FACEDETECT_FEATURE_NUM      = 32;   // 人脸特征最大个数
    public static final int NET_MAX_OBJECT_LIST                 = 16;   // 智能分析设备检测到的物体ID个数上限
    public static final int NET_MAX_RULE_LIST                   = 16;   // 智能分析设备规则个数上限
    public static final int MAX_HUMANFACE_LIST_SIZE             = 8;    // 视频分析设备支持的人脸检测类型列表个数上限
    public static final int MAX_FEATURE_LIST_SIZE				= 32;	// 视频分析设备支持的人脸属性列表个数上限
    public static final int NET_MAX_DETECT_REGION_NUM           = 20;   // 规则检测区域最大顶点数
    public static final int NET_MAX_DETECT_LINE_NUM             = 20;   // 规则检测线最大顶点数
    public static final int NET_MAX_TRACK_LINE_NUM              = 20;   // 物体运动轨迹最大顶点数
    public static final int NET_MACADDR_LEN                     = 40;   // MAC地址字符串长度
    public static final int NET_DEV_TYPE_LEN                    = 32;   // 设备型号字符串（如"IPC-F725"）长度
    public static final int NET_DEV_SERIALNO_LEN                = 48;   // 序列号字符串长度
    public static final int NET_MAX_URL_LEN                     = 128;  // URL字符串长度
    public static final int NET_MAX_STRING_LEN                  = 128;
    public static final int NET_MACHINE_NAME_NUM                = 64;   // 机器名称长度
    public static final int NET_USER_NAME_LENGTH_EX             = 16;   // 用户名长度
    public static final int NET_USER_NAME_LENGTH                = 8;    // 用户名长度
    public static final int NET_USER_PSW_LENGTH                 = 8;    // 用户密码长度
    public static final int NET_EVENT_NAME_LEN                  = 128;  // 事件名称长度
    public static final int NET_MAX_LANE_NUM                    = 8;    // 视频分析设备每个通道对应车道数上限
    public static final int MAX_DRIVING_DIR_NUM                 = 16;   // 车道行驶方向最大个数
    public static final int FLOWSTAT_ADDR_NAME                  = 16;   // 上下行地点名长
    public static final int NET_MAX_DRIVINGDIRECTION            = 256;  // 行驶方向字符串长度
    public static final int COMMON_SEAT_MAX_NUMBER              = 8;    // 默认检测最大座驾个数
    public static final int NET_MAX_ATTACHMENT_NUM              = 8;    // 最大车辆物件数量
    public static final int NET_MAX_ANNUUALINSPECTION_NUM       = 8;    // 最大年检标识位置
    public static final int NET_MAX_EVENT_PIC_NUM				= 6;    // 最大原始图片张数
    public static final int NET_COMMON_STRING_4                 = 4;    // 通用字符串长度4
    public static final int NET_COMMON_STRING_8                 = 8;    // 通用字符串长度8
    public static final int NET_COMMON_STRING_16                = 16;   // 通用字符串长度16
    public static final int NET_COMMON_STRING_20                = 20;   // 通用字符串长度20
    public static final int NET_COMMON_STRING_32                = 32;   // 通用字符串长度32
    public static final int NET_COMMON_STRING_64                = 64;   // 通用字符串长度64
    public static final int NET_COMMON_STRING_128               = 128;  // 通用字符串长度128
    public static final int NET_COMMON_STRING_256               = 256;  // 通用字符串长度256
    public static final int NET_COMMON_STRING_512               = 512;  // 通用字符串长度512
    public static final int NET_COMMON_STRING_1024              = 1024; // 通用字符串长度1024
    public static final int NET_COMMON_STRING_2048              = 2048; // 通用字符串长度2048
    public static final int MAX_VIDEOSTREAM_NUM                 = 4;    // 最大码流个数
    public static final int MAX_VIDEO_COVER_NUM                 = 16;   // 最大遮挡区域个数
    public static final int MAX_VIDEO_IN_ZOOM                   = 32;   // 单通道最大变速配置个数
    public static final int NET_EVENT_CARD_LEN                  = 36;   // 卡片名称长度
    public static final int NET_EVENT_MAX_CARD_NUM              = 16;   // 事件上报信息包含最大卡片个数
    public static final int MAX_STATUS_NUM                      = 16;   // 交通设备状态最大个数
    public static final int NET_MAX_CHANMASK 					= 64;   // 通道掩码最大值
    public static final int NET_CHAN_NAME_LEN                   = 32;   // 通道名长度,DVR DSP能力限制,最多32字节
    public static final int MAX_LANE_NUM                        = 8;    // 视频分析设备每个通道对应车道数上限
    public static final int MAX_STAFF_NUM                       = 20;   // 视频分析设备每个通道对应的标尺数上限
    public static final int MAX_ANALYSE_RULE_NUM                = 32;   // 视频分析设备最大规则个数
    public static final int MAX_POLYLINE_NUM                    = 20;   // 视频分析设备折线顶点个数上限
    public static final int MAX_TEMPLATEREGION_NUM              = 32;   // 视频分析设备模拟区域信息点对个数上限
    public static final int POINT_PAIR_NUM                      = 2;    // 视频分析设备模拟区域点对包含的点个数
    public static final int MAX_VEHICLE_SIZE_LIST               = 4;    // 视频分析设备车辆大小个数上限
    public static final int MAX_VEHICLE_TYPE_LIST               = 4;    // 视频分析设备车辆类型个数上限
    public static final int MAX_PLATE_TYPE_LIST                 = 32;   // 视频分析设备车牌类型个数上限
    public static final int MAX_CALIBRATEAREA_NUM               = 20;   // 视频分析设备标定区域的上限
    public static final int MAX_ANALYSE_SCENE_NUM               = 32;   // 视频分析全局配置场景最大数量
    public static final int MAX_PLATEHINT_NUM                   = 8;    // 车牌字符暗示个数上限
    public static final int MAX_LIGHT_NUM                       = 8;    // 交通灯个数上限
    public static final int MAX_LIGHTGROUP_NUM                  = 8;    // 交通灯组个数上限
    public static final int MAX_LIGHT_TYPE                      = 8;    // 交通灯类型上限
    public static final int MAX_PARKING_SPACE_NUM          		= 6;    // 最多配置6个车位信息
    public static final int MAX_SHIELD_AREA_NUM            		= 16;   // 1个车位最多对应16个屏蔽区域
    public static final int MAX_SCENE_TYPE_LIST_SIZE            = 8;    // 场景列表中最多支持的场景个数
    public static final int MAX_LIGHT_DIRECTION                 = 8;    // 交通灯指示方向数上限
    public static final int CFG_FLOWSTAT_ADDR_NAME			    = 16;	//上下行地点名长
    public static final int MAX_ACCESS_READER_NUM               = 32;   // 门禁单个门最大读卡器数量
    public static final int MAX_ACCESSSUBCONTROLLER_NUM         = 64;   // 最大门禁分控器数量
    public static final int MAX_BACKPIC_COUNT					= 8;	// 最大背景图片个数
    public static final int NET_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN = 32;// 无线设备序列号最大长度
    public static final int NET_MAX_CUSTOM_PERSON_INFO_NUM		= 4;    // 注册人员信息扩展最大个数
    public static final int NET_MAX_PERSON_INFO_LEN         	= 64;   // 人员扩展信息最大长度
    public static final int MAX_ALARMEXT_MODULE_NUM        		= 256;  // 最大扩展模块数目
    public static final int MAX_CALIBRATEAREA_TYPE_NUM          = 4;    // 标定区域类型上限
    public static final int MAX_SCENE_SUBTYPE_LEN               = 64;   // 场景子类型字符串长度
    public static final int MAX_SCENE_SUBTYPE_NUM               = 32;   // 场景子类型最大个数  
    public static final int	MAX_SUPPORTED_COMP_SIZE             = 4;    // 最大支持的场景组合项
    public static final int	MAX_SUPPORTED_COMP_DATA             = 8;    // 每个组合项里最多支持的场景个数
    public static final int MAX_NUMBER_STAT_MAULT_NUM			= 32;	// 最大客流量统计场景PD个数
    
    public static final int NET_NEW_MAX_RIGHT_NUM               = 1024; // 用户权限个数上限
    public static final int NET_MAX_GROUP_NUM                   = 20;   // 用户组个数上限
    public static final int NET_MAX_USER_NUM                    = 200;  // 用户个数上限
    public static final int NET_RIGHT_NAME_LENGTH               = 32;   // 权限名长度
    public static final int NET_MEMO_LENGTH                     = 32;   // 备注长度
    public static final int NET_NEW_USER_NAME_LENGTH            = 128;  // 用户名长度
    public static final int NET_NEW_USER_PSW_LENGTH             = 128;  // 密码
    public static final int NET_MAX_RIGHT_NUM                   = 100;  // 用户权限个数上限
    public static final int NET_COMMENT_LENGTH					= 100;	// 备注信息长度
    public static final int NET_GROUPID_LENGTH					= 64;	// group id 信息长度
    public static final int NET_GROUPNAME_LENGTH				= 128;	// group name 信息长度
    public static final int NET_FEATUREVALUE_LENGTH				= 128;	// 人脸特征 信息长度

    public static final int	MAX_GROUP_ID_LEN					= 64;	// 最大布控组ID长度
    public static final int	MAX_COLOR_NAME_LEN					= 32;	// 最大颜色名长度
    public static final int	MAX_COLOR_HEX_LEN					= 8;	// 最大HEX颜色长度
    public static final int	MAX_LINK_GROUP_NUM					= 20;	// 联动的布控组最大数量
    public static final int MAX_PATH_LEN					    = 260;	// 最大路径长度
    public static final int MAX_RIDER_NUM 						= 16;	// 骑车人数组上限
    public static final int MAX_ALARM_CHANNEL_NAME_LEN		    = 64;   // 最大报警名称长度
    public static final int MAX_ATTACHMENT_NUM				    = 8;	// 最大车内物品个数
    public static final int NET_MAX_FRAMESEQUENCE_NUM				= 2;	// 最大帧序号个数
    public static final int NET_MAX_TIMESTAMP_NUM					= 2;	// 最大时间戳个数
    public static final int NET_VIDEOANALYSE_SCENES   			 = 32;		// 最大场景个数
    public static final int NET_VIDEOANALYSE_RULES   			 = 64;		// 最大规则个数
    public static final int SDK_EVENT_NAME_LEN                  = 128;        // 事件名称长度
    // 支持用户名最大长度为8位或16位的设备,对应扩展接口CLIENT_QueryUserInfoEx和CLIENT_OperateUserInfoEx
    public static final int NET_USER_PSW_LENGTH_EX       		= 16;   // 密码

    public static final int AV_CFG_Device_ID_Len				= 64;   // 设备ID长度
    public static final int AV_CFG_Channel_Name_Len             = 64;   // 通道名称长度
    public static final int AV_CFG_Monitor_Name_Len				= 64;	// 电视墙名称长度
    public static final int AV_CFG_Max_TV_In_Block				= 128;	// 区块中TV的最大数量
    public static final int AV_CFG_Max_Block_In_Wall			= 128;	// 电视墙中区块的最大数量
    public static final int AV_CFG_IP_Address_Len				= 32;   // IP 长度
    public static final int AV_CFG_Protocol_Len 				= 32;   // 协议名长度
    public static final int AV_CFG_User_Name_Len 				= 64;   // 用户名长度
    public static final int	AV_CFG_Password_Len 				= 64;   // 密码长度
    public static final int AV_CFG_Serial_Len					= 32;	// 序列号长度
    public static final int AV_CFG_Device_Class_Len				= 16;   // 设备类型长度
    public static final int AV_CFG_Device_Type_Len				= 32;	// 设备具体型号长度
    public static final int AV_CFG_Device_Name_Len				= 128;	// 机器名称
    public static final int AV_CFG_Address_Len					= 128;	// 机器部署地点
    public static final int AV_CFG_Max_Path						= 260;	// 路径长度
    public static final int AV_CFG_Group_Name_Len               = 64;   // 分组名称长度
    public static final int AV_CFG_DeviceNo_Len                 = 32;   // 设备编号长度
    public static final int AV_CFG_Group_Memo_Len               = 128;  // 分组说明长度
    public static final int AV_CFG_Max_Channel_Num              = 1024; // 最大通道数量
    public static final int MAX_DEVICE_NAME_LEN					= 64;   // 机器名称
    public static final int MAX_DEV_ID_LEN_EX					= 128;  // 设备ID最大长度
    public static final int MAX_PATH_STOR                       = 240;  // 远程目录的长度
    public static final int	MAX_REMOTE_DEV_NUM       			= 256;  // 最大远程设备数量
    public static final int NET_MAX_PLATE_NUMBER_LEN            = 32;   // 车牌字符长度
    public static final int NET_MAX_AUTHORITY_LIST_NUM          = 16;   // 权限列表最大个数
    public static final int NET_MAX_ALARMOUT_NUM_EX 			= 32;   //报警输出口个数上限扩展
    public static final int NET_MAX_VIDEO_IN_NUM_EX 			= 32;   //视频输入口个数上限扩展
    public static final int NET_MAX_SAERCH_IP_NUM               = 256;  // 最大搜索IP个数
    public static final int NET_MAX_POS_MAC_NUM                 = 8;    // 刷卡机Mac码最大长度
    public static final int NET_MAX_BUSCARD_NUM                 = 64;   // 公交卡号最大长度
    public static final int NET_STORAGE_NAME_LEN                = 128;  // 存储设备名称长度

    public static final int NET_MAX_DOOR_NUM               		= 32;   // 最大有权限门禁数目
    public static final int NET_MAX_TIMESECTION_NUM        		= 32;   // 最大有效时间段数目
    public static final int NET_MAX_CARDNAME_LEN           		= 64;   // 门禁卡命名最大长度
    public static final int NET_MAX_CARDNO_LEN             		= 32;   // 门禁卡号最大长度
    public static final int NET_MAX_USERID_LEN             		= 32;   // 门禁卡用户ID最大长度
    public static final int NET_MAX_IC_LEN				  		= 32;	// 身份证最大长度
    public static final int NET_MAX_QRCODE_LEN			  		= 128;	// QRCode 最大长度
    public static final int NET_MAX_CARD_INFO_LEN               = 256;  // 卡号信息最大长度
    public static final int NET_MAX_SIM_LEN                     = 16;   // SIM卡的值的最大长度
    public static final int NET_MAX_DISKNUM                     = 256;  // 最大硬盘个数
    public static final int MAX_FACE_DATA_NUM                	= 20;   // 人脸模版最大个数
    public static final int MAX_FINGERPRINT_NUM              	= 10;   // 最大指纹个数
    public static final int MAX_FACE_DATA_LEN                   = 2 * 1024; // 人脸模版数据最大长度
    public static final int MAX_COMMON_STRING_8              	= 8;    // 通用字符串长度8
    public static final int MAX_COMMON_STRING_16             	= 16;   // 通用字符串长度16
    public static final int MAX_COMMON_STRING_32             	= 32;   // 通用字符串长度32
    public static final int MAX_COMMON_STRING_64             	= 64;   // 通用字符串长度64
    public static final int MAX_COMMON_STRING_128               = 128;  // 通用字符串长度128
    public static final int MAX_USER_NAME_LEN                   = 128;  // 最大用户名长度
    public static final int MAX_ROOMNUM_COUNT					= 32;	// 房间最大个数
    public static final int MAX_FACE_COUTN						= 20;	// 人脸模板数据最大个数
    public static final int MAX_PHOTO_COUNT                     = 5;    // 人脸照片最大个数
    public static final int MAX_WINDOWS_COUNT					= 16;	// 诱导屏最大窗口个数
    public static final int MAX_CLASS_NUMBER_LEN			    = 32;	// 最大班级长度
    public static final int MAX_PHONENUMBER_LEN				    = 16;   // 最大电话长度
    public static final int MAX_NASFILE_NUM                     = 8;    // 最大NAS文件个数
    public static final int MAX_CELL_PHONE_NUMBER_LEN           = 32;   // 最大手机号长度
    public static final int MAX_MAIL_LEN                        = 64;   // 邮箱最大长度
    public static final int MAX_PWD_LEN                         = 128;  // 最大密码长度
    public static final int MAX_ACCESS_FLOOR_NUM                = 64;   // 最大楼层数量
    public static final int MAX_ORDER_NUMBER 					= 6;	// 排序规则的最大数量
    public static final int MAX_NUMBER_REGISTER_INFO			= 32;
    public static final int MAX_COMPANION_CARD_NUM              = 6;    // 陪同者卡号最大个数

    public static final int CFG_COMMON_STRING_8                 = 8;    // 通用字符串长度8
    public static final int CFG_COMMON_STRING_16                = 16;   // 通用字符串长度16
    public static final int CFG_COMMON_STRING_32                = 32;   // 通用字符串长度32
    public static final int CFG_COMMON_STRING_64                = 64;   // 通用字符串长度64
    public static final int CFG_COMMON_STRING_128               = 128;  // 通用字符串长度128
    public static final int CFG_COMMON_STRING_256               = 256;  // 通用字符串长度256
    public static final int CFG_COMMON_STRING_512               = 512;  // 通用字符串长度512

    public static final int MAX_COILCONFIG          			= 3;    // 智能交通车检器线圈配置上限
    public static final int MAX_DETECTOR            			= 6;    // 智能交通车检器配置上限
    public static final int MAX_VIOLATIONCODE					= 16;   // 智能交通违章代码长度上限
    public static final int MAX_LANE_CONFIG_NUMBER              = 32;   // 车道最大个数
    public static final int MAX_VIOLATIONCODE_DESCRIPT          = 64;   // 智能交通违章代码长度上限
    public static final int MAX_ROADWAYNO           			= 128;  // 道路编号	由32个数字和字母构成
    public static final int MAX_PRIORITY_NUMBER                 = 256;  // 违章优先级包含违章最大个数
    public static final int MAX_DRIVINGDIRECTION          		= 256;  // 行驶方向字符串长度

    public static final int MAX_OSD_CUSTOM_SORT_NUM       		= 8;
    public static final int MAX_OSD_CUSTOM_SORT_ELEM_NUM  		= 8;
    public static final int MAX_OSD_CUSTOM_GENERAL_NUM    		= 8;
    public static final int MAX_OSD_ITEM_ATTR_NUM         		= 8;
    public static final int MAX_PRE_POX_STR_LEN           		= 32;
    public static final int MAX_OSD_CUSTOM_NAME_LEN       		= 32;
    public static final int MAX_OSD_CUSTOM_VALUE_LEN      		= 256;
    public static final int MAX_CONF_CHAR 						= 256;
    public static final int MAX_IVS_EVENT_NUM    				= 256;
    public static final int MAX_QUERY_USER_NUM   				= 4;    // 最大查询用户个数
    public static final int MAX_DEVICE_ADDRESS      			= 256;  // TrafficSnapshot智能交通设备地址
    public static final int MAX_STORAGE_NUM                 	= 8;    // 存储设备最大个数
    public static final int MAX_PARTITION_NUM               	= 8;    // 最大分区个数
    public static final int MAX_SCADA_POINT_LIST_INFO_NUM       = 256;  // 最大点位表路径个数
    public static final int MAX_SCADA_POINT_LIST_ALARM_INFO_NUM = 256;  // 最大点位表报警个数
    public static final int	MAX_LABEL_ARRAY						= 1024;

    public static final int	MAX_DELIVERY_FILE_NUM  				= 128;  // 最大投放文件数量
    public static final int	DELIVERY_FILE_URL_LEN  				= 128;  // 投放文件的URL长度

    public static final int MAX_COMMON_STRING_512               = 512;  // 通用字符串长度512
    public static final int	MAX_RFIDELETAG_CARDID_LEN		    = 16;	// RFID 电子车牌标签信息中卡号最大长度
    public static final int	MAX_RFIDELETAG_DATE_LEN		 	    = 16;	// RFID 电子车牌标签信息中时间最大长度
    public static final int MAX_REPEATENTERROUTE_NUM   			= 12;   //反潜路径个数
    public static final int ECK_SCREEN_NUM_MAX                  = 8;    // 智能停车系统出入口机最大屏数量
    public static final int MAX_CAR_CANDIDATE_NUM				= 50;
    public static final int MAX_REGISTER_NUM                    = 10;   // 主动注册配置最大个数
    public static final int MAX_SERVER_NUM                      = 10;   // 服务器最大个数
    public static final int	NET_COUNTRY_LENGTH				    = 3;	// 国家缩写长度
    public static final int	MAX_ATTENDANCE_USERNAME_LEN			= 36;	// 考勤用户名长度
    public static final int	NET_MAX_FINGER_PRINT				= 10;	// 指纹最大个数
    public static final int	MAX_EVENT_ID_LEN					= 52;   // 国标事件ID最大长度
    public static final int	MAX_HUMANTRAIT_EVENT_LEN			= 36; 	// 补充人体特征上报事件最大长度
    public static final int MAX_EXIT_MAN_NUM					= 32;	// 最大支持的离开人员数量
    public static final int NET_MAX_CALLTYPE_LIST_NUM           = 16;   // 呼叫类型查询条件列表最大个数
    public static final int NET_MAX_ENDSTATE_LIST_NUM           = 16;   // 最终状态查询条件列表最大个数
    public static final int MAX_CHAN_NUM						= 256;  // 最大通道数上限
    public static final int AV_CFG_Max_ChannelRule				= 32;   // 通道存储规则最大长度, 仅通道部分
    public static final int MAX_DEV_NUM							= 16;   // 最大设备上限
    public static final int CFG_MAX_CHANNEL_NAME_LEN			= 256;  // 通道名称最大长度
    public static final int HDBJ_MAX_OBJECTS_NUM 				= 200;  // 检测到目标的最大个数
    public static final int NET_MAX_RAID_NUM  					= 16;	// Raid最大个数
    public static final int MAX_PLATE_NUMBER_LEN           		= 64;   // 最大车牌号码长度
    public static final int MAX_MASTER_OF_CAR_LEN          		= 32;   // 最大车主姓名长度
    public static final int MAX_USER_TYPE_LEN              		= 32;   // 最大用户类型长度
    public static final int MAX_SUB_USER_TYPE_LEN         		= 64;   // 最大用户子类型长度
    public static final int MAX_REMARKS_LEN                		= 64;   // 最大备注信息长度
    public static final int MAX_PARK_CHARGE_LEN            		= 32;   // 最大停车费长度
    public static final int MAX_CUSTOM_LEN                 		= 128;  // 最大自定义显示长度
    public static final int MAX_RESOURCE_LEN               		= 64;   // 最大资源文件长度
    public static final int MAX_PARKINGLOCK_STATE_NUM      		= 6;    // 最大车位锁状态个数
    public static final int MAX_SMALLPIC_NUM  					= 32;	// 最大小图张数
    public static final int MAX_PASSWORD_LEN               		= 64;   // 最大密码长度
    public static final int MAX_OSD_SUMMARY_LEN            		= 256;  // osd叠加内容最大长度
    public static final int MAX_OSD_TITLE_LEN              		= 128;  // osd叠加标题最大长度
    public static final int MAX_CUSTOMCASE_NUM             		= 16;   // 自定义司法案件最大个数
    public static final int MAX_CARGO_CHANNEL_NUM          		= 8;    // 最大货物通道数
    public static final int MAX_MAN_LIST_COUNT             		= 64;   // 人员列表最大数量
    public static final int MAX_SNAP_SHOT_NUM              		= 8;    // 最大抓拍张数

    // 矩阵子卡类型, 多种类型可以组合
    public static final int NET_MATRIX_CARD_MAIN                = 0x10000000;   // 主卡
    public static final int NET_MATRIX_CARD_INPUT               = 0x00000001;   // 输入卡
    public static final int NET_MATRIX_CARD_OUTPUT              = 0x00000002;   // 输出卡
    public static final int NET_MATRIX_CARD_ENCODE              = 0x00000004;   // 编码卡
    public static final int NET_MATRIX_CARD_DECODE              = 0x00000008;   // 解码卡
    public static final int NET_MATRIX_CARD_CASCADE             = 0x00000010;   // 级联卡
    public static final int NET_MATRIX_CARD_INTELLIGENT         = 0x00000020;   // 智能卡
    public static final int NET_MATRIX_CARD_ALARM               = 0x00000040;   // 报警卡
    public static final int NET_MATRIX_CARD_RAID                = 0x00000080;   // 硬Raid卡
    public static final int NET_MATRIX_CARD_NET_DECODE          = 0x00000100;   // 网络解码卡

    public static final int RESERVED_TYPE_FOR_INTEL_BOX 		= 0x00000001;
    public static final int RESERVED_TYPE_FOR_COMMON   			= 0x00000010;
    public static final int RESERVED_TYPE_FOR_PATH         		= 0x00000100;

    public static final int NET_DATA_CALL_BACK_VALUE      		= 1000;       	// 配合EM_REAL_DATA_TYPE使用,码流转换后的数据回调函数(fRealDataCallBackEx,fDataCallBack)中的参数dwDataType的值
    // 为所转换的码流类型加上NET_DATA_CALL_BACK_VALUE.
    // 即,dwDataType = NET_DATA_CALL_BACK_VALUE + emDataType
    // 在回调函数中接受码流转换后的数据,必须要先判断 dwDataType 的值是否为 NET_DATA_CALL_BACK_VALUE和emDataType之和
    // 另,EM_REAL_DATA_TYPE_PRIVATE不用做此判断

    public static final int DH_MAX_PERSON_INFO_LEN         = 64;      // 人员扩展信息最大长度

    /**************************录像二次分析接口*************************/
    public static final int MAX_SECONDARY_ANALYSE_TASK_NUM		= 32;  // 二次分析任务支持的最大个数
    public static final int MAX_SECONDARY_ANALYSE_RULE_NUM		= 8;	  // 二次分析规则支持的最大个数
    public static final int MAX_SECONDARY_ANALYSE_EVENT_NUM		= 8;	  // 二次分析事件支持的最大个数

    /************************************************************************
     ** 结构体
     ***********************************************************************/
    // 设置登入时的相关参数
    public static class NET_PARAM  extends SdkStructure
    {
        public int                    nWaittime;                // 等待超时时间(毫秒为单位)，为0默认5000ms
        public int                    nConnectTime;            	// 连接超时时间(毫秒为单位)，为0默认1500ms
        public int                    nConnectTryNum;           // 连接尝试次数，为0默认1次
        public int                    nSubConnectSpaceTime;    	// 子连接之间的等待时间(毫秒为单位)，为0默认10ms
        public int                    nGetDevInfoTime;        	// 获取设备信息超时时间，为0默认1000ms
        public int                    nConnectBufSize;        	// 每个连接接收数据缓冲大小(字节为单位)，为0默认250*1024
        public int                    nGetConnInfoTime;         // 获取子连接信息超时时间(毫秒为单位)，为0默认1000ms
        public int                    nSearchRecordTime;      	// 按时间查询录像文件的超时时间(毫秒为单位),为0默认为3000ms
        public int                    nsubDisconnetTime;      	// 检测子链接断线等待时间(毫秒为单位)，为0默认为60000ms
        public byte                   byNetType;                // 网络类型, 0-LAN, 1-WAN
        public byte                   byPlaybackBufSize;      	// 回放数据接收缓冲大小（M为单位），为0默认为4M
        public byte                   bDetectDisconnTime;       // 心跳检测断线时间(单位为秒),为0默认为60s,最小时间为2s
        public byte                   bKeepLifeInterval;        // 心跳包发送间隔(单位为秒),为0默认为10s,最小间隔为2s
        public int                    nPicBufSize;              // 实时图片接收缓冲大小（字节为单位），为0默认为2*1024*1024
        public byte[]                 bReserved = new byte[4];  // 保留字段字段
    }

    // 设备设备参数
    public static class NET_DEVICE_SEARCH_PARAM extends SdkStructure {

        public int       	dwSize;						// 结构体大小
        /**
         * 是否使用默认配置,默认为TRUE
         */
        public int        	bUseDefault;
        /**
         * 广播本地端口, 默认5050, 值为0时使用最近一次配置
         */
        public short        wBroadcastLocalPort;
        /**
         * 广播远程端口, 默认5050, 值为0时使用最近一次配置
         */
        public short        wBroadcastRemotePort;
        /**
         * 组播远程端口, 默认37810, 值为0时使用最近一次配置
         */
        public short        wMulticastRemotePort;
        /**
         * 组播修改设备时是否只支持组播回复,默认FALSE表示单播或组播回复
         */
        public int        	bMulticastModifyRespond;
        /**
         * 组播本地端口, 默认37810, 值为0时使用最近一次配置
         */
        public short        wMulticastLocalPort;
        /**
         * 端口不可用时自动更新端口次数,默认50次，范围[0-65534]
         */
        public int			iAutoUpdatePortTimes;
        /**
         * AOL 组播远程端口, 默认8087, 值为0时使用最近一次配置
         */
        public short        wAOLMulticastRemotePort;
        /**
         * AOL 组播本地端口, 默认37811, 值为0时使用最近一次配置
         */
        public short        wAOLMulticastLocalPort;

        public NET_DEVICE_SEARCH_PARAM() {
            this.dwSize = this.size();
        }
    }

    // 设备信息
    public static class NET_DEVICEINFO extends SdkStructure {
        public byte[]              sSerialNumber = new byte[NET_SERIALNO_LEN];    // 序列号
        public byte                byAlarmInPortNum;         // DVR报警输入个数
        public byte                byAlarmOutPortNum;        // DVR报警输出个数
        public byte                byDiskNum;                // DVR硬盘个数
        public byte                byDVRType;                // DVR类型, 见枚举NET_DEV_DEVICE_TYPE
        public union 			   union = new union();
        public static class union extends Union {
            public byte                byChanNum;                // DVR通道个数
            public byte                byLeftLogTimes;           // 当登陆失败原因为密码错误时,通过此参数通知用户,剩余登陆次数,为0时表示此参数无效
        }
    }

    // 设备信息扩展///////////////////////////////////////////////////
    public static class NET_DEVICEINFO_Ex extends SdkStructure {
        public byte[]     sSerialNumber = new byte[NET_SERIALNO_LEN];    // 序列号
        public int        byAlarmInPortNum;                              // DVR报警输入个数
        public int        byAlarmOutPortNum;                             // DVR报警输出个数
        public int        byDiskNum;                                     // DVR硬盘个数
        public int        byDVRType;                                     // DVR类型,见枚举NET_DEVICE_TYPE
        public int        byChanNum;                                     // DVR通道个数
        public byte       byLimitLoginTime;                              // 在线超时时间,为0表示不限制登陆,非0表示限制的分钟数
        public byte       byLeftLogTimes;                                // 当登陆失败原因为密码错误时,通过此参数通知用户,剩余登陆次数,为0时表示此参数无效
        public byte[]     bReserved = new byte[2];                       // 保留字节,字节对齐
        public int        byLockLeftTime;                                // 当登陆失败,用户解锁剩余时间（秒数）, -1表示设备未设置该参数
        public byte[]     Reserved = new byte[24];                       // 保留
    }

    // 对应接口 CLIENT_LoginEx2/////////////////////////////////////////////////////////
    public static class EM_LOGIN_SPAC_CAP_TYPE extends SdkStructure {
        public static final int EM_LOGIN_SPEC_CAP_TCP               = 0;    // TCP登陆, 默认方式
        public static final int EM_LOGIN_SPEC_CAP_ANY               = 1;    // 无条件登陆
        public static final int EM_LOGIN_SPEC_CAP_SERVER_CONN       = 2;    // 主动注册的登入
        public static final int	EM_LOGIN_SPEC_CAP_MULTICAST         = 3;    // 组播登陆
        public static final int	EM_LOGIN_SPEC_CAP_UDP               = 4;    // UDP方式下的登入
        public static final int	EM_LOGIN_SPEC_CAP_MAIN_CONN_ONLY    = 6;    // 只建主连接下的登入
        public static final int	EM_LOGIN_SPEC_CAP_SSL               = 7;    // SSL加密方式登陆

        public static final int	EM_LOGIN_SPEC_CAP_INTELLIGENT_BOX   = 9;    // 登录智能盒远程设备
        public static final int	EM_LOGIN_SPEC_CAP_NO_CONFIG         = 10;   // 登录设备后不做取配置操作
        public static final int EM_LOGIN_SPEC_CAP_U_LOGIN           = 11;   // 用U盾设备的登入
        public static final int	EM_LOGIN_SPEC_CAP_LDAP              = 12;   // LDAP方式登录
        public static final int EM_LOGIN_SPEC_CAP_AD                = 13;   // AD（ActiveDirectory）登录方式
        public static final int EM_LOGIN_SPEC_CAP_RADIUS            = 14;   // Radius 登录方式
        public static final int EM_LOGIN_SPEC_CAP_SOCKET_5          = 15;   // Socks5登陆方式
        public static final int EM_LOGIN_SPEC_CAP_CLOUD             = 16;   // 云登陆方式
        public static final int EM_LOGIN_SPEC_CAP_AUTH_TWICE        = 17;   // 二次鉴权登陆方式
        public static final int EM_LOGIN_SPEC_CAP_TS                = 18;   // TS码流客户端登陆方式
        public static final int	EM_LOGIN_SPEC_CAP_P2P               = 19;   // 为P2P登陆方式
        public static final int	EM_LOGIN_SPEC_CAP_MOBILE            = 20;   // 手机客户端登陆
    }

    // 时间
    public static class NET_TIME extends SdkStructure {
        public int                dwYear;                   // 年
        public int                dwMonth;                  // 月
        public int                dwDay;                    // 日
        public int                dwHour;                   // 时
        public int                dwMinute;                 // 分
        public int                dwSecond;                 // 秒

        public NET_TIME() {
            this.dwYear = 0;
            this.dwMonth = 0;
            this.dwDay = 0;
            this.dwHour = 0;
            this.dwMinute = 0;
            this.dwSecond = 0;
        }

        public void setTime(int year, int month, int day, int hour, int minute, int second) {
            this.dwYear = year;
            this.dwMonth = month;
            this.dwDay = day;
            this.dwHour = hour;
            this.dwMinute = minute;
            this.dwSecond = second;
        }

        public NET_TIME(NET_TIME other) {
            this.dwYear = other.dwYear;
            this.dwMonth = other.dwMonth;
            this.dwDay = other.dwDay;
            this.dwHour = other.dwHour;
            this.dwMinute = other.dwMinute;
            this.dwSecond = other.dwSecond;
        }

        //用于列表中显示
        public String toStringTime() {
            return  String.format("%02d/%02d/%02d %02d:%02d:%02d", dwYear, dwMonth, dwDay, dwHour, dwMinute, dwSecond);
        }

        public String toStringTimeEx() {
            return  String.format("%02d-%02d-%02d %02d:%02d:%02d", dwYear, dwMonth, dwDay, dwHour, dwMinute, dwSecond);
        }

        public String toString() {
            return String.format("%02d%02d%02d%02d%02d%02d", dwYear, dwMonth, dwDay, dwHour, dwMinute, dwSecond);
        }
    }

    public static class NET_TIME_EX extends SdkStructure
    {
        public int                dwYear;                    // 年
        public int                dwMonth;                   // 月
        public int                dwDay;                     // 日
        public int                dwHour;                    // 时
        public int                dwMinute;                  // 分
        public int                dwSecond;                  // 秒
        public int                dwMillisecond;             // 毫秒
        public int                dwUTC;             		 // utc时间(获取时0表示无效，非0有效   下发无效)
        public int[]              dwReserved = new int[1];   // 保留字段

        public void setTime(int year, int month, int day, int hour, int minute, int second) {
            this.dwYear = year;
            this.dwMonth = month;
            this.dwDay = day;
            this.dwHour = hour;
            this.dwMinute = minute;
            this.dwSecond = second;
            this.dwMillisecond = 0;
        }

        public String toString() {
            return dwYear + "/" + dwMonth + "/" + dwDay + " " + dwHour + ":" + dwMinute + ":" + dwSecond;
        }

        //用于列表中显示
        public String toStringTime()
        {
            return  String.format("%02d/%02d/%02d %02d:%02d:%02d", dwYear, dwMonth, dwDay, dwHour, dwMinute, dwSecond);
        }

        //存储文件名使用
        public String toStringTitle()
        {
            return  String.format("Time_%02d%02d%02d_%02d%02d%02d", dwYear, dwMonth, dwDay, dwHour, dwMinute, dwSecond);
        }
    }

    // 区域
    public static class  NET_CFG_Rect extends SdkStructure
    {
        public int            nStructSize;
        public int            nLeft;
        public int            nTop;
        public int            nRight;
        public int            nBottom;

        public NET_CFG_Rect()
        {
            this.nStructSize = this.size();
        }
    }

    // 颜色
    public static class  NET_CFG_Color extends SdkStructure
    {
        public int            nStructSize;
        public int            nRed;                            		// 红
        public int            nGreen;                            	// 绿
        public int            nBlue;                            	// 蓝
        public int            nAlpha;                            	// 透明

        public NET_CFG_Color()
        {
            this.nStructSize = this.size();
        }
    }

    // 编码物件-通道标题
    public static class  NET_CFG_VideoWidgetChannelTitle extends SdkStructure
    {
        public int                nStructSize;
        public int            	  bEncodeBlend;                    // 叠加到主码流, 类型为BOOL, 取值0或者1
        public int            	  bEncodeBlendExtra1;              // 叠加到辅码流1, 类型为BOOL, 取值0或者1
        public int                bEncodeBlendExtra2;              // 叠加到辅码流2, 类型为BOOL, 取值0或者1
        public int            	  bEncodeBlendExtra3;              // 叠加到辅码流3, 类型为BOOL, 取值0或者1
        public int            	  bEncodeBlendSnapshot;            // 叠加到抓图, 类型为BOOL, 取值0或者1
        public NET_CFG_Color      stuFrontColor = new NET_CFG_Color();    // 前景色
        public NET_CFG_Color      stuBackColor = new NET_CFG_Color();    // 背景色
        public NET_CFG_Rect       stuRect = new NET_CFG_Rect();        // 区域, 坐标取值0~8191, 仅使用left和top值, 点(left,top)应和(right,bottom)设置成同样的点
        public int            bPreviewBlend;                    // 叠加到预览视频, 类型为BOOL， 取值0或者1

        public NET_CFG_VideoWidgetChannelTitle()
        {
            this.nStructSize = this.size();
        }
    }

    // 编码物件-时间标题
    public static class  NET_CFG_VideoWidgetTimeTitle extends SdkStructure
    {
        public int                nStructSize;
        public int            bEncodeBlend;                        // 叠加到主码流, 类型为BOOL, 取值0或者1
        public int            bEncodeBlendExtra1;                    // 叠加到辅码流1, 类型为BOOL, 取值0或者1
        public int            bEncodeBlendExtra2;                    // 叠加到辅码流2, 类型为BOOL, 取值0或者1
        public int            bEncodeBlendExtra3;                    // 叠加到辅码流3, 类型为BOOL, 取值0或者1
        public int            bEncodeBlendSnapshot;                // 叠加到抓图, 类型为BOOL, 取值0或者1
        public NET_CFG_Color        stuFrontColor = new NET_CFG_Color();    // 前景色
        public NET_CFG_Color        stuBackColor = new NET_CFG_Color();    // 背景色
        public NET_CFG_Rect        stuRect = new NET_CFG_Rect();        // 区域, 坐标取值0~8191, 仅使用left和top值, 点(left,top)应和(right,bottom)设置成同样的点
        public int            bShowWeek;                            // 是否显示星期, 类型为BOOL, 取值0或者1
        public int            bPreviewBlend;                        // 叠加到预览视频, 类型为BOOL, 取值0或者1

        public NET_CFG_VideoWidgetTimeTitle()
        {
            this.nStructSize = this.size();
        }
    }

    // 编码物件-区域覆盖配置
    public static class  NET_CFG_VideoWidgetCover extends SdkStructure
    {
        public int                nStructSize;
        public int            bEncodeBlend;                    // 叠加到主码流, 类型为BOOL, 取值0或者1
        public int            bEncodeBlendExtra1;                // 叠加到辅码流1, 类型为BOOL, 取值0或者1
        public int            bEncodeBlendExtra2;                // 叠加到辅码流2, 类型为BOOL, 取值0或者1
        public int            bEncodeBlendExtra3;                // 叠加到辅码流3, 类型为BOOL, 取值0或者1
        public int            bEncodeBlendSnapshot;            // 叠加到抓图, 类型为BOOL, 取值0或者1
        public NET_CFG_Color        stuFrontColor = new NET_CFG_Color();        // 前景色
        public NET_CFG_Color        stuBackColor = new NET_CFG_Color();        // 背景色
        public NET_CFG_Rect        stuRect = new NET_CFG_Rect();            // 区域, 坐标取值0~8191
        public int            bPreviewBlend;                    // 叠加到预览视频, 类型为BOOL, 取值0或者1

        public NET_CFG_VideoWidgetCover()
        {
            this.nStructSize = this.size();
        }
    }

    public class EM_TITLE_TEXT_ALIGN
    {
        public static final int EM_TEXT_ALIGN_INVALID         = 0;     // 无效的对齐方式
        public static final int EM_TEXT_ALIGN_LEFT            = 1;       // 左对齐
        public static final int EM_TEXT_ALIGN_XCENTER        = 2;    // X坐标中对齐
        public static final int EM_TEXT_ALIGN_YCENTER        = 3;    // Y坐标中对齐
        public static final int EM_TEXT_ALIGN_CENTER        = 4;      // 居中
        public static final int EM_TEXT_ALIGN_RIGHT            = 5;       // 右对齐
        public static final int EM_TEXT_ALIGN_TOP            = 6;       // 按照顶部对齐
        public static final int EM_TEXT_ALIGN_BOTTOM        = 7;     // 按照底部对齐
        public static final int EM_TEXT_ALIGN_LEFTTOP        = 8;    // 按照左上角对齐
        public static final int EM_TEXT_ALIGN_CHANGELINE    = 9;      // 换行对齐
    }

    // 编码物件-自定义标题
    public static class  NET_CFG_VideoWidgetCustomTitle extends SdkStructure
    {
        public int                nStructSize;
        public int            bEncodeBlend;                        // 叠加到主码流, 类型为BOOL, 取值0或者1
        public int            bEncodeBlendExtra1;                    // 叠加到辅码流1, 类型为BOOL, 取值0或者1
        public int            bEncodeBlendExtra2;                    // 叠加到辅码流2, 类型为BOOL, 取值0或者1
        public int            bEncodeBlendExtra3;                    // 叠加到辅码流3, 类型为BOOL, 取值0或者1
        public int            bEncodeBlendSnapshot;                // 叠加到抓图, 类型为BOOL, 取值0或者1
        public NET_CFG_Color        stuFrontColor = new NET_CFG_Color();    // 前景色
        public NET_CFG_Color        stuBackColor = new NET_CFG_Color();    // 背景色
        public NET_CFG_Rect        stuRect = new NET_CFG_Rect();        // 区域, 坐标取值0~8191, 仅使用left和top值, 点(left,top)应和(right,bottom)设置成同样的点
        public byte[]            szText = new byte[NET_CFG_Custom_Title_Len];// 标题内容
        public int            bPreviewBlend;                    // 叠加到预览视频, 类型为BOOL, 取值0或者1
        public byte[]           szType = new byte[NET_CFG_Custom_TitleType_Len];// 标题类型 "Rtinfo" 实时刻录信息 "Custom" 自定义叠加、温湿度叠加 "Title" :片头信息 "Check"  校验码
        // 地理信息 "Geography"  ATM卡号信息 "ATMCardInfo" 摄像机编号 "CameraID"
        public int                  emTextAlign;                    // 标题对齐方式 (参见EM_TITLE_TEXT_ALIGN)

        public NET_CFG_VideoWidgetCustomTitle()
        {
            this.nStructSize = this.size();
        }
    }

    //  编码物件-叠加传感器信息-叠加内容描述
    public static class  NET_CFG_VideoWidgetSensorInfo_Description extends SdkStructure
    {
        public int            nStructSize;
        public int            nSensorID;                        // 需要描述的传感器的ID(即模拟量报警通道号)
        public byte[]         szDevID =  new byte[CFG_COMMON_STRING_32];  // 设备ID
        public byte[]         szPointID = new byte[CFG_COMMON_STRING_32];// 测点ID
        public byte[]         szText = new byte[CFG_COMMON_STRING_256];  // 需要叠加的内容
        public NET_CFG_VideoWidgetSensorInfo_Description()
        {
            this.nStructSize = this.size();
        }
    }

    // 编码物件-叠加传感器信息
    public static class  NET_CFG_VideoWidgetSensorInfo extends SdkStructure
    {
        public int            nStructSize;
        public int        bPreviewBlend;                    // 叠加到预览视频, 类型为BOOL, 取值0或者1
        public int        bEncodeBlend;                    // 叠加到主码流视频编码, 类型为BOOL, 取值0或者1
        public NET_CFG_Rect    stuRect = new NET_CFG_Rect();                        // 区域, 坐标取值0~8191
        public int            nDescriptionNum;                // 叠加区域描述数目
        public NET_CFG_VideoWidgetSensorInfo_Description[]  stuDescription = (NET_CFG_VideoWidgetSensorInfo_Description[])new NET_CFG_VideoWidgetSensorInfo_Description().toArray(NET_CFG_Max_Description_Num);// 叠加区域描述信息

        public NET_CFG_VideoWidgetSensorInfo()
        {
            this.nStructSize = this.size();
        }
    }

    // 视频编码物件配置
    public static class NET_CFG_VideoWidget extends SdkStructure
    {
        public int                              nStructSize;
        public NET_CFG_VideoWidgetChannelTitle  stuChannelTitle = new NET_CFG_VideoWidgetChannelTitle();        // 通道标题
        public NET_CFG_VideoWidgetTimeTitle     stuTimeTitle = new NET_CFG_VideoWidgetTimeTitle();            // 时间标题
        public int                              nConverNum;              // 区域覆盖数量
        public NET_CFG_VideoWidgetCover[]       stuCovers = new NET_CFG_VideoWidgetCover[NET_CFG_Max_Video_Widget_Cover];                        // 覆盖区域
        public int                              nCustomTitleNum;         // 自定义标题数量
        public NET_CFG_VideoWidgetCustomTitle[] stuCustomTitle = new NET_CFG_VideoWidgetCustomTitle[NET_CFG_Max_Video_Widget_Custom_Title];    // 自定义标题
        public int                              nSensorInfo;             // 传感器信息叠加区域数目
        public NET_CFG_VideoWidgetSensorInfo[]  stuSensorInfo = new NET_CFG_VideoWidgetSensorInfo[NET_CFG_Max_Video_Widget_Sensor_Info];        // 传感器信息叠加区域信息
        public double                           fFontSizeScale;          //叠加字体大小放大比例
        //当fFontSizeScale≠0时,nFontSize不起作用
        //当fFontSizeScale=0时,nFontSize起作用
        //设备默认fFontSizeScale=1.0
        //如果需要修改倍数，修改该值
        //如果需要按照像素设置，则置该值为0，nFontSize的值生效
        public int                               nFontSize;              //叠加到主码流上的全局字体大小,单位 px.
        //和fFontSizeScale共同作用
        public int                               nFontSizeExtra1;        //叠加到辅码流1上的全局字体大小,单位 px
        public int                               nFontSizeExtra2;        //叠加到辅码流2上的全局字体大小,单位 px
        public int                               nFontSizeExtra3;        //叠加到辅码流3上的全局字体大小,单位 px
        public int                               nFontSizeSnapshot;      //叠加到抓图流上的全局字体大小, 单位 px
        public int                               nFontSizeMergeSnapshot; //叠加到抓图流上合成图片的字体大小,单位 px
        public int							     emFontSolutionSnapshot; //叠加到抓图流上的字体方案   // 0 未知 ; 1- 默认字体 "default-font" 2-楷体 "simkai" 3- 宋体"simsun"

        public NET_CFG_VideoWidget()
        {
            this.nStructSize = this.size();
            for (int i = 0; i < stuCustomTitle.length; i++) {
                stuCustomTitle[i] = new NET_CFG_VideoWidgetCustomTitle();
            }

            for (int i = 0; i < stuCovers.length; i++) {
                stuCovers[i] = new NET_CFG_VideoWidgetCover();
            }

            for (int i = 0; i < stuSensorInfo.length; i++) {
                stuSensorInfo[i] = new NET_CFG_VideoWidgetSensorInfo();
            }
        }
    }

    // 报警事件类型 NET_EVENT_VIDEOABNORMALDETECTION 对应的数据描述信息
    public static class ALARM_VIDEOABNORMAL_DETECTION_INFO extends SdkStructure
    {
        public int          dwSize;
        public int          nChannelID;                     // 通道号
        public double       PTS;                            // 时间戳(单位是毫秒)
        public NET_TIME_EX  UTC;                            // 事件发生的时间
        public int             nEventID;                       // 事件ID
        public int          nEventAction;                   // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public int          nType;                          // 检测类型,0-视频丢失, 1-视频遮挡, 2-画面冻结, 3-过亮, 4-过暗, 5-场景变化
        // 6-条纹检测 , 7-噪声检测 , 8-偏色检测 , 9-视频模糊检测 , 10-对比度异常检测
        // 11-视频运动, 12-视频闪烁, 13-视频颜色, 14-虚焦检测, 15-过曝检测
        public int          nValue;                         // 检测值,值越高表示视频质量越差, GB30147定义
        public int          nOccurrenceCount;               // 规则被触发生次数

        public ALARM_VIDEOABNORMAL_DETECTION_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 停车发卡刷卡类型
    public static class NET_PARKING_CARD_TYPE extends SdkStructure
    {
        public static final int NET_PARKING_CARD_TYPE_UNKNOWN = 0;
        public static final int NET_PARKING_CARD_TYPE_SEND = 1;   // 发卡
        public static final int NET_PARKING_CARD_TYPE_DETECT = 2; // 刷卡
    }

    // 报警事件类型 NET_ALARM_PARKING_CARD (停车刷卡事件)对应的数据描述信息
    public static class ALARM_PARKING_CARD extends SdkStructure {
        public int                   dwSize;
        public int   				 emType;                       // 类型, 参考 NET_PARKING_CARD_TYPE
        public int                   dwCardNo;                     // 卡号
        public byte[]                szPlate = new byte[NET_COMMON_STRING_16]; // 车牌

        public ALARM_PARKING_CARD() {
            this.dwSize = this.size();
        }
    }

    // 报警事件类型 NET_ALARM_NEW_FILE 对应的数据描述信息
    public static class ALARM_NEW_FILE_INFO extends SdkStructure
    {
        public int      dwSize;
        public int      nChannel;                           // 抓图通道号
        public int      nEventID;                           // 事件ID
        public int      dwEvent;                            // 事件类型
        public int      FileSize;                           // 文件大小,单位是字节
        public int      nIndex;                             // 事件源通道
        public int      dwStorPoint;                        // 存储点
        public byte[]   szFileName = new byte[128];         // 文件名

        public ALARM_NEW_FILE_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 人数越上限类型
    public static class EM_UPPER_LIMIT_TYPE extends SdkStructure
    {
        public static final int EM_UPPER_LIMIT_TYPE_UNKNOWN     = 0;
        public static final int EM_UPPER_LIMIT_TYPE_ENTER_OVER  = 1; // 进入越上限
        public static final int EM_UPPER_LIMIT_TYPE_EXIT_OVER   = 2; // 出来越上限
        public static final int EM_UPPER_LIMIT_TYPE_INSIDE_OVER = 3; // 内部越上限
    }


    // 事件类型 NET_ALARM_HUMAM_NUMBER_STATISTIC (人数量/客流量统计事件NumberStat对应的数据描述信息)
    public static class  ALARM_HUMAN_NUMBER_STATISTIC_INFO extends SdkStructure
    {
        public double              PTS;                            // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                            // 事件发生的时间
        public int                 nEventAction;                   // 事件动作,0-事件持续, 1-表示事件开始, 2-表示事件结束;
        public int                 nNumber;                        // 区域内物体的个数
        public int                 nEnteredNumber;                 // 进入区域或者出入口内的物体个数
        public int                 nExitedNumber;                  // 出来区域或者出入口内的物体个数
        public int                 emUpperLimitType;               // 人数越上限类型,参见EM_UPPER_LIMIT_TYPE定义
        public byte[]              reserved = new byte[512];       // 预留
    }

    /////////////////////////////////智能支持/////////////////////////////////
    //物体对应图片文件信息,对应DH_PIC_INFO
    public static class NET_PIC_INFO extends SdkStructure
    {
        public int 			dwOffSet;				 // 文件在二进制数据块中的偏移位置,单位:字节
        public int 			dwFileLenth;			 // 文件大小,单位:字节
        public short 		wWidth;					 // 图片宽度,单位:像素
        public short 		wHeight;				 // 图片高度,单位:像素
        public Pointer 		pszFilePath;			 // 鉴于历史原因,该成员只在事件上报时有效， char *
        // 文件路径
        // 用户使用该字段时需要自行申请空间进行拷贝保存
        public byte 		bIsDetected;			 // 图片是否算法检测出来的检测过的提交识别服务器时,
        // 则不需要再时检测定位抠图,1:检测过的,0:没有检测过
        public byte[] 		bReserved = new byte[2]; // 预留字节数
        public byte         byQulityScore;           // 人脸抓拍质量分数, 0-100
        public int			nFilePathLen;			 // 文件路径长度 既pszFilePath 用户申请的大小
        public NET_POINT 	stuPoint;			 	 // 小图左上角在大图的位置，使用绝对坐标系

        public NET_PIC_INFO() {
        }
    }

    // 人员类型
    public static class EM_PERSON_TYPE extends SdkStructure
    {
        public static final int PERSON_TYPE_UNKNOWN = 0;
        public static final int PERSON_TYPE_NORMAL = 1; 	//普通人员
        public static final int PERSON_TYPE_SUSPICION = 2;  //嫌疑人员
    }

    // 证件类型
    public static class EM_CERTIFICATE_TYPE extends SdkStructure
    {
        public static final int CERTIFICATE_TYPE_UNKNOWN = 0;
        public static final int CERTIFICATE_TYPE_IC = 1; 		//身份证
        public static final int CERTIFICATE_TYPE_PASSPORT = 2;  //护照
    }

    //人员信息
    public static class FACERECOGNITION_PERSON_INFO extends SdkStructure
    {
        public byte[] 	 szPersonName = new byte[NET_MAX_NAME_LEN]; 	// 姓名,此参数作废
        public short	 wYear;											// 出生年,作为查询条件时,此参数填0,则表示此参数无效
        public byte 	 byMonth;										// 出生月,作为查询条件时,此参数填0,则表示此参数无效
        public byte 	 byDay;									    	// 出生日,作为查询条件时,此参数填0,则表示此参数无效
        public byte[] 	 szID = new byte[NET_MAX_PERSON_ID_LEN];		// 人员唯一标示(身份证号码,工号,或其他编号)
        public byte		 bImportantRank;								// 人员重要等级,1~10,数值越高越重要,作为查询条件时,此参数填0,则表示此参数无效
        public byte 	 bySex;											// 性别,1-男,2-女,作为查询条件时,此参数填0,则表示此参数无效
        public short 	 wFacePicNum;									// 图片张数
        public NET_PIC_INFO[] szFacePicInfo =  (NET_PIC_INFO[])new NET_PIC_INFO().toArray(NET_MAX_PERSON_IMAGE_NUM);//当前人员对应的图片信息
        public byte		 byType;										// 人员类型,详见EM_PERSON_TYPE
        public byte 	 byIDType;										// 证件类型,详见EM_CERTIFICATE_TYPE
        public byte		 byGlasses;										// 是否戴眼镜，0-未知 1-不戴 2-戴
        public byte      byAge;											// 年龄,0表示未知
        public byte[]	 szProvince = new byte[NET_MAX_PROVINCE_NAME_LEN];// 省份
        public byte[]	 szCity = new byte[NET_MAX_CITY_NAME_LEN];		// 城市
        public byte[]	 szPersonNameEx = new byte[NET_MAX_PERSON_NAME_LEN];// 姓名,因存在姓名过长,16字节无法存放问题,故增加此参数,
        public byte[] 	 szUID = new byte[NET_MAX_PERSON_ID_LEN];		// 人员唯一标识符,首次由服务端生成,区别于ID字段
        // 修改,删除操作时必填
        public byte[] 	 szCountry = new byte[NET_COUNTRY_LENGTH];		// 国籍,符合ISO3166规范
        public byte		 byIsCustomType;								// 人员类型是否为自定义: 0 使用Type规定的类型 1 自定义,使用szPersonName字段
        public Pointer	 pszComment;									// 备注信息, 用户自己申请内存的情况时,
        // 下方bCommentLen需填写对应的具体长度值，推荐长度 NET_COMMENT_LENGTH

        public Pointer	 pszGroupID;									// 人员所属组ID, 用户自己申请内存的情况时,
        // 下方bGroupIdLen需填写对应的具体长度值，推荐长度 NET_GROUPID_LENGTH

        public Pointer	 pszGroupName;									// 人员所属组名, 用户自己申请内存的情况时,
        // 下方bGroupNameLen需填写对应的具体长度值，推荐长度 NET_GROUPNAME_LENGTH

        public Pointer	 pszFeatureValue;								// 人脸特征, 用户自己申请内存的情况时,
        // 下方bFeatureValueLen需填写对应的具体长度值，推荐长度 NET_FEATUREVALUE_LENGTH

        public byte		 bGroupIdLen;									// pszGroupID的长度
        public byte		 bGroupNameLen;									// pszGroupName的长度
        public byte		 bFeatureValueLen;								// pszFeatureValue的长度
        public byte		 bCommentLen;									// pszComment的长度
        public int		 emEmotion;										// 表情, 参考 EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE

        public FACERECOGNITION_PERSON_INFO() {
        }
    }

    ///////////////////////////////////人脸识别模块相关结构体///////////////////////////////////////
    public static class NET_UID_CHAR extends SdkStructure
    {
        public byte[] szUID = new byte[NET_MAX_PERSON_ID_LEN];//UID内容
    }

    //人脸识别数据库操作
    public static class EM_OPERATE_FACERECONGNITIONDB_TYPE
    {
        public static final int NET_FACERECONGNITIONDB_UNKOWN = 0;
        public static final int NET_FACERECONGNITIONDB_ADD = 1;             //添加人员信息和人脸样本，如果人员已经存在，图片数据和原来的数据合并
        public static final int NET_FACERECONGNITIONDB_DELETE = 2;          //删除人员信息和人脸样本
        public static final int NET_FACERECONGNITIONDB_MODIFY = 3;          //修改人员信息和人脸样本,人员的UID标识必填
        public static final int NET_FACERECONGNITIONDB_DELETE_BY_UID = 4;   //通过UID删除人员信息和人脸样本
    }

    //CLIENT_OperateFaceRecognitionDB接口输入参数
    public static class NET_IN_OPERATE_FACERECONGNITIONDB extends SdkStructure
    {
        public int 								dwSize;
        public int 								emOperateType;		//操作类型, 取EM_OPERATE_FACERECONGNITIONDB_TYPE中的值
        public FACERECOGNITION_PERSON_INFO  	stPersonInfo;		//人员信息
        //emOperateType操作类型为ET_FACERECONGNITIONDB_DELETE_BY_UID时使用,stPeronInfo字段无效
        public int 								nUIDNum;			//UID个数
        public Pointer 							stuUIDs;			//人员唯一标识符,首次由服务端生成,区别于ID字段, NET_UID_CHAR[]

        // 图片二进制数据
        public Pointer 							pBuffer;			//缓冲地址, char *
        public int 								nBufferLen;			//缓冲数据长度

        public int			  					bUsePersonInfoEx;	// 使用人员扩展信息, 1:true   0:false
        public FACERECOGNITION_PERSON_INFOEX	stPersonInfoEx;	    // 人员信息扩展

        public NET_IN_OPERATE_FACERECONGNITIONDB()
        {
            this.dwSize = this.size();
        }
    }

    // 错误代码，emOperateType操作类型为ET_FACERECONGNITIONDB_DELETE_BY_UID时使用
    public static class EM_ERRORCODE_TYPE extends SdkStructure
    {
        public static final int EM_ERRORCODE_TYPE_UNKNOWN = -1;               // 未知错误
        public static final int EM_ERRORCODE_TYPE_SUCCESS=0;               // 成功
        public static final int EM_ERRORCODE_TYPE_PERSON_NOT_EXIST=1;            // 人员不存在
        public static final int EM_ERRORCODE_TYPE_DATABASE_ERROR=2;             //  数据库操作失败
    };

    //CLIENT_OperateFaceRecognitionDB接口输出参数
    public static class NET_OUT_OPERATE_FACERECONGNITIONDB extends SdkStructure
    {
        public int 		dwSize;
        public byte[]	szUID = new byte[NET_MAX_PERSON_ID_LEN];	// 人员唯一标识符, 只有在操作类型为NET_FACERECONGNITIONDB_ADD时有效

        //emOperateType操作类型为ET_FACERECONGNITIONDB_DELETE_BY_UID时使用
        public int                nErrorCodeNum; // 错误码个数
        public int[]          emErrorCodes=new int[512]; // 错误码
        // emOperateType操作类型为ET_FACERECONGNITIONDB_DELETE_BY_UID时使用

        public NET_OUT_OPERATE_FACERECONGNITIONDB()
        {
            this.dwSize = this.size();
        }
    }

    //人脸对比模式
    public static class EM_FACE_COMPARE_MODE extends SdkStructure
    {
        public static final int NET_FACE_COMPARE_MODE_UNKOWN = 0;
        public static final int NET_FACE_COMPARE_MODE_NORMAL = 1; //正常
        public static final int NET_FACE_COMPARE_MODE_AREA = 2; //指定人脸区域组合区域
        public static final int  NET_FACE_COMPARE_MODE_AUTO = 3; //智能模式,算法根据人脸各个区域情况自动选取组合
    }

    //人脸区域
    public static class EM_FACE_AREA_TYPE extends SdkStructure
    {
        public static final int NET_FACE_AREA_TYPE_UNKOWN = 0;
        public static final int NET_FACE_AREA_TYPE_EYEBROW = 1; //眉毛
        public static final int NET_FACE_AREA_TYPE_EYE = 2; //眼睛
        public static final int NET_FACE_AREA_TYPE_NOSE= 3; //鼻子
        public static final int NET_FACE_AREA_TYPE_MOUTH = 4; //嘴巴
        public static final int NET_FACE_AREA_TYPE_CHEEK =5; //脸颊
    }

    public static class NET_FACE_MATCH_OPTIONS extends SdkStructure
    {
        public int 			dwSize;
        public int 			nMatchImportant;						// 人员重要等级1~10,数值越高越重要,(查询重要等级大于等于此等级的人员)， 类型为unsigned int
        public int 			emMode;									// 人脸比对模式,详见EM_FACE_COMPARE_MODE, 取EM_FACE_COMPARE_MODE中的值
        public int 			nAreaNum;								// 人脸区域个数
        public int[] 		szAreas= new int[MAX_FACE_AREA_NUM];	// 人脸区域组合,emMode为NET_FACE_COMPARE_MODE_AREA时有效, 数组元素取EM_FACE_AREA_TYPE中的值
        public int 			nAccuracy;								// 识别精度(取值1~10,随着值增大,检测精度提高,检测速度下降。最小值为1表示检测速度优先,最大值为10表示检测精度优先。暂时只对人脸检测有效)
        public int 			nSimilarity;							// 相似度(必须大于该相识度才报告;百分比表示,1~100)
        public int 			nMaxCandidate;							// 报告的最大候选个数(根据相似度进行排序,取相似度最大的候选人数报告)
        public int 			emQueryMode;                 			// 以图搜图查询模式，详见EM_FINDPIC_QUERY_MODE
        public int 			emOrdered;                 				// 以图搜图结果上报排序方式，详见EM_FINDPIC_QUERY_ORDERED

        public NET_FACE_MATCH_OPTIONS()
        {
            this.dwSize = this.size();
        }
    }

    // 以图搜图查询模式
    public static class EM_FINDPIC_QUERY_MODE extends SdkStructure
    {
        public static final int EM_FINDPIC_QUERY_UNKNOWN             = 0;   // 未知
        public static final int EM_FINDPIC_QUERY_PASSIVE             = 1;   // 被动查询
        public static final int EM_FINDPIC_QUERY_ACTIVE              = 2;   // 主动推送
    }

    // 以图搜图结果上报排序方式
    public static class EM_FINDPIC_QUERY_ORDERED extends SdkStructure
    {
        public static final int EM_FINDPIC_QUERY_BY_SIMILARITY       = 0;   // 按相似度从高到底
        public static final int EM_FINDPIC_QUERY_BY_TIME_FORWARD     = 1;   // 按时间正序
        public static final int EM_FINDPIC_QUERY_BY_TIME_REVERSE     = 2;   // 按时间倒序
    }

    //人脸识别人脸类型
    public static class EM_FACERECOGNITION_FACE_TYPE extends SdkStructure
    {
        public static final int  EM_FACERECOGNITION_FACE_TYPE_UNKOWN = 0;
        public static final int  EM_FACERECOGNITION_FACE_TYPE_ALL = 1; 			// 所有人脸
        public static final int  EM_FACERECOGNITION_FACE_TYPE_REC_SUCCESS=  2;	// 识别成功
        public static final int  EM_FACERECOGNITION_FACE_TYPE_REC_FAIL = 3;		// 识别失败
    }

    public static class NET_FACE_FILTER_CONDTION extends SdkStructure
    {
        public int 			dwSize;
        public NET_TIME 	stStartTime;							// 开始时间
        public NET_TIME 	stEndTime;								// 结束时间
        public byte[] 		szMachineAddress = new byte[MAX_PATH];	// 地点,支持模糊匹配
        public int 			nRangeNum;								// 实际数据库个数
        public byte[] 		szRange = new byte[MAX_FACE_DB_NUM];	// 待查询数据库类型,详见EM_FACE_DB_TYPE
        public int 			emFaceType;								// 待查询人脸类型,详见EM_FACERECOGNITION_FACE_TYPE， 取EM_FACERECOGNITION_FACE_TYPE中的值
        public int 			nGroupIdNum;							// 人员组数
        public GROUP_ID[] 	szGroupIdArr = (GROUP_ID[])new GROUP_ID().toArray(MAX_GOURP_NUM); // 人员组ID
        public NET_TIME 	stBirthdayRangeStart;   				// 生日起始时间
        public NET_TIME 	stBirthdayRangeEnd;     				// 生日结束时间
        public byte[]		byAge = new byte[MAX_AGE_NUM];			// 年龄区间，当byAge[0]=0与byAge[1]=0时，表示查询全年龄
        public byte[]		byReserved = new byte[2];				// 保留字节对齐
        public int[]	    emEmotion = new int[MAX_EMOTION_NUM];	// 表情条件
        public int			nEmotionNum;				   			// 表情条件的个数
        public int                 nUIDNum;                       // 人员唯一标识数
        public byte[]                szUIDs=new byte[64*32];                // 人员唯一标识列表
        public NET_FACE_FILTER_CONDTION()
        {
            this.dwSize = this.size();
        }
    }

    // 人员组ID
    public static class GROUP_ID extends SdkStructure
    {
        public byte[]   szGroupId= new byte[NET_COMMON_STRING_64];  //人员组ID
    }

    //CLIENT_StartFindFaceRecognition接口输入参数
    public static class NET_IN_STARTFIND_FACERECONGNITION extends SdkStructure
    {
        public int 								dwSize;
        public int 								bPersonEnable;		// 人员信息查询条件是否有效, BOOL类型，取值0或1
        public FACERECOGNITION_PERSON_INFO  	stPerson;			// 人员信息查询条件
        public NET_FACE_MATCH_OPTIONS 			stMatchOptions; 	// 人脸匹配选项
        public NET_FACE_FILTER_CONDTION 		stFilterInfo;		// 查询过滤条件

        // 图片二进制数据
        public Pointer 							pBuffer;			// 缓冲地址, char *
        public int 								nBufferLen;			// 缓冲数据长度
        public int 								nChannelID;			// 通道号

        public int								bPersonExEnable;	// 人员信息查询条件是否有效, 并使用扩展结构体
        public FACERECOGNITION_PERSON_INFOEX	stPersonInfoEx;		// 人员信息扩展
        public int								nSmallPicIDNum;		// 小图ID数量
        public int[]							nSmallPicID = new int[MAX_SMALLPIC_NUM];	// 小图ID
        public int                              emObjectType;       // 搜索的目标类型
        public NET_IN_STARTFIND_FACERECONGNITION()
        {
            this.dwSize = this.size();
        }
    }

    //CLIENT_StartFindFaceRecognition接口输出参数
    public static class NET_OUT_STARTFIND_FACERECONGNITION extends SdkStructure {
        public int 		dwSize;
        public int 		nTotalCount;	// 返回的符合查询条件的记录个数
        // -1表示总条数未生成,要推迟获取
        // 使用CLIENT_AttachFaceFindState接口状态
        public LLong 	lFindHandle;	// 查询句柄
        public int 		nToken;			// 获取到的查询令牌

        public NET_OUT_STARTFIND_FACERECONGNITION() {
            this.dwSize = this.size();
        }
    }

    //CLIENT_DoFindFaceRecognition 接口输入参数
    public static class NET_IN_DOFIND_FACERECONGNITION extends SdkStructure {
        public int 			dwSize;
        public LLong 		lFindHandle;	// 查询句柄
        public int 			nBeginNum;		// 查询起始序号
        public int 			nCount;			// 当前想查询的记录条数
        public int			emDataType;		// 指定查询结果返回图片的格式. 参考  EM_NEEDED_PIC_RETURN_TYPE

        public NET_IN_DOFIND_FACERECONGNITION()
        {
            this.dwSize = this.size();
        }
    }

    // 查询结果返回图片的格式
    public static class EM_NEEDED_PIC_RETURN_TYPE extends SdkStructure {
        public static final int EM_NEEDED_PIC_TYPE_UNKOWN = 0;            // 未知类型
        public static final int EM_NEEDED_PIC_TYPE_HTTP_URL = 1;          // 返回图片HTTP链接
        public static final int EM_NEEDED_PIC_TYPE_BINARY_DATA = 2;       // 返回图片二进制数据
        public static final int EM_NEEDED_PIC_TYPE_HTTP_AND_BINARY = 3;   // 返回二进制和HTTP链接
    }

    //候选人员信息
    public static class CANDIDATE_INFO extends SdkStructure {
        public FACERECOGNITION_PERSON_INFO stPersonInfo;					// 人员信息
        // 布控（黑名单）库,指布控库中人员信息；
        // 历史库,指历史库中人员信息
        // 报警库,指布控库的人员信息
        public byte 						bySimilarity;					// 和查询图片的相似度,百分比表示,1~100
        public byte 						byRange;						// 人员所属数据库范围,详见EM_FACE_DB_TYPE
        public byte[] 						byReserved1 = new byte[2];
        public NET_TIME 					stTime;							// 当byRange为历史数据库时有效,表示查询人员出现的时间
        public byte[] 						szAddress = new byte[MAX_PATH]; // 当byRange为历史数据库时有效,表示查询人员出现的地点
        public int 							bIsHit; 						// BOOL类型,是否有识别结果,指这个检测出的人脸在库中有没有比对结果
        public NET_PIC_INFO_EX3 			stuSceneImage;  				// 人脸全景图
        public int 							nChannelID;				 		// 通道号
        public byte[] 						byReserved = new byte[32];		// 保留字节

        public CANDIDATE_INFO() {}
    }

    // 物体对应图片文件信息(包含图片路径)
    public static class NET_PIC_INFO_EX3 extends SdkStructure
    {
        public int          dwOffSet;                       // 文件在二进制数据块中的偏移位置, 单位:字节
        public int          dwFileLenth;                    // 文件大小, 单位:字节
        public short        wWidth;                         // 图片宽度, 单位:像素
        public short        wHeight;                        // 图片高度, 单位:像素
        public byte[]       szFilePath = new byte[64];      // 文件路径
        public byte         bIsDetected;                    // 图片是否算法检测出来的检测过的提交识别服务器时,
        // 则不需要再时检测定位抠图,1:检测过的,0:没有检测过
        public byte[]       bReserved = new byte[11];       // 保留
    }

    //CLIENT_DoFindFaceRecognition接口输出参数
    public static class NET_OUT_DOFIND_FACERECONGNITION extends SdkStructure
    {
        public int 					dwSize;
        public int 					nCadidateNum;					// 实际返回的候选信息结构体个数
        public CANDIDATE_INFO[] 	stCadidateInfo = (CANDIDATE_INFO[])new CANDIDATE_INFO().toArray(MAX_FIND_COUNT);//候选信息数组

        // 图片二进制数据
        public Pointer 				pBuffer;						// 缓冲地址, char *
        public int 					nBufferLen;					 	// 缓冲数据长度

        public int					bUseCandidatesEx;				// 是否使用候选对象扩展结构体,
        // 若为1-true, 则表示使用stuCandidatesEx, 且stuCandidates无效, 否则相反
        public int 					nCadidateExNum;					// 实际返回的候选信息结构体个数
        public CANDIDATE_INFOEX[]	stuCandidatesEx = (CANDIDATE_INFOEX[])new CANDIDATE_INFOEX().toArray(MAX_FIND_COUNT); // 当前人脸匹配到的候选对象信息, 实际返回个数同nCandidateNum

        public NET_OUT_DOFIND_FACERECONGNITION()
        {
            this.dwSize = this.size();
        }
    }

    /////////////////////////////////智能支持/////////////////////////////////
    //CLIENT_DetectFace接口输入参数
    public static class NET_IN_DETECT_FACE extends SdkStructure
    {
        public int dwSize;
        public NET_PIC_INFO stPicInfo;//大图信息
        // 图片二进制数据
        public Pointer pBuffer;//缓冲地址, char *
        public int nBufferLen;//缓冲数据长度

        public NET_IN_DETECT_FACE()
        {
            this.dwSize = this.size();
        }
    }

    //CLIENT_DetectFace接口输出参数
    public static class NET_OUT_DETECT_FACE extends SdkStructure
    {
        public int dwSize;
        public Pointer pPicInfo;//检测出的人脸图片信息,由用户申请空间, NET_PIC_INFO*
        public int nMaxPicNum;//最大人脸图片信息个数
        public int nRetPicNum;//实际返回的人脸图片个数
        // 图片二进制数据
        public Pointer pBuffer;//缓冲地址,由用户申请空间,存放检测出的人脸图片数据, char *
        public int nBufferLen;//缓冲数据长度

        public NET_OUT_DETECT_FACE()
        {
            this.dwSize = this.size();
        }
    }

    // 人脸识别事件类型
    public static class EM_FACERECOGNITION_ALARM_TYPE extends SdkStructure
    {
        public static final int NET_FACERECOGNITION_ALARM_TYPE_UNKOWN = 0;
        public static final int NET_FACERECOGNITION_ALARM_TYPE_ALL = 1; //黑白名单
        public static final int NET_FACERECOGNITION_ALARM_TYPE_BLACKLIST = 2; //黑名单
        public static final int NET_FACERECOGNITION_ALARM_TYPE_WHITELIST = 3; //白名单
    }

    // NET_FILE_QUERY_FACE 对应的人脸识别服务查询参数
    public static class MEDIAFILE_FACERECOGNITION_PARAM extends SdkStructure
    {
        public int 								dwSize;			// 结构体大小

        //////// 查询过滤条件
        public NET_TIME 						stStartTime;	// 开始时间
        public NET_TIME 						stEndTime;		// 结束时间
        public byte[] 							szMachineAddress = new byte[MAX_PATH];//地点,支持模糊匹配
        public int 								nAlarmType;		// 待查询报警类型,详见 EM_FACERECOGNITION_ALARM_TYPE
        public int 								abPersonInfo;	// 人员信息是否有效, BOOL类型，取值0或1
        public FACERECOGNITION_PERSON_INFO 	 	stPersonInfo;	// 人员信息
        public int 								nChannelId;		// 通道号
        public int 								nGroupIdNum;	// 人员组数
        public GROUP_ID[]						szGroupIdArr = (GROUP_ID[])new GROUP_ID().toArray(MAX_GOURP_NUM); // 人员组ID
        public int                				abPersonInfoEx; // 人员信息扩展是否有效
        public FACERECOGNITION_PERSON_INFOEX	stPersonInfoEx; // 人员信息扩展
        public int				                bSimilaryRangeEnable;       			//相似度是否有效
        public int[]					        nSimilaryRange=new int[2];				//相似度范围
        public int                              nFileType;      // 获取文件的类型 1 为 jpg 图片
        public MEDIAFILE_FACERECOGNITION_PARAM()
        {
            this.dwSize = this.size();
        }
    }

    // 图片类型
    public static class EM_FACEPIC_TYPE extends SdkStructure
    {
        public static final int  NET_FACEPIC_TYPE_UNKOWN = 0;            // 未知类型
        public static final int  NET_FACEPIC_TYPE_GLOBAL_SENCE = 1;      // 人脸全景大图
        public static final int  NET_FACEPIC_TYPE_SMALL = 2;             // 人脸小图
    }

    // 参数详细信息
    public static class MEDIAFILE_FACE_DETECTION_DETAIL_PARAM extends SdkStructure
    {
        public int               			dwSize;				// 结构体大小
        public int							dwObjectId;			// 物体ID
        public int 							dwFrameSequence;	// 帧序号
        public NET_TIME_EX					stTime;             // 发生时间

        public MEDIAFILE_FACE_DETECTION_DETAIL_PARAM()
        {
            this.dwSize = this.size();
        }
    }

    // 人脸检测人脸戴眼镜特征类型
    public static class EM_FACEDETECT_GLASSES_TYPE extends SdkStructure
    {
        public static final int EM_FACEDETECT_GLASSES_UNKNOWN = 0;      // 未知
        public static final int EM_FACEDETECT_WITH_GLASSES = 1;         // 戴眼镜
        public static final int EM_FACEDETECT_WITHOUT_GLASSES = 2;      // 不戴眼镜
    }

    // NET_FILE_QUERY_FACE_DETECTION 对应的人脸识别服务查询参数
    public static class MEDIAFILE_FACE_DETECTION_PARAM extends SdkStructure
    {
        public int               			dwSize;			// 结构体大小
        ////////查询过滤条件
        public int							nChannelID;		// 通道号
        public NET_TIME 					stuStartTime;	// 起始时间
        public NET_TIME 					stuEndTime;		// 结束时间
        public int							emPicType;		// 图片类型,对应枚举 EM_FACEPIC_TYPE
        public int							bDetailEnable;	// 是否有详细信息,boolean类型,为1或者0
        public MEDIAFILE_FACE_DETECTION_DETAIL_PARAM	stuDetail;	// 参数详细信息
        public int 							emSex;					// 性别类型, 参考 EM_DEV_EVENT_FACEDETECT_SEX_TYPE
        public int   						bAgeEnable;             // 是否指定年龄段
        public int[]               			nAgeRange = new int[2]; // 年龄范围
        public int							nEmotionValidNum;		// 人脸特征数组有效个数,与 emFeature 结合使用, 如果为0则表示查询所有表情
        public int[]						emEmotion = new int[NET_MAX_FACEDETECT_FEATURE_NUM]; // 人脸特征数组,与 byFeatureValidNum 结合使用,对应 EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE
        public int							emGlasses;		// 是否戴眼镜,参考 EM_FACEDETECT_GLASSES_TYPE
        public int 							emMask;			// 是否带口罩,参考 EM_MASK_STATE_TYPE
        public int 							emBeard;		// 是否有胡子,参考 EM_BEARD_STATE_TYPE
        public int 							nIsStranger;	// 0-都查询；1-仅查未开启陌生人模式；2-仅查开启陌生人模式

        public MEDIAFILE_FACE_DETECTION_PARAM()
        {
            this.dwSize = this.size();
        }

    }

    // NET_FILE_QUERY_FACE_DETECTION对应的人脸识别服务FINDNEXT查询返回参数
    public static class MEDIAFILE_FACE_DETECTION_INFO extends SdkStructure
    {
        public int               dwSize;                               // 结构体大小
        public int				  ch;									// 通道号
        public byte[]			  szFilePath = new byte[128];			// 文件路径
        public int				  size;									// 文件长度,该字段废弃，请使用sizeEx
        public NET_TIME		  starttime;                            // 开始时间
        public NET_TIME		  endtime;								// 结束时间
        public int 			  nWorkDirSN;							// 工作目录编号
        public byte 			  nFileType;							// 文件类型  1：jpg图片
        public byte			  bHint;								// 文件定位索引
        public byte			  bDriveNo;								// 磁盘号
        public byte			  byPictureType;						// 图片类型, 0-普通, 1-合成, 2-抠图
        public int				  nCluster;								// 簇号
        public int				  emPicType;   							// 图片类型,详见  EM_FACEPIC_TYPE
        public int 			  dwObjectId;							// 物体ID
        public int[] 			  dwFrameSequence = new int[NET_MAX_FRAMESEQUENCE_NUM];			// 帧序号,数组有2个元素时,第一个表示小图,第二个表示大图
        public int 			  nFrameSequenceNum;					// 帧序号个数
        public NET_TIME_EX[]	  stTimes = (NET_TIME_EX[])new NET_TIME_EX().toArray(NET_MAX_TIMESTAMP_NUM); // 发生时间,数组有2个元素时,第一个表示小图,第二个表示大图
        public int 			  nTimeStampNum;						// 表示在簇中的图片序号
        public int 			  nPicIndex;							// 表示在簇中的图片序号
        // 对于同一个簇中打包多张图片,提供索引方式定位图片
        public int				  emSex;								// 性别类型,参考 EM_DEV_EVENT_FACEDETECT_SEX_TYPE
        public int 			  nAge;									// 年龄
        public int 			  emEmotion;							// 人脸表情,参考 EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE
        public int 			  emGlasses;							// 是否戴眼镜,参考 EM_FACEDETECT_GLASSES_TYPE
        public long			  sizeEx;								// 文件长度扩展，支持文件长度大于4G，单位字节
        public int 			  emMask;								// 是否带口罩,参考 EM_MASK_STATE_TYPE
        public int				  emBeard;								// 是否有胡子,参考 EM_BEARD_STATE_TYPE
        public int				  emRace;								// 肤色,参考 EM_RACE_TYPE
        public int				  emEye;								// 眼睛状态,参考 EM_EYE_STATE_TYPE
        public int				  emMouth;								// 嘴巴状态,参考 EM_MOUTH_STATE_TYPE
        public int 			  nAttractive;							// 魅力值
        public int 			  nIsStranger; 			 				// 0-未知；1-未开启陌生人模式；2-开启了陌生人模式
        public byte[]			  szFaceObjectUrl = new byte[128];		// 当 emPicType 为 NET_FACEPIC_TYPE_GLOBAL_SENCE 时, 代表人脸小图路径
        public NET_EULER_ANGLE             stuFaceCaptureAngle;                // 人脸在抓拍图片中的角度信息, nPitch:抬头低头的俯仰角, nYaw左右转头的偏航角, nRoll头在平面内左偏右偏的翻滚角
        // 角度值取值范围[-90,90], 三个角度值都为999表示此角度信息无效
        public int                        nFaceQuality;                       // 人脸抓拍质量分数
        public NET_FACEDETECT_IMAGE_INFO   stuSceneImage;                      // 大图信息
        public NET_POINT                   stuFaceCenter;                      // 人脸型心(不是包围盒中心), 0-8191相对坐标, 相对于小图
        public MEDIAFILE_FACE_DETECTION_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // NET_MEDIA_QUERY_TRAFFICCAR对应的查询条件
    public static class MEDIA_QUERY_TRAFFICCAR_PARAM extends SdkStructure
    {
        public int                 nChannelID;                     // 通道号从0开始,-1表示查询所有通道
        public NET_TIME            StartTime;                      // 开始时间
        public NET_TIME            EndTime;                        // 结束时间
        public int                 nMediaType;                     // 文件类型,0:任意类型, 1:jpg图片, 2:dav文件
        public int                 nEventType;                     // 事件类型,详见"智能分析事件类型", 0:表示查询任意事件,此参数废弃,请使用pEventTypes
        public byte[]              szPlateNumber = new byte[32];   // 车牌号, "\0"则表示查询任意车牌号
        public int                 nSpeedUpperLimit;               // 查询的车速范围; 速度上限 单位: km/h
        public int                 nSpeedLowerLimit;               // 查询的车速范围; 速度下限 单位: km/h
        public int                 bSpeedLimit;                    // 是否按速度查询; TRUE:按速度查询,nSpeedUpperLimit和nSpeedLowerLimit有效。
        public int                 dwBreakingRule;                 // 违章类型：
        // 当事件类型为 EVENT_IVS_TRAFFICGATE时
        //        第一位:逆行;  第二位:压线行驶; 第三位:超速行驶;
        //        第四位：欠速行驶; 第五位:闯红灯;
        // 当事件类型为 EVENT_IVS_TRAFFICJUNCTION
        //        第一位:闯红灯;  第二位:不按规定车道行驶;
        //        第三位:逆行; 第四位：违章掉头;
        //        第五位:压线行驶;

        public byte[]              szPlateType=new byte[32];       // 车牌类型,"Unknown" 未知,"Normal" 蓝牌黑牌,"Yellow" 黄牌,"DoubleYellow" 双层黄尾牌,"Police" 警牌"Armed" 武警牌,
        // "Military" BD号牌,"DoubleMilitary" BD双层,"SAR" 港澳特区号牌,"Trainning" 教练车号牌
        // "Personal" 个性号牌,"Agri" 农用牌,"Embassy" 使馆号牌,"Moto" 摩托车号牌,"Tractor" 拖拉机号牌,"Other" 其他号牌
        public byte[]              szPlateColor = new byte[16];    // 车牌颜色, "Blue"蓝色,"Yellow"黄色, "White"白色,"Black"黑色
        public byte[]              szVehicleColor = new byte[16];  // 车身颜色:"White"白色, "Black"黑色, "Red"红色, "Yellow"黄色, "Gray"灰色, "Blue"蓝色,"Green"绿色
        public byte[]              szVehicleSize = new byte[16];   // 车辆大小类型:"Light-duty":小型车;"Medium":中型车; "Oversize":大型车; "Unknown": 未知
        public int                 nGroupID;                       // 事件组编号(此值>=0时有效)
        public short               byLane;                         // 车道号(此值>=0时表示具体车道,-1表示所有车道,即不下发此字段)
        public byte                byFileFlag;                     // 文件标志, 0xFF-使用nFileFlagEx, 0-表示所有录像, 1-定时文件, 2-手动文件, 3-事件文件, 4-重要文件, 5-合成文件
        public byte                byRandomAccess;                 // 是否需要在查询过程中随意跳转,0-不需要,1-需要
        public int                 nFileFlagEx;                    // 文件标志, 按位表示: bit0-定时文件, bit1-手动文件, bit2-事件文件, bit3-重要文件, bit4-合成文件, bit5-黑名单图片 0xFFFFFFFF-所有录像
        public int                 nDirection;                     // 车道方向（车开往的方向）    0-北 1-东北 2-东 3-东南 4-南 5-西南 6-西 7-西北 8-未知 -1-所有方向
        public Pointer             szDirs;                         // 工作目录列表,一次可查询多个目录,为空表示查询所有目录。目录之间以分号分隔,如“/mnt/dvr/sda0;/mnt/dvr/sda1”,szDirs==null 或"" 表示查询所有
        public Pointer             pEventTypes;                    // 待查询的事件类型数组指针,事件类型,详见"智能分析事件类型",若为NULL则认为查询所有事件（缓冲需由用户申请）
        public int                 nEventTypeNum;                  // 事件类型数组大小
        public Pointer             pszDeviceAddress;               // 设备地址, NULL表示该字段不起作用
        public Pointer             pszMachineAddress;              // 机器部署地点, NULL表示该字段不起作用
        public Pointer             pszVehicleSign;                 // 车辆标识, 例如 "Unknown"-未知, "Audi"-奥迪, "Honda"-本田... NULL表示该字段不起作用
        public short               wVehicleSubBrand;               // 车辆子品牌 需要通过映射表得到真正的子品牌 映射表详见开发手册
        public short               wVehicleYearModel;              // 车辆品牌年款 需要通过映射表得到真正的年款 映射表详见开发手册
        public int				   emSafeBeltState;				   // 安全带状态, 参考枚举  EM_SAFE_BELT_STATE
        public int                 emCallingState;				   // 打电话状态, 参考枚举 EM_CALLING_STATE
        public int 				   emAttachMentType;			   // 车内饰品类型, 参考枚举 EM_ATTACHMENT_TYPE
        public int				   emCarType;					   // 车辆类型, 参考枚举  EM_CATEGORY_TYPE
        public Pointer	           pstuTrafficCarParamEx;	// 参数扩展,对应结构体NET_MEDIA_QUERY_TRAFFICCAR_PARAM_EX
        public int[]               bReserved=new int[4];                  // 保留字段
    }

    // NET_MEDIA_QUERY_TRAFFICCAR_EX对应的查询条件
    public static class MEDIA_QUERY_TRAFFICCAR_PARAM_EX extends SdkStructure
    {
        public int               dwSize;
        public MEDIA_QUERY_TRAFFICCAR_PARAM stuParam;                  // 基本查询参数

        public MEDIA_QUERY_TRAFFICCAR_PARAM_EX() {
            this.dwSize = this.size();
        }
    }

    // NET_MEDIA_QUERY_TRAFFICCAR查询出来的media文件信息
    public static class MEDIAFILE_TRAFFICCAR_INFO extends SdkStructure
    {
        public int				   ch;                                 // 通道号
        public byte[]              szFilePath = new byte[128];         // 文件路径
        public int        		   size;                               // 文件长度
        public NET_TIME            starttime;                          // 开始时间
        public NET_TIME            endtime;                            // 结束时间
        public int                 nWorkDirSN;                         // 工作目录编号
        public byte                nFileType;                          // 文件类型  1：jpg图片
        public byte                bHint;                              // 文件定位索引
        public byte                bDriveNo;                           // 磁盘号
        public byte                bReserved2;
        public int                 nCluster;                           // 簇号
        public byte                byPictureType;                      // 图片类型, 0-普通, 1-合成, 2-抠图
        public byte[]              bReserved = new byte[3];            // 保留字段

        //以下是交通车辆信息
        public byte[]              szPlateNumber = new byte[32];       // 车牌号码
        public byte[]              szPlateType = new byte[32];         // 号牌类型"Unknown" 未知; "Normal" 蓝牌黑牌; "Yellow" 黄牌; "DoubleYellow" 双层黄尾牌
        // "Police" 警牌; "Armed" 武警牌; "Military" BD号牌; "DoubleMilitary" BD双层
        // "SAR" 港澳特区号牌; "Trainning" 教练车号牌; "Personal" 个性号牌; "Agri" 农用牌
        // "Embassy" 使馆号牌; "Moto" 摩托车号牌; "Tractor" 拖拉机号牌; "Other" 其他号牌
        public byte[]              szPlateColor = new byte[16];        // 车牌颜色:"Blue","Yellow", "White","Black"
        public byte[]              szVehicleColor = new byte[16];      // 车身颜色:"White", "Black", "Red", "Yellow", "Gray", "Blue","Green"
        public int                 nSpeed;                             // 车速,单位 Km/H
        public int                 nEventsNum;                         // 关联的事件个数
        public int[]               nEvents = new int[32];              // 关联的事件列表,数组值表示相应的事件,详见"智能分析事件类型"
        public int                 dwBreakingRule;                     // 具体违章类型掩码,第一位:闯红灯; 第二位:不按规定车道行驶;
        // 第三位:逆行; 第四位：违章掉头;否则默认为:交通路口事件
        public byte[]              szVehicleSize = new byte[16];       // 车辆大小类型:"Light-duty":小型车;"Medium":中型车; "Oversize":大型车
        public byte[]              szChannelName = new byte[NET_CHAN_NAME_LEN];    // 本地或远程的通道名称
        public byte[]              szMachineName = new byte[NET_MAX_NAME_LEN];     // 本地或远程设备名称

        public int                 nSpeedUpperLimit;                   // 速度上限 单位: km/h
        public int                 nSpeedLowerLimit;                   // 速度下限 单位: km/h
        public int                 nGroupID;                           // 事件里的组编号
        public byte                byCountInGroup;                     // 一个事件组内的抓拍张数
        public byte                byIndexInGroup;                     // 一个事件组内的抓拍序号
        public byte                byLane;                             // 车道,参见MEDIA_QUERY_TRAFFICCAR_PARAM
        public byte[]              bReserved1 = new byte[21];          // 保留
        public NET_TIME            stSnapTime;                         // 抓拍时间
        public int                 nDirection;                         // 车道方向,参见MEDIA_QUERY_TRAFFICCAR_PARAM
        public byte[]              szMachineAddress = new byte[MAX_PATH]; // 机器部署地点
        public long                sizeEx;                             // 文件长度扩展，支持文件长度大于4G，单位字节
    }

    // NET_MEDIA_QUERY_TRAFFICCAR_EX查询出来的文件信息
    public static class MEDIAFILE_TRAFFICCAR_INFO_EX extends SdkStructure
    {
        public int               			dwSize;
        public MEDIAFILE_TRAFFICCAR_INFO 	stuInfo;  									 		// 基本信息
        public byte[]            			szDeviceAddr = new byte[NET_COMMON_STRING_256];     // 设备地址
        public byte[]            			szVehicleSign = new byte[NET_COMMON_STRING_32];     // 车辆标识, 例如 "Unknown"-未知, "Audi"-奥迪, "Honda"-本田...
        public byte[]            			szCustomParkNo = new byte[NET_COMMON_STRING_64];    // 自定义车位号（停车场用）
        public short             			wVehicleSubBrand;                      			 	// 车辆子品牌，需要通过映射表得到真正的子品牌
        public short             			wVehicleYearModel;                      			// 车辆年款，需要通过映射表得到真正的年款
        public NET_TIME			 			stuEleTagInfoUTC;									// 对应电子车牌标签信息中的过车时间(ThroughTime)
        public int[] 			 			emFalgLists = new int[EM_RECORD_SNAP_FLAG_TYPE.FLAG_TYPE_MAX];	// 录像或抓图文件标志, 参考 EM_RECORD_SNAP_FLAG_TYPE
        public int               			nFalgCount;										 	// 标志总数
        public int							emSafeBelSate;										// 安全带状态, 对应枚举 EM_SAFE_BELT_STATE
        public int 							emCallingState;										// 打电话状态, 对应枚举  EM_CALLING_STATE
        public int							nAttachMentNum;										// 车内物品个数
        public NET_ATTACH_MENET_INFO[]      stuAttachMent = (NET_ATTACH_MENET_INFO[])new NET_ATTACH_MENET_INFO().toArray(MAX_ATTACHMENT_NUM);// 车内物品信息
        public byte[]						szCountry = new byte[NET_COMMON_STRING_32];			// 车牌所属国家和地区
        public int							emCarType;											// 车辆类型, 对应枚举  EM_CATEGORY_TYPE
        public int							emSunShadeState;									// 遮阳板状态, 对应枚举 NET_SUNSHADE_STATE
        public int 							emSmokingState;										// 是否抽烟, 对应枚举 EM_SMOKING_STATE
        public int							nAnnualInspection;									// 年检标个数
        public byte[]				        byReserved=new byte[4];							// 字节对齐
        public int					        nPicIDHigh;								// PictureID高四字节
        public int					        nPicIDLow;								// PictureID低四字节
        public NET_UPLOAD_CLIENT_INFO	    stuClient1;							// 平台客户端1上传信息
        public NET_UPLOAD_CLIENT_INFO	    stuClient2;							// 平台客户端2上传信息
        public PlateNumber[]				szExtraPlateNumber=(PlateNumber[])new PlateNumber().toArray(3);				// 三地车牌
        public int					nExtraPlateNumberNum;					// 车牌个数
        public MEDIAFILE_TRAFFICCAR_INFO_EX() {
            this.dwSize = this.size();
        }
    }




    // 车内饰品信息
    public static class NET_ATTACH_MENET_INFO extends SdkStructure
    {
        public int							emAttachMentType;									// 车内物品类型, 对应枚举  EM_ATTACHMENT_TYPE
        public byte[]                		bReserved1 = new byte[128];                    		// 保留字节
    }

    // 安全带状态
    public static class EM_SAFE_BELT_STATE extends SdkStructure
    {
        public static final int EM_SAFE_BELT_UNKNOWN = 0;			// 未知
        public static final int EM_SAFE_BELT_OTHER = 1;				// 未识别
        public static final int EM_SAFE_BELT_WITH = 2;				// 有安全带
        public static final int EM_SAFE_BELT_WITHOUT = 3;			// 无安全带
    }

    // 车内饰品类型
    public static class EM_ATTACHMENT_TYPE extends SdkStructure
    {
        public static final int EM_ATTACHMENT_UNKNOWN = 0;			// 未知
        public static final int EM_ATTACHMENT_OTHER = 1;			// 其他类型
        public static final int EM_ATTACHMENT_FURNITURE = 2;		// 摆件
        public static final int EM_ATTACHMENT_PENDANT = 3;			// 挂件
        public static final int EM_ATTACHMENT_TISSUEBOX = 4;		// 纸巾盒
        public static final int EM_ATTACHMENT_DANGER = 5;			// 危险品
        public static final int EM_ATTACHMENT_PERFUMEBOX = 6;		// 香水
    }

    // 打电话状态
    public static class EM_CALLING_STATE extends SdkStructure
    {
        public static final int EM_CALLING_UNKNOWN = 0;				// 未知
        public static final int EM_CALLING_OTHER = 1;				// 未识别
        public static final int EM_CALLING_NO = 2;					// 未打电话
        public static final int EM_CALLING_YES = 3;					// 打电话
    }

    // 车辆类型
    public static class EM_CATEGORY_TYPE extends SdkStructure
    {
        public static final int EM_CATEGORY_UNKNOWN = 0;						// 未知
        public static final int EM_CATEGORY_OTHER = 1;							// 其他
        public static final int EM_CATEGORY_MOTOR = 2;							// 机动车
        public static final int EM_CATEGORY_BUS = 3;							// 公交车
        public static final int EM_CATEGORY_UNLICENSED_MOTOR = 4;				// 无牌机动车
        public static final int EM_CATEGORY_LARGE_CAR = 5;						// 大型汽车
        public static final int EM_CATEGORY_MICRO_CAR = 6;						// 小型汽车
        public static final int EM_CATEGORY_EMBASSY_CAR = 7;					// 使馆汽车
        public static final int EM_CATEGORY_MARGINAL_CAR = 8;					// 领馆汽车
        public static final int EM_CATEGORY_AREAOUT_CAR = 9;					// 境外汽车
        public static final int EM_CATEGORY_FOREIGN_CAR = 10;					// 外籍汽车
        public static final int EM_CATEGORY_FARMTRANSMIT_CAR = 11;				// 农用运输车
        public static final int EM_CATEGORY_TRACTOR = 12;						// 拖拉机
        public static final int EM_CATEGORY_TRAILER = 13;						// 挂车
        public static final int EM_CATEGORY_COACH_CAR = 14;						// 教练汽车
        public static final int EM_CATEGORY_TRIAL_CAR = 15;						// 试验汽车
        public static final int EM_CATEGORY_TEMPORARY_ENTRY_CAR = 16;			// 临时入境汽车
        public static final int EM_CATEGORY_TEMPORARY_ENTRY_MOTORCYCLE = 17;	// 临时入境摩托
        public static final int EM_CATEGORY_TEMPORARY_STEER_CAR = 18;			// 临时行驶车
        public static final int EM_CATEGORY_LARGE_TRUCK = 19;					// 大货车
        public static final int EM_CATEGORY_MID_TRUCK = 20;						// 中货车
        public static final int EM_CATEGORY_MICRO_TRUCK = 21;					// 小货车
        public static final int EM_CATEGORY_MICROBUS = 22;						// 面包车
        public static final int EM_CATEGORY_SALOON_CAR = 23;					// 轿车
        public static final int EM_CATEGORY_CARRIAGE = 24;						// 小轿车
        public static final int EM_CATEGORY_MINI_CARRIAGE = 25;					// 微型轿车
        public static final int EM_CATEGORY_SUV_MPV = 26;						// SUV或者MPV
        public static final int EM_CATEGORY_SUV = 27;							// SUV
        public static final int EM_CATEGORY_MPV = 28;							// MPV
        public static final int EM_CATEGORY_PASSENGER_CAR = 29;					// 客车
        public static final int EM_CATEGORY_MOTOR_BUS = 30;						// 大客
        public static final int EM_CATEGORY_MID_PASSENGER_CAR = 31;				// 中客车
        public static final int EM_CATEGORY_MINI_BUS = 32;						// 小客车
        public static final int EM_CATEGORY_PICKUP = 33;						// 皮卡车
        public static final int EM_CATEGORY_OILTANK_TRUCK = 34;					// 油罐车
        public static final int EM_CATEGORY_TANK_CAR = 35;						// 危化品车辆
        public static final int EM_CATEGORY_SLOT_TANK_CAR = 36;					// 槽罐车
        public static final int EM_CATEGORY_DREGS_CAR = 37;						// 渣土车
        public static final int EM_CATEGORY_CONCRETE_MIXER_TRUCK = 38;			// 混凝土搅拌车
        public static final int EM_CATEGORY_TAXI = 39;							// 出租车
        public static final int EM_CATEGORY_POLICE = 40;						// 警车
        public static final int EM_CATEGORY_AMBULANCE = 41;						// 救护车
        public static final int EM_CATEGORY_GENERAL = 42;						// 普通车
        public static final int EM_CATEGORY_WATERING_CAR = 43;					// 洒水车
        public static final int EM_CATEGORY_FIRE_ENGINE = 44;					// 消防车
        public static final int EM_CATEGORY_MACHINE_TRUCK = 45;					// 工程车
        public static final int EM_CATEGORY_POWER_LOT_VEHICLE = 46;				// 粉粒物料车
        public static final int EM_CATEGORY_SUCTION_SEWAGE_TRUCK = 47;			// 吸污车
        public static final int EM_CATEGORY_NORMAL_TANK_TRUCK = 48;				// 普通罐车
    }

    // 是否抽烟
    public static class EM_SMOKING_STATE
    {
        public static final int EM_SMOKING_UNKNOWN = 0;							// 未知
        public static final int EM_SMOKING_NO = 1;								// 未抽烟
        public static final int EM_SMOKING_YES = 2;								// 抽烟
    }

    public static class NET_PIC_INFO_EX extends SdkStructure
    {
        public int dwSize;//结构体大小
        public int dwFileLenth;//文件大小,单位:字节
        public byte[] szFilePath = new byte[MAX_PATH];// 文件路径

        public NET_PIC_INFO_EX()
        {
            this.dwSize = this.size();
        }
    }

    //区域；各边距按整长8192的比例
    public static class NET_RECT extends SdkStructure
    {
        public int left;
        public int top;
        public int right;
        public int bottom;

        public String toString() {
            return "[" + left + " " + top + " " + right + " " + bottom + "]";
        }
    }


    // 时间段结构
    public static class NET_TSECT extends SdkStructure
    {
        public int             bEnable;        // 当表示录像时间段时,按位表示四个使能,从低位到高位分别表示动检录象、报警录象、普通录象、动检和报警同时发生才录像
                                               // 当表示布撤防时间段时, 表示使能
                                               // 当表示推送时间段时, 表示使能：1表示使能，0表示非使能
        public int             iBeginHour;
        public int             iBeginMin;
        public int             iBeginSec;
        public int             iEndHour;
        public int             iEndMin;
        public int             iEndSec;

        public String startTime() {
            return iBeginHour + ":" + iBeginMin + ":" + iBeginSec;
        }

        public String endTime() {
            return iEndHour + ":" + iEndMin + ":" + iEndSec;
        }
    }


    public static class DH_RECT extends SdkStructure
    {
        public NativeLong  	left;
        public NativeLong  	top;
        public NativeLong  	right;
        public NativeLong  	bottom;
    }

    //二维空间点
    public static class NET_POINT extends SdkStructure
    {
        public short nx;
        public short ny;

        @Override
        public String toString() {
            return "NET_POINT{" +
                    "nx=" + nx +
                    ", ny=" + ny +
                    '}';
        }

        public NET_POINT() {
        }
    }

    //二维空间点
    public static class DH_POINT extends SdkStructure
    {
        public short nx;
        public short ny;

        public DH_POINT(){}

        public DH_POINT(short x, short y){
            this.nx = x;
            this.ny = y;
        }
    }

    public static class NET_CANDIDAT_PIC_PATHS extends SdkStructure
    {
        public int dwSize;//结构体大小
        public int nFileCount;//实际文件个数
        public NET_PIC_INFO_EX[] stFiles = (NET_PIC_INFO_EX[])new NET_PIC_INFO_EX().toArray(NET_MAX_PERSON_IMAGE_NUM);//文件信息

        public NET_CANDIDAT_PIC_PATHS()
        {
            this.dwSize = this.size();
        }

        public int fieldOffset(String name) {
            return super.fieldOffset(name);
        }
    }

    //颜色类型
    public static class EM_COLOR_TYPE extends SdkStructure
    {
        public static final int NET_COLOR_TYPE_RED = 0;//红色
        public static final int NET_COLOR_TYPE_YELLOW = 1;//黄色
        public static final int NET_COLOR_TYPE_GREEN = 2; //绿色
        public static final int NET_COLOR_TYPE_CYAN = 3; //青色
        public static final int NET_COLOR_TYPE_BLUE = 4; //蓝色
        public static final int NET_COLOR_TYPE_PURPLE = 5; //紫色
        public static final int NET_COLOR_TYPE_BLACK = 6; //黑色
        public static final int NET_COLOR_TYPE_WHITE = 7; //白色
        public static final int NET_COLOR_TYPE_MAX = 8;
    }

    //视频分析物体信息结构体
    public static class NET_MSG_OBJECT extends SdkStructure
    {
        public int 			nObjectID;							//物体ID,每个ID表示一个唯一的物体
        public byte[] 		szObjectType = new byte[128];		//物体类型
        public int 			nConfidence;						//置信度(0~255),值越大表示置信度越高
        public int 			nAction;						    //物体动作:1:Appear2:Move3:Stay
        public DH_RECT 		BoundingBox;						//包围盒
        public NET_POINT 	Center;								//物体型心
        public int 			nPolygonNum;						//多边形顶点个数
        public NET_POINT[]  Contour = (NET_POINT[])new NET_POINT().toArray(NET_MAX_POLYGON_NUM);//较精确的轮廓多边形
        public int 			rgbaMainColor;						//表示车牌、车身等物体主要颜色；按字节表示,分别为红、绿、蓝和透明度,例如:RGB值为(0,255,0),透明度为0时,其值为0x00ff0000.

        public byte[] 		szText = new byte[128];			    // 物体上相关的带0结束符文本,比如车牌,集装箱号等等
        // "ObjectType"为"Vehicle"或者"Logo"时（尽量使用Logo。Vehicle是为了兼容老产品）表示车标,支持：
        // "Unknown"未知
        // "Audi" 奥迪
        // "Honda" 本田
        // "Buick" 别克
        // "Volkswagen" 大众
        // "Toyota" 丰田
        // "BMW" 宝马
        // "Peugeot" 标致
        // "Ford" 福特
        // "Mazda" 马自达
        // "Nissan" 尼桑
        // "Hyundai" 现代
        // "Suzuki" 铃木
        // "Citroen" 雪铁龙
        // "Benz" 奔驰
        // "BYD" 比亚迪
        // "Geely" 吉利
        // "Lexus" 雷克萨斯
        // "Chevrolet" 雪佛兰
        // "Chery" 奇瑞
        // "Kia" 起亚
        // "Charade" 夏利
        // "DF" 东风
        // "Naveco" 依维柯
        // "SGMW" 五菱
        // "Jinbei" 金杯
        // "JAC" 江淮
        // "Emgrand" 帝豪
        // "ChangAn" 长安
        // "Great Wall" 长城
        // "Skoda" 斯柯达
        // "BaoJun" 宝骏
        // "Subaru" 斯巴鲁
        // "LandWind" 陆风
        // "Luxgen" 纳智捷
        // "Renault" 雷诺
        // "Mitsubishi" 三菱
        // "Roewe" 荣威
        // "Cadillac" 凯迪拉克
        // "MG" 名爵
        // "Zotye" 众泰
        // "ZhongHua" 中华
        // "Foton" 福田
        // "SongHuaJiang" 松花江
        // "Opel" 欧宝
        // "HongQi" 一汽红旗
        // "Fiat" 菲亚特
        // "Jaguar" 捷豹
        // "Volvo" 沃尔沃
        // "Acura" 讴歌
        // "Porsche" 保时捷
        // "Jeep" 吉普
        // "Bentley" 宾利
        // "Bugatti" 布加迪
        // "ChuanQi" 传祺
        // "Daewoo" 大宇
        // "DongNan" 东南
        // "Ferrari" 法拉利
        // "Fudi" 福迪
        // "Huapu" 华普
        // "HawTai" 华泰
        // "JMC" 江铃
        // "JingLong" 金龙客车
        // "JoyLong" 九龙
        // "Karry" 开瑞
        // "Chrysler" 克莱斯勒
        // "Lamborghini" 兰博基尼
        // "RollsRoyce" 劳斯莱斯
        // "Linian" 理念
        // "LiFan" 力帆
        // "LieBao" 猎豹
        // "Lincoln" 林肯
        // "LandRover" 路虎
        // "Lotus" 路特斯
        // "Maserati" 玛莎拉蒂
        // "Maybach" 迈巴赫
        // "Mclaren" 迈凯轮
        // "Youngman" 青年客车
        // "Tesla" 特斯拉
        // "Rely" 威麟
        // "Lsuzu" 五十铃
        // "Yiqi" 一汽
        // "Infiniti" 英菲尼迪
        // "YuTong" 宇通客车
        // "AnKai" 安凯客车
        // "Canghe" 昌河
        // "HaiMa" 海马
        // "Crown" 丰田皇冠
        // "HuangHai" 黄海
        // "JinLv" 金旅客车
        // "JinNing" 精灵
        // "KuBo" 酷博
        // "Europestar" 莲花
        // "MINI" 迷你
        // "Gleagle" 全球鹰
        // "ShiDai" 时代
        // "ShuangHuan" 双环
        // "TianYe" 田野
        // "WeiZi" 威姿
        // "Englon" 英伦
        // "ZhongTong" 中通客车
        // "Changan" 长安轿车
        // "Yuejin" 跃进
        // "Taurus" 金牛星
        // "Alto" 奥拓
        // "Weiwang" 威旺
        // "Chenglong" 乘龙
        // "Haige" 海格
        // "Shaolin" 少林客车
        // "Beifang" 北方客车
        // "Beijing" 北京汽车
        // "Hafu" 哈弗

        public byte[] 		szObjectSubType = new byte[62];		// 物体子类别,根据不同的物体类型,可以取以下子类型：
        // Vehicle Category:"Unknown"  未知,"Motor" 机动车,"Non-Motor":非机动车,"Bus": 公交车,"Bicycle" 自行车,"Motorcycle":摩托车,"PassengerCar":客车,
        // "LargeTruck":大货车,    "MidTruck":中货车,"SaloonCar":轿车,"Microbus":面包车,"MicroTruck":小货车,"Tricycle":三轮车,    "Passerby":行人
        // Plate Category："Unknown" 未知,"Normal" 蓝牌黑牌,"Yellow" 黄牌,"DoubleYellow" 双层黄尾牌,"Police" 警牌"Armed" 武警牌,
        // "Military" BD号牌,"DoubleMilitary" BD双层,"SAR" 港澳特区号牌,"Trainning" 教练车号牌
        // "Personal" 个性号牌,"Agri" 农用牌,"Embassy" 使馆号牌,"Moto" 摩托车号牌,"Tractor" 拖拉机号牌,"Other" 其他号牌
        // HumanFace Category:"Normal" 普通人脸,"HideEye" 眼部遮挡,"HideNose" 鼻子遮挡,"HideMouth" 嘴部遮挡

        public short        wColorLogoIndex;                    // 车标索引
        public short 		wSubBrand;   						// 车辆子品牌 需要通过映射表得到真正的子品牌 映射表详见开发手册
        public byte 		byReserved1;
        public byte 		bPicEnble;							//是否有物体对应图片文件信息, 类型小bool, 取值0或者1
        public NET_PIC_INFO stPicInfo;							//物体对应图片信息
        public byte 		bShotFrame;							//是否是抓拍张的识别结果,  类型小bool, 取值0或者1
        public byte 		bColor;								//物体颜色(rgbaMainColor)是否可用, 类型小bool, 取值0或者1
        public byte 		byReserved2;
        public byte 		byTimeType;							//时间表示类型,详见 EM_TIME_TYPE 说明
        public NET_TIME_EX  stuCurrentTime;						//针对视频浓缩,当前时间戳（物体抓拍或识别时,会将此识别智能帧附在一个视频帧或jpeg图片中,此帧所在原始视频中的出现时间）
        public NET_TIME_EX  stuStartTime;						//开始时间戳（物体开始出现时）
        public NET_TIME_EX  stuEndTime;							//结束时间戳（物体最后出现时）
        public DH_RECT 		stuOriginalBoundingBox;				//包围盒(绝对坐标)
        public DH_RECT 		stuSignBoundingBox;					//车标坐标包围盒
        public int 			dwCurrentSequence;					//当前帧序号（抓下这个物体时的帧）
        public int 			dwBeginSequence;					//开始帧序号（物体开始出现时的帧序号）
        public int 			dwEndSequence;						//结束帧序号（物体消逝时的帧序号）
        public long 		nBeginFileOffse;					//开始时文件偏移,单位:字（物体开始出现时,视频帧在原始视频文件中相对于文件起始处的偏移）
        public long 		nEndFileOffset;						//结束时文件偏移,单位:字节（物体消逝时,视频帧在原始视频文件中相对于文件起始处的偏移）
        public byte[] 		byColorSimilar = new byte[EM_COLOR_TYPE.NET_COLOR_TYPE_MAX];			//物体颜色相似度,取值范围：0-100,数组下标值代表某种颜色,详见 EM_COLOR_TYPE
        public byte[] 		byUpperBodyColorSimilar = new byte[EM_COLOR_TYPE.NET_COLOR_TYPE_MAX];	//上半身物体颜色相似度(物体类型为人时有效)
        public byte[] 		byLowerBodyColorSimilar = new byte[EM_COLOR_TYPE.NET_COLOR_TYPE_MAX];	//下半身物体颜色相似度(物体类型为人时有效)
        public int 			nRelativeID;						//相关物体ID
        public byte[] 		szSubText = new byte[20];			//"ObjectType"为"Vehicle"或者"Logo"时,表示车标下的某一车系,比如奥迪A6L,由于车系较多,SDK实现时透传此字段,设备如实填写。
        public short 		wBrandYear;   						// 车辆品牌年款 需要通过映射表得到真正的年款 映射表详见开发手册

        protected int getNativeAlignment(Class<?> type, Object value, boolean isFirstElement) {
            int alignment = super.getNativeAlignment(type, value, isFirstElement);
            return Math.min(4, alignment);
        }
    }


    // 物体截图信息
    public static class IMAGE_INFO extends SdkStructure
    {
        public int					nLength;			// 图片大小,单位:字节
        public int					nWidth;				// 图片宽度
        public int					nHeight;			// 图片高度
        public byte[]				szFilePath=new byte[260];	// 文件路径
        public byte[]				byReserved=new byte[512];	// 预留字节
    };

    // 目标人脸信息
    public static class FACE_INFO_OBJECT extends SdkStructure
    {
        public IMAGE_INFO			   stuImageInfo;			// 物体截图信息
        public int                     emSex;                   // 性别类型
        public int                     nAge;                    // 年龄
        public int                     emGlasses;               // 是否戴眼镜
        public int                     emEmotion;               // 人脸表情
        public int				       emComplexion;			// 肤色
        public int			           emEye;					// 眼睛状态
        public int			           emMouth;					// 嘴巴状态
        public int			           emMask;				    // 是否带口罩
        public int			           emBeard;				    // 是否有胡子
        public int					   nAttractive;				// 魅力值,0表示未识别,识别时范围1-100,得分高魅力高
        public NET_EULER_ANGLE		   stuFaceCaptureAngle;		// 人脸在抓拍图片中的角度信息, nPitch:抬头低头的俯仰角, nYaw左右转头的偏航角, nRoll头在平面内左偏右偏的翻滚角
        // 角度值取值范围[-90,90], 三个角度值都为999表示此角度信息无效
        public int					   nFaceQuality;			// 人脸抓拍质量分数
        public double                  fMaxTemp;                // 温度信息
        public int                     nIsOverTemp;             // 是否超温
        public int                     nIsUnderTemp;            // 是否低温
        public int                     emTempUnit;              // 温度单位 EM_TEMPERATURE_UNIT
        public byte[]                  byReserved=new byte[2012];			// 保留字段
    };

    public static class EM_TEMPERATURE_UNIT extends SdkStructure
    {
        public final static int EM_TEMPERATURE_CENTIGRADE = 0;          // 摄氏度
        public final static int EM_TEMPERATURE_FAHRENHEIT = 1;          // 华氏度
        public final static int EM_TEMPERATURE_KELVIN = 2;              // 开尔文
    }

    // NET_FILE_QUERY_FACE 对应的人脸识别服务FINDNEXT查询返回参数
    public static class MEDIAFILE_FACERECOGNITION_INFO extends SdkStructure
    {
        public int 						dwSize;							// 结构体大小
        public int 						bGlobalScenePic;				// 全景图是否存在, BOOL类型，取值0或1
        public NET_PIC_INFO_EX 			stGlobalScenePic;				// 全景图片文件路径
        public NET_MSG_OBJECT 			stuObject;						// 目标人脸物体信息
        public NET_PIC_INFO_EX 			stObjectPic;					// 目标人脸文件路径
        public int 						nCandidateNum;					// 当前人脸匹配到的候选对象数量
        public CANDIDATE_INFO[] 		stuCandidates = (CANDIDATE_INFO[])new CANDIDATE_INFO().toArray(NET_MAX_CANDIDATE_NUM); //当前人脸匹配到的候选对象信息
        public NET_CANDIDAT_PIC_PATHS[] stuCandidatesPic = (NET_CANDIDAT_PIC_PATHS[])new NET_CANDIDAT_PIC_PATHS().toArray(NET_MAX_CANDIDATE_NUM);// 当前人脸匹配到的候选对象图片文件路径
        public NET_TIME 				stTime;							// 报警发生时间
        public byte[] 					szAddress = new byte[MAX_PATH]; // 报警发生地点
        public int 						nChannelId;						// 通道号
        public int						bUseCandidatesEx;				// 是否使用候选对象扩展结构体, 1-true, 0-false
        // 若为TRUE, 则表示使用stuCandidatesEx, 且stuCandidates无效, 否则相反
        public int						nCandidateExNum;				// 当前人脸匹配到的候选对象(扩展结构体) 数量
        public CANDIDATE_INFOEX[]		stuCandidatesEx = (CANDIDATE_INFOEX[])new CANDIDATE_INFOEX().toArray(NET_MAX_CANDIDATE_NUM);	// 当前人脸匹配到的候选对象信息, 实际返回个数同nCandidateNum
        public FACE_INFO_OBJECT			stuFaceInfoObject;                      // 目标人脸信息
        public NET_POINT                stuFaceCenter;                          // 人脸型心(不是包围盒中心), 0-8191相对坐标, 相对于小图
        public NET_MEDIAFILE_GENERAL_INFO	stuGeneralInfo;							// 通用信息
        public MEDIAFILE_FACERECOGNITION_INFO()
        {
            this.dwSize = this.size();
        }

        public int fieldOffset(String name) {
            return super.fieldOffset(name);
        }

    }

    //每个视频输入通道对应的所有事件规则：缓冲区pRuleBuf填充多个事件规则信息，每个事件规则信息内容为 CFG_RULE_INFO + "事件类型对应的规则配置结构体"。
    public static class CFG_ANALYSERULES_INFO extends SdkStructure
    {
        public int 			nRuleCount;  // 事件规则个数
        public Pointer  	pRuleBuf;    // 每个视频输入通道对应的视频分析事件规则配置缓冲, 对应  CFG_RULE_INFO[]
        public int 			nRuleLen;    // 缓冲大小
    }

    // 规则通用信息
    public static class CFG_RULE_COMM_INFO extends SdkStructure
    {
        public byte 		bRuleId;							// 规则编号
        public int   		emClassType;						// 规则所属的场景, EM_SCENE_TYPE
        public byte[] 		bReserved = new byte[512];			// 保留字节
    }

    public static class CFG_RULE_INFO extends SdkStructure
    {
        public int 					dwRuleType;			// 事件类型，详见dhnetsdk.h中"智能分析事件类型"
        public int 					nRuleSize;			// 该事件类型规则配置结构体大小
        public CFG_RULE_COMM_INFO   stuRuleCommInfo;	// 规则通用信息
    }

    // 应用场景, 内容与 EM_SCENE_CLASS_TYPE 一致
    public static class EM_SCENE_TYPE extends SdkStructure
    {
        public static final int EM_SCENE_UNKNOW = 0;				// 未知
        public static final int EM_SCENE_NORMAL = 1;				// "Normal" 普通场景
        public static final int EM_SCENE_TRAFFIC = 2;				// "Traffic" 交通场景
        public static final int EM_SCENE_TRAFFIC_PATROL = 3;		// "TrafficPatrol" 交通巡视
        public static final int EM_SCENE_FACEDETECTION = 4;			// "FaceDetection" 人脸检测/人脸识别
        public static final int EM_SCENE_ATM = 5;					// "ATM"
        public static final int EM_SCENE_INDOOR = 6;				// "Indoor"  室内行为分析，和普通规则相同，对室内场景的算法优化版
        public static final int EM_SCENE_FACERECOGNITION = 7;		// "FaceRecognition" 人脸识别
        public static final int EM_SCENE_PRISON = 8;				// "Prison" 监狱
        public static final int EM_SCENE_NUMBERSTAT = 9;			// "NumberStat" 客流量统计
        public static final int EM_SCENE_HEAT_MAP = 10;				// "HeatMap" 热度图
        public static final int EM_SCENE_VIDEODIAGNOSIS = 11;		// "VideoDiagnosis" 视频诊断
        public static final int EM_SCENE_VEHICLEANALYSE = 12;		// "VehicleAnalyse" 车辆特征检测分析
        public static final int EM_SCENE_COURSERECORD = 13;			// "CourseRecord" 自动录播
        public static final int EM_SCENE_VEHICLE = 14;				// "Vehicle" 车载场景(车载行业用，不同于智能交通的Traffic)
        public static final int EM_SCENE_STANDUPDETECTION = 15;		// "StandUpDetection" 起立检测
        public static final int EM_SCENE_GATE = 16;					// "Gate" 卡口
        public static final int EM_SCENE_SDFACEDETECTION = 17;		// "SDFaceDetect"  多预置点人脸检测，配置一条规则但可以在不同预置点下生效
        public static final int EM_SCENE_HEAT_MAP_PLAN = 18;		// "HeatMapPlan" 球机热度图计划
        public static final int EM_SCENE_NUMBERSTAT_PLAN = 19;		// "NumberStatPlan"	球机客流量统计计划
        public static final int EM_SCENE_ATMFD = 20;				// "ATMFD"金融人脸检测，包括正常人脸、异常人脸、相邻人脸、头盔人脸等针对ATM场景特殊优化
        public static final int EM_SCENE_HIGHWAY = 21;				// "Highway" 高速交通事件检测
        public static final int EM_SCENE_CITY = 22;					// "City" 城市交通事件检测
        public static final int EM_SCENE_LETRACK = 23;				// "LeTrack" 民用简易跟踪
        public static final int EM_SCENE_SCR = 24;					// "SCR"打靶相机
        public static final int EM_SCENE_STEREO_VISION = 25;    	// "StereoVision"立体视觉(双目)
        public static final int EM_SCENE_HUMANDETECT = 26;      	// "HumanDetect"人体检测
        public static final int EM_SCENE_FACEANALYSIS = 27;			// "FaceAnalysis" 人脸分析(同时支持人脸检测、人脸识别、人脸属性等综合型业务)
        public static final int EM_SCENE_XRAY_DETECTION = 28;		// "XRayDetection" X光检测
        public static final int EM_SCENE_STEREO_NUMBER = 29;    	// "StereoNumber" 双目相机客流量统计
        public static final int EM_SCENE_CROWD_DISTRI_MAP = 30;		// "CrowdDistriMap" 人群分布图
        public static final int EM_SCENE_CLASS_OBJECTDETECT = 31;	// "ObjectDetect"目标检测

        public static final int EM_SCENE_FACEATTRIBUTE = 32;		// "FaceAttribute" IVSS人脸检测
        public static final int EM_SCENE_FACECOMPARE = 33;		// "FaceCompare" IVSS人脸识别
        public static final int EM_SCENE_STEREO_BEHAVIOR = 34;	// "StereoBehavior" 立体行为分析(典型场景ATM舱)
        public static final int EM_SCENE_INTELLICITYMANAGER = 35;// "IntelliCityMgr" 智慧城管
        public static final int EM_SCENE_PROTECTIVECABIN = 36;	// "ProtectiveCabin" 防护舱（ATM舱内）
        public static final int EM_SCENE_AIRPLANEDETECT = 37;	// "AirplaneDetect" 飞机行为检测
        public static final int EM_SCENE_CROWDPOSTURE = 38;		// "CrowdPosture" 人群态势（人群分布图服务）
        public static final int EM_SCENE_PHONECALLDETECT = 39;	// "PhoneCallDetect"  打电话检测
        public static final int EM_SCENE_SMOKEDETECTION = 40;	// "SmokeDetection"   烟雾检测
        public static final int EM_SCENE_BOATDETECTION = 41;		// "BoatDetection"	  船只检测
        public static final int EM_SCENE_SMOKINGDETECT = 42;		// "SmokingDetect"	  吸烟检测
        public static final int EM_SCENE_WATERMONITOR = 43;		// "WaterMonitor"	  水利监测
        public static final int EM_SCENE_GENERATEGRAPHDETECTION = 44; // GenerateGraphDetection 生成图规则
        public static final int EM_SCENE_TRAFFIC_PARK = 45;		// "TrafficPark"		交通停车
        public static final int EM_SCENE_OPERATEMONITOR = 46; 	// "OperateMonitor"     作业检测
        public static final int EM_SCENE_INTELLI_RETAIL = 47;	// "IntelliRetail" 智慧零售大类
        public static final int EM_SCENE_CLASSROOM_ANALYSE = 48;	// "ClassroomAnalyse" 教育智慧课堂
        public static final int EM_SCENE_PARKINGSPACE=57;      // "ParkingSpace" 车位检测大类
        public static final int EM_SCENE_ANATOMYTEMP_DETECT=60;// "AnatomyTempDetect" 超温检测
        //public static final int EM_SCENE_CROWD_ABNORMAL				 = 60;	// 人群异常检测 "CrowdAbnormal"
    }

    public static class EM_SCENE_CLASS_TYPE extends SdkStructure
    {

        public static final int EM_SCENE_CLASS_UNKNOW = 0;			// 未知
        public static final int EM_SCENE_CLASS_NORMAL = 1;			// "Normal" 普通场景
        public static final int EM_SCENE_CLASS_TRAFFIC = 2;			// "Traffic" 交通场景
        public static final int EM_SCENE_CLASS_TRAFFIC_PATROL = 3;	// "TrafficPatrol" 交通巡视
        public static final int EM_SCENE_CLASS_FACEDETECTION = 4;	// "FaceDetection" 人脸检测/人脸识别
        public static final int EM_SCENE_CLASS_ATM = 5;				// "ATM"
        public static final int EM_SENCE_CLASS_INDOOR = 6;			// "Indoor"  室内行为分析，和普通规则相同，对室内场景的算法优化版
        public static final int EM_SENCE_CLASS_FACERECOGNITION = 7;	// "FaceRecognition" 人脸识别
        public static final int EM_SENCE_CLASS_PRISON = 8;			// "Prison" 监狱
        public static final int EM_SENCE_CLASS_NUMBERSTAT = 9;		// "NumberStat" 客流量统计
        public static final int EM_SENCE_CLASS_HEAT_MAP = 10;		// "HeatMap" 热度图
        public static final int EM_SENCE_CLASS_VIDEODIAGNOSIS = 11;	// "VideoDiagnosis" 视频诊断
        public static final int EM_SENCE_CLASS_VEHICLEANALYSE = 12;	// "VehicleAnalyse" 车辆特征检测分析
        public static final int EM_SENCE_CLASS_COURSERECORD = 13;	// "CourseRecord" 自动录播
        public static final int EM_SENCE_CLASS_VEHICLE = 14;			// "Vehicle" 车载场景(车载行业用，不同于智能交通的Traffic)
        public static final int EM_SENCE_CLASS_STANDUPDETECTION = 15;	// "StandUpDetection" 起立检测
        public static final int EM_SCENE_CLASS_GATE = 16;			// "Gate" 卡口
        public static final int EM_SCENE_CLASS_SDFACEDETECTION = 17;	// "SDFaceDetect"  多预置点人脸检测，配置一条规则但可以在不同预置点下生效
        public static final int EM_SCENE_CLASS_HEAT_MAP_PLAN = 18;	// "HeatMapPlan" 球机热度图计划
        public static final int EM_SCENE_CLASS_NUMBERSTAT_PLAN = 19;	// "NumberStatPlan"	球机客流量统计计划
        public static final int EM_SCENE_CLASS_ATMFD = 20;			// "ATMFD"金融人脸检测，包括正常人脸、异常人脸、相邻人脸、头盔人脸等针对ATM场景特殊优化
        public static final int EM_SCENE_CLASS_HIGHWAY = 21;			// "Highway" 高速交通事件检测
        public static final int EM_SCENE_CLASS_CITY = 22;			// "City" 城市交通事件检测
        public static final int EM_SCENE_CLASS_LETRACK = 23;			// "LeTrack" 民用简易跟踪
        public static final int EM_SCENE_CLASS_SCR = 24;				// "SCR" 打靶相机
        public static final int EM_SCENE_CLASS_STEREO_VISION = 25;   // "StereoVision" 立体视觉(双目)
        public static final int EM_SCENE_CLASS_HUMANDETECT = 26;		// "HumanDetect"人体检测
        public static final int EM_SCENE_CLASS_FACEANALYSIS = 27;	// "FaceAnalysis" 人脸分析
        public static final int EM_SCENE_CLASS_XRAY_DETECTION = 28;	// "XRayDetection" X光检测
        public static final int EM_SCENE_CLASS_STEREO_NUMBER = 29;	// "StereoNumber" 双目相机客流量统计
        public static final int EM_SCENE_CLASS_CROWDDISTRIMAP = 30;	// "CrowdDistriMap"人群分布图
        public static final int EM_SCENE_CLASS_OBJECTDETECT = 31;	// "ObjectDetect"目标检测
        public static final int EM_SCENE_CLASS_FACEATTRIBUTE = 32;	// "FaceAttribute" IVSS人脸检测
        public static final int EM_SCENE_CLASS_FACECOMPARE = 33;		// "FaceCompare" IVSS人脸识别
        public static final int EM_SCENE_CLASS_STEREO_BEHAVIOR = 34;	// "StereoBehavior" 立体行为分析(典型场景ATM舱)
        public static final int EM_SCENE_CLASS_INTELLICITYMANAGER = 35;	// "IntelliCityMgr" 智慧城管
        public static final int EM_SCENE_CLASS_PROTECTIVECABIN = 36;	// "ProtectiveCabin" 防护舱（ATM舱内）
        public static final int EM_SCENE_CLASS_AIRPLANEDETECT = 37;	// "AirplaneDetect" 飞机行为检测
        public static final int EM_SCENE_CLASS_CROWDPOSTURE = 38;	// "CrowdPosture" 人群态势（人群分布图服务）
        public static final int EM_SCENE_CLASS_PHONECALLDETECT = 39;	// "PhoneCallDetect"  打电话检测
        public static final int EM_SCENE_CLASS_SMOKEDETECTION = 40;	// "SmokeDetection"   烟雾检测
        public static final int EM_SCENE_CLASS_BOATDETECTION = 41;	// "BoatDetection"	  船只检测
        public static final int EM_SCENE_CLASS_SMOKINGDETECT = 42;	// "SmokingDetect"	  吸烟检测
        public static final int EM_SCENE_CLASS_WATERMONITOR = 43;	// "WaterMonitor"	  水利监测
        public static final int EM_SCENE_CLASS_GENERATEGRAPHDETECTION = 44;// "GenerateGraphDetection" 生成图规则
        public static final int EM_SCENE_CLASS_TRAFFIC_PARK = 45;	// "TrafficPark"		  交通停车
        public static final int EM_SCENE_CLASS_OPERATEMONITOR = 46; 	// "OperateMonitor" 作业检测
        public static final int EM_SCENE_CLASS_INTELLI_RETAIL = 47;	// IntelliRetail" 智慧零售大类
        public static final int EM_SCENE_CLASS_CLASSROOM_ANALYSE = 48;// "ClassroomAnalyse" 教育智慧课堂
        public static final int EM_SCENE_CLASS_FEATURE_ABSTRACT = 49;  // "FeatureAbstract" 特征向量提取大类
        public static final int EM_SCENE_CLASS_CROWD_ABNORMAL=59;	  // "CrowdAbnormal" 人群异常检测
        public static final int EM_CLASS_WEATHER_MONITOR			 = 64;	// 天气监控 "WeatherMonitor"
    }

    //区域顶点信息
    public static class CFG_POLYGON extends SdkStructure
    {
        public int nX;//0~8191
        public int nY;
    }

    //区域信息
    public static class CFG_REGION extends SdkStructure
    {
        public int nPointNum;
        public CFG_POLYGON[] stuPolygon = (CFG_POLYGON[])new CFG_POLYGON().toArray(MAX_POLYGON_NUM);
    }

    public static class CFG_SIZE_Attribute extends Union
    {
        public float nWidth;//宽
        public float nArea;//面积
    }

    //Size
    public static class CFG_SIZE extends SdkStructure
    {
        public CFG_SIZE_Attribute attr;
        public float nHeight;//高
    }

    public static class NET_SIZE extends SdkStructure
    {
        public int                 nWidth;                     // 宽度
        public int                 nHeight;                    // 高度
    }

    //校准框信息
    public static class CFG_CALIBRATEBOX_INFO extends SdkStructure
    {
        public CFG_POLYGON stuCenterPoint;//校准框中心点坐标(点的坐标归一化到[0,8191]区间)
        public float fRatio;//相对基准校准框的比率(比如1表示基准框大小，0.5表示基准框大小的一半)
    }

    //尺寸过滤器
    public static class CFG_SIZEFILTER_INFO extends SdkStructure
    {
        public int nCalibrateBoxNum;//校准框个数
        public CFG_CALIBRATEBOX_INFO[] stuCalibrateBoxs = (CFG_CALIBRATEBOX_INFO[])new CFG_CALIBRATEBOX_INFO().toArray(MAX_CALIBRATEBOX_NUM);//校准框(远端近端标定模式下有效)
        public byte bMeasureModeEnable;//计量方式参数是否有效， 类型bool, 取值0或1
        public byte bMeasureMode;//计量方式,0-像素，不需要远端、近端标定,1-实际长度，单位：米,2-远端近端标定后的像素
        public byte bFilterTypeEnable;//过滤类型参数是否有效， 类型bool, 取值0或1
        // ByArea,ByRatio仅作兼容，使用独立的ByArea和ByRatio选项代替 2012/03/06
        public byte bFilterType;//过滤类型:0:"ByLength",1:"ByArea",2"ByWidthHeight"
        public byte[] bReserved=new byte[2];                             // 保留字段
        public byte bFilterMinSizeEnable;//物体最小尺寸参数是否有效， 类型bool, 取值0或1
        public byte bFilterMaxSizeEnable;//物体最大尺寸参数是否有效， 类型bool, 取值0或1
        public CFG_SIZE stuFilterMinSize;//物体最小尺寸"ByLength"模式下表示宽高的尺寸，"ByArea"模式下宽表示面积，高无效(远端近端标定模式下表示基准框的宽高尺寸)。
        public CFG_SIZE stuFilterMaxSize;//物体最大尺寸"ByLength"模式下表示宽高的尺寸，"ByArea"模式下宽表示面积，高无效(远端近端标定模式下表示基准框的宽高尺寸)。
        public byte abByArea;//类型bool, 取值0或1
        public byte abMinArea;//类型bool, 取值0或1
        public byte abMaxArea;//类型bool, 取值0或1
        public byte abMinAreaSize;//类型bool, 取值0或1
        public byte abMaxAreaSize;//类型bool, 取值0或1
        public byte bByArea;//是否按面积过滤通过能力ComplexSizeFilter判断是否可用， 类型bool, 取值0或1
        public byte[] bReserved1 = new byte[2];                            // 补齐
        public float nMinArea;//最小面积
        public float nMaxArea;//最大面积
        public CFG_SIZE stuMinAreaSize;//最小面积矩形框尺寸"计量方式"为"像素"时，表示最小面积矩形框的宽高尺寸；"计量方式"为"远端近端标定模式"时，表示基准框的最小宽高尺寸；
        public CFG_SIZE stuMaxAreaSize;//最大面积矩形框尺寸,同上
        public byte abByRatio;//类型bool, 取值0或1
        public byte abMinRatio;//类型bool, 取值0或1
        public byte abMaxRatio;//类型bool, 取值0或1
        public byte abMinRatioSize;//类型bool, 取值0或1
        public byte abMaxRatioSize;//类型bool, 取值0或1
        public byte bByRatio;//是否按宽高比过滤通过能力ComplexSizeFilter判断是否可用， 类型bool, 取值0或1
        public byte[] bReserved2 = new byte[6];
        public double dMinRatio;//最小宽高比
        public double dMaxRatio;//最大宽高比
        public CFG_SIZE stuMinRatioSize;//最小宽高比矩形框尺寸，最小宽高比对应矩形框的宽高尺寸。
        public CFG_SIZE stuMaxRatioSize;//最大宽高比矩形框尺寸，同上
        public byte nAreaCalibrateBoxNum;//面积校准框个数
        public CFG_CALIBRATEBOX_INFO[] stuAreaCalibrateBoxs = (CFG_CALIBRATEBOX_INFO[])new CFG_CALIBRATEBOX_INFO().toArray(MAX_CALIBRATEBOX_NUM);//面积校准框
        public byte nRatioCalibrateBoxs;//宽高校准框个数
        public CFG_CALIBRATEBOX_INFO[] stuRatioCalibrateBoxs = (CFG_CALIBRATEBOX_INFO[])new CFG_CALIBRATEBOX_INFO().toArray(MAX_CALIBRATEBOX_NUM);//宽高校准框
        public byte abBySize;//长宽过滤使能参数是否有效， 类型bool, 取值0或1
        public byte bBySize;//长宽过滤使能， 类型bool, 取值0或1
        public byte[]  bReserved3=new byte[6]; // 保留字段
    }

    //各种物体特定的过滤器
    public static class CFG_OBJECT_SIZEFILTER_INFO extends SdkStructure
    {
        public byte[] szObjectType = new byte[MAX_NAME_LEN];//物体类型
        public CFG_SIZEFILTER_INFO stSizeFilter;//对应的尺寸过滤器
    }

    //特殊区域的属性类型
    public static class EM_SEPCIALREGION_PROPERTY_TYPE extends SdkStructure
    {
        public static final int EM_SEPCIALREGION_PROPERTY_TYPE_HIGHLIGHT = 1;//高亮，键盘检测区域具有此特性
        public static final int EM_SEPCIALREGION_PROPERTY_TYPE_REGULARBLINK = 2; //规律的闪烁，插卡区域具有此特性
        public static final int EM_SEPCIALREGION_PROPERTY_TYPE_IREGULARBLINK = 3; //不规律的闪烁，屏幕区域具有此特性
        public static final int EM_SEPCIALREGION_PROPERTY_TYPE_NUM = 4;
    }

    //特殊检测区，是指从检测区中区分出来，有特殊检测属性的区域
    public static class CFG_SPECIALDETECT_INFO extends SdkStructure
    {
        public int nDetectNum;//检测区域顶点数
        public CFG_POLYGON[] stDetectRegion = (CFG_POLYGON[])new CFG_POLYGON().toArray(MAX_POLYGON_NUM);//检测区域
        public int nPropertyNum;//特殊检测区属性个数
        public int[] nPropertys = new int[EM_SEPCIALREGION_PROPERTY_TYPE.EM_SEPCIALREGION_PROPERTY_TYPE_NUM];//特殊检测区属性
    }

    //各类物体的子类型
    public static class CFG_CATEGORY_TYPE extends SdkStructure
    {
        public static final int CFG_CATEGORY_TYPE_UNKNOW = 0; //未知类型
        //车型相关子类别
        public static final int CFG_CATEGORY_VEHICLE_TYPE_MOTOR = 1; //"Motor"机动车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_NON_MOTOR = 2; //"Non-Motor"非机动车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_BUS = 3; //"Bus"公交车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_BICYCLE = 4; //"Bicycle"自行车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_MOTORCYCLE = 5; //"Motorcycle"摩托车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_UNLICENSEDMOTOR = 6; //"UnlicensedMotor":无牌机动车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_LARGECAR = 7; //"LargeCar"大型汽车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_MICROCAR = 8; //"MicroCar"小型汽车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_EMBASSYCAR = 9; //"EmbassyCar"使馆汽车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_MARGINALCAR = 10; //"MarginalCar"领馆汽车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_AREAOUTCAR = 11; //"AreaoutCar"境外汽车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_FOREIGNCAR = 12; //"ForeignCar"外籍汽车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_DUALTRIWHEELMOTORCYCLE = 13; //"DualTriWheelMotorcycle"两、三轮摩托车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_LIGHTMOTORCYCLE = 14; //"LightMotorcycle"轻便摩托车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_EMBASSYMOTORCYCLE = 15 ; //"EmbassyMotorcycle"使馆摩托车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_MARGINALMOTORCYCLE = 16; //"MarginalMotorcycle"领馆摩托车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_AREAOUTMOTORCYCLE = 17; //"AreaoutMotorcycle"境外摩托车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_FOREIGNMOTORCYCLE = 18; //"ForeignMotorcycle"外籍摩托车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_FARMTRANSMITCAR = 19; //"FarmTransmitCar"农用运输车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_TRACTOR = 20; //"Tractor"拖拉机
        public static final int CFG_CATEGORY_VEHICLE_TYPE_TRAILER = 21; //"Trailer"挂车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_COACHCAR = 22; //"CoachCar"教练汽车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_COACHMOTORCYCLE = 23; //"CoachMotorcycle"教练摩托车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_TRIALCAR = 24; //"TrialCar"试验汽车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_TRIALMOTORCYCLE = 25; //"TrialMotorcycle"试验摩托车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_TEMPORARYENTRYCAR = 26; //"TemporaryEntryCar"临时入境汽车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_TEMPORARYENTRYMOTORCYCLE = 27; //"TemporaryEntryMotorcycle"临时入境摩托车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_TEMPORARYSTEERCAR = 28; //"TemporarySteerCar"临时行驶车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_PASSENGERCAR = 29; //"PassengerCar"客车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_LARGETRUCK = 30; //"LargeTruck"大货车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_MIDTRUCK =31 ; //"MidTruck"中货车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_SALOONCAR = 32; //"SaloonCar"轿车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_MICROBUS = 33; //"Microbus"面包车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_MICROTRUCK = 34; //"MicroTruck"小货车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_TRICYCLE = 35; //"Tricycle"三轮车
        public static final int CFG_CATEGORY_VEHICLE_TYPE_PASSERBY = 36; //"Passerby"行人
        //车牌相关子类别
        public static final int CFG_CATEGORY_PLATE_TYPE_NORMAL = 37; //"Normal"蓝牌黑字
        public static final int CFG_CATEGORY_PLATE_TYPE_YELLOW = 38; //"Yellow"黄牌
        public static final int CFG_CATEGORY_PLATE_TYPE_DOUBLEYELLOW = 39; //"DoubleYellow"双层黄尾牌
        public static final int CFG_CATEGORY_PLATE_TYPE_POLICE = 40; //"Police"警牌
        public static final int CFG_CATEGORY_PLATE_TYPE_ARMED = 41; //"Armed"武警牌
        public static final int CFG_CATEGORY_PLATE_TYPE_MILITARY = 42; //"Military"BD号牌
        public static final int CFG_CATEGORY_PLATE_TYPE_DOUBLEMILITARY = 43; //"DoubleMilitary"BD双层
        public static final int CFG_CATEGORY_PLATE_TYPE_SAR = 44; //"SAR"港澳特区号牌
        public static final int CFG_CATEGORY_PLATE_TYPE_TRAINNING = 45; //"Trainning"教练车号牌
        public static final int CFG_CATEGORY_PLATE_TYPE_PERSONAL = 46; //"Personal"个性号牌
        public static final int CFG_CATEGORY_PLATE_TYPE_AGRI = 47; //"Agri"农用牌
        public static final int CFG_CATEGORY_PLATE_TYPE_EMBASSY = 48; //"Embassy"使馆号牌
        public static final int CFG_CATEGORY_PLATE_TYPE_MOTO = 49; //"Moto"摩托车号牌
        public static final int CFG_CATEGORY_PLATE_TYPE_TRACTOR = 50; //"Tractor"拖拉机号牌
        public static final int CFG_CATEGORY_PLATE_TYPE_OFFICIALCAR = 51; //"OfficialCar"公务车
        public static final int CFG_CATEGORY_PLATE_TYPE_PERSONALCAR = 52; //"PersonalCar"私家车
        public static final int CFG_CATEGORY_PLATE_TYPE_WARCAR = 53; //"WarCar"军用
        public static final int CFG_CATEGORY_PLATE_TYPE_OTHER = 54; //"Other"其他号牌
        public static final int CFG_CATEGORY_PLATE_TYPE_CIVILAVIATION = 55; //"Civilaviation"民航号牌
        public static final int CFG_CATEGORY_PLATE_TYPE_BLACK = 56; //"Black"黑牌
    }

    //不同区域各种类型物体的检测模块配置
    public static class CFG_MODULE_INFO extends SdkStructure
    {
        // 信息
        public byte[] szObjectType = new byte[MAX_NAME_LEN];//默认物体类型,详见"支持的检测物体类型列表"
        public byte bSnapShot;//是否对识别物体抓图，类型bool，取值0或1
        public byte bSensitivity;//灵敏度,取值1-10，值越小灵敏度越低
        public byte bMeasureModeEnable;//计量方式参数是否有效，类型bool，取值0或1
        public byte bMeasureMode;//计量方式,0-像素，不需要远端、近端标定,1-实际长度，单位：米,2-远端近端标定后的像素
        public int nDetectRegionPoint;//检测区域顶点数
        public CFG_POLYGON[] stuDetectRegion = (CFG_POLYGON[])new CFG_POLYGON().toArray(MAX_POLYGON_NUM);//检测区域
        public int nTrackRegionPoint;//跟踪区域顶点数
        public CFG_POLYGON[] stuTrackRegion = (CFG_POLYGON[])new CFG_POLYGON().toArray(MAX_POLYGON_NUM);//跟踪区域
        public byte bFilterTypeEnable;//过滤类型参数是否有效，类型bool，取值0或1
        // ByArea,ByRatio仅作兼容使枚懒⒌腂yArea和ByRatio选项代替 2012/03/06
        public byte nFilterType;//过滤类型:0:"ByLength",1:"ByArea",2:"ByWidthHeight",3:"ByRatio":
        public byte bBackgroudEnable;//区域的背景类型参数是否有效，类型bool，取值0或1
        public byte bBackgroud;//区域的背景类型,0-普通类型,1-高光类型
        public byte abBySize;//长宽过滤使能参数是否有效，类型bool，取值0或1
        public byte bBySize;//长宽过滤使能，类型bool，取值0或1
        public byte bFilterMinSizeEnable;//物体最小尺寸参数是否有效，类型bool，取值0或1
        public byte bFilterMaxSizeEnable;//物体最大尺寸参数是否有效，类型bool，取值0或1
        public CFG_SIZE stuFilterMinSize;//物体最小尺寸"ByLength"模式下表示宽高的尺寸，"ByArea"模式下宽表示面积，高无效。
        public CFG_SIZE stuFilterMaxSize;//物体最大尺寸"ByLength"模式下表示宽高的尺寸，"ByArea"模式下宽表示面积，高无效。
        public int nExcludeRegionNum;//排除区域数
        public CFG_REGION[] stuExcludeRegion = (CFG_REGION[])new CFG_REGION().toArray(MAX_EXCLUDEREGION_NUM);//排除区域
        public int nCalibrateBoxNum;//校准框个数
        public CFG_CALIBRATEBOX_INFO[] stuCalibrateBoxs = (CFG_CALIBRATEBOX_INFO[])new CFG_CALIBRATEBOX_INFO().toArray(MAX_CALIBRATEBOX_NUM);//校准框(远端近端标定模式下有效)
        public byte bAccuracy;//检测精度是否有效，类型bool，取值0或1
        public byte byAccuracy;//检测精度
        public byte bMovingStep;//算法移动步长是否有效，类型bool，取值0或1
        public byte byMovingStep;//算法移动步长
        public byte bScalingFactor;//算法缩放因子是否有效，类型bool，取值0或1
        public byte byScalingFactor;//算法缩放因子
        public byte[] bReserved2 = new byte[1];//保留字段
        public byte abDetectBalance;//漏检和误检平衡参数是否有效，类型bool，取值0或1
        public int nDetectBalance;//漏检和误检平衡0-折中模式(默认)1-漏检更少2-误检更少
        public byte abByRatio;//类型bool，取值0或1
        public byte abMinRatio;;//类型bool，取值0或1
        public byte abMaxRatio;;//类型bool，取值0或1
        public byte abMinAreaSize;;//类型bool，取值0或1
        public byte abMaxAreaSize;;//类型bool，取值0或1
        public byte bByRatio;//是否按宽高比过滤通过能力ComplexSizeFilter判断是否可用可以和nFilterType复用，类型bool，取值0或1
        public byte[] bReserved1 = new byte[2];
        public double dMinRatio;//最小宽高比
        public double dMaxRatio;//最大宽高比
        public CFG_SIZE stuMinAreaSize;//最小面积矩形框尺寸"计量方式"为"像素"时，表示最小面积矩形框的宽高尺寸；"计量方式"为"远端近端标定模式"时，表示基准框的最小宽高尺寸；
        public CFG_SIZE stuMaxAreaSize;//最大面积矩形框尺寸,同上
        public byte abByArea;//类型bool，取值0或1
        public byte abMinArea;//类型bool，取值0或1
        public byte abMaxArea;//类型bool，取值0或1
        public byte abMinRatioSize;//类型bool，取值0或1
        public byte abMaxRatioSize;//类型bool，取值0或1
        public byte bByArea;//是否按面积过滤通过能力ComplexSizeFilter判断是否可用可以和nFilterType复用，类型bool，取值0或1
        public byte[] bReserved3 = new byte[2];
        public float nMinArea;//最小面积
        public float nMaxArea;//最大面积
        public CFG_SIZE stuMinRatioSize;//最小宽高比矩形框尺寸，最小宽高比对应矩形框的宽高尺寸。
        public CFG_SIZE stuMaxRatioSize;//最大宽高比矩形框尺寸，同上
        public int nAreaCalibrateBoxNum;//面积校准框个数
        public CFG_CALIBRATEBOX_INFO[] stuAreaCalibrateBoxs = (CFG_CALIBRATEBOX_INFO[])new CFG_CALIBRATEBOX_INFO().toArray(MAX_CALIBRATEBOX_NUM);//面积校准框
        public int nRatioCalibrateBoxs;//比例校准框个数
        public CFG_CALIBRATEBOX_INFO[] stuRatioCalibrateBoxs = (CFG_CALIBRATEBOX_INFO[])new CFG_CALIBRATEBOX_INFO().toArray(MAX_CALIBRATEBOX_NUM);//比例校准框个数
        public byte bAntiDisturbance;//是否开启去扰动模块，类型bool，取值0或1
        public byte bBacklight;//是否有逆光，类型bool，取值0或1
        public byte bShadow;//是否有阴影，类型bool，取值0或1
        public byte bContourAssistantTrack;//是否开启轮廓辅助跟踪，例：在人脸识别时可以通过跟踪人体来辅助识别脸，类型bool，取值0或1
        public int nPtzPresetId;//云台预置点，0~255，0表示固定场景，忽略预置点。大于0表示在此预置点时模块有效
        public int nObjectFilterNum;//物体特定的过滤器个数
        public CFG_OBJECT_SIZEFILTER_INFO[] stObjectFilter= (CFG_OBJECT_SIZEFILTER_INFO[])new CFG_OBJECT_SIZEFILTER_INFO().toArray(MAX_OBJECT_LIST_SIZE);//物体特定的过滤器信息
        public int abObjectImageSize; //BOOL类型，取值0或1
        public CFG_SIZE stObjectImageSize;//保证物体图像尺寸相同,单位是像素,不支持小数，取值：>=0,0表示自动调整大小
        public int nSpecailDetectNum;//特殊检测区域个数
        public CFG_SPECIALDETECT_INFO[] stSpecialDetectRegions= (CFG_SPECIALDETECT_INFO[])new CFG_SPECIALDETECT_INFO().toArray(MAX_SPECIALDETECT_NUM);//特殊检测区信息
        public int nAttribute;//需要识别物体的属性个数， 类型为unsigned int
        public byte[] szAttributes = new byte[MAX_OBJECT_ATTRIBUTES_SIZE*MAX_NAME_LEN];//需要识别物体的属性列表，“Category”
        public int abPlateAnalyseMode;//nPlateAnalyseMode是否有效, BOOL类型，取值0或1
        public int nPlateAnalyseMode;//车牌识别模式，0-只识别车头牌照1-只识别车尾牌照2-车头牌照优先（场景中大部分车均是车头牌照）3-车尾牌照优先（场景中大部分车均是车尾牌照）
        //szAttributes属性存在"Category"时生效
        public int nCategoryNum;//需要识别物体的子类型总数
        public int[] emCategoryType= new int[MAX_CATEGORY_TYPE_NUMBER];//子类型信息, 元素取CFG_CATEGORY_TYPE中的值
        public byte[] szSceneType = new byte[CFG_COMMON_STRING_16];		// 检测区参数用于的场景类型
        public CFG_LENGTH_FILETER_INFO		stuLengthFilter;				// 物体类型过滤器，如果指定新的过滤器以新的为准
        public boolean						bSceneTypeEx;								// szSceneTypeEx 是否有效
        public byte[]						szSceneTypeEx=new byte[128];							// 检测区参数用于的场景类型扩展
    }

    // 计量方式
    public static class EM_CFG_MEASURE_MODE_TYPE extends SdkStructure
    {
        public static final int EM_CFG_NEASURE_MODE_TYPE_UNKNOW=0;				// 未知
        public static final int EM_CFG_NEASURE_MODE_TYPE_PIXEL=1;					// 像素
        public static final int EM_CFG_NEASURE_MODE_TYPE_METRIC=2;				// 实际长度
    };

    // 过滤类型
    public static class CFG_FILTER_HEIGHT_TYPE extends SdkStructure
    {
        public static final int CFG_FILTER_HEIGHT_TYPE_UNKNOW=0;				// 未知
        public static final int CFG_FILTER_HEIGHT_TYPE_BYHEIGHT=1;			// 高度
    };

    // 物体类型长度过滤器
    public static class CFG_LENGTH_FILETER_INFO extends SdkStructure
    {
        public int	emMeasureMode;	// 计量方式
        public int		emFilterType;	// 过滤类型
        public int							nDetectType;	// 0:大于且小于 1:大于或等于且小于或等于 2:大于且小于或等于 3:大于或等于且小于
        public int							nMinLen;		// 最小检测长度，单位：cm
        public int							nMaxLen;		// 最大检测长度，单位：cm
    };

    public static class CFG_ANALYSEMODULES_INFO extends SdkStructure
    {
        public int nMoudlesNum;//检测模块数
        public CFG_MODULE_INFO[] stuModuleInfo= (CFG_MODULE_INFO[])new CFG_MODULE_INFO().toArray(MAX_ANALYSE_MODULE_NUM);//每个视频输入通道对应的各种类型物体的检测模块配置
    }

    // CLIENT_FindGroupInfo接口输入参数
    public static class NET_IN_FIND_GROUP_INFO extends SdkStructure
    {
        public int dwSize;
        public byte[] szGroupId = new byte[NET_COMMON_STRING_64];//人员组ID,唯一标识一组人员,为空表示查询全部人员组信息

        public NET_IN_FIND_GROUP_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 人脸数据类型
    public static class EM_FACE_DB_TYPE extends SdkStructure
    {
        public static final int NET_FACE_DB_TYPE_UNKOWN = 0;
        public static final int NET_FACE_DB_TYPE_HISTORY = 1;    // 历史数据库,存放的是检测出的人脸信息,一般没有包含人脸对应人员信息
        public static final int NET_FACE_DB_TYPE_BLACKLIST = 2;  // 黑名单数据库
        public static final int NET_FACE_DB_TYPE_WHITELIST = 3;  // 白名单数据库,废弃
        public static final int NET_FACE_DB_TYPE_ALARM = 4;      // 报警库
        public static final int NET_FACE_DB_TYPE_PASSERBY = 5;   // 路人库
    }

    // 人员组信息
    public static class NET_FACERECONGNITION_GROUP_INFO extends SdkStructure
    {
        public int 			dwSize;
        public int 			emFaceDBType;							   		  // 人员组类型,详见EM_FACE_DB_TYPE, 取值为EM_FACE_DB_TYPE中的值
        public byte[] 		szGroupId = new byte[NET_COMMON_STRING_64];		  // 人员组ID,唯一标识一组人员(不可修改,添加操作时无效)
        public byte[] 		szGroupName = new byte[NET_COMMON_STRING_128];	  // 人员组名称
        public byte[] 		szGroupRemarks = new byte[NET_COMMON_STRING_256]; // 人员组备注信息
        public int 			nGroupSize;									      // 当前组内人员数
        public int			nRetSimilarityCount;							  // 实际返回的库相似度阈值个数
        public int[]		nSimilarity = new int[MAX_SIMILARITY_COUNT];	  // 库相似度阈值，人脸比对高于阈值认为匹配成功
        public int			nRetChnCount;									  // 实际返回的通道号个数
        public int[] 		nChannel = new int[NET_MAX_CAMERA_CHANNEL_NUM];   // 当前组绑定到的视频通道号列表
        public int[] 		nFeatureState = new int[MAX_FEATURESTATE_NUM];	  // 人脸组建模状态信息:
        // [0]-准备建模的人员数量，不保证一定建模成功
        // [1]-建模失败的人员数量，图片不符合算法要求，需要更换图片
        // [2]-已建模成功人员数量，数据可用于算法进行人脸识别
        // [3]-曾经建模成功，但因算法升级变得不可用的数量，重新建模就可用
        public int          emRegisterDbType;                     			  // 注册库类型，详见EM_REGISTER_DB_TYPE
        public byte[]		byReserved1=new byte[4];							// 字节对齐
        public NET_PASSERBY_DB_CONFIG_INFO	stuPasserbyDBConfig;					// 路人库配置（选填）

        public NET_FACERECONGNITION_GROUP_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 注册库属性
    public static class EM_REGISTER_DB_TYPE extends SdkStructure
    {
        public static final int EM_REGISTER_DB_TYPE_UNKNOWN          = 0;   // 未知
        public static final int EM_REGISTER_DB_TYPE_NORMAL           = 1;   // 普通库
        public static final int EM_REGISTER_DB_TYPE_BLACKLIST        = 2;   // 黑名单
        public static final int EM_REGISTER_DB_TYPE_WHITELIST        = 3;   // 白名单
        public static final int EM_REGISTER_DB_TYPE_VIP              = 4;   // VIP库
        public static final int EM_REGISTER_DB_TYPE_STAFF            = 5;   // 员工库
        public static final int EM_REGISTER_DB_TYPE_LEADER           = 6;   // 领导库
    }

    // CLIENT_FindGroupInfo接口输出参数
    public static class NET_OUT_FIND_GROUP_INFO extends SdkStructure
    {
        public int 		dwSize;
        public Pointer  pGroupInfos;	// 人员组信息,由用户申请空间， 指向 NET_FACERECONGNITION_GROUP_INFO 的指针
        public int 		nMaxGroupNum;	// 当前申请的数组大小
        public int 		nRetGroupNum;	// 设备返回的人员组个数

        public NET_OUT_FIND_GROUP_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 人员组操作枚举
    public static class EM_OPERATE_FACERECONGNITION_GROUP_TYPE extends SdkStructure
    {
        public static final int NET_FACERECONGNITION_GROUP_UNKOWN = 0;
        public static final int NET_FACERECONGNITION_GROUP_ADD = 1; 	// 添加人员组信息, 对应结构体为 NET_ADD_FACERECONGNITION_GROUP_INFO
        public static final int NET_FACERECONGNITION_GROUP_MODIFY = 2;  // 修改人员组信息, 对应结构体为 NET_MODIFY_FACERECONGNITION_GROUP_INFO
        public static final int NET_FACERECONGNITION_GROUP_DELETE = 3;  // 删除人员组信息, 对应结构体为 NET_DELETE_FACERECONGNITION_GROUP_INFO
    }

    // CLIENT_OperateFaceRecognitionGroup 接口输入参数
    public static class NET_IN_OPERATE_FACERECONGNITION_GROUP extends SdkStructure
    {
        public int 		dwSize;
        public int 		emOperateType;	// 操作类型, 取值为 EM_OPERATE_FACERECONGNITION_GROUP_TYPE 中的值
        public Pointer 	pOPerateInfo;	// 相关操作信息，指向void *

        public NET_IN_OPERATE_FACERECONGNITION_GROUP()
        {
            this.dwSize = this.size();
        }
    }

    // CLIENT_OperateFaceRecognitionGroup接口输出参数
    public static class NET_OUT_OPERATE_FACERECONGNITION_GROUP extends SdkStructure
    {
        public int 		dwSize;
        public byte[] 	szGroupId = new byte[NET_COMMON_STRING_64]; // 新增记录的人员组ID,唯一标识一组人员

        public NET_OUT_OPERATE_FACERECONGNITION_GROUP()
        {
            this.dwSize = this.size();
        }
    }

    // 添加人员组信息
    public static class NET_ADD_FACERECONGNITION_GROUP_INFO extends SdkStructure
    {
        public int               				dwSize;
        public NET_FACERECONGNITION_GROUP_INFO  stuGroupInfo;      // 人员组信息

        public NET_ADD_FACERECONGNITION_GROUP_INFO() {
            this.dwSize = this.size();
        }
    }

    // 修改人员组信息
    public static class NET_MODIFY_FACERECONGNITION_GROUP_INFO extends SdkStructure
    {
        public int               				dwSize;
        public NET_FACERECONGNITION_GROUP_INFO  stuGroupInfo;      // 人员组信息

        public NET_MODIFY_FACERECONGNITION_GROUP_INFO() {
            this.dwSize = this.size();
        }
    }

    // 删除人员组信息
    public static class NET_DELETE_FACERECONGNITION_GROUP_INFO extends SdkStructure
    {
        public int               dwSize;
        public byte[]            szGroupId = new byte[NET_COMMON_STRING_64];  // 人员组ID,唯一标识一组人员

        public NET_DELETE_FACERECONGNITION_GROUP_INFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_SetGroupInfoForChannel接口输入参数
    public static class NET_IN_SET_GROUPINFO_FOR_CHANNEL extends SdkStructure
    {
        public int 			dwSize;
        public int 			nChannelID;															// 通道号
        public int 			nGroupIdNum;														// 人员组数
        public GROUP_ID[]   szGroupIdArr = (GROUP_ID[])new GROUP_ID().toArray(MAX_GOURP_NUM);	// 人员组ID
        public int			nSimilaryNum;														// 相似度阈值个数, 与人员组数相同
        public int[]		nSimilary = new int[MAX_GOURP_NUM];									// 每个人脸组的相似度阈值, 0-100

        public NET_IN_SET_GROUPINFO_FOR_CHANNEL()
        {
            this.dwSize = this.size();
        }
    }

    // CLIENT_SetGroupInfoForChannel接口输出参数
    public static class NET_OUT_SET_GROUPINFO_FOR_CHANNEL extends SdkStructure
    {
        public int dwSize;

        public NET_OUT_SET_GROUPINFO_FOR_CHANNEL()
        {
            this.dwSize = this.size();
        }
    }

    // 人脸查询状态信息回调函数, lAttachHandle是CLIENT_AttachFaceFindState的返回值
    public static class NET_CB_FACE_FIND_STATE extends SdkStructure
    {
        public int 		dwSize;
        public int 		nToken;					// 视频浓缩任务数据库主键ID
        public int 		nProgress;				// 正常取值范围：0-100,-1,表示查询token不存在(当订阅一个不存在或结束的查询时)
        public int 		nCurrentCount;			// 目前符合查询条件的人脸数量

        public NET_CB_FACE_FIND_STATE()
        {
            this.dwSize = this.size();
        }
    }

    //CLIENT_AttachFaceFindState接口输入参数
    public static class NET_IN_FACE_FIND_STATE extends SdkStructure
    {
        public int 				dwSize;			 //结构体大小,必须填写
        public int 				nTokenNum;		 //查询令牌数,为0时,表示订阅所有的查询任务
        public IntByReference 	nTokens;		 //查询令牌, 指向int的指针
        public Callback  cbFaceFindState;        //回调函数 fFaceFindState 回调
        public Pointer 			dwUser;			 //用户数据

        public NET_IN_FACE_FIND_STATE()
        {
            this.dwSize = this.size();
        }
    }

    //CLIENT_AttachFaceFindState接口输入参数
    public static class NET_OUT_FACE_FIND_STATE extends SdkStructure
    {
        public int dwSize;

        public NET_OUT_FACE_FIND_STATE()
        {
            this.dwSize = this.size();
        }
    }

    // SDK全局日志打印信息
    public static class LOG_SET_PRINT_INFO extends SdkStructure
    {
        public int 		dwSize;
        public int 		bSetFilePath;//是否重设日志路径, BOOL类型，取值0或1
        public byte[] 	szLogFilePath = new byte[MAX_LOG_PATH_LEN];//日志路径(默认"./sdk_log/sdk_log.log")
        public int 		bSetFileSize;//是否重设日志文件大小, BOOL类型，取值0或1
        public int 		nFileSize;//每个日志文件的大小(默认大小10240),单位:比特, 类型为unsigned int
        public int 		bSetFileNum;//是否重设日志文件个数, BOOL类型，取值0或1
        public int 		nFileNum;//绕接日志文件个数(默认大小10), 类型为unsigned int
        public int 		bSetPrintStrategy;//是否重设日志打印输出策略, BOOL类型，取值0或1
        public int 		nPrintStrategy;//日志输出策略,0:输出到文件(默认); 1:输出到窗口, 类型为unsigned int
        public byte[]	byReserved=new byte[4];							// 字节对齐
        public Pointer	cbSDKLogCallBack;						// 日志回调，需要将sdk日志回调出来时设置，默认为NULL
        public Pointer	dwUser;									// 用户数据
        public LOG_SET_PRINT_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // media文件查询条件
    public static class EM_FILE_QUERY_TYPE extends SdkStructure
    {
        public static final int NET_FILE_QUERY_TRAFFICCAR = 0; 		//交通车辆信息, 对应结构体为 MEDIA_QUERY_TRAFFICCAR_PARAM
        public static final int NET_FILE_QUERY_ATM = 1; 			//ATM信息
        public static final int NET_FILE_QUERY_ATMTXN = 2; 			//ATM交易信息
        public static final int NET_FILE_QUERY_FACE = 3; 			//人脸信息 MEDIAFILE_FACERECOGNITION_PARAM 和 MEDIAFILE_FACERECOGNITION_INFO
        public static final int NET_FILE_QUERY_FILE = 4; 			//文件信息对应 NET_IN_MEDIA_QUERY_FILE 和 NET_OUT_MEDIA_QUERY_FILE
        public static final int NET_FILE_QUERY_TRAFFICCAR_EX = 5; 	//交通车辆信息,扩展 NET_FILE_QUERY_TRAFFICCAR,支持更多的字段, 对应结构体为 MEDIA_QUERY_TRAFFICCAR_PARAM_EX
        public static final int NET_FILE_QUERY_FACE_DETECTION = 6; 	//人脸检测事件信息MEDIAFILE_FACE_DETECTION_PARAM和 MEDIAFILE_FACE_DETECTION_INFO
        public static final int NET_FILE_QUERY_SNAPSHOT_WITH_MARK = 17;// 标记抓图查询, 对应MEDIAFILE_SNAPSHORT_WITH_MARK_PARAM 和MEDIAFILE_SNAPSHORT_WITH_MARK_INFO
        public static final int NET_FILE_QUERY_ANATOMY_TEMP_DETECT = 18;// 人体测温信息查询， 对应 MEDIAFILE_ANATOMY_TEMP_DETECT_PARAM 和 MEDIAFILE_ANATOMY_TEMP_DETECT_INFO
    }

    // 查询跳转条件
    public static class NET_FINDING_JUMP_OPTION_INFO extends SdkStructure
    {
        public int dwSize;
        public int nOffset;//查询结果偏移量,是相对于当前查询的第一条查询结果的位置偏移

        public NET_FINDING_JUMP_OPTION_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 云台联动类型
    public static class CFG_LINK_TYPE extends SdkStructure
    {
        public static final int LINK_TYPE_NONE = 0; //无联动
        public static final int LINK_TYPE_PRESET = 1; //联动预置点
        public static final int LINK_TYPE_TOUR = 2; //联动巡航
        public static final int LINK_TYPE_PATTERN = 3; //联动轨迹
        public static final int LINK_TYPE_ZOOM = 4;			// 联动变倍
        public static final int LINK_TYPE_SINGLESCENE = 5;	// 联动智能单场景
        public static final int LINK_TYPE_QUICKFOCUS = 6;	// 热成像云台联动快速定位
    }

    // 联动云台信息
    public static class CFG_PTZ_LINK extends SdkStructure
    {
        public int emType;//联动类型, 取值为CFG_LINK_TYPE中的值
        public int nValue;//联动取值分别对应预置点号，巡航号等等
    }

    // 联动云台信息扩展
    public static class CFG_PTZ_LINK_EX extends SdkStructure
    {
        public int emType;//联动类型, 取值为CFG_LINK_TYPE中的值
        public int nParam1;//联动参数1
        public int nParam2;//联动参数2
        public int nParam3;//联动参数3
        public int nChannelID;//所联动云台通道
    }

    // RGBA信息
    public static class CFG_RGBA extends SdkStructure
    {
        public int nRed;
        public int nGreen;
        public int nBlue;
        public int nAlpha;
    }

    // 事件标题内容结构体
    public static class CFG_EVENT_TITLE extends SdkStructure
    {
        public byte[] szText = new byte[MAX_CHANNELNAME_LEN];
        public CFG_POLYGON stuPoint;//标题左上角坐标,采用0-8191相对坐标系
        public CFG_SIZE stuSize;//标题的宽度和高度,采用0-8191相对坐标系，某项或者两项为0表示按照字体自适应宽高
        public CFG_RGBA stuFrontColor;//前景颜色
        public CFG_RGBA stuBackColor;//背景颜色
    }

    public static class NET_CFG_EVENT_TITLE extends SdkStructure
    {
        public byte[] szText = new byte[MAX_CHANNELNAME_LEN];
        public NET_POINT stuPoint;//标题左上角坐标,采用0-8191相对坐标系
        public NET_SIZE stuSize;//标题的宽度和高度,采用0-8191相对坐标系，某项或者两项为0表示按照字体自适应宽高
        public CFG_RGBA stuFrontColor;//前景颜色
        public CFG_RGBA stuBackColor;//背景颜色
    }


    // 邮件附件类型
    public static class CFG_ATTACHMENT_TYPE extends SdkStructure
    {
        public static final int ATTACHMENT_TYPE_PIC = 0; //图片附件
        public static final int ATTACHMENT_TYPE_VIDEO = 1; //视频附件
        public static final int ATTACHMENT_TYPE_NUM = 2; //附件类型总数
    }

    // 分割模式
    public static class CFG_SPLITMODE extends SdkStructure
    {
        public static final int SPLITMODE_1 =1;//1画面
        public static final int SPLITMODE_2 =2;//2画面
        public static final int SPLITMODE_4 =4;//4画面
        public static final int SPLITMODE_5 =5;//5画面
        public static final int SPLITMODE_6 =6;//6画面
        public static final int SPLITMODE_8 =8;//8画面
        public static final int SPLITMODE_9 =9;//9画面
        public static final int SPLITMODE_3  = 10; // 3画面
        public static final int SPLITMODE_3B = 11; // 3画面倒品
        public static final int SPLITMODE_12 =12;//12画面
        public static final int SPLITMODE_16 =16;//16画面
        public static final int SPLITMODE_20 =20;//20画面
        public static final int SPLITMODE_25 =25;//25画面
        public static final int SPLITMODE_36 =36;//36画面
        public static final int SPLITMODE_64 =64;//64画面
        public static final int SPLITMODE_144 =144;//144画面
        public static final int SPLITMODE_PIP =1000;//画中画分割模式基础值
        public static final int SPLITMODE_PIP1 =SPLITMODE_PIP+1;//画中画模式, 1个全屏大画面+1个小画面窗口
        public static final int SPLITMODE_PIP3 =SPLITMODE_PIP+3;//画中画模式, 1个全屏大画面+3个小画面窗口
        public static final int SPLITMODE_FREE =SPLITMODE_PIP*2;//自由开窗模式，可以自由创建、关闭窗口，自由设置窗口位置和Z轴次序
        public static final int SPLITMODE_COMPOSITE_1 = SPLITMODE_PIP * 3 + 1;  // 融合屏成员1分割
        public static final int SPLITMODE_COMPOSITE_4 = SPLITMODE_PIP * 3 + 4;  // 融合屏成员4分割
        public static final int SPLITMODE_4A = SPLITMODE_PIP * 4 + 1;
        public static final int SPLITMODE_EOF = SPLITMODE_COMPOSITE_4+1; //结束标识
    }

    // 轮巡联动配置
    public static class CFG_TOURLINK extends SdkStructure
    {
        public int bEnable;//轮巡使能, BOOL类型，取值0或1
        public int emSplitMode;//轮巡时的分割模式,取值范围为CFG_SPLITMODE中的值
        public int[] nChannels = new int[MAX_VIDEO_CHANNEL_NUM];//轮巡通道号列表
        public int nChannelCount;//轮巡通道数量
    }

    // 门禁操作类型
    public static class EM_CFG_ACCESSCONTROLTYPE extends SdkStructure
    {
        public static final int EM_CFG_ACCESSCONTROLTYPE_NULL = 0;//不做操作
        public static final int EM_CFG_ACCESSCONTROLTYPE_AUTO = 1; //自动
        public static final int EM_CFG_ACCESSCONTROLTYPE_OPEN = 2; //开门
        public static final int EM_CFG_ACCESSCONTROLTYPE_CLOSE = 3; //关门
        public static final int EM_CFG_ACCESSCONTROLTYPE_OPENALWAYS = 4; //永远开启
        public static final int EM_CFG_ACCESSCONTROLTYPE_CLOSEALWAYS = 5; //永远关闭
    }

    // 邮件详细内容
    public static class CFG_MAIL_DETAIL extends SdkStructure
    {
        public int emAttachType;//附件类型, 取值范围为CFG_ATTACHMENT_TYPE中的值
        public int nMaxSize;//文件大小上限，单位kB
        public int nMaxTimeLength;//最大录像时间长度，单位秒，对video有效
    }

    // 语音呼叫发起方
    public static class EM_CALLER_TYPE extends SdkStructure
    {
        public static final int EM_CALLER_DEVICE = 0;//设备发起
    }

    // 呼叫协议
    public static class EM_CALLER_PROTOCOL_TYPE extends SdkStructure
    {
        public static final int EM_CALLER_PROTOCOL_CELLULAR = 0;//手机方式
    }

    // 语音呼叫联动信息
    public static class CFG_TALKBACK_INFO extends SdkStructure
    {
        public int bCallEnable;//语音呼叫使能, BOOL类型，取值0或1
        public int emCallerType;//语音呼叫发起方, 取值范围为EM_CALLER_TYPE中的值
        public int emCallerProtocol;//语音呼叫协议, 取值范围为EM_CALLER_PROTOCOL_TYPE中的值
    }

    // 电话报警中心联动信息
    public static class CFG_PSTN_ALARM_SERVER extends SdkStructure
    {
        public int bNeedReport;//是否上报至电话报警中心, BOOL类型，取值0或1
        public int nServerCount;//电话报警服务器个数
        public byte[] byDestination = new byte[MAX_PSTN_SERVER_NUM];//上报的报警中心下标,详见配置CFG_PSTN_ALARM_CENTER_INFO
    }

    // 时间表信息
    public static class CFG_TIME_SCHEDULE extends SdkStructure
    {
        public int 						 bEnableHoliday;         //是否支持节假日配置，默认为不支持，除非获取配置后返回为TRUE，不要使能假日配置, BOOL类型，取值0或1
        public CFG_TIME_SECTION[] stuTimeSectionWeekDay =
                (CFG_TIME_SECTION[])new CFG_TIME_SECTION().toArray(MAX_TIME_SCHEDULE_NUM*MAX_REC_TSECT);//第一维前7个元素对应每周7天，第8个元素对应节假日，每天最多6个时间段
    }

    // 报警联动信息
    public static class CFG_ALARM_MSG_HANDLE extends SdkStructure
    {
        //能力
        public byte abRecordMask;//类型bool, 取值0或者1
        public byte abRecordEnable;//类型bool, 取值0或者1
        public byte abRecordLatch;//类型bool, 取值0或者1
        public byte abAlarmOutMask;//类型bool, 取值0或者1
        public byte abAlarmOutEn;//类型bool, 取值0或者1
        public byte abAlarmOutLatch;//类型bool, 取值0或者1
        public byte abExAlarmOutMask;//类型bool, 取值0或者1
        public byte abExAlarmOutEn;//类型bool, 取值0或者1
        public byte abPtzLinkEn;//类型bool, 取值0或者1
        public byte abTourMask;//类型bool, 取值0或者1
        public byte abTourEnable;//类型bool, 取值0或者1
        public byte abSnapshot;//类型bool, 取值0或者1
        public byte abSnapshotEn;//类型bool, 取值0或者1
        public byte abSnapshotPeriod;//类型bool, 取值0或者1
        public byte abSnapshotTimes;//类型bool, 取值0或者1
        public byte abTipEnable;//类型bool, 取值0或者1
        public byte abMailEnable;//类型bool, 取值0或者1
        public byte abMessageEnable;//类型bool, 取值0或者1
        public byte abBeepEnable;//类型bool, 取值0或者1
        public byte abVoiceEnable;//类型bool, 取值0或者1
        public byte abMatrixMask;//类型bool, 取值0或者1
        public byte abMatrixEnable;//类型bool, 取值0或者1
        public byte abEventLatch;//类型bool, 取值0或者1
        public byte abLogEnable;//类型bool, 取值0或者1
        public byte abDelay;//类型bool, 取值0或者1
        public byte abVideoMessageEn;//类型bool, 取值0或者1
        public byte abMMSEnable;//类型bool, 取值0或者1
        public byte abMessageToNetEn;//类型bool, 取值0或者1
        public byte abTourSplit;//类型bool, 取值0或者1
        public byte abSnapshotTitleEn;//类型bool, 取值0或者1
        public byte abChannelCount;//类型bool, 取值0或者1
        public byte abAlarmOutCount;//类型bool, 取值0或者1
        public byte abPtzLinkEx;//类型bool, 取值0或者1
        public byte abSnapshotTitle;//类型bool, 取值0或者1
        public byte abMailDetail;//类型bool, 取值0或者1
        public byte abVideoTitleEn;//类型bool, 取值0或者1
        public byte abVideoTitle;//类型bool, 取值0或者1
        public byte abTour;//类型bool, 取值0或者1
        public byte abDBKeys;//类型bool, 取值0或者1
        public byte abJpegSummary;//类型bool, 取值0或者1
        public byte abFlashEn;//类型bool, 取值0或者1
        public byte abFlashLatch;//类型bool, 取值0或者1
        public byte[]				byReserved1=new byte[2];                             // 补齐
        //信息
        public int nChannelCount;//设备的视频通道数
        public int nAlarmOutCount;//设备的报警输出个数
        public int[] dwRecordMask = new int[MAX_CHANNEL_COUNT];//录像通道掩码(按位)
        public int bRecordEnable;//录像使能, BOOL类型，取值0或1
        public int nRecordLatch;//录像延时时间(秒)
        public int[] dwAlarmOutMask = new int[MAX_CHANNEL_COUNT];//报警输出通道掩码
        public int bAlarmOutEn;//报警输出使能, BOOL类型，取值0或1
        public int nAlarmOutLatch;//报警输出延时时间(秒)
        public int[] dwExAlarmOutMask = new int[MAX_CHANNEL_COUNT];//扩展报警输出通道掩码
        public int bExAlarmOutEn;//扩展报警输出使能, BOOL类型，取值0或1
        public CFG_PTZ_LINK [] stuPtzLink = (CFG_PTZ_LINK [])new CFG_PTZ_LINK().toArray(MAX_VIDEO_CHANNEL_NUM);//云台联动项
        public int bPtzLinkEn;//云台联动使能, BOOL类型，取值0或1
        public int[] dwTourMask = new int[MAX_CHANNEL_COUNT];//轮询通道掩码
        public int bTourEnable;//轮询使能, BOOL类型，取值0或1
        public int[] dwSnapshot = new int[MAX_CHANNEL_COUNT];//快照通道号掩码
        public int bSnapshotEn;//快照使能, BOOL类型，取值0或1
        public int nSnapshotPeriod;//连拍周期(秒)
        public int nSnapshotTimes;//连拍次数
        public int bTipEnable;//本地消息框提示, BOOL类型，取值0或1
        public int bMailEnable;//发送邮件，如果有图片，作为附件, BOOL类型，取值0或1
        public int bMessageEnable;//上传到报警服务器, BOOL类型，取值0或1
        public int bBeepEnable;//蜂鸣, BOOL类型，取值0或1
        public int bVoiceEnable;//语音提示, BOOL类型，取值0或1
        public int[] dwMatrixMask = new int[MAX_CHANNEL_COUNT];//联动视频矩阵通道掩码
        public int bMatrixEnable;//联动视频矩阵, BOOL类型，取值0或1
        public int nEventLatch;//联动开始延时时间(秒)，0－15
        public int bLogEnable;//是否记录日志, BOOL类型，取值0或1
        public int nDelay;//设置时先延时再生效，单位为秒
        public int bVideoMessageEn;//叠加提示字幕到视频。叠加的字幕包括事件类型，通道号，秒计时。BOOL类型，取值0或1
        public int bMMSEnable;//发送彩信使能, BOOL类型，取值0或1
        public int bMessageToNetEn;//消息上传给网络使能, BOOL类型，取值0或1
        public int nTourSplit;//轮巡时的分割模式0:1画面;
        public int bSnapshotTitleEn;//是否叠加图片标题, BOOL类型，取值0或1
        public int nPtzLinkExNum;//云台配置数
        public CFG_PTZ_LINK_EX[] stuPtzLinkEx = (CFG_PTZ_LINK_EX[])new CFG_PTZ_LINK_EX().toArray(MAX_VIDEO_CHANNEL_NUM);//扩展云台信息
        public int nSnapTitleNum;//图片标题内容数
        public CFG_EVENT_TITLE[] stuSnapshotTitle = (CFG_EVENT_TITLE[])new CFG_EVENT_TITLE().toArray(MAX_VIDEO_CHANNEL_NUM);//图片标题内容
        public CFG_MAIL_DETAIL stuMailDetail;//邮件详细内容
        public int bVideoTitleEn;//是否叠加视频标题，主要指主码流, BOOL类型，取值0或1
        public int nVideoTitleNum;//视频标题内容数目
        public CFG_EVENT_TITLE[] stuVideoTitle = (CFG_EVENT_TITLE[])new CFG_EVENT_TITLE().toArray(MAX_VIDEO_CHANNEL_NUM);//视频标题内容
        public int nTourNum;//轮询联动数目
        public CFG_TOURLINK[] stuTour = (CFG_TOURLINK[])new CFG_TOURLINK().toArray(MAX_VIDEO_CHANNEL_NUM);//轮询联动配置
        public int nDBKeysNum;//指定数据库关键字的有效数
        public byte[] szDBKeys = new byte[MAX_DBKEY_NUM*MAX_CHANNELNAME_LEN];//指定事件详细信息里需要写到数据库的关键字
        public byte[] byJpegSummary = new byte[MAX_SUMMARY_LEN];//叠加到JPEG图片的摘要信息
        public int bFlashEnable;//是否使能补光灯, BOOL类型，取值0或1
        public int nFlashLatch;//补光灯延时时间(秒),延时时间范围：10,300]
        public byte abAudioFileName;//bool类型，取值0或1
        public byte abAlarmBellEn;//bool类型，取值0或1
        public byte abAccessControlEn;//bool类型，取值0或1
        public byte abAccessControl;//bool类型，取值0或1
        public byte[] szAudioFileName = new byte[MAX_PATH];//联动语音文件绝对路径
        public int bAlarmBellEn;//警号使能, BOOL类型，取值0或1
        public int bAccessControlEn;//门禁使能, BOOL类型，取值0或1
        public int dwAccessControl;//门禁组数
        public int[] emAccessControlType = new int[MAX_ACCESSCONTROL_NUM];//门禁联动操作信息, 元素取值范围为EM_CFG_ACCESSCONTROLTYPE中的值
        public byte abTalkBack;//bool类型，取值0或1
        public CFG_TALKBACK_INFO stuTalkback;//语音呼叫联动信息
        public byte abPSTNAlarmServer;//bool类型，取值0或1
        public CFG_PSTN_ALARM_SERVER stuPSTNAlarmServer;//电话报警中心联动信息
        public CFG_TIME_SCHEDULE stuTimeSection;//事件响应时间表
        public byte abAlarmBellLatch;//bool类型，取值0或1
        public int nAlarmBellLatch;//警号输出延时时间(10-300秒)
        public byte                           abAudioPlayTimes;
        public byte                           abAudioLinkTime;
        public int                            nAudioPlayTimes;                      // 联动语音播放次数
        public int                            nAudioLinkTime;                       // 联动语音播放的时间, 单位：秒
        public int				abAlarmOutTime;								// nAlarmOutTime 是否有效
        public int					nAlarmOutTime;								// 报警输出持续时间,单位秒, 如果无此字段，按设备原来的方式实现（定制）
        public int				abBeepTime;									// nBeepTime 是否有效
        public int					nBeepTime;									// 蜂鸣时长（定制），单位秒，最大值为3600，0代表持续蜂鸣
    }

    // 报警联动信息
    public static class NET_ALARM_MSG_HANDLE extends SdkStructure
    {
        //能力
        public byte                				abChannelCount;                                 // 是否支持通道数量 bool类型，取值0或1
        public byte                				abAlarmOutCount;                                // 是否支持报警输出数量 bool类型，取值0或1

        public byte								abRecordMask;                                   // 是否支持录像通道 bool类型，取值0或1
        public byte								abRecordEnable;                                 // 是否支持录像使能 bool类型，取值0或1
        public byte								abRecordLatch;                                  // 是否支持录像延时 bool类型，取值0或1

        public byte								abAlarmOutMask;                                 // 是否支持报警输出通道 bool类型，取值0或1

        public byte								abAlarmOutEn;                                   // 是否支持报警输出使能 bool类型，取值0或1
        public byte								abAlarmOutLatch;                                // 是否支持报警输出延时 bool类型，取值0或1
        public byte								abExAlarmOutMask;                               // 是否支持扩展报警输出通道 bool类型，取值0或1
        public byte								abExAlarmOutEn;                                 // 是否支持扩展报警输出使能 bool类型，取值0或1

        public byte								abPtzLinkEn;                                    // 是否支持云台联动使能 bool类型，取值0或1
        public byte								abTourMask;                                     // 是否支持轮巡掩码 bool类型，取值0或1
        public byte								abTourEnable;                                   // 是否支持轮巡使能 bool类型，取值0或1

        public byte								abSnapshot;                                     // 是否支持快照 bool类型，取值0或1
        public byte								abSnapshotEn;                                   // 是否支持快照使能 bool类型，取值0或1
        public byte								abSnapshotPeriod;                               // 是否支持帧间隔，每隔多少帧抓一张图片 bool类型，取值0或1
        public byte								abSnapshotTimes;                                // 是否支持连拍次数 bool类型，取值0或1
        public byte								abTipEnable;                                    // 是否支持本地消息框提示 bool类型，取值0或1

        public byte								abMailEnable;                                   // 是否支持发送邮件 bool类型，取值0或1
        public byte								abMessageEnable;                                // 是否支持上传到报警中心服务器 bool类型，取值0或1
        public byte								abBeepEnable;                                   // 是否支持蜂鸣 bool类型，取值0或1
        public byte								abVoiceEnable;                                  // 是否支持语音提示 bool类型，取值0或1

        public byte								abMatrixMask;                                   // 是否支持联动视频矩阵掩码 bool类型，取值0或1
        public byte								abMatrixEnable;                                 // 是否支持联动视频矩阵使能 bool类型，取值0或1
        public byte								abEventLatch;                                   // 是否支持联动开始延时时间 bool类型，取值0或1
        public byte								abLogEnable;                                    // 是否支持日志使能 bool类型，取值0或1

        public byte								abDelay;                                        // 是否支持报警延时 bool类型，取值0或1
        public byte								abVideoMessageEn;                               // 是否支持叠加提示字幕到视频 bool类型，取值0或1
        public byte								abMMSEnable;                                    // 是否支持发送短消息 bool类型，取值0或1
        public byte								abMessageToNetEn;                               // 是否支持消息上传给网络使能 bool类型，取值0或1
        public byte								abTourSplit;                                    // 是否支持换面分割轮巡 bool类型，取值0或1

        public byte								abSnapshotTitleEn;                              // 是否支持叠加图片标题使能 bool类型，取值0或1
        public byte                				abPtzLinkEx;                                    // 是否支持云台联动使能 bool类型，取值0或1
        public byte                				abSnapshotTitle;                                // 是否支持叠加图片标题 bool类型，取值0或1
        public byte                				abMailDetail;                                   // 是否支持邮件详情 bool类型，取值0或1
        public byte                				abVideoTitleEn;                                 // 是否支持叠加视频标题，主要指主码流 bool类型，取值0或1
        public byte                				abVideoTitle;                                   // 是否支持视频标题内容 bool类型，取值0或1

        public byte                				abTour;                                         // 是否支持轮巡 bool类型，取值0或1
        public byte                				abDBKeys;                                       // 是否支持指定事件详细信息里需要写到数据库的关键字 bool类型，取值0或1
        public byte                				abJpegSummary;                                  // 是否支持叠加到JPEG图片的摘要信息 bool类型，取值0或1
        public byte                				abFlashEn;                                      // 是否支持补光灯使能 bool类型，取值0或1
        public byte                				abFlashLatch;                                   // 是否支持补光灯延时bool类型，取值0或1

        public byte								abAudioFileName;                                // 是否支持联动语音文件绝对路径 bool类型，取值0或1
        public byte								abAlarmBellEn;                                  // 是否支持警号使能 bool类型，取值0或1
        public byte								abAccessControlEn;                              // 是否支持门禁控制使能 bool类型，取值0或1
        public byte								abAccessControl;                                // 是否支持门禁控制 bool类型，取值0或1

        public byte								abTalkBack;	                                    // 是否支持语音呼叫 bool类型，取值0或1
        public byte								abPSTNAlarmServer;                              // 是否支持电话报警中心 bool类型，取值0或1
        public byte								abAlarmBellLatch;                               // 是否支持警号输出延时 bool类型，取值0或1

        public byte                             abPlayTimes;                                    // 是否支持联动语音播放次数 bool类型，取值0或1
        public byte                             abReboot;                                       // 是否支持重启使能 bool类型，取值0或1
        public byte                             abBeepTime;                                     // 是否支持蜂鸣时长 bool类型，取值0或1

        public byte[]                           byReserved = new byte[68];                      // 能力保留字段

        //信息
        public CFG_TIME_SCHEDULE				stuTimeSection;									// 事件响应时间表

        public int								nChannelCount;									// 设备的视频通道数
        public int								nAlarmOutCount;									// 设备的报警输出个数

        public int[]							dwRecordMask = new int[MAX_CHANNEL_COUNT];		// 录像通道掩码(按位)
        public int								bRecordEnable;									// 录像使能
        public int								nRecordLatch;									// 录像延时时间(秒)
        public int[]							dwAlarmOutMask = new int[MAX_CHANNEL_COUNT];	// 报警输出通道掩码

        public int								bAlarmOutEn;									// 报警输出使能
        public int								nAlarmOutLatch;									// 报警输出延时时间(秒)
        public int[]							dwExAlarmOutMask = new int[MAX_CHANNEL_COUNT];	// 扩展报警输出通道掩码
        public int								bExAlarmOutEn;									// 扩展报警输出使能

        public CFG_PTZ_LINK[]					stuPtzLink = (CFG_PTZ_LINK [])new CFG_PTZ_LINK().toArray(MAX_VIDEO_CHANNEL_NUM);	// 云台联动项		//这个参数并没有被解析，应该是被扩展替代
        public int								bPtzLinkEn;										// 云台联动使能
        public int[]							dwTourMask = new int[MAX_CHANNEL_COUNT];		// 轮询通道掩码
        public int								bTourEnable;									// 轮询使能

        public int[]							dwSnapshot = new int[MAX_CHANNEL_COUNT];		// 快照通道号掩码
        public int								bSnapshotEn;									// 快照使能
        public int								nSnapshotPeriod;								// 连拍周期(秒)
        public int								nSnapshotTimes;									// 连拍次数
        public int								bTipEnable;										// 本地消息框提示

        public int								bMailEnable;									// 发送邮件，如果有图片，作为附件
        public int								bMessageEnable;									// 上传到报警服务器
        public int								bBeepEnable;							 		// 蜂鸣

        public int								bVoiceEnable;									// 语音提示
        public int                              nPlayTimes;                                  	// 联动语音播放次数bVoiceEnable=TRUE时生效

        public int[]							dwMatrixMask = new int[MAX_CHANNEL_COUNT];		// 联动视频矩阵通道掩码
        public int								bMatrixEnable;									// 联动视频矩阵
        public int								nEventLatch;									// 联动开始延时时间(秒)，0－15
        public int								bLogEnable;										// 是否记录日志

        public int								nDelay;											// 设置时先延时再生效，单位为秒
        public int								bVideoMessageEn;								// 叠加提示字幕到视频。叠加的字幕包括事件类型，通道号，秒计时。
        public int								bMMSEnable;										// 发送彩信使能
        public int								bMessageToNetEn;								// 消息上传给网络使能
        public int								nTourSplit;										// 轮巡时的分割模式 0: 1画面; 1: 8画面

        public int								bSnapshotTitleEn;								// 是否叠加图片标题
        public int                 				nPtzLinkExNum;									// 云台配置数
        public CFG_PTZ_LINK_EX[] 				stuPtzLinkEx = (CFG_PTZ_LINK_EX [])new CFG_PTZ_LINK_EX().toArray(MAX_VIDEO_CHANNEL_NUM);  // 扩展云台信息
        public int                 				nSnapTitleNum;									// 图片标题内容数
        public NET_CFG_EVENT_TITLE[] 			stuSnapshotTitle = (NET_CFG_EVENT_TITLE [])new NET_CFG_EVENT_TITLE().toArray(MAX_VIDEO_CHANNEL_NUM);	// 图片标题内容
        public CFG_MAIL_DETAIL 					stuMailDetail;									// 邮件详细内容
        public int                				bVideoTitleEn;									// 是否叠加视频标题，主要指主码流
        public int                 				nVideoTitleNum;									// 视频标题内容数目
        public NET_CFG_EVENT_TITLE[] 			stuVideoTitle = (NET_CFG_EVENT_TITLE [])new NET_CFG_EVENT_TITLE().toArray(MAX_VIDEO_CHANNEL_NUM);		// 视频标题内容

        public int                 				nTourNum;										// 轮询联动数目
        public CFG_TOURLINK[]    				stuTour = (CFG_TOURLINK [])new CFG_TOURLINK().toArray(MAX_VIDEO_CHANNEL_NUM);// 轮询联动配置
        public int                 				nDBKeysNum;										// 指定数据库关键字的有效数
        public byte[]                			szDBKeys = new byte[MAX_DBKEY_NUM * MAX_CHANNELNAME_LEN];	// 指定事件详细信息里需要写到数据库的关键字
        public byte[]                			byJpegSummary = new byte[MAX_SUMMARY_LEN];						// 叠加到JPEG图片的摘要信息
        public int                				bFlashEnable;											// 是否使能补光灯
        public int                 				nFlashLatch;											// 补光灯延时时间(秒),延时时间范围：[10,300]

        public byte[]							szAudioFileName = new byte[MAX_PATH];						// 联动语音文件绝对路径
        public int								bAlarmBellEn;									// 警号使能
        public int								bAccessControlEn;								// 门禁使能
        public int								dwAccessControl;								// 门禁组数
        public int[]							emAccessControlType = new int[MAX_ACCESSCONTROL_NUM];	// 门禁联动操作信息,详见EM_CFG_ACCESSCONTROLTYPE

        public CFG_TALKBACK_INFO				stuTalkback;									// 语音呼叫联动信息
        public CFG_PSTN_ALARM_SERVER			stuPSTNAlarmServer;								// 电话报警中心联动信息
        public int								nAlarmBellLatch;								// 警号输出延时时间(10-300秒)

        public int                              bReboot;                                        //重启使能TRUE:使能 FALSE:不使能
        public int                              nBeepTime;                                      //蜂鸣时长最大值为3600，0代表持续蜂鸣
        public int                              abAudioLinkTime;                                //联动语音时间使能
        public int							    nAudioLinkTime;									// 联动语音播放的时间, 单位：秒
        public int							    abAudioPlayTimes;								// 联动语音播放使能
        public int								nAudioPlayTimes;								// 联动语音播放次数        
        public byte[]							byReserve = new byte[2032];						// 预留字节
    }

    // 时间段信息
    public static class CFG_TIME_SECTION extends SdkStructure
    {
        public int 		dwRecordMask;//录像掩码，按位分别为动态检测录像、报警录像、定时录像、Bit3~Bit15保留、Bit16动态检测抓图、Bit17报警抓图、Bit18定时抓图
                                     // 当表示推送时间段时, 表示使能：1表示使能，0表示非使能
        public int 		nBeginHour;
        public int 		nBeginMin;
        public int 		nBeginSec;
        public int 		nEndHour;
        public int 		nEndMin;
        public int 		nEndSec;

        public void setStartTime(int nBeginHour, int nBeginMin, int nBeginSec) {
            this.nBeginHour = nBeginHour;
            this.nBeginMin = nBeginMin;
            this.nBeginSec = nBeginSec;
        }

        public void setEndTime(int nEndHour, int nEndMin, int nEndSec) {
            this.nEndHour = nEndHour;
            this.nEndMin = nEndMin;
            this.nEndSec = nEndSec;
        }

        public String startTime() {
            return nBeginHour + ":" + nBeginMin + ":" + nBeginSec;
        }

        public String endTime() {
            return nEndHour + ":" + nEndMin + ":" + nEndSec;
        }
    }

    // 事件类型EVENT_IVS_FACERECOGNITION(人脸识别)对应的规则配置
    public static class CFG_FACERECOGNITION_INFO extends SdkStructure
    {
        // 信息
        public byte[] 						szRuleName = new byte[MAX_NAME_LEN];	// 规则名称,不同规则不能重名
        public byte 						bRuleEnable;						    // 规则使能,bool类型，取值0或1
        public byte[] 						bReserved = new byte[2];				// 保留字段
        public int 							nObjectTypeNum;							// 相应物体类型个数
        public byte[] 						szObjectTypes = new byte[MAX_OBJECT_LIST_SIZE*MAX_NAME_LEN];//相应物体类型列表
        public int 							nPtzPresetId;							// 云台预置点编号0~65535
        public byte 						bySimilarity;							// 相似度，必须大于该相识度才报告(1~100)
        public byte 						byAccuracy;								// 识别精度(取值1~10，随着值增大，检测精度提高，检测速度下降。最小值为1表示检测速度优先，最大值为10表示检测精度优先)
        public byte				    		byMode;									// 对比模式,0-正常,1-指定人脸区域组合,
        public byte 						byImportantRank;						// 查询重要等级大于等于此等级的人员(1~10,数值越高越重要)
        public int 							nAreaNum;								// 区域数
        public byte[]						byAreas = new byte[8];					// 人脸区域组合,0-眉毛，1-眼睛，2-鼻子，3-嘴巴，4-脸颊(此参数在对比模式为1时有效)
        public int 							nMaxCandidate;							// 报告的最大匹配图片个数
        public CFG_ALARM_MSG_HANDLE 		stuEventHandler;						// 报警联动
        public TIME_SECTION_WEEK_DAY_10[]   stuTimeSectionWeekDay =
                (TIME_SECTION_WEEK_DAY_10[])new TIME_SECTION_WEEK_DAY_10().toArray(WEEK_DAY_NUM); // 事件响应时间段
    }

    // 事件类型EVENT_IVSS_FACEATTRIBUTE(IVSS人脸检测事件) 对应的规则配置
    public static class CFG_FACEATTRIBUTE_INFO extends SdkStructure
    {
        // 信息
        public byte[] 						szRuleName = new byte[MAX_NAME_LEN];							// 规则名称,不同规则不能重名
        public byte 						bRuleEnable;						    						// 规则使能,bool类型，取值0或1
        public byte[] 						bReserved = new byte[3];										// 保留字
        public int							nObjectTypeNum;													// 相应物体类型个数
        public byte[] 						szObjectTypes = new byte[MAX_OBJECT_LIST_SIZE*MAX_NAME_LEN]; 	// 相应物体类型列表
        public int							nDetectRegionPoint;												// 检测区顶点数
        public CFG_POLYGON[]                stuDetectRegion = (CFG_POLYGON[])new CFG_POLYGON().toArray(MAX_POLYGON_NUM); // 检测区
        public CFG_ALARM_MSG_HANDLE 		stuEventHandler;												// 报警联动
        public TIME_SECTION_WEEK_DAY_10[]   stuTimeSectionWeekDay =
                (TIME_SECTION_WEEK_DAY_10[])new TIME_SECTION_WEEK_DAY_10().toArray(WEEK_DAY_NUM);// 事件响应时间段
        public int                 			nPtzPresetId;													// 云台预置点编号	0~65535
        public int                 			nMinDuration;                                           		// 最短触发时间,单位：秒
        public int                 			nTriggerTargetsNumber;                                  		// 触发报警的人脸个数
        public int                 			nSensitivity;                                           		// 灵敏度,范围[1,10],灵敏度越高越容易检测
        public int                 			nReportInterval;                                        		// 重复报警间隔,单位:秒,[0,600](等于0表示不重复报警)
        public int               		 	bSizeFileter;                                           		// 规则特定的尺寸过滤器是否有效,bool类型 取值0或1
        public CFG_SIZEFILTER_INFO 			stuSizeFileter;                                         		// 规则特定的尺寸过滤器
        public int							nFaceFeatureNum;												// 需要检测的人脸属性个数
        public int[]  						emFaceFeatureType = new int[MAX_FEATURE_LIST_SIZE];				// 需检测的人脸属性, 参考  EM_FACEFEATURE_TYPE
        public boolean                      bFeatureFilter;                                         // 在人脸属性开启前提下，如果人脸图像质量太差，是否不上报属性
        public int                          nMinQuality;                                            // 人脸图片质量阈值,和bFeatureFilter一起使用 范围[0,100]
    }

    // 联动的布控组
    public static class CFG_LINKGROUP_INFO extends SdkStructure
    {
        public int 					bEnable;									// 布控组是否启用,bool类型 取值0或1
        public byte[]					szGroupID = new byte[MAX_GROUP_ID_LEN];		// 布控组ID
        public byte                		bySimilarity;                       		// 相似度阈值
        public byte[]					szColorName = new byte[MAX_COLOR_NAME_LEN];	// 事件触发时绘制人脸框的颜色
        public int 					bShowTitle;									// 事件触发时规则框上是否显示报警标题,bool类型 取值0或1
        public int 					bShowPlate;									// 事件触发时是否显示比对面板	,bool类型 取值0或1
        public byte[]					bReserved=new byte[511];						// 保留字段
        public CFG_ALARM_MSG_HANDLE 	stuEventHandler;							// 报警联动
    }

    // 陌生人布防模式
    public static class CFG_STRANGERMODE_INFO extends SdkStructure
    {
        public int 					    bEnable;									// 模式是否启用,bool类型 取值0或1
        public byte[]					szColorHex = new byte[MAX_COLOR_HEX_LEN];	// 事件触发时绘制人脸框的颜色
        public int 					    bShowTitle;									// 事件触发时规则框上是否显示报警标题,bool类型 取值0或1
        public int 					    bShowPlate;									// 事件触发时是否显示比对面板,bool类型 取值0或1
        public byte[]					bReserved=new byte[512];									// 保留字段
        public CFG_ALARM_MSG_HANDLE 	stuEventHandler;							// 报警联动
    }

    // 事件类型EVENT_IVS_FACEANALYSIS(人脸分析事件) 对应的规则配置
    public static class CFG_FACEANALYSIS_INFO extends SdkStructure
    {
        public byte[] 						szRuleName = new byte[MAX_NAME_LEN];							// 规则名称,不同规则不能重名
        public byte 						bRuleEnable;						    						// 规则使能,bool类型，取值0或1
        public byte[] 						bReserved = new byte[3];										// 保留字
        public int							nObjectTypeNum;													// 相应物体类型个数
        public byte[] 						szObjectTypes = new byte[MAX_OBJECT_LIST_SIZE*MAX_NAME_LEN]; 	// 相应物体类型列表
        public int							nDetectRegionPoint;												// 检测区顶点数
        public CFG_POLYGON[]                stuDetectRegion = (CFG_POLYGON[])new CFG_POLYGON().toArray(MAX_POLYGON_NUM); // 检测区
        public CFG_ALARM_MSG_HANDLE 		stuEventHandler;												// 报警联动
        public TIME_SECTION_WEEK_DAY_10[]   stuTimeSectionWeekDay =
                (TIME_SECTION_WEEK_DAY_10[])new TIME_SECTION_WEEK_DAY_10().toArray(WEEK_DAY_NUM);// 事件响应时间段
        public int                 			nPtzPresetId;													// 云台预置点编号	0~65535
        public int                 			nSensitivity;                                           		// 灵敏度,范围[1,10],灵敏度越高越容易检测
        public int                 			nLinkGroupNum;                                        			// 联动布控个数
        public CFG_LINKGROUP_INFO[]		    stuLinkGroupArr = (CFG_LINKGROUP_INFO[])new CFG_LINKGROUP_INFO().toArray(MAX_LINK_GROUP_NUM); // 联动的布控组
        public CFG_STRANGERMODE_INFO		stuStrangerMode;												// 陌生人布防模式
        public int               		 	bSizeFileter;                                           		// 规则特定的尺寸过滤器是否有效
        public CFG_SIZEFILTER_INFO 			stuSizeFileter;                                         		// 规则特定的尺寸过滤器, 1-true  0-false
        public int							bFeatureEnable;													// 是否开启人脸属性识别
        public int							nFaceFeatureNum;												// 需要检测的人脸属性个数
        public int[]  						emFaceFeatureType = new int[MAX_FEATURE_LIST_SIZE];				// 需检测的人脸属性, 参考  EM_FACEFEATURE_TYPE
        public int							bFeatureFilter;													// 在人脸属性开启前提下，如果人脸图像质量太差，是否不上报属性
        // true-图像太差不上报属性 false-图像很差也上报属性(可能会非常不准，影响用户体验)
        public int							nMinQuality;													// 人脸图片质量阈值,和bFeatureFilter一起使用 范围[1,100]
    }

    // 事件类型EVENT_IVSS_FACECOMPARE(IVSS人脸识别事件) 对应的规则配置
    public static class CFG_FACECOMPARE_INFO extends SdkStructure
    {
        public byte[] 						szRuleName = new byte[MAX_NAME_LEN];							// 规则名称,不同规则不能重名
        public byte 						bRuleEnable;						    						// 规则使能,bool类型，取值0或1
        public byte[] 						bReserved = new byte[3];										// 保留字
        public int							nObjectTypeNum;													// 相应物体类型个数
        public byte[] 						szObjectTypes = new byte[MAX_OBJECT_LIST_SIZE*MAX_NAME_LEN]; 	// 相应物体类型列表
        public CFG_ALARM_MSG_HANDLE 		stuEventHandler;												// 报警联动
        public TIME_SECTION_WEEK_DAY_10[]   stuTimeSectionWeekDay =
                (TIME_SECTION_WEEK_DAY_10[])new TIME_SECTION_WEEK_DAY_10().toArray(WEEK_DAY_NUM);// 事件响应时间段
        public int                 			nPtzPresetId;													// 云台预置点编号	0~65535
        public int                 			nLinkGroupNum;                                        			// 联动布控个数
        public CFG_LINKGROUP_INFO[]		    stuLinkGroupArr = (CFG_LINKGROUP_INFO[])new CFG_LINKGROUP_INFO().toArray(MAX_LINK_GROUP_NUM); // 联动的布控组
        public CFG_STRANGERMODE_INFO		stuStrangerMode;												// 陌生人布防模式
    }

    // 智能报警事件公共信息
    public static class EVENT_INTELLI_COMM_INFO extends SdkStructure
    {
        public int 			emClassType;				// 智能事件所属大类， 取值为  EM_CLASS_TYPE 中的值
        public int			nPresetID;					// 该事件触发的预置点，对应该设置规则的预置点
        public byte[]       bReserved = new byte[124];  // 保留字节,留待扩展.
    }

    // 事件类型EVENT_IVS_FACERECOGNITION(人脸识别)对应的数据块描述信息
    public static class DEV_EVENT_FACERECOGNITION_INFO extends SdkStructure
    {
        public int 						nChannelID;									// 通道号
        public byte[] 					szName = new byte[128]; 					// 事件名称
        public int 						nEventID;									// 事件ID
        public NET_TIME_EX  			UTC;										// 事件发生的时间
        public NET_MSG_OBJECT   		stuObject;									// 检测到的物体
        public int 						nCandidateNum;								// 当前人脸匹配到的候选对象数量
        public CANDIDATE_INFO[] 		stuCandidates = (CANDIDATE_INFO[])new CANDIDATE_INFO().toArray(NET_MAX_CANDIDATE_NUM);//当前人脸匹配到的候选对象信息
        public byte 					bEventAction;								// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte 					byImageIndex;								// 图片的序号,同一时间内(精确到秒)可能有多张图片,从0开始
        public byte[] 					byReserved1 = new byte[2];  				// 对齐
        public int 						bGlobalScenePic;							// 全景图是否存在, 类型为BOOL, 取值为0或者1
        public NET_PIC_INFO 			stuGlobalScenePicInfo;						// 全景图片信息
        public byte[] 					szSnapDevAddress = new byte[MAX_PATH];		// 抓拍当前人脸的设备地址,如：滨康路37号
        public int 						nOccurrenceCount;							// 事件触发累计次数， 类型为unsigned int
        public EVENT_INTELLI_COMM_INFO  stuIntelliCommInfo;							// 智能事件公共信息
        public NET_FACE_DATA 			stuFaceData;								// 人脸数据
        public byte[]					szUID = new byte[NET_COMMON_STRING_32];		// 抓拍人员写入数据库的唯一标识符
        public NET_FEATURE_VECTOR	    stuFeatureVector;							// 特征值信息
        public byte[]				    szFeatureVersion = new byte[32];			// 特征值算法版本
        public int 						emFaceDetectStatus;                       	// 人脸在摄像机画面中的状态,详见EM_FACE_DETECT_STATUS
        public byte[]					szSourceID = new byte[32];					// 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
        public NET_PASSERBY_INFO		stuPasserbyInfo;							// 路人库信息
        public int						nStayTime;									// 路人逗留时间 单位：秒
        public byte[]                	bReserved = new byte[432];                  // 保留字节,留待扩展.
        public NET_GPS_INFO             stuGPSInfo;                                 // GPS信息
        public int					    nRetCandidatesExNum;						// 当前人脸匹配到的候选对象数量实际返回值
        public CANDIDATE_INFOEX[]       stuCandidatesEx = (CANDIDATE_INFOEX[])new CANDIDATE_INFOEX().toArray(NET_MAX_CANDIDATE_NUM);     // 当前人脸匹配到的候选对象信息扩展
        public byte[]					szSerialUUID = new byte[22];				// 级联物体ID唯一标识
        //    																				// 格式如下：前2位%d%d:01-视频片段,02-图片,03-文件,99-其他;
//    																				// 中间14位YYYYMMDDhhmmss:年月日时分秒;后5位%u%u%u%u%u：物体ID，如00001
        public byte[]                	byReserved = new byte[2];                   // 对齐
        public NET_CUSTOM_PROJECTS_INFO stuCustomProjects;						// 项目定制信息
        public boolean				bIsDuplicateRemove;							// 智慧零售，是否符合去重策略（TRUE：符合 FALSE：不符合）
        public byte[]				byReserved2=new byte[4];								// 字节对齐
        @Override
        public int fieldOffset(String name) {
            // TODO Auto-generated method stub
            return super.fieldOffset(name);
        }
    }

    // 路人信息
    public static class NET_PASSERBY_INFO extends SdkStructure
    {
        public byte[]				szPasserbyUID = new byte[MAX_COMMON_STRING_32];			// 路人唯一标识符
        public byte[]               szPasserbyGroupId = new byte[MAX_COMMON_STRING_64];		// 路人库ID
        public byte[]				szPasserbyGroupName = new byte[MAX_COMMON_STRING_128];	// 路人库名称
        public byte[]				byReserved = new byte[128];								// 保留
    }

    // 候选人员信息扩展结构体
    public static class CANDIDATE_INFOEX extends SdkStructure
    {
        public FACERECOGNITION_PERSON_INFOEX  stPersonInfo;            			  // 1 人员信息扩展
        // 布控（黑名单）库,指布控库中人员信息；
        // 历史库,指历史库中人员信息
        // 报警库,指布控库的人员信息
        public byte                           bySimilarity;            			  // 1 和查询图片的相似度,百分比表示,1~100
        public byte                           byRange;                 			  // 人员所属数据库范围,详见EM_FACE_DB_TYPE
        public byte[]                         byReserved1 = new byte[2];
        public NET_TIME                       stTime;                  			  // 当byRange为历史数据库时有效,表示查询人员出现的时间
        public byte[]                         szAddress = new byte[MAX_PATH];     // 当byRange为历史数据库时有效,表示查询人员出现的地点
        public int                         	  bIsHit;                  			  // 是否有识别结果,指这个检测出的人脸在库中有没有比对结果
        public NET_PIC_INFO_EX3               stuSceneImage;           			  // 人脸全景图
        public int							  nChannelID;			    		  // 通道号
        public byte[]            			  szFilePathEx = new byte[256];  	  // 文件路径
        public byte[]                         byReserved = new byte[1024];   	  // 保留字节

        public int fieldOffset(String name) {
            return super.fieldOffset(name);
        }
    }

    // 存储IVSS项目招行VIP需求,特征值信息
    public static class NET_FEATURE_VECTOR extends SdkStructure
    {
        public int							 dwOffset;							// 人脸小图特征值在二进制数据块中的偏移
        public int							 dwLength;							// 人脸小图特征值长度，单位:字节
        public byte[]						 byReserved = new byte[120];					// 保留
    }

    // 人员信息扩展结构体
    public static class FACERECOGNITION_PERSON_INFOEX extends SdkStructure
    {
        public byte[]                		szPersonName = new byte[NET_MAX_PERSON_NAME_LEN];   // ---姓名
        public short                		wYear;                                          	// 出生年,作为查询条件时,此参数填0,则表示此参数无效
        public byte                			byMonth;                                        	// 出生月,作为查询条件时,此参数填0,则表示此参数无效
        public byte                			byDay;                                          	// 出生日,作为查询条件时,此参数填0,则表示此参数无效
        public byte                			bImportantRank;                                 	// 人员重要等级,1~10,数值越高越重要,作为查询条件时,此参数填0,则表示此参数无效
        public byte                			bySex;                                          	// 性别,1-男,2-女,作为查询条件时,此参数填0,则表示此参数无效
        public byte[]                		szID = new byte[NET_MAX_PERSON_ID_LEN];             // ---人员唯一标示(身份证号码,工号,或其他编号)
        public short                		wFacePicNum;                                    	// 图片张数
        public NET_PIC_INFO[]         		szFacePicInfo = (NET_PIC_INFO[])new NET_PIC_INFO().toArray(NET_MAX_PERSON_IMAGE_NUM);  // 当前人员对应的图片信息
        public byte                			byType;                                         	// 人员类型,详见 EM_PERSON_TYPE
        public byte                			byIDType;                                       	// 证件类型,详见 EM_CERTIFICATE_TYPE
        public byte							byGlasses;											// 是否戴眼镜，0-未知 1-不戴 2-戴
        public byte                			byAge;												// 年龄,0表示未知
        public byte[]                		szProvince = new byte[NET_MAX_PROVINCE_NAME_LEN];   // 省份
        public byte[]                		szCity = new byte[NET_MAX_CITY_NAME_LEN];           // 城市
        public byte[]                		szUID = new byte[NET_MAX_PERSON_ID_LEN];            // ---人员唯一标识符,首次由服务端生成,区别于ID字段
        // 修改,删除操作时必填
        public byte[]						szCountry = new byte[NET_COUNTRY_LENGTH];			// 国籍,符合ISO3166规范
        public byte							byIsCustomType;										// 人员类型是否为自定义: 0 使用Type规定的类型 1 自定义,使用szCustomType字段
        public byte[]						szCustomType = new byte[NET_COMMON_STRING_16];	    // 人员自定义类型
        public byte[]						szComment = new byte[NET_COMMENT_LENGTH];			// ---备注信息
        public byte[]						szGroupID = new byte[NET_GROUPID_LENGTH];			// 人员所属组ID
        public byte[]						szGroupName = new byte[NET_GROUPNAME_LENGTH];		// ---人员所属组名, 用户自己申请内存的情况时,
        public int							emEmotion;											// 表情, 参考  EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE
        public byte[]						szHomeAddress = new byte[NET_COMMON_STRING_128];	// 注册人员家庭地址
        public int							emGlassesType;										// 眼镜类型, 参考 EM_GLASSES_TYPE
        public int							emRace;												// 肤色, 参考 EM_RACE_TYPE
        public int							emEye;												// 眼睛状态, 参考 EM_EYE_STATE_TYPE
        public int							emMouth;											// 嘴巴状态, 参考  EM_MOUTH_STATE_TYPE
        public int 							emMask;												// 口罩状态, 参考 EM_MASK_STATE_TYPE
        public int							emBeard;											// 胡子状态, 参考  EM_BEARD_STATE_TYPE
        public int							nAttractive;										// 魅力值, -1表示无效, 0未识别，识别时范围1-100,得分高魅力高
        public int							emFeatureState;										// 人员建模状态, 参考 EM_PERSON_FEATURE_STATE
        public int                			bAgeEnable;                     					// 是否指定年龄段, 1-true; 0-false
        public int[]                 		nAgeRange = new int[2];                  	 		// 年龄范围
        public int							nEmotionValidNum;               					// 人脸特征数组有效个数,与 emFeature 结合使用, 如果为0则表示查询所有表情
        public int[]    					emEmotions = new int[NET_MAX_FACEDETECT_FEATURE_NUM];// 人脸特征数组,与 byFeatureValidNum 结合使用  设置查询条件的时候使用, 参考 EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE
        public int                			nCustomPersonInfoNum;                                // 注册人员信息扩展个数
        public CUSTOM_PERSON_INFO[]         szCustomPersonInfo
                = (CUSTOM_PERSON_INFO[])new CUSTOM_PERSON_INFO().toArray(NET_MAX_CUSTOM_PERSON_INFO_NUM);  //注册人员信息扩展
        public int							emRegisterDbType;									// 注册库类型，详见EM_REGISTER_DB_TYPE
        public NET_TIME                     stuEffectiveTime;                           // 有效期时间
        public int                          emFeatureErrCode;                           // 建模失败原因
        public int    wFacePicNumEx;    // 人脸图片张数
        public NET_FACE_PIC_INFO[]    szFacePicInfoEx = (NET_FACE_PIC_INFO[])new NET_FACE_PIC_INFO().toArray(6);    // 当前人员对应的图片信息
        public NET_PERSON_FEATURE_VALUE_INFO    stuPersonFeatureValue;    // 人员特征信息
        public byte[]    byReserved = new byte[396];    // 保留字节
    }

    //注册人员信息扩展结构体
    public static class CUSTOM_PERSON_INFO extends SdkStructure
    {
        public byte[] 						szPersonInfo = new byte[NET_MAX_PERSON_INFO_LEN];   //人员扩展信息
        public byte[]                       byReserved = new byte[124];   						// 保留字节
    }

    // 人体测温温度单位
    public static class EM_HUMAN_TEMPERATURE_UNIT extends SdkStructure
    {
        public static final int EM_HUMAN_TEMPERATURE_UNKNOWN        = -1;   // 未知
        public static final int EM_HUMAN_TEMPERATURE_CENTIGRADE		= 0;	// 摄氏度
        public static final int EM_HUMAN_TEMPERATURE_FAHRENHEIT 	= 1;    // 华氏度
        public static final int EM_HUMAN_TEMPERATURE_KELVIN			= 2;	// 开尔文
    };

    // 人脸数据
    public static class NET_FACE_DATA extends SdkStructure
    {
        public int 				emSex;							// 性别, 参考 EM_DEV_EVENT_FACEDETECT_SEX_TYPE
        public int        		nAge;							// 年龄,-1表示该字段数据无效
        public int        		nFeatureValidNum;           	// 人脸特征数组有效个数,与 emFeature 结合使用
        public int[]    		emFeature = new int[NET_MAX_FACEDETECT_FEATURE_NUM];   // 人脸特征数组,与 nFeatureValidNum 结合使用, 参考 EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE
        public int				emRace;							// 肤色, 参考 EM_RACE_TYPE
        public int				emEye;							// 眼睛状态, 参考 EM_EYE_STATE_TYPE
        public int				emMouth;						// 嘴巴状态, 参考 EM_MOUTH_STATE_TYPE
        public int 				emMask;							// 口罩状态, 参考 EM_MASK_STATE_TYPE
        public int				emBeard;						// 胡子状态, 参考 EM_BEARD_STATE_TYPE
        public int				nAttractive;					// 魅力值, -1表示无效, 0未识别，识别时范围1-100,得分高魅力高
        public byte[]           bReserved1 = new byte[4];       // 保留字节
        public NET_EULER_ANGLE	stuFaceCaptureAngle;		    // 人脸在抓拍图片中的角度信息, nPitch:抬头低头的俯仰角, nYaw左右转头的偏航角, nRoll头在平面内左偏右偏的翻滚角
        // 角度值取值范围[-90,90], 三个角度值都为999表示此角度信息无效
        public int				nFaceQuality;				    // 人脸抓拍质量分数
        public int              nFaceAlignScore;                // 人脸对齐得分分数,范围 0~10000,-1为无效值
        public int              nFaceClarity;                   // 人脸清晰度分数,范围 0~10000,-1为无效值

        public double			dbTemperature;				    // 温度, bAnatomyTempDetect 为TRUE时有效
        public int			    bAnatomyTempDetect;			    // 是否人体测温
        public int              emTemperatureUnit;              // 温度单位, bAnatomyTempDetect 为TRUE时有效
        public boolean          bIsOverTemp;                    // 是否超温, bAnatomyTempDetect 为TRUE时有效
        public boolean          bIsUnderTemp;                   // 是否低温, bAnatomyTempDetect 为TRUE时有效
        public byte[]           bReserved = new byte[76];       // 保留字节,留待扩展.
    }

    //人脸检测对应性别类型
    public static class EM_DEV_EVENT_FACEDETECT_SEX_TYPE extends SdkStructure
    {
        public static final int EM_DEV_EVENT_FACEDETECT_SEX_TYPE_UNKNOWN = 0; //未知
        public static final int EM_DEV_EVENT_FACEDETECT_SEX_TYPE_MAN = 1; //男性
        public static final int EM_DEV_EVENT_FACEDETECT_SEX_TYPE_WOMAN = 2; //女性
    }

    //人脸检测对应人脸特征类型
    public static class EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE extends SdkStructure
    {
        public static final int EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_UNKNOWN = 0; //未知
        public static final int EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_WEAR_GLASSES = 1; //戴眼镜
        public static final int EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SMILE = 2; //微笑
        public static final int EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_ANGER = 3; //愤怒
        public static final int EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SADNESS = 4; //悲伤
        public static final int EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_DISGUST = 5; //厌恶
        public static final int EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_FEAR = 6; //害怕
        public static final int EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SURPRISE = 7; //惊讶
        public static final int EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_NEUTRAL = 8; //正常
        public static final int EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_LAUGH = 9; //大笑
        public static final int EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_NOGLASSES = 10; // 没戴眼镜
        public static final int EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_HAPPY = 11;	 // 高兴
        public static final int EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_CONFUSED = 12;	 // 困惑
        public static final int EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_SCREAM = 13;	 // 尖叫
        public static final int EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE_WEAR_SUNGLASSES = 14; // 戴太阳眼镜
    }

    // 肤色类型
    public static class EM_RACE_TYPE extends SdkStructure
    {
        public static final int EM_RACE_UNKNOWN = 0;
        public static final int EM_RACE_NODISTI = 1;
        public static final int EM_RACE_YELLOW = 2;
        public static final int EM_RACE_BLACK = 3;
        public static final int EM_RACE_WHITE = 4;
    }

    // 眼睛状态
    public static class EM_EYE_STATE_TYPE extends SdkStructure
    {
        public static final int EM_EYE_STATE_UNKNOWN = 0;		// 未知
        public static final int EM_EYE_STATE_NODISTI = 1;		// 未识别
        public static final int EM_EYE_STATE_CLOSE = 2;		    // 闭眼
        public static final int EM_EYE_STATE_OPEN = 3;			// 睁眼
    }

    // 嘴巴状态
    public static class EM_MOUTH_STATE_TYPE extends SdkStructure
    {
        public static final int EM_MOUTH_STATE_UNKNOWN = 0;		// 未知
        public static final int EM_MOUTH_STATE_NODISTI = 1;		// 未识别
        public static final int EM_MOUTH_STATE_CLOSE = 2;		// 闭嘴
        public static final int EM_MOUTH_STATE_OPEN = 3;		// 张嘴
    }

    // 口罩状态
    public static class EM_MASK_STATE_TYPE extends SdkStructure
    {
        public static final int EM_MASK_STATE_UNKNOWN = 0;		// 未知
        public static final int EM_MASK_STATE_NODISTI = 1;		// 未识别
        public static final int EM_MASK_STATE_NOMASK = 2;		// 没戴口罩
        public static final int EM_MASK_STATE_WEAR = 3;			// 戴口罩
    }

    // 胡子状态
    public static class EM_BEARD_STATE_TYPE extends SdkStructure
    {
        public static final int EM_BEARD_STATE_UNKNOWN = 0;		// 未知
        public static final int EM_BEARD_STATE__NODISTI = 1;	// 未识别
        public static final int EM_BEARD_STATE_NOBEARD = 2;		// 没胡子
        public static final int EM_BEARD_STATE_HAVEBEARD = 3;	// 有胡子
    }

    // 人员建模状态
    public static class EM_PERSON_FEATURE_STATE extends SdkStructure
    {
        public static final int EM_PERSON_FEATURE_UNKNOWN = 0;		// 未知
        public static final int EM_PERSON_FEATURE_FAIL = 1;			// 建模失败,可能是图片不符合要求,需要换图片
        public static final int EM_PERSON_FEATURE_USEFUL = 2;		// 有可用的特征值
        public static final int EM_PERSON_FEATURE_CALCULATING = 3;	// 正在计算特征值
        public static final int EM_PERSON_FEATURE_UNUSEFUL = 4;		// 已建模，但算法升级导致数据不可用，需要重新建模
    }

    // 事件文件的文件标签类型
    public static class EM_EVENT_FILETAG extends SdkStructure
    {
        public static final int NET_ATMBEFOREPASTE = 1; //ATM贴条前
        public static final int NET_ATMAFTERPASTE = 2;  //ATM贴条后
    }

    // 事件对应文件信息
    public static class NET_EVENT_FILE_INFO extends SdkStructure
    {
        public byte 		bCount;			// 当前文件所在文件组中的文件总数
        public byte 		bIndex;			// 当前文件在文件组中的文件编号(编号1开始)
        public byte 		bFileTag;		// 文件标签,具体说明见枚举类型 EM_EVENT_FILETAG
        public byte 		bFileType;		// 文件类型,0-普通1-合成2-抠图
        public NET_TIME_EX  stuFileTime;	// 文件时间
        public int 			nGroupId;		// 同一组抓拍文件的唯一标识

        @Override
        public String toString() {
            return "事件对应文件信息,NET_EVENT_FILE_INFO{" +
                    "bCount=" + bCount +
                    ", bIndex=" + bIndex +
                    ", bFileTag=" + bFileTag +
                    ", bFileType=" + bFileType +
                    ", stuFileTime=" + stuFileTime.toStringTime() +
                    ", nGroupId=" + nGroupId +
                    '}';
        }
    }

    // 多人脸检测信息
    public static class NET_FACE_INFO extends SdkStructure
    {
        public int 			nObjectID;						// 物体ID,每个ID表示一个唯一的物体
        public byte[] 		szObjectType = new byte[128];	// 物体类型
        public int 			nRelativeID;					// Relative与另一张图片ID相同,表示这张人脸抠图是从大图中取出的
        public DH_RECT 		BoundingBox;					// 包围盒
        public NET_POINT 	Center;							// 物体型心
    }

    public static class EM_FACE_DETECT_STATUS extends SdkStructure
    {
        public static final int EM_FACE_DETECT_UNKNOWN = 0; 	// 未知
        public static final int EM_FACE_DETECT_APPEAR = 1;  	//出现
        public static final int EM_FACE_DETECT_INPICTURE = 2;  	//在画面中
        public static final int EM_FACE_DETECT_EXIT = 3;  		//离开
    }

    // 姿态角数据
    public static class NET_EULER_ANGLE extends SdkStructure
    {
        public int 			nPitch;	// 仰俯角
        public int 			nYaw;	// 偏航角
        public int 			nRoll;	// 翻滚角
    }

    //事件类型EVENT_IVS_FACEDETECT(人脸检测事件)对应的数据块描述信息
    public static class DEV_EVENT_FACEDETECT_INFO extends SdkStructure
    {
        public int 						nChannelID;					// 通道号
        public byte[] 					szName = new byte[128];		// 事件名称
        public byte[] 					bReserved1 = new byte[4];	// 字节对齐
        public double 					PTS;						// 时间戳(单位是毫秒)
        public NET_TIME_EX  			UTC;						// 事件发生的时间
        public int 						nEventID;					// 事件ID
        public NET_MSG_OBJECT 			stuObject;					// 检测到的物体
        public NET_EVENT_FILE_INFO  	stuFileInfo;				// 事件对应文件信息
        public byte 					bEventAction;				// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[] 					reserved = new byte[2];		// 保留字节
        public byte 					byImageIndex;				// 图片的序号,同一时间内(精确到秒)可能有多张图片,从0开始
        public int 						nDetectRegionNum;			// 规则检测区域顶点数
        public NET_POINT[] 				DetectRegion = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM);// 规则检测区域
        public int 						dwSnapFlagMask;				// 抓图标志(按位),具体见NET_RESERVED_COMMON
        public byte[] 					szSnapDevAddress = new byte[MAX_PATH];// 抓拍当前人脸的设备地址,如：滨康路37号
        public int 						nOccurrenceCount;			// 事件触发累计次数, 类型为unsigned int
        public int 						emSex;						// 性别, 取值为EM_DEV_EVENT_FACEDETECT_SEX_TYPE中的值
        public int 						nAge;						// 年龄,-1表示该字段数据无效
        public int 						nFeatureValidNum;			//人脸特征数组有效个数,与emFeature结合使用, 类型为unsigned int
        public int[] 					emFeature = new int[NET_MAX_FACEDETECT_FEATURE_NUM];		// 人脸特征数组,与nFeatureValidNum, 取值为EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE中的值
        public int 						nFacesNum;					// 指示stuFaces有效数量
        public NET_FACE_INFO[] 			stuFaces = (NET_FACE_INFO[])new NET_FACE_INFO().toArray(10);// 多张人脸时使用,此时没有Object
        public EVENT_INTELLI_COMM_INFO  stuIntelliCommInfo;			// 智能事件公共信息
        public int 						emRace;					    // 肤色
        public int 						emEye;					    // 眼睛状态
        public int 						emMouth;					// 嘴巴状态
        public int  					emMask;						// 口罩状态
        public int 						emBeard;					// 胡子状态
        public int 						nAttractive;			    // 魅力值, -1表示无效, 0未识别，识别时范围1-100,得分高魅力高
        public byte[] 					szUID = new byte[NET_COMMON_STRING_32];			// 抓拍人员写入数据库的唯一标识符

        public byte[]                   bReserved2 = new byte[4];	        // 保留字节
        public NET_FEATURE_VECTOR		stuFeatureVector;					// 特征值信息
        public byte[]				    szFeatureVersion = new byte[32];				// 特征值算法版本
        public int						emFaceDetectStatus;                 // 人脸在摄像机画面中的状态 ，参考EM_FACE_DETECT_STATUS
        public NET_EULER_ANGLE			stuFaceCaptureAngle;				// 人脸在抓拍图片中的角度信息, nPitch:抬头低头的俯仰角, nYaw左右转头的偏航角, nRoll头在平面内左偏右偏的翻滚角
        // 角度值取值范围[-90,90], 三个角度值都为999表示此角度信息无效
        public int						nFaceQuality;

        public byte[] 					bReserved = new byte[652];	// 保留字节,留待扩展
    }

    // 事件类型EVENT_IVS_TRAFFICJAM(交通拥堵事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFICJAM_INFO extends SdkStructure {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                     // 事件名称
        public byte[]              bReserved1 = new byte[4];                   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public int                 nLane;                                      // 对应车道号
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte                bJamLenght;                                 // 表示拥堵长度(总车道长度百分比）0-100
        public byte                reserved;                                   // 保留字节
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public NET_TIME_EX         stuStartJamTime;                            // 开始停车时间
        public int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束(bEventAction=2时此参数有效)
        public int                 nAlarmIntervalTime;                         // 报警时间间隔,单位:秒。(此事件为连续性事件,在收到第一个此事件之后,若在超过间隔时间后未收到此事件的后续事件,则认为此事件异常结束了)
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public int                 nJamRealLength;                             // 表实际的拥堵长度,单位米
        public byte[]              bReserved = new byte[1008];                 // 保留字节,留待扩展.
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    }

    // 车辆行驶方向
    public static class NET_FLOWSTAT_DIRECTION extends SdkStructure
    {
        public static final int DRIVING_DIR_UNKNOW   = 0 ;     //兼容之前
        public static final int DRIVING_DIR_APPROACH = 1 ;     //上行,即车辆离设备部署点越来越近
        public static final int DRIVING_DIR_LEAVE    = 2 ;     //下行,即车辆离设备部署点越来越远
    }

    //车辆流量统计车辆行驶方向信息
    public static class NET_TRAFFIC_FLOWSTAT_INFO_DIR extends SdkStructure
    {
        public int                         emDrivingDir;      //行驶方向 (参见NET_FLOWSTAT_DIRECTION)
        public byte[]                      szUpGoing = new byte[FLOWSTAT_ADDR_NAME];      //上行地点
        public byte[]                      szDownGoing = new byte[FLOWSTAT_ADDR_NAME];    //下行地点
        public byte[]                      reserved= new byte[32];                       //保留字节

    }

    public static class NET_TRAFFIC_JAM_STATUS extends SdkStructure
    {
        public static final int JAM_STATUS_UNKNOW = 0; //未知
        public static final int JAM_STATUS_CLEAR  = 1; //通畅
        public static final int JAM_STATUS_JAMMED = 2; //拥堵
    }


    public static class  NET_TRAFFIC_FLOW_STATE  extends SdkStructure
    {
        public int                             nLane;                          // 车道号
        public int                             dwState;                        // 状态值
        // 1- 流量过大
        // 2- 流量过大恢复
        // 3- 正常
        // 4- 流量过小
        // 5- 流量过小恢复
        public int                             dwFlow;                         // 流量值, 单位: 辆
        public int                             dwPeriod;                       // 流量值对应的统计时间
        public NET_TRAFFIC_FLOWSTAT_INFO_DIR   stTrafficFlowDir;               // 车道方向信息
        public int                             nVehicles;                      // 通过车辆总数
        public float                           fAverageSpeed;                  // 平均车速,单位km/h
        public float                           fAverageLength;                 // 平均车长,单位米
        public float                           fTimeOccupyRatio;               // 时间占有率,即单位时间内通过断面的车辆所用时间的总和占单位时间的比例
        public float                           fSpaceOccupyRatio;              // 空间占有率,即按百分率计量的车辆长度总和除以时间间隔内车辆平均行驶距离
        public float                           fSpaceHeadway;                  // 车头间距,相邻车辆之间的距离,单位米/辆
        public float                           fTimeHeadway;                   // 车头时距,单位秒/辆
        public float                           fDensity;                       // 车辆密度,每公里的车辆数,单位辆/km
        public int                             nOverSpeedVehicles;             // 超速车辆数
        public int                             nUnderSpeedVehicles;            // 低速车辆数
        public int                             nLargeVehicles;                 // 大车交通量(9米<车长<12米),辆/单位时间
        public int                             nMediumVehicles;                // 中型车交通量(6米<车长<9米),辆/单位时间
        public int                             nSmallVehicles;                 // 小车交通量(4米<车长<6米),辆/单位时间,
        public int                             nMotoVehicles;                  // 摩托交通量(微型车,车长<4米),辆/单位时间,
        public int                             nLongVehicles;                  // 超长交通量(车长>=12米),辆/单位时间,
        public int                             nVolume;                        // 交通量, 辆/单位时间, 某时间间隔通过车道、道路或其他通道上一点的车辆数,常以1小时计,
        public int                             nFlowRate;                      // 流率小车当量,辆/小时, 车辆通过车道、道路某一断面或某一路段的当量小时流量
        public int                             nBackOfQueue;                   // 排队长度,单位：米, 从信号交叉口停车线到上游排队车辆末端之间的距离
        public int                             nTravelTime;                    // 旅行时间,单位：秒, 车辆通过某一条道路所用时间。包括所有停车延误
        public int                             nDelay;                         // 延误,单位：秒,驾驶员、乘客或行人花费的额外的行程时间
        public byte[]                          byDirection = new byte[MAX_DRIVING_DIR_NUM]; // 车道方向,详见NET_ROAD_DIRECTION
        public byte                            byDirectionNum;                 // 车道行驶方向个数
        public byte[]                          reserved1 = new byte[3];        // 字节对齐
        public int          				   emJamState;                     // 道路拥挤状况 (参见 NET_TRAFFIC_JAM_STATUS )
        //  按车辆类型统计交通量
        public int                             nPassengerCarVehicles;          // 客车交通量(辆/单位时间)
        public int                             nLargeTruckVehicles;            // 大货车交通量(辆/单位时间)
        public int                             nMidTruckVehicles;              // 中货车交通量(辆/单位时间)
        public int                             nSaloonCarVehicles;             // 轿车交通量(辆/单位时间)
        public int                             nMicrobusVehicles;              // 面包车交通量(辆/单位时间)
        public int                             nMicroTruckVehicles;            // 小货车交通量(辆/单位时间)
        public int                             nTricycleVehicles;              // 三轮车交通量(辆/单位时间)
        public int                             nMotorcycleVehicles;            // 摩托车交通量(辆/单位时间)
        public int                             nPasserbyVehicles;              // 行人交通量(辆/单位时间)
        public int							   emRank;						   // 道路等级, 参考  NET_TRAFFIC_ROAD_RANK
        public int							   nState;						   // 流量状态
        // 1- 流量过大(拥堵)
        // 2- 流量过大恢复(略堵)
        // 3- 正常
        // 4- 流量过小(通畅)
        // 5- 流量过小恢复(良好)
        public int                            bOccupyHeadCoil;                 // 车头虚拟线圈是否被占用 TURE表示占用，FALSE表示未占用
        public int                            bOccupyTailCoil;                 // 车尾虚拟线圈是否被占用 TURE表示占用，FALSE表示未占用
        public int                            bStatistics;                     // 流量数据是否有效 TURE表示有效，FALSE表示无效

        public int							  nLeftVehicles;				   // 左转车辆总数,单位:分钟
        public int							  nRightVehicles;				   // 右转车辆总数,单位:分钟
        public int							  nStraightVehicles;			   // 直行车辆总数,单位:分钟
        public int							  nUTurnVehicles;				   // 掉头车辆总数,单位:分钟
        public NET_POINT                      stQueueEnd;                      // 每个车道的最后一辆车坐标,采用8192坐标系
        public double						  dBackOfQueue;					   // 排队长度,单位：米, 从信号交叉口停车线到上游排队车辆末端之间的距离
        public int							  dwPeriodByMili;				   // 流量值的毫秒时间,值不超过60000,和dwPeriod一起使用,流量值总时间:dwPeriod*60*1000+dwPeriodByMili(单位：毫秒)
        public int							  nBusVehicles;					   // 公交车交通量(辆/单位时间)
        public int							  nMPVVehicles;					   // MPV交通量(辆/单位时间)
        public int							  nMidPassengerCarVehicles;		   // 中客车交通量(辆/单位时间)
        public int							  nMiniCarriageVehicles;		   // 微型轿车交通量(辆/单位时间)
        public int							  nOilTankTruckVehicles;		   // 油罐车交通量(辆/单位时间)
        public int							  nPickupVehicles;				   // 皮卡车交通量(辆/单位时间)
        public int							  nSUVVehicles;					   // SUV交通量(辆/单位时间)
        public int							  nSUVorMPVVehicles;			   // SUV或者MPV交通量(辆/单位时间)
        public int							  nTankCarVehicles;				   // 槽罐车交通量(辆/单位时间)
        public int							  nUnknownVehicles;				   // 未知车辆交通量(辆/单位时间)
        public byte[]                         reserved = new byte[724];        // 保留字节
    }

    //事件类型 EVENT_IVS_TRAFFIC_FLOWSTATE(交通流量事件)对应数据块描述信息
    public static class DEV_EVENT_TRAFFIC_FLOW_STATE extends SdkStructure
    {
        public int                       nChannelID;                             // 通道号
        public byte[]                    szName = new byte[NET_EVENT_NAME_LEN];  // 事件名称
        public byte[]                    bReserved1 = new byte[8];               // 字节对齐
        public int                       PTS;                                    // 时间戳(单位是毫秒)
        public NET_TIME_EX               UTC;                                    // 事件发生的时间
        public int                       nEventID;                               // 事件ID
        public int                       nSequence;                              // 序号
        public int                       nStateNum;                              // 流量状态数量
        public NET_TRAFFIC_FLOW_STATE[]  stuStates = (NET_TRAFFIC_FLOW_STATE[])new NET_TRAFFIC_FLOW_STATE().toArray(NET_MAX_LANE_NUM);             // 流量状态, 每个车道对应数组中一个元素
        public EVENT_INTELLI_COMM_INFO   stuIntelliCommInfo;                 	 // 智能事件公共信息
        public byte[]                    bReserved = new byte[892];              // 保留字节
    }

    // 图片分辨率
    public static class NET_RESOLUTION_INFO extends SdkStructure
    {
        public short snWidth;//宽
        public short snHight;//高

        @Override
        public String toString() {
            return "NET_RESOLUTION_INFO{" +
                    "宽=" + snWidth +
                    ",高=" + snHight +
                    '}';
        }
    }

    public static class EM_COMMON_SEAT_TYPE extends SdkStructure
    {
        public static final int COMMON_SEAT_TYPE_UNKNOWN = 0;//未识别
        public static final int COMMON_SEAT_TYPE_MAIN = 1;//主驾驶
        public static final int COMMON_SEAT_TYPE_SLAVE = 2;//副驾驶
    }

    // 违规状态
    public static class EVENT_COMM_STATUS extends SdkStructure
    {
        public byte bySmoking;//是否抽烟
        public byte byCalling;//是否打电话
        public byte[] szReserved = new byte[14];//预留字段
    }

    public static class NET_SAFEBELT_STATE extends SdkStructure
    {
        public static final int SS_NUKNOW = 0;//未知
        public static final int SS_WITH_SAFE_BELT = 1;//已系安全带
        public static final int SS_WITHOUT_SAFE_BELT = 2;//未系安全带
    }

    //遮阳板状态
    public static class NET_SUNSHADE_STATE extends SdkStructure
    {
        public static final int SS_NUKNOW_SUN_SHADE = 0;//未知
        public static final int SS_WITH_SUN_SHADE = 1;//有遮阳板
        public static final int SS_WITHOUT_SUN_SHADE = 2;//无遮阳板
    }

    // 驾驶位违规信息
    public static class EVENT_COMM_SEAT extends SdkStructure
    {
        public int bEnable;//是否检测到座驾信息, 类型BOOL, 取值0或者1
        public int emSeatType;//座驾类型,0:未识别;1:主驾驶; 取值为EM_COMMON_SEAT_TYPE中的值
        public EVENT_COMM_STATUS stStatus;//违规状态
        public int emSafeBeltStatus;//安全带状态, 取值为NET_SAFEBELT_STATE中的值
        public int emSunShadeStatus;//遮阳板状态, 取值为NET_SUNSHADE_STATE中的值
        public byte[] szReserved = new byte[24];//预留字节
    }

    // 车辆物件
    public static class EVENT_COMM_ATTACHMENT extends SdkStructure
    {
        public int emAttachmentType;//物件类型, 取值为EM_COMM_ATTACHMENT_TYPE中的值
        public NET_RECT stuRect;//坐标
        public byte[] bReserved = new byte[20];//预留字节
    }

    //NTP校时状态
    public static class EM_NTP_STATUS extends SdkStructure
    {
        public static final int NET_NTP_STATUS_UNKNOWN = 0;
        public static final int NET_NTP_STATUS_DISABLE = 1;
        public static final int NET_NTP_STATUS_SUCCESSFUL = 2;
        public static final int NET_NTP_STATUS_FAILED = 3;
    }

    // 交通抓图图片信息
    public static class EVENT_PIC_INFO extends SdkStructure
    {
        public int                       nOffset;                // 原始图片偏移，单位字节
        public int                       nLength;                // 原始图片长度，单位字节
    }

    public static class EVENT_COMM_INFO extends SdkStructure
    {
        public int 						emNTPStatus;					// NTP校时状态, 取值为EM_NTP_STATUS中的值
        public int 						nDriversNum;					// 驾驶员信息数
        public Pointer 					pstDriversInfo;					// 驾驶员信息数据，类型为 NET_MSG_OBJECT_EX*
        public Pointer 					pszFilePath;					// 本地硬盘或者sd卡成功写入路径,为NULL时,路径不存在， 类型为char *
        public Pointer 					pszFTPPath;						// 设备成功写到ftp服务器的路径， 类型为char *
        public Pointer 					pszVideoPath;					// 当前接入需要获取当前违章的关联视频的FTP上传路径， 类型为char *
        public EVENT_COMM_SEAT[] 		stCommSeat = (EVENT_COMM_SEAT[])new EVENT_COMM_SEAT().toArray(COMMON_SEAT_MAX_NUMBER);// 驾驶位信息
        public int 						nAttachmentNum;					// 车辆物件个数
        public EVENT_COMM_ATTACHMENT[]  stuAttachment = (EVENT_COMM_ATTACHMENT[])new EVENT_COMM_ATTACHMENT().toArray(NET_MAX_ATTACHMENT_NUM);//车辆物件信息
        public int 						nAnnualInspectionNum;			// 年检标志个数
        public NET_RECT[] 				stuAnnualInspection = (NET_RECT[])new NET_RECT().toArray(NET_MAX_ANNUUALINSPECTION_NUM);//年检标志
        public float 					fHCRatio; 						// HC所占比例，单位：%
        public float 					fNORatio; 						// NO所占比例，单位：%
        public float 					fCOPercent; 					// CO所占百分比，单位：% 取值0~100
        public float 					fCO2Percent; 					// CO2所占百分比，单位：% 取值0~100
        public float 					fLightObscuration; 				// 不透光度，单位：% 取值0~100
        public int 						nPictureNum;					// 原始图片张数
        public EVENT_PIC_INFO[] 		stuPicInfos = (EVENT_PIC_INFO[])new EVENT_PIC_INFO().toArray(NET_MAX_EVENT_PIC_NUM);// 原始图片信息
        public float 					fTemperature;                   // 温度值,单位摄氏度
        public int 						nHumidity;                      // 相对湿度百分比值
        public float 					fPressure;                      // 气压值,单位Kpa
        public float 					fWindForce;                     // 风力值,单位m/s
        public int 						nWindDirection;                 // 风向,单位度,范围:[0,360]
        public float 					fRoadGradient;                  // 道路坡度值,单位度
        public float 					fAcceleration;                  // 加速度值,单位:m/s2
        public NET_RFIDELETAG_INFO		stuRFIDEleTagInfo;				// RFID 电子车牌标签信息
        public EVENT_PIC_INFO           stuBinarizedPlateInfo;          // 二值化车牌抠图
        public EVENT_PIC_INFO           stuVehicleBodyInfo;             // 车身特写抠图
        public int            			emVehicleTypeInTollStation;     // 收费站车型分类,详见EM_VEHICLE_TYPE
        public int             			emSnapCategory;                 // 抓拍的类型，默认为机动车,详见EM_SNAPCATEGORY
        public int                      nRegionCode;                    // 车牌所属地区代码,(孟加拉海外车牌识别项目),默认-1表示未识别
        public int                      emVehicleTypeByFunc;            // 按功能划分的车辆类型，详见EM_VEHICLE_TYPE_BY_FUNC
        public int                      emStandardVehicleType;          // 标准车辆类型，详见EM_STANDARD_VEHICLE_TYPE
        public int                      nExtraPlateCount;               // 额外车牌数量
        public byte[]                   szExtraPlateNumer = new byte[3*32];  // 额外车牌信息
        public byte[]                   bReserved = new byte[568];      // 预留字节
        public byte[] 					szCountry = new byte[20];		// 国家
    }

    //收费站车型分类
    public static class EM_VEHICLE_TYPE extends SdkStructure
    {
        public static final int EM_VEHICLE_TYPE_UNKNOWN = 0;                            // 未知
        public static final int EM_VEHICLE_TYPE_PASSENGERCAR1 = 1;                      // 客1
        public static final int EM_VEHICLE_TYPE_TRUCK1 = 2;                             // 货1
        public static final int EM_VEHICLE_TYPE_PASSENGERCAR2 = 3;                     	// 客2
        public static final int EM_VEHICLE_TYPE_TRUCK2 = 4;                             // 货2
        public static final int EM_VEHICLE_TYPE_PASSENGERCAR3 = 5;                      // 客3
        public static final int EM_VEHICLE_TYPE_TRUCK3 = 6;                             // 货3
        public static final int EM_VEHICLE_TYPE_PASSENGERCAR4 = 7;                      // 客4
        public static final int EM_VEHICLE_TYPE_TRUCK4 = 8;                             // 货4
        public static final int EM_VEHICLE_TYPE_PASSENGERCAR5 = 9;                      // 客5
        public static final int EM_VEHICLE_TYPE_TRUCK5 = 10;                            // 货5
    }

    //抓拍的类型
    public static class EM_SNAPCATEGORY extends SdkStructure
    {
        public static final int EM_SNAPCATEGORY_MOTOR = 0;     						// 机动车
        public static final int EM_SNAPCATEGORY_NONMOTOR = 1;                       // 非机动车
    }

    // RFID 电子车牌标签信息
    public static class NET_RFIDELETAG_INFO extends SdkStructure
    {
        public byte[]					szCardID = new byte[MAX_RFIDELETAG_CARDID_LEN];	// 卡号
        public int						nCardType;										// 卡号类型, 0:交通管理机关发行卡, 1:新车出厂预装卡
        public int						emCardPrivince;									// 卡号省份, 对应   EM_CARD_PROVINCE
        public byte[]					szPlateNumber = new byte[NET_MAX_PLATE_NUMBER_LEN];			// 车牌号码
        public byte[]					szProductionDate = new byte[MAX_RFIDELETAG_DATE_LEN];		// 出厂日期
        public int						emCarType;										// 车辆类型, 对应  EM_CAR_TYPE
        public int						nPower;											// 功率,单位：千瓦时，功率值范围0~254；255表示该车功率大于可存储的最大功率值
        public int						nDisplacement;									// 排量,单位：百毫升，排量值范围0~254；255表示该车排量大于可存储的最大排量值
        public int						nAntennaID;										// 天线ID，取值范围:1~4
        public int						emPlateType;									// 号牌种类, 对应  EM_PLATE_TYPE
        public byte[]					szInspectionValidity = new byte[MAX_RFIDELETAG_DATE_LEN];	// 检验有效期，年-月
        public int						nInspectionFlag;								// 逾期未年检标志, 0:已年检, 1:逾期未年检
        public int						nMandatoryRetirement;							// 强制报废期，从检验有效期开始，距离强制报废期的年数
        public int						emCarColor;										// 车身颜色, 对应  EM_CAR_COLOR_TYPE
        public int						nApprovedCapacity;								// 核定载客量，该值<0时：无效；此值表示核定载客，单位为人
        public int						nApprovedTotalQuality;							// 此值表示总质量，单位为百千克；该值<0时：无效；该值的有效范围为0~0x3FF，0x3FF（1023）表示数据值超过了可存储的最大值
        public NET_TIME_EX				stuThroughTime;									// 过车时间
        public int						emUseProperty;									// 使用性质, 对应  EM_USE_PROPERTY_TYPE
        public byte[]					szPlateCode = new byte[MAX_COMMON_STRING_8];	// 发牌代号，UTF-8编码
        public byte[]					szPlateSN = new byte[MAX_COMMON_STRING_16];		// 号牌号码序号，UTF-8编码
        public byte[]                   szTID = new byte[MAX_COMMON_STRING_64];  		// 标签(唯一标识), UTF-8编码
        public byte[]               	bReserved = new byte[40];		                // 保留字节,留待扩展.
    }

    // 车检器冗余信息
    public static class NET_SIG_CARWAY_INFO_EX extends SdkStructure
    {
        public byte[] byRedundance = new byte[8];//由车检器产生抓拍信号冗余信息
        public byte[] bReserved = new byte[120];//保留字段
    }

    // 颜色RGBA
    public static class NET_COLOR_RGBA extends SdkStructure
    {
        public int nRed;//红
        public int nGreen;//绿
        public int nBlue;//蓝
        public int nAlpha;//透明

        public String toString() {
            return "[" + nRed + " " + nGreen + " " + nBlue + " " + nAlpha + "]";
        }
    }

    // TrafficCar 交通车辆信息
    public static class DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO extends SdkStructure
    {
        public byte[] 			szPlateNumber = new byte[32];	//车牌号码
        public byte[] 			szPlateType = new byte[32];		//号牌类型参见VideoAnalyseRule中车牌类型定义
        public byte[] 			szPlateColor = new byte[32];	//车牌颜色"Blue","Yellow",
        public byte[] 			szVehicleColor = new byte[32];	//车身颜色"White",
        public int 				nSpeed;							//速度单位Km/H
        public byte[] 			szEvent = new byte[64];			//触发的相关事件参见事件列表Event
        public byte[] 			szViolationCode = new byte[32]; //违章代码详见TrafficGlobal.ViolationCode
        public byte[] 			szViolationDesc = new byte[64]; //违章描述
        public int 				nLowerSpeedLimit;				//速度下限
        public int 				nUpperSpeedLimit;				//速度上限
        public int 				nOverSpeedMargin;				//限高速宽限值单位：km/h
        public int 				nUnderSpeedMargin;				//限低速宽限值单位：km/h
        public int 				nLane;							//车道参见事件列表EventList中卡口和路口事件。
        public int 				nVehicleSize;					//车辆大小,-1表示未知,否则按位
        // 第0位:"Light-duty", 小型车
        // 第1位:"Medium", 中型车
        // 第2位:"Oversize", 大型车
        // 第3位:"Minisize", 微型车
        // 第4位:"Largesize", 长车
        public float 			fVehicleLength;					// 车辆长度单位米
        public int 				nSnapshotMode;					// 抓拍方式0-未分类,1-全景,2-近景,4-同向抓拍,8-反向抓拍,16-号牌图像
        public byte[] 			szChannelName = new byte[32];	// 本地或远程的通道名称,可以是地点信息来源于通道标题配置ChannelTitle.Name
        public byte[] 			szMachineName = new byte[256];	// 本地或远程设备名称来源于普通配置General.MachineName
        public byte[] 			szMachineGroup = new byte[256]; // 机器分组或叫设备所属单位默认为空,用户可以将不同的设备编为一组,便于管理,可重复。
        public byte[] 			szRoadwayNo = new byte[64];		// 道路编号
        public byte[] 			szDrivingDirection = new byte[3*NET_MAX_DRIVINGDIRECTION];//
        // 行驶方向 , "DrivingDirection" : ["Approach", "上海", "杭州"],
        // "Approach"-上行,即车辆离设备部署点越来越近；"Leave"-下行,
        // 即车辆离设备部署点越来越远,第二和第三个参数分别代表上行和
        // 下行的两个地点
        public Pointer 			szDeviceAddress;				// 设备地址,OSD叠加到图片上的,来源于配 置TrafficSnapshot.DeviceAddress,'\0'结束
        public byte[] 			szVehicleSign = new byte[32];	// 车辆标识,例如
        public NET_SIG_CARWAY_INFO_EX stuSigInfo;				// 由车检器产生抓拍信号冗余信息
        public Pointer 			szMachineAddr;					// 设备部署地点
        public float 			fActualShutter;					// 当前图片曝光时间,单位为毫秒
        public byte 			byActualGain;					// 当前图片增益,范围为0~100
        public byte 			byDirection;					// 车道方向,0-南向北1-西南向东北2-西向东
        public byte[] 			byReserved = new byte[2];
        public Pointer 			szDetailedAddress;				// 详细地址,作为szDeviceAddress的补充
        public byte[] 			szDefendCode = new byte[NET_COMMON_STRING_64];//图片防伪码
        public int 				nTrafficBlackListID;			// 关联黑名单数据库记录默认主键ID,0,无效；>0,黑名单数据记录
        public NET_COLOR_RGBA 	stuRGBA;						// 车身颜色RGBA
        public NET_TIME 		stSnapTime;						// 抓拍时间
        public int 				nRecNo;							// 记录编号
        public byte[] 			szCustomParkNo= new byte[NET_COMMON_STRING_32+1];// 自定义车位号（停车场用）
        public byte[] 			byReserved1 = new byte[3];
        public int 				nDeckNo;						// 车板位号
        public int 				nFreeDeckCount;					// 空闲车板数量
        public int 				nFullDeckCount;					// 占用车板数量
        public int 				nTotalDeckCount;				// 总共车板数量
        public byte[] 			szViolationName = new byte[64]; // 违章名称
        public int 				nWeight;						// 车重(单位Kg), 类型为unsigned int

        public byte[]      		szCustomRoadwayDirection = new byte[32];// 自定义车道方向,byDirection为9时有效
        public byte        		byPhysicalLane; 				// 物理车道号,取值0到5
        public byte[]      		byReserved2 = new byte[3];
        public int 		   		emMovingDirection; 				// 车辆行驶方向 EM_TRAFFICCAR_MOVE_DIRECTION
        public NET_TIME			stuEleTagInfoUTC;			    // 对应电子车牌标签信息中的过车时间(ThroughTime)
        public NET_RECT		    stuCarWindowBoundingBox;		// 车窗包围盒，0~8191
        public NET_TRAFFICCAR_WHITE_LIST    stuWhiteList;       // 白名单信息
        public int      		emCarType;                  	// 车辆类型, 详见 EM_TRAFFICCAR_CAR_TYPE
        public int     			emLaneType;                 	// 车道类型, 详见EM_TRAFFICCAR_LANE_TYPE
        public byte[]           szVehicleBrandYearText = new byte[64];  // 车系年款翻译后文本内容
        public byte[]           szCategory = new byte[32];      // 车辆子类型
        public NET_TRAFFICCAR_BLACK_LIST	stuBlackList;		// 黑名单信息
        public byte[]      		bReserved = new byte[240]; 		// 保留字节,留待扩展.
    }

    // 黑名单信息
    public static class NET_TRAFFICCAR_BLACK_LIST extends SdkStructure
    {
        public int                          bEnable;					// 是否已启用黑名单
        public int						    bIsBlackCar;				// 车牌是否属于黑名单
        public NET_TIME                     stuBeginTime;				// 黑名单起始时间
        public NET_TIME                     stuCancelTime;			    // 黑名单过期时间
        public byte[]                       bReserved = new byte[32];	// 保留字节
    }

    // 车辆类型
    public static class EM_TRAFFICCAR_CAR_TYPE extends SdkStructure
    {
        public static final int EM_TRAFFICCAR_CAR_TYPE_UNKNOWN = 0;     	// 未知
        public static final int EM_TRAFFICCAR_CAR_TYPE_TRUST_CAR = 1;       // 白名单车辆
        public static final int EM_TRAFFICCAR_CAR_TYPE_SUSPICIOUS_CAR = 2;  // 黑名单车辆
        public static final int EM_TRAFFICCAR_CAR_TYPE_NORMAL_CAR = 3;      // 非白名单且非黑名单车辆
    }

    // 车道类型
    public static class EM_TRAFFICCAR_LANE_TYPE extends SdkStructure
    {
        public static final int EM_TRAFFICCAR_LANE_TYPE_UNKNOWN      = 0;   // 未知
        public static final int EM_TRAFFICCAR_LANE_TYPE_NORMAL       = 1;   // 普通车道
        public static final int EM_TRAFFICCAR_LANE_TYPE_NONMOTOR     = 2;   // 非机动车车道
        public static final int EM_TRAFFICCAR_LANE_TYPE_LIGHT_DUTY   = 3;   // 小型车车道
        public static final int EM_TRAFFICCAR_LANE_TYPE_BUS          = 4;   // 公交车车道
        public static final int EM_TRAFFICCAR_LANE_TYPE_EMERGENCY    = 5;   // 应急车道
        public static final int EM_TRAFFICCAR_LANE_TYPE_DANGEROUS    = 6;   // 危险品车道
    }

    // 白名单信息
    public static class NET_TRAFFICCAR_WHITE_LIST extends SdkStructure
    {
        public int                            bTrustCar;               // 车牌是否属于白名单
        public NET_TIME                       stuBeginTime;            // 白名单起始时间
        public NET_TIME                       stuCancelTime;           // 白名单过期时间
        public NET_WHITE_LIST_AUTHORITY_LIST  stuAuthorityList;        // 白名单权限列表
        public byte[]      					  bReserved = new byte[32];// 保留字节
    }

    // 白名单权限列表
    public static class NET_WHITE_LIST_AUTHORITY_LIST extends SdkStructure
    {
        public int              bOpenGate;                      // 是否有开闸权限
        public byte[]      		bReserved = new byte[16]; 		// 保留字节
    }

    // 事件类型EVENT_IVS_TRAFFIC_PARKING(交通违章停车事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_PARKING_INFO extends SdkStructure
    {
        public int nChannelID;//通道号
        public byte[] szName = new byte[128];//事件名称
        public byte[] bReserved1 = new byte[4];//字节对齐
        public double PTS;//时间戳(单位是毫秒)
        public NET_TIME_EX UTC;//事件发生的时间
        public int nEventID;//事件ID
        public NET_MSG_OBJECT stuObject;//检测到的物体
        public NET_MSG_OBJECT stuVehicle;//车身信息
        public int nLane;//对应车道号
        public NET_EVENT_FILE_INFO stuFileInfo;//事件对应文件信息
        public byte bEventAction;//事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[] reserved = new byte[2];//保留字节
        public byte byImageIndex;//图片的序号,同一时间内(精确到秒)可能有多张图片,从0开始
        public NET_TIME_EX stuStartParkingTime;//开始停车时间
        public int nSequence;//表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束(bEventAction=2时此参数有效)
        public int nAlarmIntervalTime;//报警时间间隔,单位:秒。(此事件为连续性事件,在收到第一个此事件之后,若在超过间隔时间后未收到此事件的后续事件,则认为此事件异常结束了)
        public int nParkingAllowedTime;//允许停车时长,单位：秒。
        public int nDetectRegionNum;//规则检测区域顶点数
        public NET_POINT[] DetectRegion = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM);//规则检测区域
        public int dwSnapFlagMask;//抓图标志(按位),具体见NET_RESERVED_COMMON
        public NET_RESOLUTION_INFO stuResolution;//对应图片的分辨率
        public int bIsExistAlarmRecord;//true:有对应的报警录像;false:无对应的报警录像, 类型为BOOL, 取值为0或1
        public int dwAlarmRecordSize;//录像大小
        public byte[] szAlarmRecordPath = new byte[NET_COMMON_STRING_256];//录像路径
        public byte[] szFTPPath = new byte[NET_COMMON_STRING_256];//FTP路径
        public EVENT_INTELLI_COMM_INFO stuIntelliCommInfo;//智能事件公共信息
        public byte byPreAlarm;	// 是否为违章预警图片,0 违章停车事件1 预警事件(预警触发后一定时间，车辆还没有离开，才判定为违章)由于此字段会导致事件含义改变，必须和在平台识别预警事件后，才能有此字段,
        public byte[]  bReserved2 = new byte[3]; // 保留字节,留待扩展.
        public NET_GPS_INFO stuGPSInfo;   // GPS信息 车载定制
        public byte[] bReserved = new byte[228];//保留字节,留待扩展.
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;//交通车辆信息
        public EVENT_COMM_INFO stCommInfo;//公共信息
        public VA_OBJECT_NONMOTOR  stuNonMotor;                                // 非机动车对象
        public boolean             bHasNonMotor;                               // 是否有非机动车对象
    }

    //停车场信息
    public static class DEV_TRAFFIC_PARKING_INFO extends SdkStructure
    {
        public int           nFeaturePicAreaPointNum;                                                        // 特征图片区点个数
        public NET_POINT[]   stFeaturePicArea = (NET_POINT[])new NET_POINT().toArray(NET_MAX_POLYGON_NUM);   // 特征图片区信息
        public byte[]        bReserved = new byte[572];                                                      // 保留字节
    }

    //事件类型 EVENT_IVS_TRAFFIC_PARKINGSPACEPARKING(车位有车事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_PARKINGSPACEPARKING_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[NET_EVENT_NAME_LEN];      // 事件名称
        public byte[]              bReserved1 = new byte[8];                   // 字节对齐
        public int                 PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public int                 nLane;                                      // 对应车道号
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息

        public int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
        public int                 nParkingSpaceStatus;                        // 车位状态,0-占用,1-空闲,2-压线
        public DEV_TRAFFIC_PARKING_INFO stTrafficParingInfo;                   // 停车场信息
        public byte                byPlateTextSource;                          // 车牌识别来源, 0:本地算法识别,1:后端服务器算法识别
        public byte[]              byReserved2 = new byte[3];             	   // 字节对齐
        public byte[]              szParkingNum = new byte[32];                // 车位(地磁)编号，球机定制项目
        public int                 dwPresetNum;                                // 球机预置位编号，球机定制项目
        public int                 bParkingFault;                              // 车位是否有故障，球机定制项目
        public byte[]              bReserved = new byte[364];                  // 保留字节
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
        public NET_INTELLIGENCE_IMAGE_INFO stuParkingImage;                    // 车位图片信息
        public int                 nConfidence;                                // 事件置信度（0-100）
        public int                 emAcrossParking;                            // 是否跨位(参考EM_ACROSS_PARKING)
        public int                 emParkingDirection;                         // 停车方向(参考EM_PARKINGSPACE_DIRECTION)
        public int                 emForbidParkingStatus;				       // 禁停状态(参考EM_FORBID_PARKING_STATUS)
        public byte[]			   byReserved1 = new byte[1004];			   // 为图片信息做预留字节，新增的字段请在该保留字节下面添加
        public int                 emTriggerType;                              // 触发类型(参考EM_PARKING_TRIGGER_TYPE)
        public DEV_OCCUPIED_WARNING_INFO stuOccupiedWarningInfo;               // 一位多车信息, 如果车位此前没有车占用, 不会带有本字段信息
    }

    // 是否跨位
    public static class EM_ACROSS_PARKING
    {
        public static int EM_ACROSS_PARKING_UNKNOWN = 0;                  // 未知
        public static int EM_ACROSS_PARKING_NO = 1;                     // 未跨位
        public static int EM_ACROSS_PARKING_YES = 2;                    // 跨位
    }

    // 一位多车信息
    public class DEV_OCCUPIED_WARNING_INFO extends SdkStructure
    {
        public byte[]        szParkingNo  =  new byte[32];             // 车位号
        public DEV_OCCUPIED_WARNING_PLATE_NUMBER[] szPlateNumber = new DEV_OCCUPIED_WARNING_PLATE_NUMBER[5];   // 车牌号码
        public int           nPlateNumber;                             // 车牌数量
        public byte[]        bReserved  = new byte[508];               // 预留字节

        public DEV_OCCUPIED_WARNING_INFO(){
            for(int i = 0;i<szPlateNumber.length;i++){
                szPlateNumber[i] = new DEV_OCCUPIED_WARNING_PLATE_NUMBER();
                ;            }
        }
    }

    public class DEV_OCCUPIED_WARNING_PLATE_NUMBER extends SdkStructure
    {
        public byte[] plateNumber = new byte[64];
    }

    // 事件类型 EVENT_IVS_TRAFFIC_PARKINGSPACENOPARKING(车位无车事件)对应的数据块描述信息
    // 由于历史原因,如果要处理卡口事件,DEV_EVENT_TRAFFICJUNCTION_INFO和EVENT_IVS_TRAFFICGATE要一起处理,以防止有视频电警和线圈电警同时接入平台的情况发生
    // 另外EVENT_IVS_TRAFFIC_TOLLGATE只支持新卡口事件的配置
    public static class DEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[NET_EVENT_NAME_LEN];      // 事件名称
        public byte[]              bReserved1 = new byte[8];                   // 字节对齐
        public int                 PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public int                 nLane;                                      // 对应车道号
        public NET_MSG_OBJECT       stuObject;                                 // 检测到的物体
        public NET_MSG_OBJECT       stuVehicle;                                // 车身信息
        public NET_EVENT_FILE_INFO  stuFileInfo;                               // 事件对应文件信息

        public int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见 NET_RESERVED_COMMON
        public NET_RESOLUTION_INFO  stuResolution;                             // 对应图片的分辨率
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
        public DEV_TRAFFIC_PARKING_INFO stTrafficParingInfo;                   // 停车场信息
        public byte                byPlateTextSource;                          // 车牌识别来源, 0:本地算法识别,1:后端服务器算法识别
        public byte[]              byReserved2 = new byte[3];                  // 字节对齐
        public byte[]              szParkingNum = new byte[32];                // 车位(地磁)编号，球机定制项目
        public int                 dwPresetNum;                                // 球机预置位编号，球机定制项目
        public int                 bParkingFault;                              // 车位是否有故障，球机定制项目
        public byte[]              bReserved = new byte[368];                  // 保留字节
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
        public NET_INTELLIGENCE_IMAGE_INFO stuGlobalImage;                     // 全景大图信息
        public NET_INTELLIGENCE_IMAGE_INFO stuParkingImage;                    // 车位图片信息
        public int                 nConfidence;                                // 事件置信度（0-100）
        public byte[]			   byReserved1 = new byte[1016];			   // 为图片信息做预留字节，新增的字段请在该保留字节下面添加
        public int                 emTriggerType;                              // EM_PARKING_TRIGGER_TYPE 触发方式
        public DEV_MATCH_PARKING_INFO[] stuMatchParkingInfo = new DEV_MATCH_PARKING_INFO[5];   // 匹配到的车辆驶入信息
        public int nMatchParkingNum;

        public DEV_EVENT_TRAFFIC_PARKINGSPACENOPARKING_INFO(){
            for(int i = 0;i<stuMatchParkingInfo.length;i++){
                stuMatchParkingInfo[i] = new DEV_MATCH_PARKING_INFO();
            }
        }
    }

    // 匹配到的车辆驶入信息
    public class DEV_MATCH_PARKING_INFO extends SdkStructure
    {
        public byte[]       szParkingNo = new byte[32];                  // 驶入的车位号
        public byte[]       szPlateNum = new byte[64];                   // 驶入的车牌号信息
        public int          nSimilarity;                                 // 驶出车牌号码与匹配到的驶入车牌号码的相似度, 全匹配成功为100, 失败为0。
        // 如果开启模糊匹配, 全匹配不为100则进行模糊匹配, 如下
        // 1. 除汉字外，所有的数字和字母一样 为95
        // 2. 有一位数字或字母不一样，则为90
        // 3. 有两位数字或字母不一样，则为80
        // 其他的情况则认为没有匹配到，则为0
        public byte[]       bReserved = new byte[508];                   // 保留字节
    }

    //事件类型 EVENT_IVS_TRAFFIC_PEDESTRAIN(交通行人事件)对应数据块描述信息
    public static class DEV_EVENT_TRAFFIC_PEDESTRAIN_INFO extends SdkStructure {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[NET_EVENT_NAME_LEN];      // 事件名称
        public byte[]              bReserved1 = new byte[8];                   // 字节对齐
        public int                 PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              bReserved2 = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 nLane;                                      // 对应车道号
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
        public byte[]              bReserved = new byte[892];                 // 保留字节
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    }

    //事件类型 EVENT_IVS_TRAFFIC_THROW(交通抛洒物品事件)对应数据块描述信息
    public static class DEV_EVENT_TRAFFIC_THROW_INFO extends SdkStructure {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[NET_EVENT_NAME_LEN];      // 事件名称
        public byte[]              bReserved1 = new byte[8];                   // 字节对齐
        public int                 PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              bReserved2 = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 nLane;                                      // 对应车道号
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
        public EVENT_TRAFFIC_CAR_PART_INFO stuTrafficCarPartInfo;              // 交通车辆部分信息
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
        public byte[]              bReserved = new byte[340];                  // 保留字节
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    }

    // 交通车辆部分信息
    public class EVENT_TRAFFIC_CAR_PART_INFO extends SdkStructure
    {
        public byte[]              szMachineName = new byte[128];               // 本地或远程设备名称    来源于普通配置General.MachineName
        public byte[]              szRoadwayNo = new byte[32];                  // 道路编号
        public byte[]              bReserved = new byte[352];                   // 保留字节
    }

    // 事件上报携带卡片信息
    public static class EVENT_CARD_INFO extends SdkStructure
    {
        public byte[]              szCardNumber = new byte[NET_EVENT_CARD_LEN];// 卡片序号字符串
        public byte[]              bReserved = new byte[32];                   // 保留字节,留待扩展.
    }

    // 车辆方向信息
    public static class EM_VEHICLE_DIRECTION extends SdkStructure
    {
        public static final int    NET_VEHICLE_DIRECTION_UNKOWN = 0;           // 未知
        public static final int    NET_VEHICLE_DIRECTION_HEAD   = 1;           // 车头
        public static final int    NET_VEHICLE_DIRECTION_TAIL   = 2;           // 车尾
    }

    // 开闸状态
    public static class EM_OPEN_STROBE_STATE extends SdkStructure
    {
        public static final int    NET_OPEN_STROBE_STATE_UNKOWN = 0;           // 未知状态
        public static final int    NET_OPEN_STROBE_STATE_CLOSE  = 1;           // 关闸
        public static final int    NET_OPEN_STROBE_STATE_AUTO   = 2;           // 自动开闸
        public static final int    NET_OPEN_STROBE_STATE_MANUAL = 3;           // 手动开闸
    }

    public static class RESERVED_PARA extends SdkStructure
    {
        public int   				dwType;         						   //pData的数据类型
        //当[dwType]为 RESERVED_TYPE_FOR_INTEL_BOX 时,pData 对应为结构体 RESERVED_DATA_INTEL_BOX 的地址
        //当[dwType]为 RESERVED_TYPE_FOR_COMMON 时,[pData]对应为结构体 NET_RESERVED_COMMON 的结构体地址
        //当[dwType]为 RESERVED_TYPE_FOR_PATH 时,[pData]对应结构体NET_RESERVED_PATH的结构体地址
        public Pointer   			pData;          						   //数据,由用户申请内存，大小参考对应的结构体
    }

    // 事件类型 EVENT_IVS_TRAFFICJUNCTION 交通路口老规则事件/视频电警上的交通卡口老规则事件对应的数据块描述信息
    // 由于历史原因,如果要处理卡口事件,DEV_EVENT_TRAFFICJUNCTION_INFO 和 EVENT_IVS_TRAFFICGATE要一起处理
    // 以防止有视频电警和线圈电警同时接入平台的情况发生, 另外EVENT_IVS_TRAFFIC_TOLLGATE只支持新卡口事件的配置
    public static class DEV_EVENT_TRAFFICJUNCTION_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[NET_EVENT_NAME_LEN];      // 事件名称
        public byte                byMainSeatBelt;                             // 主驾驶座,系安全带状态,1-系安全带,2-未系安全带
        public byte                bySlaveSeatBelt;                            // 副驾驶座,系安全带状态,1-系安全带,2-未系安全带
        public byte                byVehicleDirection;                         // 当前被抓拍到的车辆是车头还是车尾,具体请见 EM_VEHICLE_DIRECTION
        public byte                byOpenStrobeState;                          // 开闸状态,具体请见 EM_OPEN_STROBE_STATE
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public int                 nLane;                                      // 对应车道号
        public int                 dwBreakingRule;                             // 违反规则掩码,第一位:闯红灯;
        // 第二位:不按规定车道行驶;
        // 第三位:逆行; 第四位：违章掉头;
        // 第五位:交通堵塞; 第六位:交通异常空闲
        // 第七位:压线行驶; 否则默认为:交通路口事件
        public NET_TIME_EX         RedLightUTC;                                // 红灯开始UTC时间
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public int                 nSpeed;                                     // 车辆实际速度Km/h
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte                byDirection;                                // 路口方向,1-表示正向,2-表示反向
        public byte                byLightState;                               // LightState表示红绿灯状态:0 未知,1 绿灯,2 红灯,3 黄灯
        public byte                byReserved;                                 // 保留字节
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见 NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public byte[]              szRecordFile = new byte[NET_COMMON_STRING_128];// 报警对应的原始录像文件信息
        public EVENT_JUNCTION_CUSTOM_INFO   stuCustomInfo;                     // 自定义信息
        public byte                byPlateTextSource;                          // 车牌识别来源, 0:本地算法识别,1:后端服务器算法识别
        public byte[]              bReserved1 = new byte[3];                   // 保留字节,留待扩展.
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制

        public byte                byNoneMotorInfo;                            // 0-无非机动车人员信息信息,1-有非机动车人员信息信息  此字段为1时下面11个字段生效
        public byte                byBag;                                      // 是否背包, 0-未知 1-不背包   2-背包
        public byte                byUmbrella;                                 // 是否打伞, 0-未知 1-不打伞   2-打伞
        public byte                byCarrierBag;                               // 手提包状态,0-未知 1-没有 2-有
        public byte                byHat;                                      // 是否戴帽子, 0-未知 1-不戴帽子 2-戴帽子
        public byte                byHelmet;                                   // 头盔状态,0-未知 1-没有 2-有
        public byte                bySex;                                      // 性别,0-未知 1-男性 2-女性
        public byte                byAge;                                      // 年龄
        public NET_COLOR_RGBA      stuUpperBodyColor;                          // 上身颜色
        public NET_COLOR_RGBA      stuLowerBodyColor;                          // 下身颜色
        public byte                byUpClothes;                                // 上身衣服类型 0:未知 1:长袖 2:短袖 3:长裤 4:短裤 5:裙子 6:背心 7:超短裤 8:超短裙
        public byte                byDownClothes;                              // 下身衣服类型 0:未知 1:长袖 2:短袖 3:长裤 4:短裤 5:裙子 6:背心 7:超短裤 8:超短裙

        public NET_EXTENSION_INFO  stuExtensionInfo;                           // 扩展信息
        public byte[]              bReserved = new byte[22];                   // 保留字节,留待扩展.
        public int                 nTriggerType;                               // TriggerType:触发类型,0车检器,1雷达,2视频
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
        public int                 dwRetCardNumber;                            // 卡片个数
        public EVENT_CARD_INFO[]   stuCardInfo = (EVENT_CARD_INFO[])new EVENT_CARD_INFO().toArray(NET_EVENT_MAX_CARD_NUM);// 卡片信息
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

        public int				   bNonMotorInfoEx;							   // 是否有非机动车信息, 1-true; 0-false
        public VA_OBJECT_NONMOTOR  stuNonMotor;								   // 非机动车信息
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
        public byte[]			   byReserved2 = new byte[1916];			   // 保留字节,留待扩展
    }

    // 非机动车对象
    public static class VA_OBJECT_NONMOTOR extends SdkStructure
    {
        public int					  nObjectID;                          	  // 物体ID,每个ID表示一个唯一的物体
        public int 					  emCategory;							  // 非机动车子类型, 对应枚举 EM_CATEGORY_NONMOTOR_TYPE
        public DH_RECT				  stuBoundingBox;                         // 包围盒， 非机动车矩形框，0~8191相对坐标
        public DH_RECT				  stuOriginalBoundingBox;                 // 包围盒， 非机动车矩形框，绝对坐标
        public NET_COLOR_RGBA		  stuMainColor;						      // 非机动车颜色, RGBA
        public int					  emColor;							      // 非机动车颜色, 枚举 EM_OBJECT_COLOR_TYPE
        public int					  bHasImage;							  // 是否有抠图, 1-true; 0-false
        public NET_NONMOTOR_PIC_INFO  stuImage;							      // 物体截图
        public int					  nNumOfCycling;						  // 骑车人数量
        public NET_RIDER_INFO[]		  stuRiderList =
                (NET_RIDER_INFO[])new NET_RIDER_INFO().toArray(MAX_RIDER_NUM); // 骑车人特征,个数和nNumOfCycling关联
        public SCENE_IMAGE_INFO			stuSceneImage;						// 全景广角图
        public FACE_SCENE_IMAGE			stuFaceSceneImage;					// 人脸全景广角图
        public int						nNumOfFace;							// 检测到的人脸数量
        public float					fSpeed;								// 物体速度，单位为km/h
        public NET_NONMOTOR_FEATURE_VECTOR_INFO stuNonMotorFeatureVectorInfo;  // 非机动车特征值数据在二进制数据中的位置信息
        public int emNonMotorFeatureVersion;			// 非机动车特征值版本号,参考EM_FEATURE_VERSION
        public NET_NONMOTOR_PLATE_INFO     stuNomotorPlateInfo;                // 非机动车牌信息
        public NET_POINT                   stuObjCenter;                       // 物体型心(不是包围盒中心), 0-8191相对坐标, 相对于大图
        public byte[] byReserved = new byte[3072]; // 保留		  // 保留
    }

    // 非机动车配牌信息
    public static class NET_NONMOTOR_PLATE_INFO extends SdkStructure
    {
        public byte[]                        szPlateNumber=new byte[128];                 // 非机动车车牌号
        public NET_RECT					stuBoundingBox;                     // 包围盒， 非机动车矩形框，0~8191相对坐标
        public NET_RECT					stuOriginalBoundingBox;             // 包围盒， 非机动车矩形框，绝对坐标
        public NET_NONMOTOR_PLATE_IMAGE    stuPlateImage;                      // 非机动车车牌抠图
        public int         emPlateColor;                       // 车牌颜色

        public byte[]						byReserved=new byte[132];					// 保留
    };

    // 非机动车车牌图片信息
    public static class NET_NONMOTOR_PLATE_IMAGE extends SdkStructure
    {
        public int        nOffset;            // 在二进制数据块中的偏移
        public int        nLength;            // 图片大小
        public int        nWidth;             // 图片宽度
        public int        nHeight;            // 图片高度
        public byte[]        byReserved=new byte[512];    // 保留字节
    };

    public static class NET_NONMOTOR_FEATURE_VECTOR_INFO extends SdkStructure {
        public int                nOffset;            // 非机动车特征值在二进制数据中的偏移, 单位:字节
        public int                nLength;            // 非机动车特征值数据长度, 单位:字节
        public byte[] byReserved = new byte[32]; // 保留
    }

    public static class EM_FEATURE_VERSION extends SdkStructure {

        public static final int EM_FEATURE_VERSION_UNKNOWN = 0;             // 未知
        public static final int EM_FEATURE_VERSION_FACE_LARGE_1_01_001 = 1;	// 人脸，大模型，1.01.001
        public static final int EM_FEATURE_VERSION_FACE_LARGE_1_02_001 = 2; // 人脸，大模型，1.02.001
        public static final int EM_FEATURE_VERSION_FACE_LARGE_1_03_001 = 3; // 人脸，大模型，1.03.001
        public static final int EM_FEATURE_VERSION_FACE_LARGE_1_04_001 = 4; // 人脸，大模型，1.04.001
        public static final int EM_FEATURE_VERSION_FACE_MIDDLE_1_01_002 = 31;   // 人脸，中模型，1.01.002
        public static final int EM_FEATURE_VERSION_FACE_MIDDLE_1_02_002 = 32;               // 人脸，中模型，1.02.002
        public static final int EM_FEATURE_VERSION_FACE_MIDDLE_1_03_002 = 33;				// 人脸，中模型，1.03.002
        public static final int EM_FEATURE_VERSION_FACE_MIDDLE_1_04_002 = 34;				// 人脸，中模型，1.04.002
        public static final int EM_FEATURE_VERSION_FACE_SMALL_1_01_003 = 61;				// 人脸，小模型，1.01.003
        public static final int EM_FEATURE_VERSION_FACE_SMALL_1_02_003 = 62;				// 人脸，小模型，1.02.003

        public static final int EM_FEATURE_VERSION_HUMAN_NONMOTOR				= 91;		// 人和非机动车，全局无版本号
        public static final int EM_FEATURE_VERSION_HUMAN_NONMOTOR_FLOAT_1_00_01	= 92;       // 人和非机动车，全局浮点，1.00.01
        public static final int EM_FEATURE_VERSION_HUMAN_NONMOTOR_HASH_1_00_01	= 93;       // 人和非机动车，全局哈希，1.00.01
        public static final int EM_FEATURE_VERSION_HUMAN_NONMOTOR_FLOAT_1_01_00	= 94;       // 人和非机动车，全局浮点，1.01.00
        public static final int EM_FEATURE_VERSION_HUMAN_NONMOTOR_HASH_1_01_00	= 95;       // 人和非机动车，全局哈希，1.01.00

        public static final int EM_FEATURE_VERSION_TRAFFIC						= 121;		// 机动车，全局无版本号
        public static final int EM_FEATURE_VERSION_TRAFFIC_FLOAT				= 122;		// 机动车，全局浮点版本号0
        public static final int EM_FEATURE_VERSION_TRAFFIC_FLOAT_1_00_01		= 123;		// 机动车，全局浮点版本号1.00.01
        public static final int EM_FEATURE_VERSION_TRAFFIC_HASH_1_00_01			= 124;		// 机动车，全局哈希版本号1.00.01
        public static final int EM_FEATURE_VERSION_TRAFFIC_FLOAT_1_00_02		= 125;		// 机动车，全局浮点版本号1.00.02
        public static final int EM_FEATURE_VERSION_TRAFFIC_HASH_1_00_02			= 126;		// 机动车，全局哈希版本号1.00.02

        public static final int EM_FEATURE_VERSION_SHANGTANG_FACE_1_5_0			= 151;		// 商汤，人脸，1.5.0
        public static final int EM_FEATURE_VERSION_SHANGTANG_FACE_1_8_1			= 152;		// 商汤，人脸，1.8.1
        public static final int EM_FEATURE_VERSION_SHANGTANG_FACE_2_1_3			= 153;		// 商汤，人脸，2.1.3
        public static final int EM_FEATURE_VERSION_SHANGTANG_FACE_2_39_6		= 154;		// 商汤，人脸，2.39.6
        public static final int EM_FEATURE_VERSION_SHANGTANG_FACE_2_39_7		= 155;		// 商汤，人脸，2.39.7
        public static final int EM_FEATURE_VERSION_SHANGTANG_FACE_2_39_8		= 156;		// 商汤，人脸，2.39.8
        public static final int EM_FEATURE_VERSION_SHANGTANG_FACE_239			= 157;		// 商汤，人脸，239
        public static final int EM_FEATURE_VERSION_SHANGTANG_FACE_242			= 158;		// 商汤，人脸，242
        public static final int EM_FEATURE_VERSION_SHANGTANG_FACE_244			= 159;		// 商汤，人脸，244
        public static final int EM_FEATURE_VERSION_SHANGTANG_FACE_245			= 160;		// 商汤，人脸，245

        public static final int EM_FEATURE_VERSION_SHENMO_HUMAN_TRAFFIC_NON_2_4_2	= 181;  // 深瞐，人脸/机动车/非机动车，2.4.2
        public static final int EM_FEATURE_VERSION_SHENMO_HUMAN_TRAFFIC_NON_2_5_7	= 182;	// 深瞐，人脸/机动车/非机动车，2.5.7
    }

    // 非机动车抠图信息
    public static class NET_NONMOTOR_PIC_INFO extends SdkStructure
    {
        public int					 uOffset;								 // 在二进制数据块中的偏移
        public int					 uLength;								 // 图片大小,单位：字节
        public int					 uWidth;								 // 图片宽度
        public int					 uHeight;								 // 图片高度
        public byte[]				 szFilePath = new byte[MAX_PATH_LEN];	 // 文件路径
        public byte[]				 byReserved = new byte[512];			 // 保留
    }

    // 骑车人脸图片信息
    public static class RIDER_FACE_IMAGE_INFO extends SdkStructure
    {
        public int					 uOffset;								 // 在二进制数据块中的偏移
        public int					 uLength;								 // 图片大小,单位：字节
        public int					 uWidth;								 // 图片宽度
        public int					 uHeight;								 // 图片高度
        public byte[]				 byReserved = new byte[48];			 // 保留
    }

    // 斜视状态
    public static class EM_STRABISMUS_TYPE extends SdkStructure
    {
        public static final int EM_STRABISMUS_UNKNOWN = 0;			// 未知
        public static final int EM_STRABISMUS_NORMAL = 1;			// 正常
        public static final int EM_STRABISMUS_YES = 2;				// 斜视
    }

    // 是否带眼镜
    public static class EM_HAS_GLASS extends SdkStructure
    {
        public static final int EM_HAS_GLASS_UNKNOWN = 0;			// 未知
        public static final int EM_HAS_GLASS_NO = 1;				// 未戴
        public static final int EM_HAS_GLASS_NORMAL = 2;			// 戴普通眼镜
        public static final int EM_HAS_GLASS_SUN = 3;				// 戴太阳眼镜
        public static final int EM_HAS_GLASS_BLACK = 4;				// 戴黑框眼镜
    }

    // 人脸属性
    public static class NET_FACE_ATTRIBUTE_EX extends SdkStructure
    {
        public int 							emSex;						// 性别,参考EM_SEX_TYPE
        public int       					nAge;						// 年龄,-1表示该字段数据无效
        public int							emComplexion;				// 肤色，参考EM_COMPLEXION_TYPE
        public int							emEye;						// 眼睛状态，参考EM_EYE_STATE_TYPE
        public int							emMouth;					// 嘴巴状态，参考EM_MOUTH_STATE_TYPE
        public int 							emMask;						// 口罩状态， 参考EM_MASK_STATE_TYPE
        public int							emBeard;					// 胡子状态， EM_BEARD_STATE_TYPE
        public int							nAttractive;				// 魅力值, 0未识别，识别时范围1-100,得分高魅力高
        public int							emGlass;					// 眼镜，参考EM_HAS_GLASS
        public int							emEmotion;					// 表情，参考EM_EMOTION_TYPE
        public NET_RECT						stuBoundingBox;				// 包围盒(8192坐标系)
        public byte[]				 		byReserved1 = new byte[4];	// 保留
        public int							emStrabismus;				// 斜视状态，EM_STRABISMUS_TYPE
        public byte[]				 		byReserved = new byte[64];	// 保留
    }

    // 骑车人信息
    public static class NET_RIDER_INFO extends SdkStructure
    {
        public int					 bFeatureValid;							// 是否识别到特征信息, TRUE时下面数据才有效, 1-true; 0-false
        public int		             emSex;								    // 性别, 对应枚举  EM_SEX_TYPE
        public int					 nAge;								    // 年龄

        public int   				 emHelmet;					  		    // 头盔状态, 对应枚举  EM_NONMOTOR_OBJECT_STATUS
        public int   			     emCall;							    // 是否在打电话, 对应枚举 EM_NONMOTOR_OBJECT_STATUS
        public int   				 emBag;					  			    // 是否有背包, 对应枚举 EM_NONMOTOR_OBJECT_STATUS
        public int    				 emCarrierBag;					  	    // 有没有手提包, 对应枚举 EM_NONMOTOR_OBJECT_STATUS
        public int    			     emUmbrella;					  	    // 是否打伞, 对应枚举 EM_NONMOTOR_OBJECT_STATUS
        public int   				 emGlasses;					  	  	    // 是否有带眼镜, 对应枚举 EM_NONMOTOR_OBJECT_STATUS
        public int   				 emMask;					  	  	    // 是否带口罩, 对应枚举 EM_NONMOTOR_OBJECT_STATUS

        public int              	 emEmotion;                             // 表情, 对应枚举 EM_EMOTION_TYPE
        public int             		 emUpClothes;                           // 上衣类型, 对应枚举 EM_CLOTHES_TYPE
        public int             		 emDownClothes;                         // 下衣类型, 对应枚举 EM_CLOTHES_TYPE
        public int        			 emUpperBodyColor;                      // 上衣颜色, 对应枚举 EM_OBJECT_COLOR_TYPE
        public int       		     emLowerBodyColor;                      // 下衣颜色, 对应枚举 EM_OBJECT_COLOR_TYPE

        public int					bHasFaceImage;							// 是否有骑车人人脸抠图信息
        public RIDER_FACE_IMAGE_INFO		stuFaceImage;					// 骑车人人脸特写描述
        public int					bHasFaceAttributes;						// 是否有人脸属性
        public NET_FACE_ATTRIBUTE_EX		stuFaceAttributes;				// 人脸属性
        public byte[]				 byReserved = new byte[316];			// 保留
    }

    // 性别
    public static class EM_SEX_TYPE extends SdkStructure
    {
        public static final int EM_SEX_TYPE_UNKNOWN = 0;					//未知
        public static final int EM_SEX_TYPE_MALE = 1;						//男性
        public static final int EM_SEX_TYPE_FEMALE = 2;						//女性
    }

    // 事件/物体状态
    public static class EM_NONMOTOR_OBJECT_STATUS extends SdkStructure
    {
        public static final int EM_NONMOTOR_OBJECT_STATUS_UNKNOWN = 0;		// 未识别
        public static final int EM_NONMOTOR_OBJECT_STATUS_NO = 1;			// 否
        public static final int EM_NONMOTOR_OBJECT_STATUS_YES = 2;			// 是
    }

    // 表情
    public static class EM_EMOTION_TYPE extends SdkStructure
    {
        public static final int EM_EMOTION_TYPE_UNKNOWN = 0;                // 未知
        public static final int EM_EMOTION_TYPE_NORMAL = 1;                 // 普通/正常
        public static final int EM_EMOTION_TYPE_SMILE = 2;                  // 微笑
        public static final int EM_EMOTION_TYPE_ANGER = 3;                  // 愤怒
        public static final int EM_EMOTION_TYPE_SADNESS = 4;                // 悲伤
        public static final int EM_EMOTION_TYPE_DISGUST = 5;                // 厌恶
        public static final int EM_EMOTION_TYPE_FEAR = 6;                   // 害怕
        public static final int EM_EMOTION_TYPE_SURPRISE = 7;               // 惊讶
        public static final int EM_EMOTION_TYPE_NEUTRAL = 8;                // 正常
        public static final int EM_EMOTION_TYPE_LAUGH = 9;                  // 大笑
        public static final int EM_EMOTION_TYPE_HAPPY = 10;                 // 高兴
        public static final int EM_EMOTION_TYPE_CONFUSED = 11;              // 困惑
        public static final int EM_EMOTION_TYPE_SCREAM = 12;                // 尖叫
        public static final int EM_EMOTION_TYPE_CALMNESS = 13;  			// 平静
    }

    public static class EM_CLOTHES_TYPE extends SdkStructure
    {
        public static final int EM_CLOTHES_TYPE_UNKNOWN = 0;                //未知
        public static final int EM_CLOTHES_TYPE_LONG_SLEEVE = 1;            //长袖
        public static final int EM_CLOTHES_TYPE_SHORT_SLEEVE = 2;           //短袖
        public static final int EM_CLOTHES_TYPE_TROUSERS = 3;               //长裤
        public static final int EM_CLOTHES_TYPE_SHORTS = 4;                 //短裤
        public static final int EM_CLOTHES_TYPE_SKIRT = 5;                  //裙子
        public static final int EM_CLOTHES_TYPE_WAISTCOAT = 6;              //背心
        public static final int EM_CLOTHES_TYPE_MINIPANTS = 7;              //超短裤
        public static final int EM_CLOTHES_TYPE_MINISKIRT = 8;              //超短裙
    }

    // 非机动车子类型
    public static class EM_CATEGORY_NONMOTOR_TYPE extends SdkStructure
    {
        public static final int EM_CATEGORY_NONMOTOR_TYPE_UNKNOWN = 0;					// 未知
        public static final int EM_CATEGORY_NONMOTOR_TYPE_TRICYCLE = 1;					// "Tricycle" 三轮车
        public static final int EM_CATEGORY_NONMOTOR_TYPE_MOTORCYCLE = 2;				// "Motorcycle" 摩托车
        public static final int EM_CATEGORY_NONMOTOR_TYPE_NON_MOTOR = 3;				// "Non-Motor"非机动车
        public static final int EM_CATEGORY_NONMOTOR_TYPE_BICYCLE = 4;					// "Bicycle" 自行车
        public static final int EM_CATEGORY_NONMOTOR_TYPE_DUALTRIWHEELMOTORCYCLE = 5;	// "DualTriWheelMotorcycle"两、三轮摩托车
        public static final int EM_CATEGORY_NONMOTOR_TYPE_LIGHTMOTORCYCLE = 6;			// "LightMotorcycle" 轻便摩托车
        public static final int EM_CATEGORY_NONMOTOR_TYPE_EMBASSYMOTORCYCLE = 7;		// "EmbassyMotorcycle "使馆摩托车
        public static final int EM_CATEGORY_NONMOTOR_TYPE_MARGINALMOTORCYCLE = 8;		// "MarginalMotorcycle "领馆摩托车
        public static final int EM_CATEGORY_NONMOTOR_TYPE_AREAOUTMOTORCYCLE = 9;		// "AreaoutMotorcycle "境外摩托车
        public static final int EM_CATEGORY_NONMOTOR_TYPE_FOREIGNMOTORCYCLE = 10;		// "ForeignMotorcycle "外籍摩托车
        public static final int EM_CATEGORY_NONMOTOR_TYPE_TRIALMOTORCYCLE = 11;			// "TrialMotorcycle "试验摩托车
        public static final int EM_CATEGORY_NONMOTOR_TYPE_COACHMOTORCYCLE = 12;			// "CoachMotorcycle "教练摩托车
    }

    // 颜色类型
    public static class EM_OBJECT_COLOR_TYPE extends SdkStructure
    {
        public static final int EM_OBJECT_COLOR_TYPE_UNKNOWN = 0;			  // 未知
        public static final int EM_OBJECT_COLOR_TYPE_WHITE = 1;				  // 白色
        public static final int EM_OBJECT_COLOR_TYPE_ORANGE = 2;			  // 橙色
        public static final int EM_OBJECT_COLOR_TYPE_PINK = 3;				  // 粉色
        public static final int EM_OBJECT_COLOR_TYPE_BLACK = 4;				  // 黑色
        public static final int EM_OBJECT_COLOR_TYPE_RED = 5;				  // 红色
        public static final int EM_OBJECT_COLOR_TYPE_YELLOW = 6;			  // 黄色
        public static final int EM_OBJECT_COLOR_TYPE_GRAY = 7;				  // 灰色
        public static final int EM_OBJECT_COLOR_TYPE_BLUE = 8;				  // 蓝色
        public static final int EM_OBJECT_COLOR_TYPE_GREEN = 9;				  // 绿色
        public static final int EM_OBJECT_COLOR_TYPE_PURPLE = 10;			  // 紫色
        public static final int EM_OBJECT_COLOR_TYPE_BROWN = 11;			  // 棕色
        public static final int EM_OBJECT_COLOR_TYPE_SLIVER = 12;			  // 银色
        public static final int EM_OBJECT_COLOR_TYPE_DARKVIOLET = 13;		  // 暗紫罗兰色
        public static final int EM_OBJECT_COLOR_TYPE_MAROON = 14;			  // 栗色
        public static final int EM_OBJECT_COLOR_TYPE_DIMGRAY = 15;			  // 暗灰色
        public static final int EM_OBJECT_COLOR_TYPE_WHITESMOKE = 16;		  // 白烟色
        public static final int EM_OBJECT_COLOR_TYPE_DARKORANGE = 17;		  // 深橙色
        public static final int EM_OBJECT_COLOR_TYPE_MISTYROSE = 18;		  // 浅玫瑰色
        public static final int EM_OBJECT_COLOR_TYPE_TOMATO = 19;			  // 番茄红色
        public static final int EM_OBJECT_COLOR_TYPE_OLIVE = 20;			  // 橄榄色
        public static final int EM_OBJECT_COLOR_TYPE_GOLD = 21;				  // 金色
        public static final int EM_OBJECT_COLOR_TYPE_DARKOLIVEGREEN = 22;	  // 暗橄榄绿色
        public static final int EM_OBJECT_COLOR_TYPE_CHARTREUSE = 23;		  // 黄绿色
        public static final int EM_OBJECT_COLOR_TYPE_GREENYELLOW = 24;		  // 绿黄色
        public static final int EM_OBJECT_COLOR_TYPE_FORESTGREEN = 25;		  // 森林绿色
        public static final int EM_OBJECT_COLOR_TYPE_SEAGREEN = 26;			  // 海洋绿色
        public static final int EM_OBJECT_COLOR_TYPE_DEEPSKYBLUE = 27;		  // 深天蓝色
        public static final int EM_OBJECT_COLOR_TYPE_CYAN = 28;				  // 青色
        public static final int EM_OBJECT_COLOR_TYPE_OTHER = 29;			  // 无法识别
    }

    public static class NET_SEAT_INFO extends SdkStructure
    {
        public NET_RECT 		  stuFaceRect; 								   // 人脸矩形框信息(8192坐标系)
        public byte   			  bySunShade;								   // 遮阳板状态 0: 未知 1：无遮阳板 2：有遮阳板
        public byte   			  byDriverCalling; 							   // 打电话状态 0: 未知 1：未打电话 2：打电话
        public byte   			  byDriverSmoking;						       // 抽烟状态	0: 未知 1：未吸烟 2：吸烟
        public byte   			  bySafeBelt; 								   // 安全带状态	0: 未知 1：未系安全带 2：系安全带
        public byte[]   		  byReserved = new byte[32];				   // 保留字节
    }

    public static class NET_VEHICLE_ATTACH extends SdkStructure
    {
        public int         		  nType; 									   // 附件类型	0-未知  1-年检标志  2-挂件  3-纸巾盒  4-香水盒
        public NET_RECT    		  stuBoundingBox;							   // 包围盒信息(8192坐标系)
        public byte[]        	  byReserved = new byte[32];				   // 保留字节
    }

    //卡口事件专用定制上报内容，定制需求增加到Custom下
    public static class EVENT_JUNCTION_CUSTOM_INFO extends SdkStructure
    {
        public EVENT_CUSTOM_WEIGHT_INFO     stuWeightInfo;      				// 原始图片信息
        public int                       	nCbirFeatureOffset;					// 数据偏移，单位字节 （由于结构体保留字节有限的限制,添加在此处， 下同）
        public int                       	nCbirFeatureLength;					// 数据大小，单位字节
        public int							dwVehicleHeadDirection;				// 车头朝向 0:未知 1:左 2:中 3:右

        public int                          nAvailableSpaceNum;         // 停车场车位余位数量 (出入口相机项目定制需求）
        public NET_RADAR_FREE_STREAM		stuRadarFreeStream;			// 雷达自由流信息
        public NET_CUSTOM_MEASURE_TEMPER   stuMeasureTemper;             // 测温信息
        public byte[]						bReserved = new byte[12];			// 预留字节
    }

    // 雷达自由流信息
    public static class NET_RADAR_FREE_STREAM extends SdkStructure
    {
        public long							nABSTime;					// 1年1月1日0时起至今的毫秒数
        public int							nVehicleID; 				// 车辆ID
        public int							unOBUMAC;					// OBU的MAC地址
    }

    //建委地磅定制称重信息
    public static class EVENT_CUSTOM_WEIGHT_INFO extends SdkStructure
    {
        public int        dwRoughWeight;                    				   // 毛重,车辆满载货物重量。单位KG
        public int        dwTareWeight;                     				   // 皮重,空车重量。单位KG
        public int        dwNetWeight;                      				   // 净重,载货重量。单位KG
        public byte[]	  bReserved = new byte[28];					   	 	   // 预留字节
    }

    // 事件类型 EVENT_IVS_TRAFFICGATE(交通卡口老规则事件/线圈电警上的交通卡口老规则事件)对应的数据块描述信息
    // 由于历史原因,如果要处理卡口事件,DEV_EVENT_TRAFFICJUNCTION_INFO和EVENT_IVS_TRAFFICGATE要一起处理,以防止有视频电警和线圈电警同时接入平台的情况发生
    // 另外 EVENT_IVS_TRAFFIC_TOLLGATE 只支持新卡口事件的配置
    public static class DEV_EVENT_TRAFFICGATE_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[NET_EVENT_NAME_LEN];      // 事件名称
        public byte                byOpenStrobeState;                          // 开闸状态,具体请见EM_OPEN_STROBE_STATE
        public byte                bReserved1[] = new byte[3];                 // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public int                 nLane;                                      // 对应车道号
        public int                 nSpeed;                                     // 车辆实际速度Km/h
        public int                 nSpeedUpperLimit;                           // 速度上限 单位：km/h
        public int                 nSpeedLowerLimit;                           // 速度下限 单位：km/h
        public int                 dwBreakingRule;                             // 违反规则掩码,第一位:逆行;
        // 第二位:压线行驶; 第三位:超速行驶;
        // 第四位：欠速行驶; 第五位:闯红灯;第六位:穿过路口(卡口事件)
        // 第七位: 压黄线; 第八位: 有车占道; 第九位: 黄牌占道;否则默认为:交通卡口事件
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public byte                szManualSnapNo[] = new byte[64];            // 手动抓拍序号
        public int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[3];                   // 保留字节
        public byte[]              szSnapFlag = new byte[16];                  // 设备产生的抓拍标识
        public byte                bySnapMode;                                 // 抓拍方式,0-未分类 1-全景 2-近景 4-同向抓拍 8-反向抓拍 16-号牌图像
        public byte                byOverSpeedPercentage;                      // 超速百分比
        public byte                byUnderSpeedingPercentage;                  // 欠速百分比
        public byte                byRedLightMargin;                           // 红灯容许间隔时间,单位：秒
        public byte                byDriveDirection;                           // 行驶方向,0-上行(即车辆离设备部署点越来越近),1-下行(即车辆离设备部署点越来越远)
        public byte[]              szRoadwayNo = new byte[32];                 // 道路编号
        public byte[]              szViolationCode = new byte[16];             // 违章代码
        public byte[]              szViolationDesc = new byte[128];            // 违章描述
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public byte[]              szVehicleType= new byte[32];                // 车辆大小类型 Minisize"微型车,"Light-duty"小型车,"Medium"中型车,
        // "Oversize"大型车,"Huge"超大车,"Largesize"长车 "Unknown"未知
        public byte                byVehicleLenth;                             // 车辆长度, 单位米
        public byte                byLightState;                               // LightState表示红绿灯状态:0 未知,1 绿灯,2 红灯,3 黄灯
        public byte                byReserved1;                                // 保留字节,留待扩展
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 nOverSpeedMargin;                           // 限高速宽限值    单位：km/h
        public int                 nUnderSpeedMargin;                          // 限低速宽限值    单位：km/h
        public byte[]              szDrivingDirection = new byte[3*NET_MAX_DRIVINGDIRECTION]; //
        // "DrivingDirection" : ["Approach", "上海", "杭州"],行驶方向
        // "Approach"-上行,即车辆离设备部署点越来越近；"Leave"-下行,
        // 即车辆离设备部署点越来越远,第二和第三个参数分别代表上行和
        // 下行的两个地点,UTF-8编码
        public byte[]              szMachineName = new byte[256];              // 本地或远程设备名称
        public byte[]              szMachineAddress = new byte[256];           // 机器部署地点、道路编码
        public byte[]              szMachineGroup = new byte[256];             // 机器分组、设备所属单位
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_SIG_CARWAY_INFO_EX stuSigInfo;                              // 由车检器产生抓拍信号冗余信息
        public byte[]              szFilePath = new byte[MAX_PATH];            // 文件路径
        public NET_TIME_EX         RedLightUTC;                                // 红灯开始UTC时间
        public Pointer             szDeviceAddress;                            // 设备地址,OSD叠加到图片上的,来源于配置TrafficSnapshot.DeviceAddress,'\0'结束
        public float               fActualShutter;                             // 当前图片曝光时间,单位为毫秒
        public byte                byActualGain;                               // 当前图片增益,范围为0~100
        public byte                byDirection;                                // 0-南向北 1-西南向东北 2-西向东 3-西北向东南 4-北向南 5-东北向西南 6-东向西 7-东南向西北 8-未知
        public byte                bReserve;                                   // 保留字节, 字节对齐
        public byte                bRetCardNumber;                             // 卡片个数
        public EVENT_CARD_INFO[]   stuCardInfo = (EVENT_CARD_INFO[])new EVENT_CARD_INFO().toArray(NET_EVENT_MAX_CARD_NUM);// 卡片信息
        public byte[]              szDefendCode = new byte[NET_COMMON_STRING_64];           // 图片防伪码
        public int                 nTrafficBlackListID;                         // 关联黑名单数据库记录默认主键ID, 0,无效；> 0,黑名单数据记录
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
        public byte[]              bReserved = new byte[452];                  // 保留字节,留待扩展.
    }

    //事件类型EVENT_IVS_TRAFFIC_RUNREDLIGHT(交通-闯红灯事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_RUNREDLIGHT_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                     // 事件名称
        public byte[]              bReserved1 = new byte[4];                   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public int                 nLane;                                      // 对应车道号
        public NET_MSG_OBJECT      stuObject;                                  // 车牌信息
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public int                 nLightState;                                // 红绿灯状态 0:未知 1：绿灯 2:红灯 3:黄灯
        public int                 nSpeed;                                     // 车速,km/h
        public int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_TIME_EX         stRedLightUTC;                              // 红灯开始时间
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public byte                byRedLightMargin;                           // 红灯容许间隔时间,单位：秒
        public byte[]              byAlignment = new byte[3];                  // 字节对齐
        public int                 nRedLightPeriod;                            // 表示红灯周期时间,单位毫秒
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
        public byte[]              bReserved = new byte[928];                  // 保留字节
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
        public Boolean				bHasNonMotor;								// 是否有非机动车对象
        public VA_OBJECT_NONMOTOR	stuNonMotor;								// 非机动车对象
    }

    //事件类型EVENT_IVS_TRAFFIC_OVERLINE(交通-压线事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_OVERLINE_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                     // 事件名称
        public byte[]              bReserved1 = new byte[4];                   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public int                 nLane;                                      // 对应车道号
        public NET_MSG_OBJECT      stuObject;                                  // 车牌信息
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public int                 nSpeed;                                     // 车辆实际速度,Km/h
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
        public byte[]              bReserved = new byte[968];                  // 保留字节
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    }

    // 事件类型EVENT_IVS_TRAFFIC_RETROGRADE(交通-逆行事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_RETROGRADE_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                     // 事件名称
        public byte[]              bReserved1 = new byte[4];                   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public int                 nLane;                                      // 对应车道号
        public NET_MSG_OBJECT      stuObject;                                  // 车牌信息
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public NET_EVENT_FILE_INFO  stuFileInfo;                               // 事件对应文件信息
        public int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public int                 nSpeed;                                     // 车辆实际速度,Km/h
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO  stuResolution;                             // 对应图片的分辨率
        public int                bIsExistAlarmRecord;                         // rue:有对应的报警录像; false:无对应的报警录像
        public int                dwAlarmRecordSize;                           // 录像大小
        public byte[]             szAlarmRecordPath = new byte[NET_COMMON_STRING_256];    // 录像路径
        public EVENT_INTELLI_COMM_INFO      intelliCommInfo;                   // 智能事件公共信息
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
        public byte[]              bReserved = new byte[484];                  // 保留字节
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
        public int                 nDetectNum;                                 // 规则检测区域顶点数
        public NET_POINT[]         DetectRegion = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM); // 规则检测区域
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
        public Boolean				bHasNonMotor;								// 是否有非机动车对象
        public VA_OBJECT_NONMOTOR	stuNonMotor;								// 非机动车对象
    }

    //事件类型EVENT_IVS_TRAFFIC_OVERSPEED(交通超速事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_OVERSPEED_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                     // 事件名称
        public byte[]              bReserved1 = new byte[4];                   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public int                 nLane;                                      // 对应车道号
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public int                 nSpeed;                                     // 车辆实际速度Km/h
        public int                 nSpeedUpperLimit;                           // 速度上限 单位：km/h
        public int                 nSpeedLowerLimit;                           // 速度下限 单位：km/h
        public int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public byte[]              szFilePath = new byte[MAX_PATH];            // 文件路径
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息  车载定制
        public int                 nSpeedingPercentage;                        // 超速百分比
        public byte[]              bReserved = new byte[572];                  // 保留字节
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    }

    //事件类型EVENT_IVS_TRAFFIC_UNDERSPEED(交通欠速事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_UNDERSPEED_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                     // 事件名称
        public byte[]              bReserved2 = new byte[4];                   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public int                 nLane;                                      // 对应车道号
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public int                 nSpeed;                                     // 车辆实际速度Km/h
        public int                 nSpeedUpperLimit;                           // 速度上限 单位：km/h
        public int                 nSpeedLowerLimit;                           // 速度下限 单位：km/h
        public int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              bReserved1 = new byte[2];                   // 对齐
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 nUnderSpeedingPercentage;                   // 欠速百分比
        public int               dwSnapFlagMask;                               // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO  stuResolution;                             // 对应图片的分辨率
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
        public byte[]              bReserved = new byte[832];                  // 保留字节
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    }

    //事件类型EVENT_IVS_TRAFFIC_WRONGROUTE(交通违章-不按车道行驶)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_WRONGROUTE_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                     // 事件名称
        public byte[]              bReserved1 = new byte[4];                   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public int                 nLane;                                      // 对应车道号
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 nSpeed;                                     // 车辆实际速度,km/h
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
        public byte[]              bReserved = new byte[972];                  // 保留字节,留待扩展.
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    }

    // 事件类型 EVENT_IVS_TRAFFIC_TURNLEFT(交通-违章左转)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_TURNLEFT_INFO extends SdkStructure
    {
        public int                 		nChannelID;                                 	// 通道号
        public byte[]                	szName = new byte[128];                         // 事件名称
        public byte[]                	bReserved1 = new byte[4];                       // 字节对齐
        public double              		PTS;                                        	// 时间戳(单位是毫秒)
        public NET_TIME_EX         		UTC ;                        					// 事件发生的时间
        public int                 		nEventID;                                   	// 事件ID
        public int                 		nLane;                                      	// 对应车道号
        public NET_MSG_OBJECT       	stuObject;               						// 车牌信息
        public NET_MSG_OBJECT       	stuVehicle;              						// 车身信息
        public NET_EVENT_FILE_INFO  	stuFileInfo;        							// 事件对应文件信息
        public int                 		nSequence;                                  	// 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public int                 		nSpeed;                                     	// 车辆实际速度,Km/h
        public byte                		bEventAction;                               	// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]                	byReserved = new byte[2];
        public byte                		byImageIndex;                               	// 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int               		dwSnapFlagMask;                             	// 抓图标志(按位),具体见  NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO  	stuResolution;     							 	// 对应图片的分辨率
        public NET_GPS_INFO        		stuGPSInfo;                                		// GPS信息 车载定制
        public byte[]                	bReserved = new byte[968];                      // 保留字节
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;   						// 交通车辆信息
        public EVENT_COMM_INFO     		stCommInfo;             						// 公共信息
    }

    // 事件类型 EVENT_IVS_TRAFFIC_TURNRIGHT (交通-违章右转)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_TURNRIGHT_INFO extends SdkStructure
    {
        public int                 		nChannelID;                                 	// 通道号
        public byte[]                	szName = new byte[128];                         // 事件名称
        public byte[]                	bReserved1 = new byte[4];                       // 字节对齐
        public double              		PTS;                                        	// 时间戳(单位是毫秒)
        public NET_TIME_EX         		UTC;                                        	// 事件发生的时间
        public int                 		nEventID;                                   	// 事件ID
        public int                 		nLane;                                      	// 对应车道号
        public NET_MSG_OBJECT       	stuObject;                                  	// 车牌信息
        public NET_MSG_OBJECT       	stuVehicle;                                 	// 车身信息
        public NET_EVENT_FILE_INFO  	stuFileInfo;                                	// 事件对应文件信息
        public int                 		nSequence;                                  	// 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public int                 		nSpeed;                                     	// 车辆实际速度,Km/h
        public byte                		bEventAction;                               	// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]                	byReserved = new byte[2];
        public byte                		byImageIndex;                               	// 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int               		dwSnapFlagMask;                             	// 抓图标志(按位),具体见  NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO  	stuResolution;                              	// 对应图片的分辨率
        public NET_GPS_INFO        		stuGPSInfo;                                 	// GPS信息 车载定制
        public byte[]                	bReserved = new byte[968];                      // 保留字节
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 			// 交通车辆信息
        public EVENT_COMM_INFO     		stCommInfo;                                 	// 公共信息
    }

    // 事件类型EVENT_IVS_TRAFFIC_UTURN(违章调头事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_UTURN_INFO extends SdkStructure
    {
        public int                 		nChannelID;                                 	// 通道号
        public byte[]                	szName = new byte[128];                         // 事件名称
        public byte[]                	bReserved1 = new byte[4];                       // 字节对齐
        public double              		PTS;                                        	// 时间戳(单位是毫秒)
        public NET_TIME_EX         		UTC;                                        	// 事件发生的时间
        public int                 		nEventID;                                   	// 事件ID
        public int                 		nLane;                                      	// 对应车道号
        public NET_MSG_OBJECT       	stuObject;                                  	// 车牌信息
        public NET_MSG_OBJECT       	stuVehicle;                                 	// 车身信息
        public NET_EVENT_FILE_INFO  	stuFileInfo;                                	// 事件对应文件信息
        public int                 		nSequence;                                  	// 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public int                 		nSpeed;                                     	// 车辆实际速度,Km/h
        public byte                		bEventAction;                               	// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]                	byReserved = new byte[2];
        public byte                		byImageIndex;                               	// 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int               		dwSnapFlagMask;                             	// 抓图标志(按位),具体见  NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO  	stuResolution;                              	// 对应图片的分辨率
        public NET_GPS_INFO        		stuGPSInfo;                                     // GPS信息 车载定制
        public byte[]                	bReserved = new byte[968];                      // 保留字节
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 			// 交通车辆信息
        public EVENT_COMM_INFO     		stCommInfo;                                 	// 公共信息
    }

    //事件类型 EVENT_IVS_TRAFFIC_RUNYELLOWLIGHT(交通违章-闯黄灯事件)对应数据块描述信息
    public static class DEV_EVENT_TRAFFIC_RUNYELLOWLIGHT_INFO extends SdkStructure
    {
        public int                 		nChannelID;                                 	// 通道号
        public byte[]                	szName = new byte[128];                         // 事件名称
        public byte[]                	bReserved1 = new byte[4];                       // 字节对齐
        public double              		PTS;                                        	// 时间戳(单位是毫秒)
        public NET_TIME_EX         		UTC;                                        	// 事件发生的时间
        public int                 		nEventID;                                   	// 事件ID
        public int                 		nLane;                                      	// 对应车道号
        public NET_MSG_OBJECT       	stuObject;                                  	// 车牌信息
        public NET_MSG_OBJECT       	stuVehicle;                                 	// 车身信息
        public NET_EVENT_FILE_INFO  	stuFileInfo;                                	// 事件对应文件信息
        public int                 		nLightState;                                	// 红绿灯状态 0:未知 1：绿灯 2:红灯 3:黄灯
        public int                 		nSpeed;                                     	// 车速,km/h
        public int                 		nSequence;                                  	// 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public byte                		bEventAction;                               	// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]                	byReserved = new byte[2];
        public byte                		byImageIndex;                               	// 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int               		dwSnapFlagMask;                             	// 抓图标志(按位),具体见  NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_TIME_EX         		stYellowLightUTC;                           	// 黄灯开始时间
        public int        				nYellowLightPeriod;                         	// 黄灯周期间隔时间,单位秒
        public NET_RESOLUTION_INFO  	stuResolution;                              	// 对应图片的分辨率
        public byte               		byRedLightMargin;                           	// 黄灯容许间隔时间,单位：秒
        public byte[]                	szSourceDevice = new byte[MAX_PATH];            // 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 			// 交通车辆信息
        public byte[]                	bReserved = new byte[1024];                     // 保留字节
        public EVENT_COMM_INFO     		stCommInfo;                                 	// 公共信息

    }

    //事件类型EVENT_IVS_TRAFFIC_OVERYELLOWLINE(交通违章-压黄线)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_OVERYELLOWLINE_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                     // 事件名称
        public byte[]              bReserved1 = new byte[4];                   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public int                 nLane;                                      // 对应车道号
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 nSpeed;                                     // 车辆实际速度,km/h
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public int                 bIsExistAlarmRecord;                        // bool 类型： 1:有对应的报警录像; 0:无对应的报警录像
        public int                 dwAlarmRecordSize;                          // 录像大小
        public byte[]              szAlarmRecordPath = new byte[NET_COMMON_STRING_256]; // 录像路径
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
        public byte[]              bReserved = new byte[532];                  // 保留字节,留待扩展.
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息

        public int                 nDetectNum;                                 // 规则检测区域顶点数
        public NET_POINT[]         DetectRegion = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM); // 规则检测区域
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    }

    //事件类型EVENT_IVS_TRAFFIC_YELLOWPLATEINLANE(交通违章-黄牌车占道事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_YELLOWPLATEINLANE_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                     // 事件名称
        public byte[]              bReserved1 = new byte[4];                   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public int                 nLane;                                      // 对应车道号
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 nSpeed;                                     // 车辆实际速度,km/h
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public byte[]              bReserved = new byte[1016];                 // 保留字节,留待扩展.
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    }

    //事件类型 EVENT_IVS_TRAFFIC_VEHICLEINROUTE(有车占道事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_VEHICLEINROUTE_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                     // 事件名称
        public byte[]              bReserved1 = new byte[4];                   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public int                 nLane;                                      // 对应车道号
        public int                 nSequence;                                  // 抓拍序号,如3-2-1/0,1表示抓拍正常结束,0表示抓拍异常结束
        public int                 nSpeed;                                     // 车速
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 表示交通车辆的数据库记录
        public NET_EVENT_FILE_INFO  stuFileInfo;                               // 事件对应文件信息
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved0 = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO  stuResolution;                             // 对应图片的分辨率
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
        public byte[]              byReserved = new byte[884];
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    }

    //事件类型EVENT_IVS_TRAFFIC_CROSSLANE(交通违章-违章变道)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_CROSSLANE_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                                // 事件名称
        public byte[]              bReserved1 = new byte[4];                              // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public int                 nLane;                                      // 对应车道号
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                nSpeed;                                     // 车辆实际速度,km/h
        public int                 dwSnapFlagMask;                               // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO  stuResolution;                             // 对应图片的分辨率
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
        public byte[]              bReserved = new byte[836];                   // 保留字节,留待扩展.留待扩展.
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;                // 交通车辆信息
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    }

    // 事件类型EVENT_IVS_TRAFFIC_NOPASSING(交通违章-禁止通行事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_NOPASSING_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[NET_EVENT_NAME_LEN];      // 事件名称
        public int                 nTriggerType;                               // TriggerType:触发类型,0车检器,1雷达,2视频
        public int                 PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public int                 UTCMS;                                      //
        public int                 nMark;                                      // 底层产生的触发抓拍帧标记
        public int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public NET_EVENT_FILE_INFO  stuFileInfo;                               // 事件对应文件信息
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
        public int               dwSnapFlagMask;                               // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO  stuResolution;                             // 对应图片的分辨率
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public byte[]              byReserved1 = new byte[3];
        public int                 nLane;                                      // 对应车道号
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public int                 nFrameSequence;                             // 视频分析帧序号
        public int                 nSource;                                    // 视频分析的数据源地址
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
        public byte[]              byReserved = new byte[984];                // 保留字节
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    }

    //事件类型 EVENT_IVS_TRAFFIC_PEDESTRAINPRIORITY(斑马线行人优先事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_PEDESTRAINPRIORITY_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                     // 事件名称
        public byte[]              bReserved1 = new byte[4];                   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_MSG_OBJECT       stuObject;                                 // 检测到的物体
        public NET_MSG_OBJECT       stuVehicle;                                // 车身信息
        public NET_EVENT_FILE_INFO  stuFileInfo;                               // 事件对应文件信息
        public int                 nLane;                                      // 对应车道号
        public double              dInitialUTC;                                // 事件初始UTC时间    UTC为事件的UTC (1970-1-1 00:00:00)秒数。
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 表示交通车辆的数据库记录
        public NET_RESOLUTION_INFO  stuResolution;                             // 对应图片的分辨率
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
        public byte[]              bReserved = new byte[984];                  // 保留字节,留待扩展.
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

    }

    //事件类型 EVENT_IVS_TRAFFIC_VEHICLEINBUSROUTE(占用公交车道事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_VEHICLEINBUSROUTE_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                     // 事件名称
        public byte[]              bReserved1 = new byte[4];                   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_MSG_OBJECT       stuObject;                                 // 检测到的物体
        public NET_MSG_OBJECT       stuVehicle;                                // 车身信息
        public NET_EVENT_FILE_INFO  stuFileInfo;                               // 事件对应文件信息
        public int                 nLane;                                      // 对应车道号
        public int                 nSequence;                                  // 抓拍序号,如3-2-1/0,1表示抓拍正常结束,0表示抓拍异常结束
        public int                 nSpeed;                                     // 车速,km/h
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int               dwSnapFlagMask;                               // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 表示交通车辆的数据库记录
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
        public byte[]              bReserved = new byte[980];                  // 保留字节,留待扩展.
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

    }

    //事件类型 EVENT_IVS_TRAFFIC_BACKING(违章倒车事件)对应的数据块描述信息
    public static class DEV_EVENT_IVS_TRAFFIC_BACKING_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                     // 事件名称
        public byte[]              bReserved1 = new byte[4];                   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_MSG_OBJECT       stuObject;                                 // 检测到的物体
        public NET_MSG_OBJECT       stuVehicle;                                // 车身信息
        public NET_EVENT_FILE_INFO  stuFileInfo;                               // 事件对应文件信息
        public int                 nLane;                                      // 对应车道号
        public int                 nSequence;                                  // 抓拍序号,如3-2-1/0,1表示抓拍正常结束,0表示抓拍异常结束
        public int                 nSpeed;                                     // 车速,km/h
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 表示交通车辆的数据库记录
        public NET_RESOLUTION_INFO  stuResolution;                             // 对应图片的分辨率
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
        public byte[]              bReserved = new byte[848];                  // 保留字节,留待扩展.
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

    }

    // GPS信息
    public static class NET_GPS_INFO extends SdkStructure
    {
        public int                  nLongitude;         	    // 经度(单位是百万分之一度)
        // 西经：0 - 180000000				实际值应为: 180*1000000 – dwLongitude
        // 东经：180000000 - 360000000		实际值应为: dwLongitude – 180*1000000
        // 如: 300168866应为（300168866 - 180*1000000）/1000000 即东经120.168866度
        public int					nLatidude;                  // 纬度(单位是百万分之一度)
        // 南纬：0 - 90000000				实际值应为: 90*1000000 – dwLatidude
        // 北纬：90000000 – 180000000		实际值应为: dwLatidude – 90*1000000
        // 如: 120186268应为 (120186268 - 90*1000000)/1000000 即北纬30. 186268度
        public double              dbAltitude;                  // 高度,单位为米
        public double              dbSpeed;                     // 速度,单位km/H
        public double              dbBearing;                   // 方向角,单位°
        public byte[]              bReserved = new byte[8];     // 保留字段

        protected int getNativeAlignment(Class<?> type, Object value, boolean isFirstElement) {
            int alignment = super.getNativeAlignment(type, value, isFirstElement);
            return Math.min(4, alignment);
        }
    }

    // 事件类型 EVENT_IVS_TRAFFIC_OVERSTOPLINE (压停车线事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_OVERSTOPLINE extends SdkStructure
    {
        public int                     nChannelID;                     // 通道号
        public byte[]                  szName = new byte[128];         // 事件名称
        public int                     nTriggerType;                   // TriggerType:触发类型,0车检器,1雷达,2视频
        public int                     PTS;                            // 时间戳(单位是毫秒)
        public NET_TIME_EX             UTC;                            // 事件发生的时间
        public int                     nEventID;                       // 事件ID
        public int                     nSequence;                      // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public byte                    byEventAction;                  // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte                    byImageIndex;                   // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public byte[]                  byReserved1 = new byte[2];
        public int                     nLane;                          // 对应车道号
        public NET_MSG_OBJECT          stuObject;                      // 检测到的物体
        public NET_MSG_OBJECT          stuVehicle;                     // 车身信息
        public NET_EVENT_FILE_INFO     stuFileInfo;                    // 事件对应文件信息
        public int                     nMark;                          // 底层产生的触发抓拍帧标记
        public int                     nFrameSequence;                 // 视频分析帧序号
        public int                     nSource;                        // 视频分析的数据源地址
        public int                     dwSnapFlagMask;                 // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO     stuResolution;                  // 对应图片的分辨率
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // 交通车辆信息
        public int                     nSpeed;                         // 车辆实际速度,Km/h
        public NET_GPS_INFO            stuGPSInfo;                     // GPS信息 车载定制
        public byte[]                  byReserved = new byte[984];    // 保留字节
        public EVENT_COMM_INFO         stCommInfo;                     // 公共信息
        public boolean					bHasNonMotor;					// 	stuNonMotor 字段是否有效
        public VA_OBJECT_NONMOTOR		stuNonMotor;					// 非机动车对象

    }

    //事件类型 EVENT_IVS_TRAFFIC_PARKINGONYELLOWBOX(黄网格线抓拍事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_PARKINGONYELLOWBOX_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                     // 事件名称
        public byte[]              bReserved1 = new byte[8];                   // 字节对齐
        public int                 PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public int                 nLane;                                      // 对应车道号
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息

        public int                 nInterval1;                                 // 第二张和第一张的延时时间,单位秒
        public int                 nInterval2;                                 // 第三张和第二张的延时时间,单位秒
        public int                 nFollowTime;                                // 跟随时间,如果一辆车与前一辆车进入黄网格的时间差小于此值,就认为是跟车进入,跟车进入情况下如果停车则不算违章

        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
        public byte[]              bReserved = new byte[984];                  // 保留字节
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

    }

    // 事件类型EVENT_IVS_TRAFFIC_WITHOUT_SAFEBELT(交通未系安全带事件事件)对应的数据块描述信息
    public static class  DEV_EVENT_TRAFFIC_WITHOUT_SAFEBELT extends SdkStructure
    {
        public int                     nChannelID;                     // 通道号
        public byte[]                  szName = new byte[128];      // 事件名称
        public int                     nTriggerType;                   // TriggerType:触发类型,0车检器,1雷达,2视频
        public int                     PTS;                            // 时间戳(单位是毫秒)
        public NET_TIME_EX             UTC;                            // 事件发生的时间
        public int                     nEventID;                       // 事件ID
        public int                     nSequence;                      // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public byte                    byEventAction;                  // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;    public byte                    byReserved1[2];
        public byte                    byImageIndex;                   // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public byte[]                  byReserved1 = new byte[2];
        public NET_EVENT_FILE_INFO     stuFileInfo;                    // 事件对应文件信息
        public int                     nLane;                          // 对应车道号
        public int                     nMark;                          // 底层产生的触发抓拍帧标记
        public int                     nFrameSequence;                 // 视频分析帧序号
        public int                     nSource;                        // 视频分析的数据源地址
        public NET_MSG_OBJECT          stuObject;                      // 检测到的物体
        public NET_MSG_OBJECT          stuVehicle;                     // 车身信息
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;        // 交通车辆信息
        public int                     nSpeed;                         // 车辆实际速度,Km/h
        public int      				emMainSeat;                     // 主驾驶座位安全带状态   参考 NET_SAFEBELT_STATE
        public int      				emSlaveSeat;                    // 副驾驶座位安全带状态 参考 NET_SAFEBELT_STATE
        public int                     dwSnapFlagMask;                 // 抓图标志(按位),具体见NET_RESERVED_COMMON , 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO     stuResolution;                  // 对应图片的分辨率
        public NET_GPS_INFO            stuGPSInfo;                     // GPS信息 车载定制
        public byte[]                  byReserved = new byte[984];    // 保留字节
        public EVENT_COMM_INFO         stCommInfo;                     // 公共信息

    }

    //事件类型EVENT_IVS_TRAFFIC_JAM_FORBID_INTO(交通拥堵禁入事件)对应的数据块描述信息
    public static class DEV_EVENT_ALARM_JAMFORBIDINTO_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[NET_EVENT_NAME_LEN];      // 事件名称
        public byte[]              bReserved1 = new byte[4];                   // 字节对齐
        public int                 PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEveID;                                     // 事件ID
        ///////////////////////////////以上为公共字段//////////////////////////////
        public NET_EVENT_FILE_INFO stuFileInfo;                               	// 事件对应文件信息
        public int					nMark;										// 底层产生的触发抓拍帧标记
        public int					nSource;									// 视频分析的数据源地址
        public int					nSequence;									// 表示抓拍序号,如3-2-1/0,1表示抓拍正常结束,0表示抓拍异常结束
        public int					nFrameSequence;								// 帧序号
        public int					nLane;										// 车道号
        public byte                byImageIndex;                   			// 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public NET_MSG_OBJECT      stuObject;                      			// 检测到的物体
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
        public byte[]              bReserved = new byte[984];                	// 保留字节
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;                // 交通车辆信息
        public EVENT_COMM_INFO     stCommInfo;                     			// 公共信息
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
    }

    //事件类型EVENT_IVS_TRAFFIC_PASSNOTINORDER(交通-未按规定依次通过)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_PASSNOTINORDER_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[NET_EVENT_NAME_LEN];      // 事件名称
        public byte[]              bReserved1 = new byte[4];                   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public int                 nLane;                                      // 对应车道号
        public NET_MSG_OBJECT      stuObject;                                  // 车牌信息
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON , 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO  stuResolution;                             // 对应图片的分辨率
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制
        public byte[]              bReserved = new byte[984];                  // 保留字节
    }

    //事件类型EVENT_IVS_TRAFFIC_MANUALSNAP(交通手动抓拍事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_MANUALSNAP_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[128];                     // 事件名称
        public byte[]              bReserved1 = new byte[4];                   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public int                 nLane;                                      // 对应车道号
        public byte[]              szManualSnapNo = new byte[64];              // 手动抓拍序号
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public NET_MSG_OBJECT      stuVehicle;                                 // 检测到的车身信息
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 表示交通车辆的数据库记录
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte                byOpenStrobeState;                          // 开闸状态, 具体请见 EM_OPEN_STROBE_STATE
        public byte[]              byReserved = new byte[1];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON , 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public byte[]              bReserved = new byte[504];            	   // 保留字节,留待扩展.
        public EVENT_MANUALSNAP_CUSTOM_DATA   stuCustom;                       // 手动抓拍专用上报内容
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息
    }

    // 手动抓拍专用上报定制内容
    public static class EVENT_MANUALSNAP_CUSTOM_DATA extends SdkStructure
    {
        public EVENT_CUSTOM_WEIGHT_INFO       stuWeighInfo;                         // 建委地磅定制称重信息
        public byte[]                         byReserved = new byte[472];           // 保留字节
    }

    // 事件类型 EVENT_IVS_CROSSLINEDETECTION(警戒线事件)对应的数据块描述信息
    public static class DEV_EVENT_CROSSLINE_INFO extends SdkStructure {
        public int                 nChannelID;                         // 通道号
        public byte[]              szName = new byte[128];             // 事件名称
        public byte[]              bReserved1 = new byte[4];           // 字节对齐
        public double              PTS;                                // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                // 事件发生的时间
        public int                 nEventID;                           // 事件ID
        public NET_MSG_OBJECT      stuObject;                          // 检测到的物体
        public NET_EVENT_FILE_INFO stuFileInfo;                        // 事件对应文件信息
        public NET_POINT[]         DetectLine = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_LINE_NUM);// 规则检测线
        public int                 nDetectLineNum;                     // 规则检测线顶点数
        public NET_POINT[]         TrackLine = (NET_POINT[])new NET_POINT().toArray(NET_MAX_TRACK_LINE_NUM);   // 物体运动轨迹
        public int                 nTrackLineNum;                      // 物体运动轨迹顶点数
        public byte                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte                bDirection;                         // 表示入侵方向, 0-由左至右, 1-由右至左
        public byte[]              byReserved=new byte[1];
        public byte                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                     // 抓图标志(按位),具体见  NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效,-1表示数据无效
        public byte[]              szSourceDevice = new byte[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int                 nOccurrenceCount;                   		   // 事件触发累计次数, 类型为unsigned int
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
        public NET_EXTENSION_INFO  stuExtensionInfo;                   // 扩展信息
        public SCENE_IMAGE_INFO_EX stuSceneImage;                      // 全景广角图
        public int                 nObjetcHumansNum;                   // 检测到人的数量
        public NET_VAOBJECT_NUMMAN []stuObjetcHumans = (NET_VAOBJECT_NUMMAN [])new NET_VAOBJECT_NUMMAN().toArray(100);                // 检测的到人
        public byte			       byReserved1[] = new byte[512];
    }

    /**
     * 检测到的人信息
     * @author 29779
     */
    public static class NET_VAOBJECT_NUMMAN extends SdkStructure {
        public int                	nObjectID;                          // 物体ID，每个ID表示一个唯一的物体
        /**
         * @link EM_UNIFORM_STYLE 制服样式
         */
        public int  				emUniformStyle;
        public NET_RECT				stuBoundingBox;                     // 包围盒,手套对象在全景图中的框坐标,为0~8191相对坐标
        public NET_RECT				stuOriginalBoundingBox;             // 包围盒,绝对坐标
        public byte[] 				byReserved = new byte[128];         // 预留字节
    }

    // 事件类型 EVENT_IVS_CROSSREGIONDETECTION(警戒区事件)对应的数据块描述信息
    public static class DEV_EVENT_CROSSREGION_INFO extends SdkStructure {
        public int                 nChannelID;                         // 通道号
        public byte[]              szName = new byte[128];             // 事件名称
        public byte[]              bReserved1 = new byte[4];           // 字节对齐
        public double              PTS;                                // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                // 事件发生的时间
        public int                 nEventID;                           // 事件ID
        public NET_MSG_OBJECT      stuObject;                          // 检测到的物体
        public NET_EVENT_FILE_INFO stuFileInfo;                        // 事件对应文件信息
        public NET_POINT[]         DetectRegion = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM); // 规则检测区域
        public int                 nDetectRegionNum;                   // 规则检测区域顶点数
        public NET_POINT[]         TrackLine = (NET_POINT[])new NET_POINT().toArray(NET_MAX_TRACK_LINE_NUM);   // 物体运动轨迹
        public int                 nTrackLineNum;                      // 物体运动轨迹顶点数
        public byte                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte                bDirection;                         // 表示入侵方向, 0-进入, 1-离开,2-出现,3-消失
        public byte                bActionType;                        // 表示检测动作类型,0-出现 1-消失 2-在区域内 3-穿越区域
        public byte                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON , 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
        public byte[]              szSourceDevice = new byte[MAX_PATH];// 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int        		   nOccurrenceCount;                   // 事件触发累计次数, unsigned int 类型
        public NET_CUSTOM_INFO     stuCustom;							// 货物通道信息
        public NET_EXTENSION_INFO  stuExtensionInfo;                   // 扩展信息
        public byte[]              bReserved = new byte[328];          // 保留字节,留待扩展.
        public int                 nObjectNum;                         // 检测到的物体个数
        public NET_MSG_OBJECT[]    stuObjectIDs = (NET_MSG_OBJECT[]) new NET_MSG_OBJECT().toArray(NET_MAX_OBJECT_LIST);   // 检测到的物体
        public int                 nTrackNum;                          // 轨迹数(与检测到的物体个数  nObjectNum 对应)
        public NET_POLY_POINTS[]   stuTrackInfo = (NET_POLY_POINTS[]) new NET_POLY_POINTS().toArray(NET_MAX_OBJECT_LIST);   // 轨迹信息(与检测到的物体对应)
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
        public SCENE_IMAGE_INFO_EX         stuSceneImage;              // 全景广角图
        public int                nObjetcHumansNum;                   // 检测到人的数量
        public NET_VAOBJECT_NUMMAN[] stuObjetcHumans = (NET_VAOBJECT_NUMMAN[])new NET_VAOBJECT_NUMMAN().toArray(100);               // 检测的到人       
        public NET_MSG_OBJECT     stuVehicle;                                         //车身信息
        public int                emTriggerType;                                       //触发类型,参考EM_TRIGGER_TYPE
        public int                nMark;                                              // 标记抓拍帧
        public int                nSource;                                            // 视频分析的数据源地址
        public int                nFrameSequence;                                            // 视频分析帧序号
        public int                emCaptureProcess;                                         // 抓拍过程,参考EM_CAPTURE_PROCESS_END_TYPE
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO  stTrafficCar;                   //交通车辆信息
        public EVENT_COMM_INFO                    stuCommInfo;                    //公共信息
    }

    // 事件类型 EVENT_IVS_WANDERDETECTION(徘徊事件)对应的数据块描述信息
    public static class DEV_EVENT_WANDER_INFO extends SdkStructure {
        public int                 nChannelID;                         // 通道号
        public byte[]              szName = new byte[128];             // 事件名称
        public byte[]              bReserved1 = new byte[4];           // 字节对齐
        public double              PTS;                                // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                // 事件发生的时间
        public int                 nEventID;                           // 事件ID
        public NET_EVENT_FILE_INFO  stuFileInfo;                       // 事件对应文件信息
        public byte                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];           // 保留字节
        public byte                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 nObjectNum;                         // 检测到的物体个数
        public NET_MSG_OBJECT[]    stuObjectIDs = (NET_MSG_OBJECT[]) new NET_MSG_OBJECT().toArray(NET_MAX_OBJECT_LIST);   // 检测到的物体
        public int                 nTrackNum;                          // 轨迹数(与检测到的物体个数对应)
        public NET_POLY_POINTS[]   stuTrackInfo = (NET_POLY_POINTS[]) new NET_POLY_POINTS().toArray(NET_MAX_OBJECT_LIST);   // 轨迹信息(与检测到的物体对应)
        public int                 nDetectRegionNum;                   // 规则检测区域顶点数
        public NET_POINT[]         DetectRegion = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM);    // 规则检测区域
        public int                 dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON , 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
        public byte[]              szSourceDevice = new byte[MAX_PATH]; // 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int        		   nOccurrenceCount;                   // 事件触发累计次数, unsigned int 类型
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
        public short               nPreserID;                          // 事件触发的预置点号，从1开始（没有表示未知）
        public byte[]              szPresetName = new byte[64];        // 事件触发的预置名称
        public NET_EXTENSION_INFO  stuExtensionInfo;                   // 扩展信息
        public byte[]              bReserved = new byte[426];          // 保留字节,留待扩展.
    }

    //事件类型 EVENT_IVS_LEAVEDETECTION(离岗检测事件)对应数据块描述信息
    public static class DEV_EVENT_IVS_LEAVE_INFO extends SdkStructure {
        public int                 nChannelID;                         // 通道号
        public byte[]              szName = new byte[128];             // 事件名称
        public byte[]              bReserved1 = new byte[4];           // 字节对齐
        public double              PTS;                                // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                // 事件发生的时间
        public int                 nEventID;                           // 事件ID
        public NET_MSG_OBJECT      stuObject;                          // 检测到的物体
        public NET_EVENT_FILE_INFO stuFileInfo;                        // 事件对应文件信息
        public NET_RESOLUTION_INFO stuResolution;                      // 对应图片的分辨率
        public int                 nDetectRegionNum;                   // 规则检测区域顶点数
        public NET_POINT[]         DetectRegion = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM);// 规则检测区域
        public byte                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息    
        public int emTriggerMode;                                      // 离岗的触发模式,参考EM_LEAVEDETECTION_TRIGGER_MODE
        public int emState;                                            // 检测状态,参考EM_LEAVEDETECTION_STATE
        public int bSceneImage;                                        // stuSceneImage 是否有效
        public SCENE_IMAGE_INFO_EX stuSceneImage;                      // 全景广角图                
        public byte[]              bReserved = new byte[94];           // 保留字节
    }

    //事件类型 EVENT_IVS_AUDIO_ABNORMALDETECTION(声音异常检测)对应数据块描述信息
    public static class DEV_EVENT_IVS_AUDIO_ABNORMALDETECTION_INFO extends SdkStructure {
        public int                 nChannelID;                         // 通道号
        public byte[]              szName = new byte[128];             // 事件名称
        public byte[]              bReserved1 = new byte[4];           // 字节对齐
        public double              PTS;                                // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                // 事件发生的时间
        public int                 nEventID;                           // 事件ID
        public NET_EVENT_FILE_INFO  stuFileInfo;                       // 事件对应文件信息
        public int                 nDecibel;                           // 声音强度
        public int                 nFrequency;                         // 声音频率
        public byte                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];
        public byte                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO stuResolution;                      // 对应图片的分辨率
        public byte[]              bReserved = new byte[1024];         // 保留字节,留待扩展.
    }

    //事件类型 EVENT_IVS_CLIMBDETECTION(攀高检测事件)对应数据块描述信息
    public static class DEV_EVENT_IVS_CLIMB_INFO extends SdkStructure {
        public int                 nChannelID;                         // 通道号
        public byte[]              szName = new byte[128];             // 事件名称
        public byte[]              bReserved1 = new byte[4];           // 字节对齐
        public double              PTS;                                // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                // 事件发生的时间
        public int                 nEventID;                           // 事件ID
        public NET_MSG_OBJECT      stuObject;                          // 检测到的物体
        public NET_EVENT_FILE_INFO stuFileInfo;                        // 事件对应文件信息
        public NET_RESOLUTION_INFO stuResolution;                      // 对应图片的分辨率
        public int                 nDetectLineNum;                     // 规则检测线顶点数
        public NET_POINT[]         DetectLine = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_LINE_NUM);         // 规则检测线
        public byte                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int        		   nOccurrenceCount;                   // 事件触发累计次数, unsigned int
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
        public byte[]              bReserved = new byte[890];          // 保留字节
    }

    // 事件类型 EVENT_IVS_FIGHTDETECTION(斗殴事件)对应的数据块描述信息
    public static class DEV_EVENT_FIGHT_INFO extends SdkStructure {
        public int                 nChannelID;                         // 通道号
        public byte[]              szName = new byte[128];             // 事件名称
        public byte[]              bReserved1 = new byte[4];           // 字节对齐
        public double              PTS;                                // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                // 事件发生的时间
        public int                 nEventID;                           // 事件ID
        public int                 nObjectNum;                         // 检测到的物体个数
        public NET_MSG_OBJECT[]    stuObjectIDs = (NET_MSG_OBJECT[])new NET_MSG_OBJECT().toArray(NET_MAX_OBJECT_LIST);   // 检测到的物体列表
        public NET_EVENT_FILE_INFO  stuFileInfo;                       // 事件对应文件信息
        public byte                bEventAction;                       // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved = new byte[2];           // 保留字节
        public byte                byImageIndex;                       // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 nDetectRegionNum;                   // 规则检测区域顶点数
        public NET_POINT[]         DetectRegion = (NET_POINT[]) new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM);    // 规则检测区域

        public int                 dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public int                 nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
        public byte[]              szSourceDevice = new byte[MAX_PATH]; // 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int                 nOccurrenceCount;                   // 事件触发累计次数, unsigned int 类型
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
        public byte[]              bReserved = new byte[492];          // 保留字节,留待扩展.
    }

    // 加油类型
    public static class EM_REFUEL_TYPE extends SdkStructure {
        public static final int 	EM_REFUEL_TYPE_UNKNOWN = 0;								// unknown
        public static final int		EM_REFUEL_TYPE_NINETY_EIGHT = 1;						// "98#"
        public static final int		EM_REFUEL_TYPE_NINETY_SEVEN = 2;						// "97#"
        public static final int		EM_REFUEL_TYPE_NINETY_FIVE  = 3;						// "95#"
        public static final int		EM_REFUEL_TYPE_NINETY_THREE = 4;                        // "93#"
        public static final int		EM_REFUEL_TYPE_NINETY = 5;								// "90#"
        public static final int		EM_REFUEL_TYPE_TEN 	= 6;								// "10#"
        public static final int		EM_REFUEL_TYPE_FIVE = 7;								// "5#"
        public static final int		EM_REFUEL_TYPE_ZERO = 8; 								// "0#"
        public static final int		EM_REFUEL_TYPE_NEGATIVE_TEN = 9;						// "-10#"
        public static final int		EM_REFUEL_TYPE_NEGATIVE_TWENTY = 10;					// "-20#"
        public static final int		EM_REFUEL_TYPE_NEGATIVE_THIRTY_FIVE = 11;				// "-35#"
        public static final int		EM_REFUEL_TYPE_NEGATIVE_FIFTY = 12;						// "-50#"
    }

    // 车辆抓拍图片信息
    public static class DEV_EVENT_TRAFFIC_FCC_IMAGE extends SdkStructure {
        public int              dwOffSet; // 图片文件在二进制数据块中的偏移位置, 单位:字节
        public int              dwLength; // 图片大小, 单位:字节
        public short            wWidth;   // 图片宽度, 单位:像素
        public short            wHeight;  // 图片高度, 单位:像素
    }

    // 车辆抓图信息
    public static class DEV_EVENT_TRAFFIC_FCC_OBJECT extends SdkStructure {
        public DEV_EVENT_TRAFFIC_FCC_IMAGE	stuImage; // 车辆抓拍图片信息
    }

    // 事件类型  EVENT_IVS_TRAFFIC_FCC 加油站提枪、挂枪事件
    public static class DEV_EVENT_TRAFFIC_FCC_INFO extends SdkStructure {
        public int              nChannelID;                                 // 通道号
        public byte[]           szName = new byte[NET_EVENT_NAME_LEN];      // 事件名称
        public int				nTriggerID;									// 触发类型: 1表示提枪, 2表示挂枪
        public double           PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX      UTC;                                        // 事件发生的时间
        public int              nEventID;                                   // 事件ID
        ///////////////////////////////以上为公共字段//////////////////////////////

        public int				nNum;										// 加油枪号
        public int				nLitre;										// 加油升数,单位 0.01升
        public int   			emType;										// 加油类型: 取值范围{"90#","93#","10#","-20#"}, 具体参考 EM_REFUEL_TYPE
        public int				dwMoney;									// 加油金额,单位 0.01元
        public byte[]		    szText = new byte[NET_COMMON_STRING_16];	// 车牌号
        public byte[]			szTime = new byte[NET_COMMON_STRING_32];	// 事件发生时间: "2016-05-23 10:31:17"
        public DEV_EVENT_TRAFFIC_FCC_OBJECT	stuObject;						// 车辆抓图信息
        public byte[]			bReserved = new byte[1024];					// 保留字节,留待扩展
    }

    // 区域或曲线顶点信息
    public static class NET_POLY_POINTS extends SdkStructure
    {
        public int         nPointNum;                               	// 顶点数
        public NET_POINT[] stuPoints = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM);     // 顶点信息
    }

    // 抓图类型
    public static class NET_CAPTURE_FORMATS extends SdkStructure
    {
        public static final int    NET_CAPTURE_BMP = 0;
        public static final int    NET_CAPTURE_JPEG  = 1;           // 100%质量的JPEG
        public static final int    NET_CAPTURE_JPEG_70 = 2;         // 70%质量的JPEG
        public static final int    NET_CAPTURE_JPEG_50 = 3;
        public static final int    NET_CAPTURE_JPEG_30 = 4;
    }

    // 抓图参数结构体
    public static class SNAP_PARAMS extends SdkStructure
    {
        public int     Channel;                       // 抓图的通道
        public int     Quality;                       // 画质；1~6
        public int     ImageSize;                     // 画面大小；0：QCIF,1：CIF,2：D1
        public int     mode;                          // 抓图模式；-1:表示停止抓图, 0：表示请求一帧, 1：表示定时发送请求, 2：表示连续请求
        public int     InterSnap;                     // 时间单位秒；若mode=1表示定时发送请求时
        // 只有部分特殊设备(如：车载设备)支持通过该字段实现定时抓图时间间隔的配置
        // 建议通过 CFG_CMD_ENCODE 配置的stuSnapFormat[nSnapMode].stuVideoFormat.nFrameRate字段实现相关功能
        public int     CmdSerial;                     // 请求序列号，有效值范围 0~65535，超过范围会被截断为 unsigned short
        public int[]   Reserved = new int[4];
    }

    // 对应CLIENT_StartSearchDevices接口
    public static class DEVICE_NET_INFO_EX extends SdkStructure
    {
        public int 		iIPVersion;										  // 4 for IPV4, 6 for IPV6
        public byte[] 	szIP = new byte[64];							  // IPIPV4形如"192.168.0.1"
        public int 		nPort;											  // tcp端口
        public byte[] 	szSubmask = new byte[64];						  // 子网掩码IPV6无子网掩码
        public byte[] 	szGateway = new byte[64];						  // 网关
        public byte[] 	szMac = new byte[NET_MACADDR_LEN];				  // MAC地址
        public byte[] 	szDeviceType = new byte[NET_DEV_TYPE_LEN];		  // 设备类型
        public byte 	byManuFactory; 									  // 目标设备的生产厂商,具体参考EM_IPC_TYPE类
        public byte 	byDefinition;									  // 1-标清2-高清
        public byte 	bDhcpEn;										  // Dhcp使能状态,true-开,false-关, 类型为bool, 取值0或者1
        public byte 	byReserved1;									  // 字节对齐
        public byte[] 	verifyData = new byte[88];						  // 校验数据通过异步搜索回调获取(在修改设备IP时会用此信息进行校验)
        public byte[] 	szSerialNo = new byte[NET_DEV_SERIALNO_LEN];	  // 序列号
        public byte[] 	szDevSoftVersion = new byte[NET_MAX_URL_LEN];	  // 设备软件版本号
        public byte[] 	szDetailType = new byte[NET_DEV_TYPE_LEN];		  // 设备型号
        public byte[] 	szVendor = new byte[NET_MAX_STRING_LEN];		  // OEM客户类型
        public byte[] 	szDevName = new byte[NET_MACHINE_NAME_NUM];		  // 设备名称
        public byte[] 	szUserName = new byte[NET_USER_NAME_LENGTH_EX];	  // 登陆设备用户名（在修改设备IP时需要填写）
        public byte[] 	szPassWord = new byte[NET_USER_NAME_LENGTH_EX];	  // 登陆设备密码（在修改设备IP时需要填写）
        public short 	nHttpPort;										  // HTTP服务端口号, unsigned short类型
        public short 	wVideoInputCh;									  // 视频输入通道数
        public short 	wRemoteVideoInputCh;							  // 远程视频输入通道数
        public short 	wVideoOutputCh;									  // 视频输出通道数
        public short 	wAlarmInputCh;									  // 报警输入通道数
        public short 	wAlarmOutputCh;									  // 报警输出通道数
        public int   	bNewWordLen;                                      // TRUE使用新密码字段szNewPassWord, BOOL类型
        public byte[]   szNewPassWord = new byte[NET_COMMON_STRING_64];   // 登陆设备密码（在修改设备IP时需要填写）

        public byte		byInitStatus;							          // 设备初始化状态，按位确定初始化状态
        // bit0~1：0-老设备，没有初始化功能 1-未初始化账号 2-已初始化账户
        // bit2~3：0-老设备，保留 1-公网接入未使能 2-公网接入已使能
        // bit4~5：0-老设备，保留 1-手机直连未使能 2-手机直连使能

        public byte		byPwdResetWay;							 		  // 支持密码重置方式：按位确定密码重置方式，只在设备有初始化账号时有意义
        // bit0-支持预置手机号 bit1-支持预置邮箱 bit2-支持文件导出
        public byte		bySpecialAbility;								  // 设备初始化能力，按位确定初始化能力
        public byte[]   szNewDetailType = new byte[NET_COMMON_STRING_64]; // 设备型号
        public int		bNewUserName;									  // TRUE表示使用新用户名(szNewUserName)字段. BOOL类型
        public byte[]	szNewUserName = new byte[NET_COMMON_STRING_64];	  // 登陆设备用户名（在修改设备IP时需要填写）
        public byte            byPwdFindVersion;                       // 密码找回的版本号,设备支持密码重置时有效;
        // 0-设备使用的是老方案的密码重置版本;1-支持预留联系方式进行密码重置操作;
        // 2-支持更换联系方式进行密码重置操作;
        public byte[]          szDeviceID=new byte[24]; // 定制字段, 不作为通用协议，不对接通用客户端
        public int             dwUnLoginFuncMask;                      // 未登陆功能掩码
        // Bit0-Wifi列表扫描及WLan设置
        // Bit1-支持会话外修改过期密码
        // Bit2-设备是否支持串口日志重定向（提前引导功能）
        public byte[]           szMachineGroup=new byte[64];                     // 设备分组
        public byte[]           cReserved=new byte[12];                          // 扩展字段
    }

    // 视频输入通道信息
    public static class NET_VIDEO_INPUTS extends SdkStructure {
        public int                      dwSize;
        public byte[]                   szChnName = new byte[64];                   // 通道名称
        public int                      bEnable;                                    // 使能
        public byte[]                   szControlID = new byte[128];                // 控制ID
        public byte[]                   szMainStreamUrl = new byte[MAX_PATH];       // 主码流url地址
        public byte[]                   szExtraStreamUrl = new byte[MAX_PATH];      // 辅码流url地址
        public int                      nOptionalMainUrlCount;                      // 备用主码流地址数量
        public byte[]                   szOptionalMainUrls = new byte[8*MAX_PATH];  // 备用主码流地址列表
        public int                      nOptionalExtraUrlCount;                     // 备用辅码流地址数量
        public byte[]                   szOptionalExtraUrls = new byte[8*MAX_PATH]; // 备用辅码流地址列表
        public byte[]                   szCaption=new byte[32];                     // 通道备注
        public int                      emServiceType;                              // 指码流传输的服务类型，参考EM_STREAM_TRANSMISSION_SERVICE_TYPE
        public NET_SOURCE_STREAM_ENCRYPT stuSourceStreamEncrypt;                    // 码流加密方式

        public NET_VIDEO_INPUTS()
        {
            this.dwSize = this.size();
        }
    }

    // 远程设备信息
    public static class NET_REMOTE_DEVICE extends SdkStructure {
        public int                       dwSize;
        public int                       bEnable;                          // 使能,1-true   0-false
        public byte[]                    szIp =  new byte[16];             // IP
        public byte[]                    szUser = new byte[8];             // 用户名, 建议使用szUserEx
        public byte[]                    szPwd = new byte[8];              // 密码, 建议使用szPwdEx
        public int                       nPort;                            // 端口
        public int                       nDefinition;                      // 清晰度, 0-标清, 1-高清
        public int                       emProtocol;                       // 协议类型  NET_DEVICE_PROTOCOL
        public byte[]                    szDevName = new byte[64];         // 设备名称
        public int                       nVideoInputChannels;              // 视频输入通道数
        public int                       nAudioInputChannels;              // 音频输入通道数
        public byte[]                    szDevClass = new byte[32];        // 设备类型, 如IPC, DVR, NVR等
        public byte[]                    szDevType = new byte[32];         // 设备具体型号, 如IPC-HF3300
        public int                       nHttpPort;                        // Http端口
        public int                       nMaxVideoInputCount;              // 视频输入通道最大数
        public int                       nRetVideoInputCount;              // 返回实际通道个数
        public Pointer                   pstuVideoInputs;                  // 视频输入通道信息 NET_VIDEO_INPUTS*
        public byte[]                    szMachineAddress = new byte[256]; // 设备部署地
        public byte[]                    szSerialNo = new byte[48];        // 设备序列号
        public int                       nRtspPort;                        // Rtsp端口

        /*以下用于新平台扩展*/
        public byte[]                    szUserEx = new byte[32];          // 用户名
        public byte[]                    szPwdEx = new byte[32];           // 密码
        public byte[] 				szVendorAbbr=new byte[NET_COMMON_STRING_32];		// 厂商缩写
        public byte[]              szSoftwareVersion=new byte[NET_COMMON_STRING_64];         // 设备软件版本
        public NET_TIME         stuActivationTime;                      // 启动时间

        public NET_REMOTE_DEVICE() {
            this.dwSize = this.size();
        }
    }

    // 可用的显示源信息
    public static class NET_MATRIX_CAMERA_INFO extends SdkStructure
    {
        public int                      dwSize;
        public byte[]                   szName = new byte[128];          // 名称
        public byte[]                   szDevID = new byte[128];         // 设备ID
        public byte[]                   szszControlID = new byte[128];   // 控制ID
        public int                      nChannelID;                        // 通道号, DeviceID设备内唯一
        public int                      nUniqueChannel;                    // 设备内统一编号的唯一通道号
        public int                      bRemoteDevice;                     // 是否远程设备
        public NET_REMOTE_DEVICE        stuRemoteDevice;                   // 远程设备信息
        public int                      emStreamType;                      // 视频码流类型  NET_STREAM_TYPE
        public int                      emChannelType;                     // 通道类型应 NET_LOGIC_CHN_TYPE

        public NET_MATRIX_CAMERA_INFO() {
            this.dwSize = this.size();
            stuRemoteDevice = new NET_REMOTE_DEVICE();
        }
    }

    // CLIENT_MatrixGetCameras接口的输入参数
    public static class NET_IN_MATRIX_GET_CAMERAS extends SdkStructure {
        public int dwSize;

        public NET_IN_MATRIX_GET_CAMERAS() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_MatrixGetCameras接口的输出参数
    public static class NET_OUT_MATRIX_GET_CAMERAS extends SdkStructure {
        public int                        dwSize;
        public Pointer                    pstuCameras;            // 显示源信息数组, 用户分配内存  NET_MATRIX_CAMERA_INFO
        public int                        nMaxCameraCount;        // 显示源数组大小
        public int                        nRetCameraCount;        // 返回的显示源数量

        public NET_OUT_MATRIX_GET_CAMERAS() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_SnapPictureToFile 接口输入参数
    public static class NET_IN_SNAP_PIC_TO_FILE_PARAM extends SdkStructure {
        public int                         dwSize;                    // 结构体大小
        public SNAP_PARAMS                 stuParam;                  // 抓图参数, 其中mode字段仅一次性抓图, 不支持定时或持续抓图; 除了车载DVR, 其他设备仅支持每秒一张的抓图频率

        public byte[]                      szFilePath = new byte[MAX_PATH];// 写入文件的地址

        public NET_IN_SNAP_PIC_TO_FILE_PARAM() {
            this.dwSize = this.size();
            this.stuParam = new SNAP_PARAMS();
        }
    }

    //  CLIENT_SnapPictureToFile 接口输出参数
    public static class NET_OUT_SNAP_PIC_TO_FILE_PARAM extends SdkStructure {
        public int                        dwSize;
        public Pointer                    szPicBuf;               // 图片内容,用户分配内存
        public int                        dwPicBufLen;            // 图片内容内存大小, 单位:字节
        public int                        dwPicBufRetLen;         // 返回的图片大小, 单位:字节

        public NET_OUT_SNAP_PIC_TO_FILE_PARAM() {
            this.dwSize = this.size();
        }

        public NET_OUT_SNAP_PIC_TO_FILE_PARAM(int nMaxBuf) {
            this.dwSize = this.size();
            this.dwPicBufLen = nMaxBuf;
            Memory mem = new Memory(nMaxBuf);
            mem.clear();
            this.szPicBuf = mem;
        }
    }

    // 录像文件信息
    public static class NET_RECORDFILE_INFO extends SdkStructure {
        public int                        ch;                         // 通道号
        public byte[]                     filename = new byte[124];   // 文件名
        public int                        framenum;                   // 文件总帧数
        public int                        size;                       // 文件长度
        public NET_TIME                   starttime = new NET_TIME(); // 开始时间
        public NET_TIME                   endtime = new NET_TIME();   // 结束时间
        public int                        driveno;                    // 磁盘号(区分网络录像和本地录像的类型,0－127表示本地录像,其中64表示光盘1,128表示网络录像)
        public int                        startcluster;               // 起始簇号
        public byte                       nRecordFileType;            // 录象文件类型  0：普通录象；1：报警录象；2：移动检测；3：卡号录象；4：图片, 5: 智能录像,255:所有录像
        public byte                       bImportantRecID;            // 0:普通录像 1:重要录像
        public byte                       bHint;                      // 文件定位索引(nRecordFileType==4<图片>时,bImportantRecID<<8 +bHint ,组成图片定位索引 )
        public byte                       bRecType;                   // 0-主码流录像 1-辅码1流录像 2-辅码流2 3-辅码流3录像

        public static class ByValue extends NET_RECORDFILE_INFO implements SdkStructure.ByValue { }
    }

    // 录像查询类型
    public static class EM_QUERY_RECORD_TYPE extends SdkStructure {
        public static final int            EM_RECORD_TYPE_ALL              = 0;            // 所有录像
        public static final int            EM_RECORD_TYPE_ALARM            = 1;            // 外部报警录像
        public static final int            EM_RECORD_TYPE_MOTION_DETECT    = 2;            // 动态检测报警录像
        public static final int            EM_RECORD_TYPE_ALARM_ALL        = 3;            // 所有报警录像
        public static final int            EM_RECORD_TYPE_CARD             = 4;            // 卡号查询
        public static final int            EM_RECORD_TYPE_CONDITION        = 5;            // 按条件查询
        public static final int            EM_RECORD_TYPE_JOIN             = 6;            // 组合查询
        public static final int            EM_RECORD_TYPE_CARD_PICTURE     = 8;            // 按卡号查询图片,HB-U、NVS等使用
        public static final int            EM_RECORD_TYPE_PICTURE          = 9;            // 查询图片,HB-U、NVS等使用
        public static final int            EM_RECORD_TYPE_FIELD            = 10;           // 按字段查询
        public static final int            EM_RECORD_TYPE_INTELLI_VIDEO    = 11;           // 智能录像查询
        public static final int            EM_RECORD_TYPE_NET_DATA         = 15;           // 查询网络数据,金桥网吧等使用
        public static final int            EM_RECORD_TYPE_TRANS_DATA       = 16;           // 查询透明串口数据录像
        public static final int            EM_RECORD_TYPE_IMPORTANT        = 17;           // 查询重要录像
        public static final int            EM_RECORD_TYPE_TALK_DATA        = 18;           // 查询录音文件

        public static final int            EM_RECORD_TYPE_INVALID          = 256;          // 无效的查询类型
    }

    // 语言种类
    public static class NET_LANGUAGE_TYPE extends SdkStructure
    {
        public static final int NET_LANGUAGE_ENGLISH = 0; //英文
        public static final int NET_LANGUAGE_CHINESE_SIMPLIFIED = NET_LANGUAGE_ENGLISH+1; //简体中文
        public static final int NET_LANGUAGE_CHINESE_TRADITIONAL = NET_LANGUAGE_CHINESE_SIMPLIFIED+1; //繁体中文
        public static final int NET_LANGUAGE_ITALIAN = NET_LANGUAGE_CHINESE_TRADITIONAL+1; //意大利文
        public static final int NET_LANGUAGE_SPANISH = NET_LANGUAGE_ITALIAN+1; //西班牙文
        public static final int NET_LANGUAGE_JAPANESE = NET_LANGUAGE_SPANISH+1; //日文版
        public static final int NET_LANGUAGE_RUSSIAN = NET_LANGUAGE_JAPANESE+1; //俄文版
        public static final int NET_LANGUAGE_FRENCH = NET_LANGUAGE_RUSSIAN+1; //法文版
        public static final int NET_LANGUAGE_GERMAN = NET_LANGUAGE_FRENCH+1; //德文版
        public static final int NET_LANGUAGE_PORTUGUESE = NET_LANGUAGE_GERMAN+1; //葡萄牙语
        public static final int NET_LANGUAGE_TURKEY = NET_LANGUAGE_PORTUGUESE+1; //土尔其语
        public static final int NET_LANGUAGE_POLISH = NET_LANGUAGE_TURKEY+1; //波兰语
        public static final int NET_LANGUAGE_ROMANIAN = NET_LANGUAGE_POLISH+1; //罗马尼亚
        public static final int NET_LANGUAGE_HUNGARIAN = NET_LANGUAGE_ROMANIAN+1; //匈牙利语
        public static final int NET_LANGUAGE_FINNISH = NET_LANGUAGE_HUNGARIAN+1; //芬兰语
        public static final int NET_LANGUAGE_ESTONIAN = NET_LANGUAGE_FINNISH+1; //爱沙尼亚语
        public static final int NET_LANGUAGE_KOREAN = NET_LANGUAGE_ESTONIAN+1; //韩语
        public static final int NET_LANGUAGE_FARSI = NET_LANGUAGE_KOREAN+1; //波斯语
        public static final int NET_LANGUAGE_DANSK = NET_LANGUAGE_FARSI+1; //丹麦语
        public static final int NET_LANGUAGE_CZECHISH = NET_LANGUAGE_DANSK+1; //捷克文
        public static final int NET_LANGUAGE_BULGARIA = NET_LANGUAGE_CZECHISH+1; //保加利亚文
        public static final int NET_LANGUAGE_SLOVAKIAN = NET_LANGUAGE_BULGARIA+1; //斯洛伐克语
        public static final int NET_LANGUAGE_SLOVENIA = NET_LANGUAGE_SLOVAKIAN+1; //斯洛文尼亚文
        public static final int NET_LANGUAGE_CROATIAN = NET_LANGUAGE_SLOVENIA+1; //克罗地亚语
        public static final int NET_LANGUAGE_DUTCH = NET_LANGUAGE_CROATIAN+1; //荷兰语
        public static final int NET_LANGUAGE_GREEK = NET_LANGUAGE_DUTCH+1; //希腊语
        public static final int NET_LANGUAGE_UKRAINIAN = NET_LANGUAGE_GREEK+1; //乌克兰语
        public static final int NET_LANGUAGE_SWEDISH = NET_LANGUAGE_UKRAINIAN+1; //瑞典语
        public static final int NET_LANGUAGE_SERBIAN = NET_LANGUAGE_SWEDISH+1; //塞尔维亚语
        public static final int NET_LANGUAGE_VIETNAMESE = NET_LANGUAGE_SERBIAN+1; //越南语
        public static final int NET_LANGUAGE_LITHUANIAN = NET_LANGUAGE_VIETNAMESE+1; //立陶宛语
        public static final int NET_LANGUAGE_FILIPINO = NET_LANGUAGE_LITHUANIAN+1; //菲律宾语
        public static final int NET_LANGUAGE_ARABIC = NET_LANGUAGE_FILIPINO+1; //阿拉伯语
        public static final int NET_LANGUAGE_CATALAN = NET_LANGUAGE_ARABIC+1; //加泰罗尼亚语
        public static final int NET_LANGUAGE_LATVIAN = NET_LANGUAGE_CATALAN+1; //拉脱维亚语
        public static final int NET_LANGUAGE_THAI = NET_LANGUAGE_LATVIAN+1; //泰语
        public static final int NET_LANGUAGE_HEBREW = NET_LANGUAGE_THAI+1; //希伯来语
        public static final int NET_LANGUAGE_Bosnian = NET_LANGUAGE_HEBREW+1; //波斯尼亚文
    }

    // 区域信息
    public static class CFG_RECT extends SdkStructure
    {
        public int nLeft;
        public int nTop;
        public int nRight;
        public int nBottom;
    }

    // 视频输入夜晚特殊配置选项，在晚上光线较暗时自动切换到夜晚的配置参数
    public static class CFG_VIDEO_IN_NIGHT_OPTIONS extends SdkStructure
    {
        public byte bySwitchMode;//已废弃,使用CFG_VIDEO_IN_OPTIONS里面的bySwitchMode
        //0-不切换，总是使用白天配置；1-根据亮度切换；2-根据时间切换；3-不切换，总是使用夜晚配置；4-使用普通配置
        public byte byProfile;//当前使用的配置文件.
        // 0-白天
        // 1-晚上
        // 2-Normal
        // 0，1,2都为临时配置，使图像生效，便于查看图像调试效果，不点击确定，离开页面不保存至设备。
        ///3-非临时配置，点击确定后保存至设备，与SwitchMode结合使用，根据SwitchMode决定最终生效的配置。
        // SwitchMode=0，Profile=3，设置白天配置到设备；
        // SwitchMode=1，Profile=3，则设置夜晚配置到设备
        // SwitchMode=2，Profile=3，根据日出日落时间段切换，白天时间段使用白天配置，夜晚时间段使用夜晚配置，保存至设备；
        // SwitchMode=4，Profile=3；使用普通配置，保存至设备
        public byte byBrightnessThreshold;//亮度阈值0~100
        public byte bySunriseHour;//大致日出和日落时间，日落之后日出之前，将采用夜晚特殊的配置。
        public byte bySunriseMinute;//00:00:00 ~ 23:59:59
        public byte bySunriseSecond;
        public byte bySunsetHour;
        public byte bySunsetMinute;
        public byte bySunsetSecond;
        public byte byGainRed;//红色增益调节，白平衡为"Custom"模式下有效0~100
        public byte byGainBlue;//绿色增益调节，白平衡为"Custom"模式下有效0~100
        public byte byGainGreen;//蓝色增益调节，白平衡为"Custom"模式下有效0~100
        public byte byExposure;//曝光模式；取值范围取决于设备能力集：0-自动曝光，1-曝光等级1，2-曝光等级2…n-1最大曝光等级数n带时间上下限的自动曝光n+1自定义时间手动曝光 (n==byExposureEn）
        public float fExposureValue1;//自动曝光时间下限或者手动曝光自定义时间,毫秒为单位，取值0.1ms~80ms
        public float fExposureValue2;//自动曝光时间上限,毫秒为单位，取值0.1ms~80ms
        public byte byWhiteBalance;//白平衡,0-"Disable", 1-"Auto", 2-"Custom", 3-"Sunny", 4-"Cloudy", 5-"Home", 6-"Office", 7-"Night", 8-"HighColorTemperature", 9-"LowColorTemperature", 10-"AutoColorTemperature", 11-"CustomColorTemperature"
        public byte byGain;//0~100,GainAuto为true时表示自动增益的上限，否则表示固定的增益值
        public byte bGainAuto;//自动增益, 类型为bool, 取值0或1
        public byte bIrisAuto;//自动光圈, 类型为bool, 取值0或1
        public float fExternalSyncPhase;//外同步的相位设置0~360
        public byte byGainMin;//增益下限
        public byte byGainMax;//增益上限
        public byte byBacklight;//背光补偿：取值范围取决于设备能力集：0-关闭1-启用2-指定区域背光补偿
        public byte byAntiFlicker;//防闪烁模式0-Outdoor1-50Hz防闪烁 2-60Hz防闪烁
        public byte byDayNightColor;//日/夜模式；0-总是彩色，1-根据亮度自动切换，2-总是黑白
        public byte byExposureMode;//曝光模式调节曝光等级为自动曝光时有效，取值：0-默认自动，1-增益优先，2-快门优先
        public byte byRotate90;//0-不旋转，1-顺时针90°，2-逆时针90°
        public byte bMirror;//镜像, 类型为bool, 取值0或1
        public byte byWideDynamicRange;//宽动态值0-关闭，1~100-为真实范围值
        public byte byGlareInhibition;//强光抑制0-关闭，1~100为范围值
        public CFG_RECT stuBacklightRegion = new CFG_RECT();//背光补偿区域
        public byte byFocusMode;//0-关闭，1-辅助聚焦，2-自动聚焦
        public byte bFlip;//翻转, 类型为bool, 取值0或1
        public byte[] reserved = new byte[74];//保留
    }

    // 闪光灯配置
    public static class CFG_FLASH_CONTROL extends SdkStructure
    {
        public byte byMode;//工作模式，0-禁止闪光，1-始终闪光，2-自动闪光
        public byte byValue;//工作值,0-0us,1-64us, 2-128us, 3-192...15-960us
        public byte byPole;//触发模式,0-低电平1-高电平 2-上升沿 3-下降沿
        public byte byPreValue;//亮度预设值区间0~100
        public byte byDutyCycle;//占空比,0~100
        public byte byFreqMultiple;//倍频,0~10
        public byte[] reserved = new byte[122];//保留
    }

    // 抓拍参数特殊配置
    public static class CFG_VIDEO_IN_SNAPSHOT_OPTIONS extends SdkStructure
    {
        public byte byGainRed;//红色增益调节，白平衡为"Custom"模式下有效0~100
        public byte byGainBlue;//绿色增益调节，白平衡为"Custom"模式下有效0~100
        public byte byGainGreen;//蓝色增益调节，白平衡为"Custom"模式下有效0~100
        public byte byExposure;//曝光模式；取值范围取决于设备能力集：0-自动曝光，1-曝光等级1，2-曝光等级2…n-1最大曝光等级数n带时间上下限的自动曝光n+1自定义时间手动曝光 (n==byExposureEn）
        public float fExposureValue1;//自动曝光时间下限或者手动曝光自定义时间,毫秒为单位，取值0.1ms~80ms
        public float fExposureValue2;//自动曝光时间上限,毫秒为单位，取值0.1ms~80ms
        public byte byWhiteBalance;//白平衡,0-"Disable", 1-"Auto", 2-"Custom", 3-"Sunny", 4-"Cloudy", 5-"Home", 6-"Office", 7-"Night", 8-"HighColorTemperature", 9-"LowColorTemperature", 10-"AutoColorTemperature", 11-"CustomColorTemperature"
        public byte byColorTemperature;//色温等级,白平衡为"CustomColorTemperature"模式下有效
        public byte bGainAuto;//自动增益, 类型为bool, 取值0或1
        public byte byGain;//增益调节,GainAuto为true时表示自动增益的上限，否则表示固定的增益值
        public byte[] reversed = new byte[112];//保留
    }

    // 鱼眼镜头配置
    public static class CFG_FISH_EYE extends SdkStructure
    {
        public CFG_POLYGON stuCenterPoint;//鱼眼圆心坐标,范围[0,8192]
        public int nRadius;//鱼眼半径大小,范围[0,8192], 类型为unsigned int
        public float fDirection;//镜头旋转方向,旋转角度[0,360.0]
        public byte byPlaceHolder;//镜头安装方式1顶装，2壁装；3地装,默认1
        public byte byCalibrateMode;//鱼眼矫正模式,详见CFG_CALIBRATE_MODE枚举值
        public byte[] reversed = new byte[31];//保留
    }

    public static class CFG_VIDEO_IN_NORMAL_OPTIONS extends SdkStructure
    {
        public byte byGainRed;//红色增益调节，白平衡为"Custom"模式下有效0~100
        public byte byGainBlue;//绿色增益调节，白平衡为"Custom"模式下有效0~100
        public byte byGainGreen;//蓝色增益调节，白平衡为"Custom"模式下有效0~100
        public byte byExposure;//曝光模式；取值范围取决于设备能力集：0-自动曝光，1-曝光等级1，2-曝光等级2…n-1最大曝光等级数n带时间上下限的自动曝光n+1自定义时间手动曝光 (n==byExposureEn）
        public float fExposureValue1;//自动曝光时间下限或者手动曝光自定义时间,毫秒为单位，取值0.1ms~80ms
        public float fExposureValue2;//自动曝光时间上限,毫秒为单位，取值0.1ms~80ms
        public byte byWhiteBalance;//白平衡,0-"Disable", 1-"Auto", 2-"Custom", 3-"Sunny", 4-"Cloudy", 5-"Home", 6-"Office", 7-"Night", 8-"HighColorTemperature", 9-"LowColorTemperature", 10-"AutoColorTemperature", 11-"CustomColorTemperature"
        public byte byGain;//0~100,GainAuto为true时表示自动增益的上限，否则表示固定的增益值
        public byte bGainAuto;//自动增益, 类型为bool, 取值0或1
        public byte bIrisAuto;//自动光圈, 类型为bool, 取值0或1
        public float fExternalSyncPhase;//外同步的相位设置0~360
        public byte byGainMin;//增益下限
        public byte byGainMax;//增益上限
        public byte byBacklight;//背光补偿：取值范围取决于设备能力集：0-关闭1-启用2-指定区域背光补偿
        public byte byAntiFlicker;//防闪烁模式0-Outdoor1-50Hz防闪烁 2-60Hz防闪烁
        public byte byDayNightColor;//日/夜模式；0-总是彩色，1-根据亮度自动切换，2-总是黑白
        public byte byExposureMode;//曝光模式调节曝光等级为自动曝光时有效，取值：0-默认自动，1-增益优先，2-快门优先
        public byte byRotate90;//0-不旋转，1-顺时针90°，2-逆时针90°
        public byte bMirror;//镜像, 类型为bool, 取值0或1
        public byte byWideDynamicRange;//宽动态值0-关闭，1~100-为真实范围值
        public byte byGlareInhibition;//强光抑制0-关闭，1~100为范围值
        public CFG_RECT stuBacklightRegion;//背光补偿区域
        public byte byFocusMode;//0-关闭，1-辅助聚焦，2-自动聚焦
        public byte bFlip;//翻转, 类型为bool, 取值0或1
        public byte[] reserved = new byte[74];//保留
    }

    // 视频输入前端选项
    public static class CFG_VIDEO_IN_OPTIONS extends SdkStructure
    {
        public byte byBacklight;//背光补偿：取值范围取决于设备能力集：0-关闭1-启用2-指定区域背光补偿
        public byte byDayNightColor;//日/夜模式；0-总是彩色，1-根据亮度自动切换，2-总是黑白
        public byte byWhiteBalance;//白平衡,0-"Disable", 1-"Auto", 2-"Custom", 3-"Sunny", 4-"Cloudy", 5-"Home", 6-"Office", 7-"Night", 8-"HighColorTemperature", 9-"LowColorTemperature", 10-"AutoColorTemperature", 11-"CustomColorTemperature"
        public byte byColorTemperature;//色温等级,白平衡为"CustomColorTemperature"模式下有效
        public byte bMirror;//镜像, 类型为bool, 取值0或1
        public byte bFlip;//翻转, 类型为bool, 取值0或1
        public byte bIrisAuto;//自动光圈, 类型为bool, 取值0或1
        public byte bInfraRed;//根据环境光自动开启红外补偿灯, 类型为bool, 取值0或1
        public byte byGainRed;//红色增益调节，白平衡为"Custom"模式下有效0~100
        public byte byGainBlue;//绿色增益调节，白平衡为"Custom"模式下有效0~100
        public byte byGainGreen;//蓝色增益调节，白平衡为"Custom"模式下有效0~100
        public byte byExposure;//曝光模式；取值范围取决于设备能力集：0-自动曝光，1-曝光等级1，2-曝光等级2…n-1最大曝光等级数n带时间上下限的自动曝光n+1自定义时间手动曝光 (n==byExposureEn）
        public float fExposureValue1;//自动曝光时间下限或者手动曝光自定义时间,毫秒为单位，取值0.1ms~80ms
        public float fExposureValue2;//自动曝光时间上限,毫秒为单位，取值0.1ms~80ms
        public byte bGainAuto;//自动增益, 类型为bool, 取值0或1
        public byte byGain;//增益调节,GainAuto为true时表示自动增益的上限，否则表示固定的增益值
        public byte bySignalFormat;//信号格式,0-Inside(内部输入)1-BT656 2-720p 3-1080p  4-1080i  5-1080sF
        public byte byRotate90;//0-不旋转，1-顺时针90°，2-逆时针90°
        public float fExternalSyncPhase;//外同步的相位设置 0~360
        public byte byExternalSync;//外部同步信号输入,0-内部同步 1-外部同步
        public byte bySwitchMode;//0-不切换，总是使用白天配置；1-根据亮度切换；2-根据时间切换；3-不切换，总是使用夜晚配置；4-使用普通配置
        public byte byDoubleExposure;//双快门,0-不启用，1-双快门全帧率，即图像和视频只有快门参数不同，2-双快门半帧率，即图像和视频快门及白平衡参数均不同
        public byte byWideDynamicRange;//宽动态值
        public CFG_VIDEO_IN_NIGHT_OPTIONS stuNightOptions;//夜晚参数
        public CFG_FLASH_CONTROL stuFlash;//闪光灯配置
        public CFG_VIDEO_IN_SNAPSHOT_OPTIONS stuSnapshot;//抓拍参数,双快门时有效
        public CFG_FISH_EYE stuFishEye;//鱼眼镜头
        public byte byFocusMode;//0-关闭，1-辅助聚焦，2-自动聚焦
        public byte[] reserved = new byte[28];//保留
        public byte byGainMin;//增益下限
        public byte byGainMax;//增益上限
        public byte byAntiFlicker;//防闪烁模式 0-Outdoor 1-50Hz防闪烁 2-60Hz防闪烁
        public byte byExposureMode;//曝光模式调节曝光等级为自动曝光时有效，取值：0-默认自动，1-增益优先，2-快门优先,4-手动
        public byte byGlareInhibition;//强光抑制0-关闭，1~100为范围值
        public CFG_RECT stuBacklightRegion;//背光补偿区域
        public CFG_VIDEO_IN_NORMAL_OPTIONS stuNormalOptions;//普通参数
    }

    // 通用云台控制命令
    public static class NET_PTZ_ControlType extends SdkStructure
    {
        public static final int NET_PTZ_UP_CONTROL = 0;//上
        public static final int NET_PTZ_DOWN_CONTROL = NET_PTZ_UP_CONTROL+1; //下
        public static final int NET_PTZ_LEFT_CONTROL = NET_PTZ_DOWN_CONTROL+1; //左
        public static final int NET_PTZ_RIGHT_CONTROL = NET_PTZ_LEFT_CONTROL+1; //右
        public static final int NET_PTZ_ZOOM_ADD_CONTROL = NET_PTZ_RIGHT_CONTROL+1; //变倍+
        public static final int NET_PTZ_ZOOM_DEC_CONTROL = NET_PTZ_ZOOM_ADD_CONTROL+1; //变倍-
        public static final int NET_PTZ_FOCUS_ADD_CONTROL = NET_PTZ_ZOOM_DEC_CONTROL+1; //调焦+
        public static final int NET_PTZ_FOCUS_DEC_CONTROL = NET_PTZ_FOCUS_ADD_CONTROL+1; //调焦-
        public static final int NET_PTZ_APERTURE_ADD_CONTROL = NET_PTZ_FOCUS_DEC_CONTROL+1; //光圈+
        public static final int NET_PTZ_APERTURE_DEC_CONTROL = NET_PTZ_APERTURE_ADD_CONTROL+1; //光圈-
        public static final int NET_PTZ_POINT_MOVE_CONTROL = NET_PTZ_APERTURE_DEC_CONTROL+1; //转至预置点
        public static final int NET_PTZ_POINT_SET_CONTROL = NET_PTZ_POINT_MOVE_CONTROL+1; //设置
        public static final int NET_PTZ_POINT_DEL_CONTROL = NET_PTZ_POINT_SET_CONTROL+1; //删除
        public static final int NET_PTZ_POINT_LOOP_CONTROL = NET_PTZ_POINT_DEL_CONTROL+1; //点间巡航
        public static final int NET_PTZ_LAMP_CONTROL = NET_PTZ_POINT_LOOP_CONTROL+1; //灯光雨刷
    }

    // 云台控制扩展命令
    public static class NET_EXTPTZ_ControlType extends SdkStructure
    {
        public static final int NET_EXTPTZ_LEFTTOP = 0x20;//左上
        public static final int NET_EXTPTZ_RIGHTTOP = NET_EXTPTZ_LEFTTOP+1; //右上
        public static final int NET_EXTPTZ_LEFTDOWN = NET_EXTPTZ_RIGHTTOP+1; //左下
        public static final int NET_EXTPTZ_RIGHTDOWN = NET_EXTPTZ_LEFTDOWN+1; //右下
        public static final int NET_EXTPTZ_ADDTOLOOP = NET_EXTPTZ_RIGHTDOWN+1; //加入预置点到巡航巡航线路预置点值
        public static final int NET_EXTPTZ_DELFROMLOOP = NET_EXTPTZ_ADDTOLOOP+1; //删除巡航中预置点巡航线路预置点值
        public static final int NET_EXTPTZ_CLOSELOOP = NET_EXTPTZ_DELFROMLOOP+1; //清除巡航巡航线路
        public static final int NET_EXTPTZ_STARTPANCRUISE = NET_EXTPTZ_CLOSELOOP+1; //开始水平旋转
        public static final int NET_EXTPTZ_STOPPANCRUISE = NET_EXTPTZ_STARTPANCRUISE+1; //停止水平旋转
        public static final int NET_EXTPTZ_SETLEFTBORDER = NET_EXTPTZ_STOPPANCRUISE+1; //设置左边界
        public static final int NET_EXTPTZ_SETRIGHTBORDER = NET_EXTPTZ_SETLEFTBORDER+1; //设置右边界
        public static final int NET_EXTPTZ_STARTLINESCAN = NET_EXTPTZ_SETRIGHTBORDER+1; //开始线扫
        public static final int NET_EXTPTZ_CLOSELINESCAN = NET_EXTPTZ_STARTLINESCAN+1; //停止线扫
        public static final int NET_EXTPTZ_SETMODESTART = NET_EXTPTZ_CLOSELINESCAN+1; //设置模式开始模式线路
        public static final int NET_EXTPTZ_SETMODESTOP = NET_EXTPTZ_SETMODESTART+1; //设置模式结束模式线路
        public static final int NET_EXTPTZ_RUNMODE = NET_EXTPTZ_SETMODESTOP+1; //运行模式模式线路
        public static final int NET_EXTPTZ_STOPMODE = NET_EXTPTZ_RUNMODE+1; //停止模式模式线路
        public static final int NET_EXTPTZ_DELETEMODE = NET_EXTPTZ_STOPMODE+1; //清除模式模式线路
        public static final int NET_EXTPTZ_REVERSECOMM = NET_EXTPTZ_DELETEMODE+1; //翻转命令
        public static final int NET_EXTPTZ_FASTGOTO = NET_EXTPTZ_REVERSECOMM+1; //快速定位水平坐标(8192)垂直坐标(8192)变倍(4)
        public static final int NET_EXTPTZ_AUXIOPEN = NET_EXTPTZ_FASTGOTO+1; //辅助开关开辅助点
        public static final int NET_EXTPTZ_AUXICLOSE = NET_EXTPTZ_AUXIOPEN+1; //辅助开关关辅助点
        public static final int NET_EXTPTZ_OPENMENU = 0x36;//打开球机菜单
        public static final int NET_EXTPTZ_CLOSEMENU = NET_EXTPTZ_OPENMENU+1; //关闭菜单
        public static final int NET_EXTPTZ_MENUOK = NET_EXTPTZ_CLOSEMENU+1; //菜单确定
        public static final int NET_EXTPTZ_MENUCANCEL = NET_EXTPTZ_MENUOK+1; //菜单取消
        public static final int NET_EXTPTZ_MENUUP = NET_EXTPTZ_MENUCANCEL+1; //菜单上
        public static final int NET_EXTPTZ_MENUDOWN = NET_EXTPTZ_MENUUP+1; //菜单下
        public static final int NET_EXTPTZ_MENULEFT = NET_EXTPTZ_MENUDOWN+1; //菜单左
        public static final int NET_EXTPTZ_MENURIGHT = NET_EXTPTZ_MENULEFT+1; //菜单右
        public static final int NET_EXTPTZ_ALARMHANDLE = 0x40;//报警联动云台parm1：报警输入通道；parm2：报警联动类型1-预置点2-线扫3-巡航；parm3：联动值，如预置点号
        public static final int NET_EXTPTZ_MATRIXSWITCH = 0x41;//矩阵切换parm1：监视器号(视频输出号)；parm2：视频输入号；parm3：矩阵号
        public static final int NET_EXTPTZ_LIGHTCONTROL= NET_EXTPTZ_MATRIXSWITCH+1; //灯光控制器
        public static final int NET_EXTPTZ_EXACTGOTO = NET_EXTPTZ_LIGHTCONTROL+1; //三维精确定位parm1：水平角度(0~3600)；parm2：垂直坐标(0~900)；parm3：变倍(1~128)
        public static final int NET_EXTPTZ_RESETZERO = NET_EXTPTZ_EXACTGOTO+1; //三维定位重设零位
        public static final int NET_EXTPTZ_MOVE_ABSOLUTELY = NET_EXTPTZ_RESETZERO+1; //绝对移动控制命令，param4对应结构PTZ_CONTROL_ABSOLUTELY
        public static final int NET_EXTPTZ_MOVE_CONTINUOUSLY = NET_EXTPTZ_MOVE_ABSOLUTELY+1; //持续移动控制命令，param4对应结构PTZ_CONTROL_CONTINUOUSLY
        public static final int NET_EXTPTZ_GOTOPRESET = NET_EXTPTZ_MOVE_CONTINUOUSLY+1; //云台控制命令，以一定速度转到预置位点，parm4对应结构PTZ_CONTROL_GOTOPRESET
        public static final int NET_EXTPTZ_SET_VIEW_RANGE = 0x49;//设置可视域(param4对应结构PTZ_VIEW_RANGE_INFO)
        public static final int NET_EXTPTZ_FOCUS_ABSOLUTELY = 0x4A;//绝对聚焦(param4对应结构PTZ_FOCUS_ABSOLUTELY)
        public static final int NET_EXTPTZ_HORSECTORSCAN = 0x4B;//水平扇扫(param4对应PTZ_CONTROL_SECTORSCAN,param1、param2、param3无效)
        public static final int NET_EXTPTZ_VERSECTORSCAN = 0x4C;//垂直扇扫(param4对应PTZ_CONTROL_SECTORSCAN,param1、param2、param3无效)
        public static final int NET_EXTPTZ_SET_ABS_ZOOMFOCUS = 0x4D;//设定绝对焦距、聚焦值,param1为焦距,范围:0,255],param2为聚焦,范围:[0,255],param3、param4无效
        public static final int NET_EXTPTZ_SET_FISHEYE_EPTZ = 0x4E;//控制鱼眼电子云台，param4对应结构PTZ_CONTROL_SET_FISHEYE_EPTZ
        public static final int NET_EXTPTZ_UP_TELE = 0x70;    //上 + TELE param1=速度(1-8)，下同
        public static final int NET_EXTPTZ_DOWN_TELE = NET_EXTPTZ_UP_TELE+1; //下 + TELE
        public static final int NET_EXTPTZ_LEFT_TELE = NET_EXTPTZ_DOWN_TELE+1; //左 + TELE
        public static final int NET_EXTPTZ_RIGHT_TELE = NET_EXTPTZ_LEFT_TELE+1; //右 + TELE
        public static final int NET_EXTPTZ_LEFTUP_TELE = NET_EXTPTZ_RIGHT_TELE+1; //左上 + TELE
        public static final int NET_EXTPTZ_LEFTDOWN_TELE = NET_EXTPTZ_LEFTUP_TELE+1; //左下 + TELE
        public static final int NET_EXTPTZ_TIGHTUP_TELE = NET_EXTPTZ_LEFTDOWN_TELE+1; //右上 + TELE
        public static final int NET_EXTPTZ_RIGHTDOWN_TELE = NET_EXTPTZ_TIGHTUP_TELE+1; //右下 + TELE
        public static final int NET_EXTPTZ_UP_WIDE = NET_EXTPTZ_RIGHTDOWN_TELE+1; // 上 + WIDEparam1=速度(1-8)，下同
        public static final int NET_EXTPTZ_DOWN_WIDE = NET_EXTPTZ_UP_WIDE+1; //下 + WIDE
        public static final int NET_EXTPTZ_LEFT_WIDE = NET_EXTPTZ_DOWN_WIDE+1; //左 + WIDE
        public static final int NET_EXTPTZ_RIGHT_WIDE = NET_EXTPTZ_LEFT_WIDE+1; //右 + WIDE
        public static final int NET_EXTPTZ_LEFTUP_WIDE = NET_EXTPTZ_RIGHT_WIDE+1; //左上 + WIDENET_IN_PTZBASE_SET_FOCUS_MAP_VALUE_INFO
        public static final int NET_EXTPTZ_LEFTDOWN_WIDE = NET_EXTPTZ_LEFTUP_WIDE+1; //左下 + WIDE
        public static final int NET_EXTPTZ_TIGHTUP_WIDE = NET_EXTPTZ_LEFTDOWN_WIDE+1; //右上 + WIDE
        public static final int NET_EXTPTZ_RIGHTDOWN_WIDE = NET_EXTPTZ_TIGHTUP_WIDE+1; //右下 + WIDE
        public static final int NET_EXTPTZ_GOTOPRESETSNAP = 0x80;                   // 转至预置点并抓图
        public static final int NET_EXTPTZ_DIRECTIONCALIBRATION = 0x82;             // 校准云台方向（双方向校准）
        public static final int NET_EXTPTZ_SINGLEDIRECTIONCALIBRATION = 0x83;       // 校准云台方向（单防线校准）,param4对应结构 NET_IN_CALIBRATE_SINGLEDIRECTION
        public static final int NET_EXTPTZ_MOVE_RELATIVELY = 0x84;			        // 云台相对定位,param4对应结构 NET_IN_MOVERELATIVELY_INFO
        public static final int NET_EXTPTZ_SET_DIRECTION = 0x85;				    // 设置云台方向, param4对应结构 NET_IN_SET_DIRECTION_INFO
        public static final int NET_EXTPTZ_BASE_MOVE_ABSOLUTELY = 0x86;		        // 精准绝对移动控制命令, param4对应结构 NET_IN_PTZBASE_MOVEABSOLUTELY_INFO（通过 CFG_CAP_CMD_PTZ 命令获取云台能力集( CFG_PTZ_PROTOCOL_CAPS_INFO )，若bSupportReal为TRUE则设备支持该操作）
        public static final int NET_EXTPTZ_BASE_MOVE_CONTINUOUSLY = NET_EXTPTZ_BASE_MOVE_ABSOLUTELY+1;	// 云台连续移动控制命令, param4 对应结构 NET_IN_PTZBASE_MOVE_CONTINUOUSLY_INFO.  通过 CFG_CAP_CMD_PTZ 命令获取云台能力集
                                                                                                        // 若 CFG_PTZ_PROTOCOL_CAPS_INFO 中 stuMoveContinuously 字段的 stuType.bSupportExtra 为 TRUE, 表示设备支持该操作
        public static final int NET_EXTPTZ_BASE_SET_FOCUS_MAP_VALUE = NET_EXTPTZ_BASE_MOVE_CONTINUOUSLY+1;	// 设置当前位置聚焦值, param4对应结构体 NET_IN_PTZBASE_SET_FOCUS_MAP_VALUE_INFO
        public static final int NET_EXTPTZ_TOTAL = NET_EXTPTZ_BASE_SET_FOCUS_MAP_VALUE+1;                   //最大命令值
    }

    // 雨刷工作模式
    public static class EM_CFG_RAINBRUSHMODE_MODE extends SdkStructure
    {
        public static final int EM_CFG_RAINBRUSHMODE_MODE_UNKNOWN = 0; //未知
        public static final int EM_CFG_RAINBRUSHMODE_MODE_MANUAL = EM_CFG_RAINBRUSHMODE_MODE_UNKNOWN+1; //手动模式
        public static final int EM_CFG_RAINBRUSHMODE_MODE_TIMING = EM_CFG_RAINBRUSHMODE_MODE_MANUAL+1; //定时模式
    }

    // 雨刷使能电平模式
    public static class EM_CFG_RAINBRUSHMODE_ENABLEMODE extends SdkStructure
    {
        public static final int EM_CFG_RAINBRUSHMODE_ENABLEMODE_UNKNOWN = 0; //未知
        public static final int EM_CFG_RAINBRUSHMODE_ENABLEMODE_LOW = EM_CFG_RAINBRUSHMODE_ENABLEMODE_UNKNOWN+1; //低电平有效（常闭）
        public static final int EM_CFG_RAINBRUSHMODE_ENABLEMODE_HIGH = EM_CFG_RAINBRUSHMODE_ENABLEMODE_LOW+1; //高电平有效（常开）
    }

    // 雨刷模式相关配置(对应 CFG_RAINBRUSHMODE_INFO 命令)
    public static class CFG_RAINBRUSHMODE_INFO extends SdkStructure
    {
        public int emMode;//雨刷工作模式, 取值为EM_CFG_RAINBRUSHMODE_MODE中的值
        public int emEnableMode;//雨刷使能电平模式, 取值为EM_CFG_RAINBRUSHMODE_ENABLEMODE中的值
        public int nPort;//雨刷使用的IO端口,-1表示未接入设备,-2表示该字段无效（设备未传送该字段）
        public int nSensitivity; // 雨刷灵敏度, 只有当mode为Auto时有效, 范围[0, 10]
    }

    public static class CFG_RAINBRUSH_INFO extends SdkStructure
    {
        public byte 					 bEnable;					// 雨刷使能, 类型为bool, 取值0或1
        public byte 					 bSpeedRate;				// 雨刷速度,1:快速;2:中速;3:慢速
        public byte[] 					 bReserved = new byte[2];	// 保留对齐
        public TIME_SECTION_WEEK_DAY_6[] stuTimeSectionWeekDay =
                (TIME_SECTION_WEEK_DAY_6[])new TIME_SECTION_WEEK_DAY_6().toArray(WEEK_DAY_NUM);// 事件响应时间段
        public int 						 nInterval; 				// 雨刷运动间隔事件, 单位: 秒
        public int 						 bProtectEnable; 			// 雨刷保护使能: true 保护开启, false 保护关闭
        public int 						 nProtectTime; 				// 保护时间, 单位: 秒
    }

    // 控制类型，对应CLIENT_ControlDevice接口
    public static class CtrlType extends SdkStructure
    {
        public static final int CTRLTYPE_CTRL_REBOOT = 0;//重启设备
        public static final int CTRLTYPE_CTRL_SHUTDOWN = CTRLTYPE_CTRL_REBOOT+1; //关闭设备
        public static final int CTRLTYPE_CTRL_DISK = CTRLTYPE_CTRL_SHUTDOWN+1; //硬盘管理
        public static final int CTRLTYPE_KEYBOARD_POWER =3;//网络键盘
        public static final int CTRLTYPE_KEYBOARD_ENTER = CTRLTYPE_KEYBOARD_POWER+1;
        public static final int CTRLTYPE_KEYBOARD_ESC = CTRLTYPE_KEYBOARD_ENTER+1;
        public static final int CTRLTYPE_KEYBOARD_UP = CTRLTYPE_KEYBOARD_ESC+1;
        public static final int CTRLTYPE_KEYBOARD_DOWN = CTRLTYPE_KEYBOARD_UP+1;
        public static final int CTRLTYPE_KEYBOARD_LEFT = CTRLTYPE_KEYBOARD_DOWN+1;
        public static final int CTRLTYPE_KEYBOARD_RIGHT = CTRLTYPE_KEYBOARD_LEFT+1;
        public static final int CTRLTYPE_KEYBOARD_BTN0 = CTRLTYPE_KEYBOARD_RIGHT+1;
        public static final int CTRLTYPE_KEYBOARD_BTN1 = CTRLTYPE_KEYBOARD_BTN0+1;
        public static final int CTRLTYPE_KEYBOARD_BTN2 = CTRLTYPE_KEYBOARD_BTN1+1;
        public static final int CTRLTYPE_KEYBOARD_BTN3 = CTRLTYPE_KEYBOARD_BTN2+1;
        public static final int CTRLTYPE_KEYBOARD_BTN4 = CTRLTYPE_KEYBOARD_BTN3+1;
        public static final int CTRLTYPE_KEYBOARD_BTN5 = CTRLTYPE_KEYBOARD_BTN4+1;
        public static final int CTRLTYPE_KEYBOARD_BTN6 = CTRLTYPE_KEYBOARD_BTN5+1;
        public static final int CTRLTYPE_KEYBOARD_BTN7 = CTRLTYPE_KEYBOARD_BTN6+1;
        public static final int CTRLTYPE_KEYBOARD_BTN8 = CTRLTYPE_KEYBOARD_BTN7+1;
        public static final int CTRLTYPE_KEYBOARD_BTN9 = CTRLTYPE_KEYBOARD_BTN8+1;
        public static final int CTRLTYPE_KEYBOARD_BTN10 = CTRLTYPE_KEYBOARD_BTN9+1;
        public static final int CTRLTYPE_KEYBOARD_BTN11 = CTRLTYPE_KEYBOARD_BTN10+1;
        public static final int CTRLTYPE_KEYBOARD_BTN12 = CTRLTYPE_KEYBOARD_BTN11+1;
        public static final int CTRLTYPE_KEYBOARD_BTN13 = CTRLTYPE_KEYBOARD_BTN12+1;
        public static final int CTRLTYPE_KEYBOARD_BTN14 = CTRLTYPE_KEYBOARD_BTN13+1;
        public static final int CTRLTYPE_KEYBOARD_BTN15 = CTRLTYPE_KEYBOARD_BTN14+1;
        public static final int CTRLTYPE_KEYBOARD_BTN16 = CTRLTYPE_KEYBOARD_BTN15+1;
        public static final int CTRLTYPE_KEYBOARD_SPLIT = CTRLTYPE_KEYBOARD_BTN16+1;
        public static final int CTRLTYPE_KEYBOARD_ONE = CTRLTYPE_KEYBOARD_SPLIT+1;
        public static final int CTRLTYPE_KEYBOARD_NINE = CTRLTYPE_KEYBOARD_ONE+1;
        public static final int CTRLTYPE_KEYBOARD_ADDR = CTRLTYPE_KEYBOARD_NINE+1;
        public static final int CTRLTYPE_KEYBOARD_INFO = CTRLTYPE_KEYBOARD_ADDR+1;
        public static final int CTRLTYPE_KEYBOARD_REC = CTRLTYPE_KEYBOARD_INFO+1;
        public static final int CTRLTYPE_KEYBOARD_FN1 = CTRLTYPE_KEYBOARD_REC+1;
        public static final int CTRLTYPE_KEYBOARD_FN2 = CTRLTYPE_KEYBOARD_FN1+1;
        public static final int CTRLTYPE_KEYBOARD_PLAY = CTRLTYPE_KEYBOARD_FN2+1;
        public static final int CTRLTYPE_KEYBOARD_STOP = CTRLTYPE_KEYBOARD_PLAY+1;
        public static final int CTRLTYPE_KEYBOARD_SLOW = CTRLTYPE_KEYBOARD_STOP+1;
        public static final int CTRLTYPE_KEYBOARD_FAST = CTRLTYPE_KEYBOARD_SLOW+1;
        public static final int CTRLTYPE_KEYBOARD_PREW = CTRLTYPE_KEYBOARD_FAST+1;
        public static final int CTRLTYPE_KEYBOARD_NEXT = CTRLTYPE_KEYBOARD_PREW+1;
        public static final int CTRLTYPE_KEYBOARD_JMPDOWN = CTRLTYPE_KEYBOARD_NEXT+1;
        public static final int CTRLTYPE_KEYBOARD_JMPUP = CTRLTYPE_KEYBOARD_JMPDOWN+1;
        public static final int CTRLTYPE_KEYBOARD_10PLUS = CTRLTYPE_KEYBOARD_JMPUP+1;
        public static final int CTRLTYPE_KEYBOARD_SHIFT = CTRLTYPE_KEYBOARD_10PLUS+1;
        public static final int CTRLTYPE_KEYBOARD_BACK = CTRLTYPE_KEYBOARD_SHIFT+1;
        public static final int CTRLTYPE_KEYBOARD_LOGIN = CTRLTYPE_KEYBOARD_BACK+1;						// 新网络键盘功能
        public static final int CTRLTYPE_KEYBOARD_CHNNEL = CTRLTYPE_KEYBOARD_LOGIN+1;					// 切换视频通道
        public static final int CTRLTYPE_TRIGGER_ALARM_IN =100;											// 触发报警输入
        public static final int CTRLTYPE_TRIGGER_ALARM_OUT = CTRLTYPE_TRIGGER_ALARM_IN+1; 				// 触发报警输出
        public static final int CTRLTYPE_CTRL_MATRIX = CTRLTYPE_TRIGGER_ALARM_OUT+1; 					// 矩阵控制
        public static final int CTRLTYPE_CTRL_SDCARD = CTRLTYPE_CTRL_MATRIX+1; 							// SD卡控制(IPC产品)参数同硬盘控制
        public static final int CTRLTYPE_BURNING_START = CTRLTYPE_CTRL_SDCARD+1; 						// 刻录机控制，开始刻录
        public static final int CTRLTYPE_BURNING_STOP = CTRLTYPE_BURNING_START+1; 						// 刻录机控制，结束刻录
        public static final int CTRLTYPE_BURNING_ADDPWD = CTRLTYPE_BURNING_STOP+1; 						// 刻录机控制，叠加密码(以'\0'为结尾的字符串，最大长度8位)
        public static final int CTRLTYPE_BURNING_ADDHEAD = CTRLTYPE_BURNING_ADDPWD+1; 					// 刻录机控制，叠加片头(以'\0'为结尾的字符串，最大长度1024字节，支持分行，行分隔符'\n')
        public static final int CTRLTYPE_BURNING_ADDSIGN = CTRLTYPE_BURNING_ADDHEAD+1; 					// 刻录机控制，叠加打点到刻录信息(参数无)
        public static final int CTRLTYPE_BURNING_ADDCURSTOMINFO = CTRLTYPE_BURNING_ADDSIGN+1; 			// 刻录机控制，自定义叠加(以'\0'为结尾的字符串，最大长度1024字节，支持分行，行分隔符'\n')
        public static final int CTRLTYPE_CTRL_RESTOREDEFAULT = CTRLTYPE_BURNING_ADDCURSTOMINFO+1; 		// 恢复设备的默认设置
        public static final int CTRLTYPE_CTRL_CAPTURE_START = CTRLTYPE_CTRL_RESTOREDEFAULT+1; 			// 触发设备抓图
        public static final int CTRLTYPE_CTRL_CLEARLOG = CTRLTYPE_CTRL_CAPTURE_START+1; 				// 清除日志
        public static final int CTRLTYPE_TRIGGER_ALARM_WIRELESS =200;									// 触发无线报警(IPC产品)
        public static final int CTRLTYPE_MARK_IMPORTANT_RECORD = CTRLTYPE_TRIGGER_ALARM_WIRELESS+1; 	// 标识重要录像文件
        public static final int CTRLTYPE_CTRL_DISK_SUBAREA = CTRLTYPE_MARK_IMPORTANT_RECORD+1; 			// 网络硬盘分区
        public static final int CTRLTYPE_BURNING_ATTACH = CTRLTYPE_CTRL_DISK_SUBAREA+1; 				// 刻录机控制，附件刻录.
        public static final int CTRLTYPE_BURNING_PAUSE = CTRLTYPE_BURNING_ATTACH+1; 					// 刻录暂停
        public static final int CTRLTYPE_BURNING_CONTINUE = CTRLTYPE_BURNING_PAUSE+1; 					// 刻录继续
        public static final int CTRLTYPE_BURNING_POSTPONE = CTRLTYPE_BURNING_CONTINUE+1; 				// 刻录顺延
        public static final int CTRLTYPE_CTRL_OEMCTRL = CTRLTYPE_BURNING_POSTPONE+1; 					// 报停控制
        public static final int CTRLTYPE_BACKUP_START = CTRLTYPE_CTRL_OEMCTRL+1; 						// 设备备份开始
        public static final int CTRLTYPE_BACKUP_STOP = CTRLTYPE_BACKUP_START+1; 						// 设备备份停止
        public static final int CTRLTYPE_VIHICLE_WIFI_ADD = CTRLTYPE_BACKUP_STOP+1; 					// 车载手动增加WIFI配置
        public static final int CTRLTYPE_VIHICLE_WIFI_DEC = CTRLTYPE_VIHICLE_WIFI_ADD+1; 				// 车载手动删除WIFI配置
        public static final int CTRLTYPE_BUZZER_START = CTRLTYPE_VIHICLE_WIFI_DEC+1; 					// 蜂鸣器控制开始
        public static final int CTRLTYPE_BUZZER_STOP = CTRLTYPE_BUZZER_START+1; 						// 蜂鸣器控制结束
        public static final int CTRLTYPE_REJECT_USER = CTRLTYPE_BUZZER_STOP+1; 							// 剔除用户
        public static final int CTRLTYPE_SHIELD_USER = CTRLTYPE_REJECT_USER+1; 							// 屏蔽用户
        public static final int CTRLTYPE_RAINBRUSH = CTRLTYPE_SHIELD_USER+1; 							// 智能交通,雨刷控制
        public static final int CTRLTYPE_MANUAL_SNAP = CTRLTYPE_RAINBRUSH+1; 							// 智能交通,手动抓拍(对应结构体MANUAL_SNAP_PARAMETER)
        public static final int CTRLTYPE_MANUAL_NTP_TIMEADJUST = CTRLTYPE_MANUAL_SNAP+1; 				// 手动NTP校时
        public static final int CTRLTYPE_NAVIGATION_SMS = CTRLTYPE_MANUAL_NTP_TIMEADJUST+1; 			// 导航信息和短消息
        public static final int CTRLTYPE_CTRL_ROUTE_CROSSING = CTRLTYPE_NAVIGATION_SMS+1; 				// 路线点位信息
        public static final int CTRLTYPE_BACKUP_FORMAT = CTRLTYPE_CTRL_ROUTE_CROSSING+1; 				// 格式化备份设备
        public static final int CTRLTYPE_DEVICE_LOCALPREVIEW_SLIPT = CTRLTYPE_BACKUP_FORMAT+1; 			// 控制设备端本地预览分割(对应结构体DEVICE_LOCALPREVIEW_SLIPT_PARAMETER)
        public static final int CTRLTYPE_CTRL_INIT_RAID = CTRLTYPE_DEVICE_LOCALPREVIEW_SLIPT+1; 		// RAID初始化
        public static final int CTRLTYPE_CTRL_RAID = CTRLTYPE_CTRL_INIT_RAID+1; 						// RAID操作
        public static final int CTRLTYPE_CTRL_SAPREDISK = CTRLTYPE_CTRL_RAID+1; 						// 热备盘操作
        public static final int CTRLTYPE_WIFI_CONNECT = CTRLTYPE_CTRL_SAPREDISK+1; 						// 手动发起WIFI连接(对应结构体WIFI_CONNECT)
        public static final int CTRLTYPE_WIFI_DISCONNECT = CTRLTYPE_WIFI_CONNECT+1; 					// 手动断开WIFI连接(对应结构体WIFI_CONNECT)
        public static final int CTRLTYPE_CTRL_ARMED = CTRLTYPE_WIFI_DISCONNECT+1; 						// 布撤防操作
        public static final int CTRLTYPE_CTRL_IP_MODIFY = CTRLTYPE_CTRL_ARMED+1; 						// 修改前端IP(对应结构体 NET_CTRL_IPMODIFY_PARAM)
        public static final int CTRLTYPE_CTRL_WIFI_BY_WPS = CTRLTYPE_CTRL_IP_MODIFY+1; 					// wps连接wifi(对应结构体NET_CTRL_CONNECT_WIFI_BYWPS)
        public static final int CTRLTYPE_CTRL_FORMAT_PATITION = CTRLTYPE_CTRL_WIFI_BY_WPS+1; 			// 格式化分区(对应结构体NET_FORMAT_PATITION)
        public static final int CTRLTYPE_CTRL_EJECT_STORAGE = CTRLTYPE_CTRL_FORMAT_PATITION+1; 			// 手动卸载设备(对应结构体NET_EJECT_STORAGE_DEVICE)
        public static final int CTRLTYPE_CTRL_LOAD_STORAGE = CTRLTYPE_CTRL_EJECT_STORAGE+1; 			// 手动装载设备(对应结构体NET_LOAD_STORAGE_DEVICE)
        public static final int CTRLTYPE_CTRL_CLOSE_BURNER = CTRLTYPE_CTRL_LOAD_STORAGE+1; 				// 关闭刻录机光驱门(对应结构体NET_CTRL_BURNERDOOR)一般需要等6
        public static final int CTRLTYPE_CTRL_EJECT_BURNER = CTRLTYPE_CTRL_CLOSE_BURNER+1; 				// 弹出刻录机光驱门(对应结构体NET_CTRL_BURNERDOOR)一般需要等4秒
        public static final int CTRLTYPE_CTRL_CLEAR_ALARM = CTRLTYPE_CTRL_EJECT_BURNER+1; 				// 消警(对应结构体NET_CTRL_CLEAR_ALARM)
        public static final int CTRLTYPE_CTRL_MONITORWALL_TVINFO = CTRLTYPE_CTRL_CLEAR_ALARM+1; 		// 电视墙信息显示(对应结构体NET_CTRL_MONITORWALL_TVINFO)
        public static final int CTRLTYPE_CTRL_START_VIDEO_ANALYSE = CTRLTYPE_CTRL_MONITORWALL_TVINFO+1; // 开始视频智能分析(对应结构体NET_CTRL_START_VIDEO_ANALYSE)
        public static final int CTRLTYPE_CTRL_STOP_VIDEO_ANALYSE = CTRLTYPE_CTRL_START_VIDEO_ANALYSE+1; // 停止视频智能分析(对应结构体NET_CTRL_STOP_VIDEO_ANALYSE)
        public static final int CTRLTYPE_CTRL_UPGRADE_DEVICE = CTRLTYPE_CTRL_STOP_VIDEO_ANALYSE+1; 		// 控制启动设备升级,由设备独立完成升级过程,不需要传输升级文件
        public static final int CTRLTYPE_CTRL_MULTIPLAYBACK_CHANNALES = CTRLTYPE_CTRL_UPGRADE_DEVICE+1; // 切换多通道预览回放的通道(对应结构体NET_CTRL_MULTIPLAYBACK_CHANNALES)
        public static final int CTRLTYPE_CTRL_SEQPOWER_OPEN = CTRLTYPE_CTRL_MULTIPLAYBACK_CHANNALES+1;  // 电源时序器打开开关量输出口(对应NET_CTRL_SEQPOWER_PARAM)
        public static final int CTRLTYPE_CTRL_SEQPOWER_CLOSE = CTRLTYPE_CTRL_SEQPOWER_OPEN+1; 			// 电源时序器关闭开关量输出口(对应NET_CTRL_SEQPOWER_PARAM)
        public static final int CTRLTYPE_CTRL_SEQPOWER_OPEN_ALL = CTRLTYPE_CTRL_SEQPOWER_CLOSE+1; 		// 电源时序器打开开关量输出口组(对应NET_CTRL_SEQPOWER_PARAM)
        public static final int CTRLTYPE_CTRL_SEQPOWER_CLOSE_ALL = CTRLTYPE_CTRL_SEQPOWER_OPEN_ALL+1;   // 电源时序器关闭开关量输出口组(对应NET_CTRL_SEQPOWER_PARAM)
        public static final int CTRLTYPE_CTRL_PROJECTOR_RISE = CTRLTYPE_CTRL_SEQPOWER_CLOSE_ALL+1; 		// 投影仪上升(对应NET_CTRL_PROJECTOR_PARAM)
        public static final int CTRLTYPE_CTRL_PROJECTOR_FALL = CTRLTYPE_CTRL_PROJECTOR_RISE+1; 			// 投影仪下降(对应NET_CTRL_PROJECTOR_PARAM)
        public static final int CTRLTYPE_CTRL_PROJECTOR_STOP = CTRLTYPE_CTRL_PROJECTOR_FALL+1; 			// 投影仪停止(对应NET_CTRL_PROJECTOR_PARAM)
        public static final int CTRLTYPE_CTRL_INFRARED_KEY = CTRLTYPE_CTRL_PROJECTOR_STOP+1; 			// 红外按键(对应NET_CTRL_INFRARED_KEY_PARAM)
        public static final int CTRLTYPE_CTRL_START_PLAYAUDIO = CTRLTYPE_CTRL_INFRARED_KEY+1; 			// 设备开始播放音频文件(对应结构体NET_CTRL_START_PLAYAUDIO)
        public static final int CTRLTYPE_CTRL_STOP_PLAYAUDIO = CTRLTYPE_CTRL_START_PLAYAUDIO+1; 		// 设备停止播放音频文件
        public static final int CTRLTYPE_CTRL_START_ALARMBELL = CTRLTYPE_CTRL_STOP_PLAYAUDIO+1; 		// 开启警号(对应结构体 NET_CTRL_ALARMBELL )
        public static final int CTRLTYPE_CTRL_STOP_ALARMBELL = CTRLTYPE_CTRL_START_ALARMBELL+1; 		// 关闭警号(对应结构体 NET_CTRL_ALARMBELL )
        public static final int CTRLTYPE_CTRL_ACCESS_OPEN = CTRLTYPE_CTRL_STOP_ALARMBELL+1; 			// 门禁控制-开门(对应结构体 NET_CTRL_ACCESS_OPEN)
        public static final int CTRLTYPE_CTRL_SET_BYPASS = CTRLTYPE_CTRL_ACCESS_OPEN+1; 				// 设置旁路功能(对应结构体NET_CTRL_SET_BYPASS)
        public static final int CTRLTYPE_CTRL_RECORDSET_INSERT = CTRLTYPE_CTRL_SET_BYPASS+1; 			// 添加记录，获得记录集编号(对应NET_CTRL_RECORDSET_INSERT_PARAM)
        public static final int CTRLTYPE_CTRL_RECORDSET_UPDATE = CTRLTYPE_CTRL_RECORDSET_INSERT+1; 		// 更新某记录集编号的记录(对应 NET_CTRL_RECORDSET_PARAM)
        public static final int CTRLTYPE_CTRL_RECORDSET_REMOVE = CTRLTYPE_CTRL_RECORDSET_UPDATE+1;	    // 根据记录集编号删除某记录(对应 NET_CTRL_RECORDSET_PARAM)
        public static final int CTRLTYPE_CTRL_RECORDSET_CLEAR = CTRLTYPE_CTRL_RECORDSET_REMOVE+1; 		// 清除所有记录集信息(对应NET_CTRL_RECORDSET_PARAM)
        public static final int CTRLTYPE_CTRL_ACCESS_CLOSE = CTRLTYPE_CTRL_RECORDSET_CLEAR+1; 			// 门禁控制-关门(对应结构体NET_CTRL_ACCESS_CLOSE)
        public static final int CTRLTYPE_CTRL_ALARM_SUBSYSTEM_ACTIVE_SET = CTRLTYPE_CTRL_ACCESS_CLOSE+1;// 报警子系统激活设置(对应结构体NET_CTRL_ALARM_SUBSYSTEM_SETACTIVE)
        public static final int CTRLTYPE_CTRL_FORBID_OPEN_STROBE = CTRLTYPE_CTRL_ALARM_SUBSYSTEM_ACTIVE_SET+1; // 禁止设备端开闸(对应结构体NET_CTRL_FORBID_OPEN_STROBE)
        public static final int CTRLTYPE_CTRL_OPEN_STROBE = CTRLTYPE_CTRL_FORBID_OPEN_STROBE+1; 		// 开启道闸(对应结构体 NET_CTRL_OPEN_STROBE)
        public static final int CTRLTYPE_CTRL_TALKING_REFUSE = CTRLTYPE_CTRL_OPEN_STROBE+1; 			// 对讲拒绝接听(对应结构体NET_CTRL_TALKING_REFUSE)
        public static final int CTRLTYPE_CTRL_ARMED_EX = CTRLTYPE_CTRL_TALKING_REFUSE+1; 				// 布撤防操作(对应结构体CTRL_ARM_DISARM_PARAM_EX),对CTRL_ARM_DISARM_PARAM升级，建议用这个
        public static final int CTRLTYPE_CTRL_NET_KEYBOARD =400;										// 网络键盘控制(对应结构体NET_CTRL_NET_KEYBOARD)
        public static final int CTRLTYPE_CTRL_AIRCONDITION_OPEN = CTRLTYPE_CTRL_NET_KEYBOARD+1; 		// 打开空调(对应结构体NET_CTRL_OPEN_AIRCONDITION)
        public static final int CTRLTYPE_CTRL_AIRCONDITION_CLOSE = CTRLTYPE_CTRL_AIRCONDITION_OPEN+1; 	// 关闭空调(对应结构体NET_CTRL_CLOSE_AIRCONDITION)
        public static final int CTRLTYPE_CTRL_AIRCONDITION_SET_TEMPERATURE = CTRLTYPE_CTRL_AIRCONDITION_CLOSE+1; // 设定空调温度(对应结构体NET_CTRL_SET_TEMPERATURE)
        public static final int CTRLTYPE_CTRL_AIRCONDITION_ADJUST_TEMPERATURE = CTRLTYPE_CTRL_AIRCONDITION_SET_TEMPERATURE+1; // 调节空调温度(对应结构体NET_CTRL_ADJUST_TEMPERATURE)
        public static final int CTRLTYPE_CTRL_AIRCONDITION_SETMODE = CTRLTYPE_CTRL_AIRCONDITION_ADJUST_TEMPERATURE+1; 		  // 设置空调工作模式(对应结构体NET_CTRL_ADJUST_TEMPERATURE)
        public static final int CTRLTYPE_CTRL_AIRCONDITION_SETWINDMODE = CTRLTYPE_CTRL_AIRCONDITION_SETMODE+1;   // 设置空调送风模式(对应结构体NET_CTRL_AIRCONDITION_SETMODE)
        public static final int CTRLTYPE_CTRL_RESTOREDEFAULT_EX  = CTRLTYPE_CTRL_AIRCONDITION_SETWINDMODE+1;	 // 恢复设备的默认设置新协议(对应结构体 NET_CTRL_RESTORE_DEFAULT )
        // 恢复配置优先使用该枚举，如果接口失败，
        // 且CLIENT_GetLastError返回NET_UNSUPPORTED,再尝试使用NET_CTRL_RESTOREDEFAULT恢复配置
        public static final int CTRLTYPE_CTRL_NOTIFY_EVENT = CTRLTYPE_CTRL_RESTOREDEFAULT_EX+1; 	   // 向设备发送事件(对应结构体NET_NOTIFY_EVENT_DATA)
        public static final int CTRLTYPE_CTRL_SILENT_ALARM_SET = CTRLTYPE_CTRL_NOTIFY_EVENT+1; 		   // 无声报警设置
        public static final int CTRLTYPE_CTRL_START_PLAYAUDIOEX = CTRLTYPE_CTRL_SILENT_ALARM_SET+1;    // 设备开始语音播报(对应结构体NET_CTRL_START_PLAYAUDIOEX)
        public static final int CTRLTYPE_CTRL_STOP_PLAYAUDIOEX = CTRLTYPE_CTRL_START_PLAYAUDIOEX+1;    // 设备停止语音播报
        public static final int CTRLTYPE_CTRL_CLOSE_STROBE = CTRLTYPE_CTRL_STOP_PLAYAUDIOEX+1;         // 关闭道闸(对应结构体 NET_CTRL_CLOSE_STROBE)
        public static final int CTRLTYPE_CTRL_SET_ORDER_STATE = CTRLTYPE_CTRL_CLOSE_STROBE+1; 		   // 设置车位预定状态(对应结构体NET_CTRL_SET_ORDER_STATE)
        public static final int CTRLTYPE_CTRL_RECORDSET_INSERTEX = CTRLTYPE_CTRL_SET_ORDER_STATE+1;    // 添加记录，获得记录集编号(对应 NET_CTRL_RECORDSET_INSERT_PARAM )
        public static final int CTRLTYPE_CTRL_RECORDSET_UPDATEEX = CTRLTYPE_CTRL_RECORDSET_INSERTEX+1; // 更新某记录集编号的记录(对应NET_CTRL_RECORDSET_PARAM)
        public static final int CTRLTYPE_CTRL_CAPTURE_FINGER_PRINT = CTRLTYPE_CTRL_RECORDSET_UPDATEEX+1; // 指纹采集(对应结构体NET_CTRL_CAPTURE_FINGER_PRINT)
        public static final int CTRLTYPE_CTRL_ECK_LED_SET = CTRLTYPE_CTRL_CAPTURE_FINGER_PRINT+1; 	   // 停车场出入口控制器LED设置(对应结构体NET_CTRL_ECK_LED_SET_PARAM)
        public static final int CTRLTYPE_CTRL_ECK_IC_CARD_IMPORT = CTRLTYPE_CTRL_ECK_LED_SET+1; 	   // 智能停车系统出入口机IC卡信息导入(对应结构体NET_CTRL_ECK_IC_CARD_IMPORT_PARAM)
        public static final int CTRLTYPE_CTRL_ECK_SYNC_IC_CARD = CTRLTYPE_CTRL_ECK_IC_CARD_IMPORT+1;   // 智能停车系统出入口机IC卡信息同步指令，收到此指令后，设备删除原有IC卡信息(对应结构体NET_CTRL_ECK_SYNC_IC_CARD_PARAM)
        public static final int CTRLTYPE_CTRL_LOWRATEWPAN_REMOVE = CTRLTYPE_CTRL_ECK_SYNC_IC_CARD+1;   // 删除指定无线设备(对应结构体NET_CTRL_LOWRATEWPAN_REMOVE)
        public static final int CTRLTYPE_CTRL_LOWRATEWPAN_MODIFY = CTRLTYPE_CTRL_LOWRATEWPAN_REMOVE+1; // 修改无线设备信息(对应结构体NET_CTRL_LOWRATEWPAN_MODIFY)
        public static final int CTRLTYPE_CTRL_ECK_SET_PARK_INFO = CTRLTYPE_CTRL_LOWRATEWPAN_MODIFY+1;  // 智能停车系统出入口机设置车位信息(对应结构体NET_CTRL_ECK_SET_PARK_INFO_PARAM)
        public static final int CTRLTYPE_CTRL_VTP_DISCONNECT = CTRLTYPE_CTRL_ECK_SET_PARK_INFO+1; 	   // 挂断视频电话(对应结构体NET_CTRL_VTP_DISCONNECT)
        public static final int CTRLTYPE_CTRL_UPDATE_FILES = CTRLTYPE_CTRL_VTP_DISCONNECT+1; 		   // 远程投放多媒体文件更新(对应结构体NET_CTRL_UPDATE_FILES)
        public static final int CTRLTYPE_CTRL_MATRIX_SAVE_SWITCH = CTRLTYPE_CTRL_UPDATE_FILES+1; 	   // 保存上下位矩阵输出关系(对应结构体NET_CTRL_MATRIX_SAVE_SWITCH)
        public static final int CTRLTYPE_CTRL_MATRIX_RESTORE_SWITCH = CTRLTYPE_CTRL_MATRIX_SAVE_SWITCH+1; // 恢复上下位矩阵输出关系(对应结构体NET_CTRL_MATRIX_RESTORE_SWITCH)
        public static final int CTRLTYPE_CTRL_VTP_DIVERTACK = CTRLTYPE_CTRL_MATRIX_RESTORE_SWITCH+1;   // 呼叫转发响应(对应结构体NET_CTRL_VTP_DIVERTACK)
        public static final int CTRLTYPE_CTRL_RAINBRUSH_MOVEONCE = CTRLTYPE_CTRL_VTP_DIVERTACK+1;      // 雨刷来回刷一次，雨刷模式配置为手动模式时有效(对应结构体NET_CTRL_RAINBRUSH_MOVEONCE)
        public static final int CTRLTYPE_CTRL_RAINBRUSH_MOVECONTINUOUSLY = CTRLTYPE_CTRL_RAINBRUSH_MOVEONCE+1; 		   // 雨刷来回循环刷，雨刷模式配置为手动模式时有效(对应结构体NET_CTRL_RAINBRUSH_MOVECONTINUOUSLY)
        public static final int CTRLTYPE_CTRL_RAINBRUSH_STOPMOVE = CTRLTYPE_CTRL_RAINBRUSH_MOVECONTINUOUSLY+1; 		   // 雨刷停止刷，雨刷模式配置为手动模式时有效(对应结构体NET_CTRL_RAINBRUSH_STOPMOVE)
        public static final int CTRLTYPE_CTRL_ALARM_ACK = CTRLTYPE_CTRL_RAINBRUSH_STOPMOVE+1; 		   				   // 报警事件确认(对应结构体NET_CTRL_ALARM_ACK)
        // NET_CTRL_ALARM_ACK 该操作切勿在报警回调接口中调用
        public static final int CTRLTYPE_CTRL_RECORDSET_IMPORT = CTRLTYPE_CTRL_ALARM_ACK + 1; 		   				   // 批量导入记录集信息(对应 NET_CTRL_RECORDSET_PARAM )
        public static final int CTRLTYPE_CTRL_DELIVERY_FILE = CTRLTYPE_CTRL_RECORDSET_IMPORT + 1; 	   				   // 向视频输出口投放视频和图片文件, 楼宇对讲使用，同一时间投放(对应 NET_CTRL_DELIVERY_FILE )
        public static final int CTRLTYPE_CTRL_FORCE_BREAKING = CTRLTYPE_CTRL_DELIVERY_FILE + 1;                        // 强制产生违章类型(对应 NET_CTRL_FORCE_BREAKING)
        public static final int CTRLTYPE_CTRL_RESTORE_EXCEPT = CTRLTYPE_CTRL_FORCE_BREAKING + 1;					   // 恢复除指定配置外的其他配置为默认。
        public static final int CTRLTYPE_CTRL_SET_PARK_INFO = CTRLTYPE_CTRL_RESTORE_EXCEPT + 1;						   // 设置停车信息，平台设置给相机，内容用于点阵屏显示(对应结构体 NET_CTRL_SET_PARK_INFO)
        public static final int CTRLTYPE_CTRL_CLEAR_SECTION_STAT = CTRLTYPE_CTRL_SET_PARK_INFO + 1;					   // 清除当前时间段内人数统计信息, 重新从0开始计算(对应结构体NET_CTRL_CLEAR_SECTION_STAT_INFO)
        public static final int CTRLTYPE_CTRL_DELIVERY_FILE_BYCAR = CTRLTYPE_CTRL_CLEAR_SECTION_STAT + 1;              // 向视频输出口投放视频和图片文件, 车载使用，广告单独时间投放(对应NET_CTRL_DELIVERY_FILE_BYCAR)
        public static final int CTRLTYPE_CTRL_ECK_GUIDINGPANEL_CONTENT = CTRLTYPE_CTRL_DELIVERY_FILE_BYCAR + 1;        // 设置诱导屏显示内容(对应结构体 NET_CTRL_ECK_GUIDINGPANEL_CONTENT)
        public static final int CTRLTYPE_CTRL_SET_SAFE_LEVEL = CTRLTYPE_CTRL_ECK_GUIDINGPANEL_CONTENT + 1;		       // 设置门禁安全等级(对应结构体，pInBuf= NET_IN_SET_SAFE_LEVEL*, pOutBuf= NET_OUT_SET_SAFE_LEVEL * )
        public static final int CTRLTYPE_CTRL_VTP_INVITEACK = CTRLTYPE_CTRL_SET_SAFE_LEVEL + 1;                        // 对讲请求回复(对应结构体 NET_CTRL_VTP_INVITEACK)
        public static final int CTRLTYPE_CTRL_ACCESS_RESET_PASSWORD = CTRLTYPE_CTRL_VTP_INVITEACK + 1;                 // 门禁控制-重置密码(对应结构体 NET_CTRL_ACCESS_RESET_PASSWORD)

        /**
         *  以下命令只在 CLIENT_ControlDeviceEx 上有效
         */
        public static final int CTRLTYPE_CTRL_THERMO_GRAPHY_ENSHUTTER = 0x10000;										// 设置热成像快门启用/禁用,pInBuf= NET_IN_THERMO_EN_SHUTTER*, pOutBuf= NET_OUT_THERMO_EN_SHUTTER *
        public static final int CTRLTYPE_CTRL_RADIOMETRY_SETOSDMARK = CTRLTYPE_CTRL_THERMO_GRAPHY_ENSHUTTER+1;          // 设置测温项的osd为高亮,pInBuf=NET_IN_RADIOMETRY_SETOSDMARK*,pOutBuf= NET_OUT_RADIOMETRY_SETOSDMARK *
        public static final int CTRLTYPE_CTRL_AUDIO_REC_START_NAME = CTRLTYPE_CTRL_RADIOMETRY_SETOSDMARK+1; 		    // 开启音频录音并得到录音名,pInBuf = NET_IN_AUDIO_REC_MNG_NAME *, pOutBuf = NET_OUT_AUDIO_REC_MNG_NAME *
        public static final int CTRLTYPE_CTRL_AUDIO_REC_STOP_NAME = CTRLTYPE_CTRL_AUDIO_REC_START_NAME+1; 				// 关闭音频录音并返回文件名称,pInBuf = NET_IN_AUDIO_REC_MNG_NAME *, pOutBuf = NET_OUT_AUDIO_REC_MNG_NAME *
        public static final int CTRLTYPE_CTRL_SNAP_MNG_SNAP_SHOT = CTRLTYPE_CTRL_AUDIO_REC_STOP_NAME+1; 				// 即时抓图(又名手动抓图),pInBuf  =NET_IN_SNAP_MNG_SHOT *, pOutBuf = NET_OUT_SNAP_MNG_SHOT *
        public static final int CTRLTYPE_CTRL_LOG_STOP = CTRLTYPE_CTRL_SNAP_MNG_SNAP_SHOT+1; 							// 强制同步缓存数据到数据库并关闭数据库,pInBuf = NET_IN_LOG_MNG_CTRL *, pOutBuf = NET_OUT_LOG_MNG_CTRL *
        public static final int CTRLTYPE_CTRL_LOG_RESUME = CTRLTYPE_CTRL_LOG_STOP+1; 									// 恢复数据库,pInBuf = NET_IN_LOG_MNG_CTRL *, pOutBuf = NET_OUT_LOG_MNG_CTRL *

        public static final int CTRLTYPE_CTRL_POS_ADD = CTRLTYPE_CTRL_LOG_RESUME + 1;	                               // 增加一个Pos设备, pInBuf = NET_IN_POS_ADD *, pOutBuf = NET_OUT_POS_ADD *
        public static final int CTRLTYPE_CTRL_POS_REMOVE = CTRLTYPE_CTRL_POS_ADD + 1;                            // 删除一个Pos设备, pInBuf = NET_IN_POS_REMOVE *, pOutBuf = NET_OUT_POS_REMOVE *
        public static final int CTRLTYPE_CTRL_POS_REMOVE_MULTI = CTRLTYPE_CTRL_POS_REMOVE + 1;                      // 批量删除Pos设备, pInBuf = NET_IN_POS_REMOVE_MULTI *, pOutBuf = NET_OUT_POS_REMOVE_MULTI *
        public static final int CTRLTYPE_CTRL_POS_MODIFY = CTRLTYPE_CTRL_POS_REMOVE_MULTI + 1;                            // 修改一个Pos设备, pInBuf = NET_IN_POS_ADD *, pOutBuf = NET_OUT_POS_ADD *
        public static final int CTRLTYPE_CTRL_SET_SOUND_ALARM = CTRLTYPE_CTRL_POS_MODIFY + 1;                       // 触发有声报警, pInBuf = NET_IN_SOUND_ALARM *, pOutBuf = NET_OUT_SOUND_ALARM *
        public static final int CTRLTYPE_CTRL_AUDIO_MATRIX_SILENCE = CTRLTYPE_CTRL_SET_SOUND_ALARM + 1;				   // 音频举证一键静音控制(对应pInBuf = NET_IN_AUDIO_MATRIX_SILENCE, pOutBuf =  NET_OUT_AUDIO_MATRIX_SILENCE)
        public static final int CTRLTYPE_CTRL_MANUAL_UPLOAD_PICTURE = CTRLTYPE_CTRL_AUDIO_MATRIX_SILENCE + 1;                 // 设置手动上传, pInBuf = NET_IN_MANUAL_UPLOAD_PICTURE *, pOutBUf = NET_OUT_MANUAL_UPLOAD_PICTURE *
        public static final int CTRLTYPE_CTRL_REBOOT_NET_DECODING_DEV = CTRLTYPE_CTRL_MANUAL_UPLOAD_PICTURE + 1;               // 重启网络解码设备, pInBuf = NET_IN_REBOOT_NET_DECODING_DEV *, pOutBuf = NET_OUT_REBOOT_NET_DECODING_DEV *
        public static final int CTRLTYPE_CTRL_SET_IC_SENDER = CTRLTYPE_CTRL_REBOOT_NET_DECODING_DEV + 1;						   // ParkingControl 设置发卡设备, pInBuf = NET_IN_SET_IC_SENDER *, pOutBuf = NET_OUT_SET_IC_SENDER *
        public static final int CTRLTYPE_CTRL_SET_MEDIAKIND = CTRLTYPE_CTRL_SET_IC_SENDER + 1;                         // 设置监视码流组成,如仅音频,仅视频,音视频 pInBuf = NET_IN_SET_MEDIAKIND *, pOutBuf = NET_OUT_SET_MEDIAKIND *// 配合功能列表能力集使用, EN_ENCODE_CHN,2-监视支持音视频分开获取
        public static final int CTRLTYPE_CTRL_LOWRATEWPAN_ADD = CTRLTYPE_CTRL_SET_MEDIAKIND + 1;                       // 增加无线设备信息(对应结构体 pInBuf = NET_CTRL_LOWRATEWPAN_ADD *, pOutBUf = NULL)
        public static final int CTRLTYPE_CTRL_LOWRATEWPAN_REMOVEALL = CTRLTYPE_CTRL_LOWRATEWPAN_ADD + 1;                 // 删除所有的无线设备信息(对应结构体 pInBuf = NET_CTRL_LOWRATEWPAN_REMOVEALL *, pOutBUf = NULL)
        public static final int CTRLTYPE_CTRL_SET_DOOR_WORK_MODE =  CTRLTYPE_CTRL_LOWRATEWPAN_REMOVEALL + 1;                   // 设置门锁工作模式(对应结构体 pInBuf = NET_IN_CTRL_ACCESS_SET_DOOR_WORK_MODE *, pOutBUf = NULL)
        public static final int CTRLTYPE_CTRL_TEST_MAIL = CTRLTYPE_CTRL_SET_DOOR_WORK_MODE + 1;                             // 测试邮件 pInBuf = NET_IN_TEST_MAIL *, pOutBUf = NET_OUT_TEST_MAIL *
        public static final int CTRLTYPE_CTRL_CONTROL_SMART_SWITCH = CTRLTYPE_CTRL_TEST_MAIL + 1;                  // 控制智能开关 pInBuf = NET_IN_CONTROL_SMART_SWITCH *, pOutBUf = NET_OUT_CONTROL_SMART_SWITCH *
        public static final int CTRLTYPE_CTRL_LOWRATEWPAN_SETWORKMODE = CTRLTYPE_CTRL_CONTROL_SMART_SWITCH + 1;          	   // 设置探测器的工作模式(对应结构体pInBuf = NET_IN_CTRL_LOWRATEWPAN_SETWORKMODE *, pOutBUf = NULL)
        public static final int CTRLTYPE_CTRL_COAXIAL_CONTROL_IO = CTRLTYPE_CTRL_LOWRATEWPAN_SETWORKMODE + 1;					   // 发送同轴IO控制命令(对应结构体pInBuf = NET_IN_CONTROL_COAXIAL_CONTROL_IO*, pOutBUf = NET_OUT_CONTROL_COAXIAL_CONTROL_IO*)
        public static final int CTRLTYPE_CTRL_START_REMOTELOWRATEWPAN_ALARMBELL = CTRLTYPE_CTRL_COAXIAL_CONTROL_IO + 1;		// 开启无线警号 (对应结构体pInBuf = NET_IN_START_REMOTELOWRATEWPAN_ALARMBELL*, pOutBUf = NET_OUT_START_REMOTELOWRATEWPAN_ALARMBELL*)
        public static final int CTRLTYPE_CTRL_STOP_REMOTELOWRATEWPAN_ALARMBELL = CTRLTYPE_CTRL_START_REMOTELOWRATEWPAN_ALARMBELL + 1;		// 关闭无线警号 (对应结构体pInBuf = NET_IN_STOP_REMOTELOWRATEWPAN_ALARMBELL*, pOutBUf = NET_OUT_STOP_REMOTELOWRATEWPAN_ALARMBELL*)
        public static final int CTRLTYPE_CTRL_THERMO_DO_FFC = CTRLTYPE_CTRL_STOP_REMOTELOWRATEWPAN_ALARMBELL + 1;							// 热成像FFC校准(对应结构体 pInBuf = NET_IN_THERMO_DO_FFC *,pOutBuf = NET_OUT_THERMO_DO_FFC *)
        public static final int CTRLTYPE_CTRL_THERMO_FIX_FOCUS = CTRLTYPE_CTRL_THERMO_DO_FFC + 1;						// 热成像双目定焦调(对应结构体 pInBuf = NET_IN_THERMO_FIX_FOCUS *,pOutBuf = NET_OUT_THERMO_FIX_FOCUS *)
        public static final int CTRLTYPE_CTRL_SET_THIRD_CALLSTATUS = CTRLTYPE_CTRL_THERMO_FIX_FOCUS + 1;					// 设置对讲状态(对应结构体pInBuf = NET_IN_VTP_THIRDCALL_STATUS*, pOutBuf = NET_OUT_VTP_THIRDCALL_STATUS*)
        public static final int CTRL_ACCESS_CLEAR_STATUS = CTRLTYPE_CTRL_SET_THIRD_CALLSTATUS + 1;	                    // 门禁定制-清除用户进出门状态 (对应结构体pInBuf = NET_IN_ACCESS_CLEAR_STATUS*, pOutBuf = NET_OUT_ACCESS_CLEAR_STATUS *)
        public static final int CTRL_ACCESS_DEAL_RECORD = CTRL_ACCESS_CLEAR_STATUS + 1;                     // 门禁定制-查询/设置用户进出门记录 (对应结构体pInBuf = NET_IN_ACCESS_DEAL_RECORD*, pOutBuf = NET_OUT_ACCESS_DEAL_RECORD*)
        public static final int CTRL_QUERY_DELIVERED_FILE = CTRL_ACCESS_DEAL_RECORD + 1;                   // 向视频输出口查询广告信息,楼宇对讲使用,(对应NET_CTRL_QUERY_DELIVERY_FILE)
        public static final int CTRL_SET_PARK_CONTROL_INFO = CTRL_QUERY_DELIVERED_FILE + 1;					// 设置停车控制信息(点阵屏和语音播报的控制)(对应结构体pInBuf = NET_IN_SET_PARK_CONTROL_INFO*, pOutBuf = NET_OUT_SET_PARK_CONTROL_INFO*)   
    }

    // 视频压缩格式
    public static class CFG_VIDEO_COMPRESSION extends SdkStructure
    {
        public static final int VIDEO_FORMAT_MPEG4 = 0; //MPEG4
        public static final int VIDEO_FORMAT_MS_MPEG4 = VIDEO_FORMAT_MPEG4+1; //MS-MPEG4
        public static final int VIDEO_FORMAT_MPEG2 = VIDEO_FORMAT_MS_MPEG4+1; //MPEG2
        public static final int VIDEO_FORMAT_MPEG1 = VIDEO_FORMAT_MPEG2+1; //MPEG1
        public static final int VIDEO_FORMAT_H263 = VIDEO_FORMAT_MPEG1+1; //H.263
        public static final int VIDEO_FORMAT_MJPG = VIDEO_FORMAT_H263+1; //MJPG
        public static final int VIDEO_FORMAT_FCC_MPEG4 = VIDEO_FORMAT_MJPG+1; //FCC-MPEG4
        public static final int VIDEO_FORMAT_H264 = VIDEO_FORMAT_FCC_MPEG4+1; //H.264
        public static final int VIDEO_FORMAT_H265 = VIDEO_FORMAT_H264+1; //H.265
    }

    // 码流控制模式
    public static class CFG_BITRATE_CONTROL extends SdkStructure
    {
        public static final int BITRATE_CBR = 0;              //固定码流
        public static final int BITRATE_VBR = BITRATE_CBR+1; //可变码流
    }

    // H264 编码级别
    public static class CFG_H264_PROFILE_RANK extends SdkStructure
    {
        public static final int PROFILE_BASELINE = 1;//提供I/P帧，仅支持progressive(逐行扫描)和CAVLC
        public static final int PROFILE_MAIN = PROFILE_BASELINE+1; //提供I/P/B帧，支持progressiv和interlaced，提供CAVLC或CABAC
        public static final int PROFILE_EXTENDED = PROFILE_MAIN+1; //提供I/P/B/SP/SI帧，仅支持progressive(逐行扫描)和CAVLC
        public static final int PROFILE_HIGH = PROFILE_EXTENDED+1; //即FRExt，Main_Profile基础上新增：8x8intraprediction(8x8帧内预测), custom
        // quant(自定义量化), lossless video coding(无损视频编码), 更多的yuv格式
    }

    // 画质
    public static class CFG_IMAGE_QUALITY extends SdkStructure
    {
        public static final int IMAGE_QUALITY_Q10 = 1;//图像质量10%
        public static final int IMAGE_QUALITY_Q30 = IMAGE_QUALITY_Q10+1; //图像质量30%
        public static final int IMAGE_QUALITY_Q50 = IMAGE_QUALITY_Q30+1; //图像质量50%
        public static final int IMAGE_QUALITY_Q60 = IMAGE_QUALITY_Q50+1; //图像质量60%
        public static final int IMAGE_QUALITY_Q80 = IMAGE_QUALITY_Q60+1; //图像质量80%
        public static final int IMAGE_QUALITY_Q100 = IMAGE_QUALITY_Q80+1; //图像质量100%
    }

    // 视频格式
    public static class CFG_VIDEO_FORMAT extends SdkStructure
    {
        // 能力
        public byte abCompression;// 类型为bool, 取值0或1
        public byte abWidth;// 类型为bool, 取值0或1
        public byte abHeight;// 类型为bool, 取值0或1
        public byte abBitRateControl;// 类型为bool, 取值0或1
        public byte abBitRate;// 类型为bool, 取值0或1
        public byte abFrameRate;// 类型为bool, 取值0或1
        public byte abIFrameInterval;// 类型为bool, 取值0或1
        public byte abImageQuality;// 类型为bool, 取值0或1
        public byte abFrameType;// 类型为bool, 取值0或1
        public byte abProfile;// 类型为bool, 取值0或1
        // 信息
        public int emCompression;//视频压缩格式, 取值为CFG_VIDEO_COMPRESSION中的值
        public int nWidth;//视频宽度
        public int nHeight;//视频高度
        public int emBitRateControl;//码流控制模式, 取值为CFG_BITRATE_CONTROL中的值
        public int nBitRate;//视频码流(kbps)
        public float nFrameRate;//视频帧率
        public int nIFrameInterval;//I帧间隔(1-100)，比如50表示每49个B帧或P帧，设置一个I帧。
        public int emImageQuality;//图像质量, 取值为CFG_IMAGE_QUALITY中的值
        public int nFrameType;//打包模式，0－DHAV，1－"PS"
        public int emProfile;//H.264编码级别, 取值为CFG_H264_PROFILE_RANK中的值
        public int nMaxBitrate;// 最大码流单位是kbps（博世专用）
    }

    // 音频编码模式
    public static class CFG_AUDIO_FORMAT extends SdkStructure
    {
        public static final int  AUDIO_FORMAT_G711A = 0; //G711a
        public static final int  AUDIO_FORMAT_PCM = AUDIO_FORMAT_G711A+1; //PCM
        public static final int  AUDIO_FORMAT_G711U = AUDIO_FORMAT_PCM+1; //G711u
        public static final int  AUDIO_FORMAT_AMR = AUDIO_FORMAT_G711U+1; //AMR
        public static final int  AUDIO_FORMAT_AAC = AUDIO_FORMAT_AMR+1; //AAC
    }

    // 音频格式
    public static class CFG_AUDIO_ENCODE_FORMAT extends SdkStructure
    {
        // 能力
        public byte abCompression;// 类型为bool, 取值0或1
        public byte abDepth;// 类型为bool, 取值0或1
        public byte abFrequency;// 类型为bool, 取值0或1
        public byte abMode;// 类型为bool, 取值0或1
        public byte abFrameType;// 类型为bool, 取值0或1
        public byte abPacketPeriod;// 类型为bool, 取值0或1
        // 信息
        public int emCompression;//音频压缩模式，取值为CFG_AUDIO_FORMAT中的值
        public int nDepth;//音频采样深度
        public int nFrequency;//音频采样频率
        public int nMode;//音频编码模式
        public int nFrameType;//音频打包模式,0-DHAV,1-PS
        public int nPacketPeriod;//音频打包周期,ms
        public int nChannelsNum;               // 视频通道的伴音通道号列表个数
        public int arrChannels[] = new int[8];   // 视频通道的伴音通道号列表
        public int bMix;                       // 是否同源
    }

    // 视频编码参数
    public static class CFG_VIDEOENC_OPT extends SdkStructure
    {
        // 能力
        public byte abVideoEnable;// 类型为bool, 取值0或1
        public byte abAudioEnable;// 类型为bool, 取值0或1
        public byte abSnapEnable;// 类型为bool, 取值0或1
        public byte abAudioAdd;//音频叠加能力, 类型为bool, 取值0或1
        public byte abAudioFormat;// 类型为bool, 取值0或1
        // 信息
        public int bVideoEnable;//视频使能, 类型为BOOL, 取值0或者1
        public CFG_VIDEO_FORMAT stuVideoFormat;//视频格式
        public int bAudioEnable;//音频使能, 类型为BOOL, 取值0或者1
        public int bSnapEnable;//定时抓图使能, 类型为BOOL, 取值0或者1
        public int bAudioAddEnable;//音频叠加使能, 类型为BOOL, 取值0或者1
        public CFG_AUDIO_ENCODE_FORMAT stuAudioFormat;//音频格式
    }

    // 遮挡信息
    public static class CFG_COVER_INFO extends SdkStructure
    {
        // 能力
        public byte abBlockType;// 类型为bool, 取值0或1
        public byte abEncodeBlend;// 类型为bool, 取值0或1
        public byte abPreviewBlend;// 类型为bool, 取值0或1
        // 信息
        public CFG_RECT stuRect = new CFG_RECT();//覆盖的区域坐标
        public CFG_RGBA stuColor = new CFG_RGBA();//覆盖的颜色
        public int nBlockType;//覆盖方式；0－黑块，1－马赛克
        public int nEncodeBlend;//编码级遮挡；1－生效，0－不生效
        public int nPreviewBlend;//预览遮挡；1－生效，0－不生效
    }

    // 多区域遮挡配置
    public static class CFG_VIDEO_COVER extends SdkStructure
    {
        public int nTotalBlocks;//支持的遮挡块数
        public int nCurBlocks;//已设置的块数
        public CFG_COVER_INFO[] stuCoverBlock = (CFG_COVER_INFO[])new CFG_COVER_INFO().toArray(MAX_VIDEO_COVER_NUM);// 覆盖的区域
    }

    // OSD信息
    public static class CFG_OSD_INFO extends SdkStructure
    {
        // 能力
        public byte abShowEnable;// 类型为bool, 取值0或1
        // 信息
        public CFG_RGBA stuFrontColor = new CFG_RGBA();//前景颜色
        public CFG_RGBA stuBackColor = new CFG_RGBA();//背景颜色
        public CFG_RECT stuRect = new CFG_RECT();//矩形区域
        public int bShowEnable;//显示使能, 类型为BOOL, 取值0或者1
    }

    // 画面颜色属性
    public static class CFG_COLOR_INFO extends SdkStructure
    {
        public int nBrightness;//亮度(0-100)
        public int nContrast;//对比度(0-100)
        public int nSaturation;//饱和度(0-100)
        public int nHue;//色度(0-100)
        public int nGain;//增益(0-100)
        public int bGainEn;//增益使能, 类型为BOOL, 取值0或者1
    }

    // 图像通道属性信息
    public static class CFG_ENCODE_INFO extends SdkStructure
    {
        public int nChannelID;//通道号(0开始),获取时，该字段有效；设置时，该字段无效
        public byte[] szChnName = new byte[MAX_CHANNELNAME_LEN];//无效字段
        public CFG_VIDEOENC_OPT[] stuMainStream = (CFG_VIDEOENC_OPT[])new CFG_VIDEOENC_OPT().toArray(MAX_VIDEOSTREAM_NUM);    // 主码流，0－普通录像，1-动检录像，2－报警录像
        public int nValidCountMainStream;                      // 主码流数组中有效的个数
        public CFG_VIDEOENC_OPT[] stuExtraStream = (CFG_VIDEOENC_OPT[])new CFG_VIDEOENC_OPT().toArray(MAX_VIDEOSTREAM_NUM);    // 辅码流，0－辅码流1，1－辅码流2，2－辅码流3
        public int nValidCountExtraStream;             		   // 辅码流数组中有效的个数
        public CFG_VIDEOENC_OPT[] stuSnapFormat = (CFG_VIDEOENC_OPT[])new CFG_VIDEOENC_OPT().toArray(MAX_VIDEOSTREAM_NUM);    // 抓图，0－普通抓图，1－动检抓图，2－报警抓图
        public int nValidCountSnapFormat;              		   // 抓图数组中有效的个数
        public int dwCoverAbilityMask;//无效字段
        public int dwCoverEnableMask;//无效字段
        public CFG_VIDEO_COVER stuVideoCover;//无效字段
        public CFG_OSD_INFO stuChnTitle;//无效字段
        public CFG_OSD_INFO stuTimeTitle;//无效字段
        public CFG_COLOR_INFO stuVideoColor;//无效字段
        public int emAudioFormat;//无效字段, 取值为CFG_AUDIO_FORMAT中的值
        public int nProtocolVer;//协议版本号,只读,获取时，该字段有效；设置时，该字段无效
    }

    // 设备软件版本信息,高16位表示主版本号,低16位表示次版本号
    public static class NET_VERSION_INFO extends SdkStructure
    {
        public int dwSoftwareVersion;
        public int dwSoftwareBuildDate;
        public int dwDspSoftwareVersion;
        public int dwDspSoftwareBuildDate;
        public int dwPanelVersion;
        public int dwPanelSoftwareBuildDate;
        public int dwHardwareVersion;
        public int dwHardwareDate;
        public int dwWebVersion;
        public int dwWebBuildDate;
    }

    // 设备软件版本信息,对应CLIENT_QueryDevState接口
    public static class NETDEV_VERSION_INFO extends SdkStructure
    {
        public byte[]       szDevSerialNo = new byte[NET_DEV_SERIALNO_LEN];         // 序列号
        public int          byDevType;                                 			    // 设备类型,见枚举  NET_DEVICE_TYPE
        public byte[]       szDevType = new byte[NET_DEV_TYPE_LEN];                 // 设备详细型号,字符串格式,可能为空
        public int          nProtocalVer;                              			    // 协议版本号
        public byte[]       szSoftWareVersion = new byte[NET_MAX_URL_LEN];
        public int          dwSoftwareBuildDate;
        public byte[]       szPeripheralSoftwareVersion = new byte[NET_MAX_URL_LEN];// 从片版本信息,字符串格式,可能为空
        public int          dwPeripheralSoftwareBuildDate;
        public byte[]       szGeographySoftwareVersion = new byte[NET_MAX_URL_LEN]; // 地理信息定位芯片版本信息,字符串格式,可能为空
        public int          dwGeographySoftwareBuildDate;
        public byte[]       szHardwareVersion = new byte[NET_MAX_URL_LEN];
        public int          dwHardwareDate;
        public byte[]       szWebVersion = new byte[NET_MAX_URL_LEN];
        public int          dwWebBuildDate;
        public byte[]       reserved = new byte[256];
    }

    // 设备类型
    public static class NET_DEVICE_TYPE extends SdkStructure
    {
        public static final int NET_PRODUCT_NONE = 0;
        public static final int NET_DVR_NONREALTIME_MACE = 1;     // 非实时MACE
        public static final int NET_DVR_NONREALTIME	= 2;          // 非实时
        public static final int NET_NVS_MPEG1 = 3;                // 网络视频服务器
        public static final int NET_DVR_MPEG1_2 = 4;              // MPEG1二路录像机
        public static final int NET_DVR_MPEG1_8 = 5;              // MPEG1八路录像机
        public static final int NET_DVR_MPEG4_8 = 6;              // MPEG4八路录像机
        public static final int NET_DVR_MPEG4_16 = 7;             // MPEG4十六路录像机
        public static final int NET_DVR_MPEG4_SX2 = 8;            // LB系列录像机
        public static final int NET_DVR_MEPG4_ST2 = 9;            // GB系列录像机
        public static final int NET_DVR_MEPG4_SH2 = 10;            // HB系列录像机               10
        public static final int NET_DVR_MPEG4_GBE = 11;            // GBE系列录像机
        public static final int NET_DVR_MPEG4_NVSII = 12;          // II代网络视频服务器
        public static final int NET_DVR_STD_NEW = 13;              // 新标准配置协议
        public static final int NET_DVR_DDNS = 14;                 // DDNS服务器
        public static final int NET_DVR_ATM = 15;                  // ATM机
        public static final int NET_NB_SERIAL = 16;                // 二代非实时NB系列机器
        public static final int NET_LN_SERIAL = 17;                // LN系列产品
        public static final int NET_BAV_SERIAL = 18;               // BAV系列产品
        public static final int NET_SDIP_SERIAL = 19;              // SDIP系列产品
        public static final int NET_IPC_SERIAL = 20;               // IPC系列产品                20
        public static final int NET_NVS_B = 21;                    // NVS B系列
        public static final int NET_NVS_C = 22;                    // NVS H系列
        public static final int NET_NVS_S = 23;                    // NVS S系列
        public static final int NET_NVS_E = 24;                    // NVS E系列
        public static final int NET_DVR_NEW_PROTOCOL = 25;         // 从QueryDevState中查询设备类型,以字符串格式
        public static final int NET_NVD_SERIAL = 26;               // 解码器
        public static final int NET_DVR_N5 = 27;                   // N5
        public static final int NET_DVR_MIX_DVR = 28;              // 混合DVR
        public static final int NET_SVR_SERIAL = 29;               // SVR系列
        public static final int NET_SVR_BS = 30;                   // SVR-BS                     30
        public static final int NET_NVR_SERIAL = 31;               // NVR系列
        public static final int NET_DVR_N51 = 32;                  // N51
        public static final int NET_ITSE_SERIAL = 33;              // ITSE 智能分析盒
        public static final int NET_ITC_SERIAL = 34;               // 智能交通像机设备
        public static final int NET_HWS_SERIAL = 35;               // 雷达测速仪HWS
        public static final int NET_PVR_SERIAL = 36;               // 便携式音视频录像机
        public static final int NET_IVS_SERIAL = 37;               // IVS（智能视频服务器系列）
        public static final int NET_IVS_B = 38;                    // 通用智能视频侦测服务器
        public static final int NET_IVS_F = 39;                    // 人脸识别服务器
        public static final int NET_IVS_V = 40;                    // 视频质量诊断服务器         40
        public static final int NET_MATRIX_SERIAL = 41;            // 矩阵
        public static final int NET_DVR_N52 = 42;                  // N52
        public static final int NET_DVR_N56 = 43;                  // N56
        public static final int NET_ESS_SERIAL = 44;               // ESS
        public static final int NET_IVS_PC = 45;                   // 人数统计服务器
        public static final int NET_PC_NVR = 46;                   // pc-nvr
        public static final int NET_DSCON = 47;                    // 大屏控制器
        public static final int NET_EVS = 48;                      // 网络视频存储服务器
        public static final int NET_EIVS = 49;                     // 嵌入式智能分析视频系统
        public static final int NET_DVR_N6 = 50;                   // DVR-N6       50
        public static final int NET_UDS = 51;                      // 万能解码器
        public static final int NET_AF6016 = 52;                   // 银行报警主机
        public static final int NET_AS5008 = 53;                   // 视频网络报警主机
        public static final int NET_AH2008 = 54;                   // 网络报警主机
        public static final int NET_A_SERIAL = 55;                 // 报警主机系列
        public static final int NET_BSC_SERIAL = 56;               // 门禁系列产品
        public static final int NET_NVS_SERIAL = 57;               // NVS系列产品
        public static final int NET_VTO_SERIAL = 58;              // VTO系列产品
        public static final int NET_VTNC_SERIAL = 59;              // VTNC系列产品
        public static final int NET_TPC_SERIAL = 60;               // TPC系列产品, 即热成像设备  60
        public static final int NET_ASM_SERIAL = 61;               // 无线中继设备
        public static final int NET_VTS_SERIAL = 62;               // 管理机
    }

    // DSP能力描述,对应CLIENT_GetDevConfig接口
    public static class NET_DSP_ENCODECAP extends SdkStructure
    {
        public int dwVideoStandardMask;//视频制式掩码,按位表示设备能够支持的视频制式
        public int dwImageSizeMask;//分辨率掩码,按位表示设备能够支持的分辨率设置
        public int dwEncodeModeMask;//编码模式掩码,按位表示设备能够支持的编码模式设置
        public int dwStreamCap;    // 按位表示设备支持的多媒体功能,
        // 第一位表示支持主码流
        // 第二位表示支持辅码流1
        // 第三位表示支持辅码流2
        // 第五位表示支持jpg抓图
        public int[] dwImageSizeMask_Assi = new int[8];//表示主码流为各分辨率时,支持的辅码流分辨率掩码。
        public int dwMaxEncodePower;//DSP支持的最高编码能力
        public short wMaxSupportChannel;//每块DSP支持最多输入视频通道数
        public short wChannelMaxSetSync;//DSP每通道的最大编码设置是否同步；0：不同步,1：同步
    }

    // 系统信息
    public static class NET_DEV_SYSTEM_ATTR_CFG extends SdkStructure
    {
        public int dwSize;
        /* 下面是设备的只读部分 */
        public NET_VERSION_INFO stVersion;
        public NET_DSP_ENCODECAP stDspEncodeCap;//DSP能力描述
        public byte[] szDevSerialNo = new byte[NET_DEV_SERIALNO_LEN];//序列号
        public byte byDevType;//设备类型,见枚举NET_DEVICE_TYPE
        public byte[] szDevType = new byte[NET_DEV_TYPE_LEN];//设备详细型号,字符串格式,可能为空
        public byte byVideoCaptureNum;//视频口数量
        public byte byAudioCaptureNum;//音频口数量
        public byte byTalkInChanNum;//对讲输入接口数量
        public byte byTalkOutChanNum;//对讲输出接口数量
        public byte byDecodeChanNum;//NSP
        public byte byAlarmInNum;//报警输入口数
        public byte byAlarmOutNum;//报警输出口数
        public byte byNetIONum;//网络口数
        public byte byUsbIONum;//USB口数量
        public byte byIdeIONum;//IDE数量
        public byte byComIONum;//串口数量
        public byte byLPTIONum;//并口数量
        public byte byVgaIONum;//NSP
        public byte byIdeControlNum;//NSP
        public byte byIdeControlType;//NSP
        public byte byCapability;//NSP,扩展描述
        public byte byMatrixOutNum;//视频矩阵输出口数
        /* 下面是设备的可写部分 */
        public byte byOverWrite;//硬盘满处理方式(覆盖、停止)
        public byte byRecordLen;//录象打包长度
        public byte byDSTEnable;//是否实行夏令时1-实行0-不实行
        public short wDevNo;//设备编号,用于遥控
        public byte byVideoStandard;//视频制式:0-PAL,1-NTSC
        public byte byDateFormat;//日期格式
        public byte byDateSprtr;//日期分割符(0：".",1："-",2："/")
        public byte byTimeFmt;//时间格式(0-24小时,1－12小时)
        public byte byLanguage;//枚举值详见NET_LANGUAGE_TYPE

        public NET_DEV_SYSTEM_ATTR_CFG()
        {
            this.dwSize = this.size();
        }
    }

    // 入侵方向
    public static class EM_MSG_OBJ_PERSON_DIRECTION extends SdkStructure
    {
        public static final int EM_MSG_OBJ_PERSON_DIRECTION_UNKOWN = 0; //未知方向
        public static final int EM_MSG_OBJ_PERSON_DIRECTION_LEFT_TO_RIGHT = EM_MSG_OBJ_PERSON_DIRECTION_UNKOWN+1; //从左向右
        public static final int EM_MSG_OBJ_PERSON_DIRECTION_RIGHT_TO_LEFT = EM_MSG_OBJ_PERSON_DIRECTION_LEFT_TO_RIGHT+1; //从右向左
    }

    // 视频分析物体信息扩展结构体
    public static class NET_MSG_OBJECT_EX extends SdkStructure
    {
        public int dwSize;
        public int nObjectID;//物体ID,每个ID表示一个唯一的物体
        public byte[] szObjectType = new byte[128];//物体类型
        public int nConfidence;//置信度(0~255),值越大表示置信度越高
        public int nAction;//物体动作:1:Appear2:Move3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
        public DH_RECT BoundingBox;//包围盒
        public NET_POINT Center;//物体型心
        public int nPolygonNum;//多边形顶点个数
        public NET_POINT[] Contour = (NET_POINT[])new NET_POINT().toArray(NET_MAX_POLYGON_NUM);// 较精确的轮廓多边形
        public int rgbaMainColor;//表示车牌、车身等物体主要颜色；按字节表示,分别为红、绿、蓝和透明度,例如:RGB值为(0,255,0),透明度为0时,其值为0x00ff0000.
        public byte[] szText = new byte[128];//同NET_MSG_OBJECT相应字段
        public byte[] szObjectSubType = new byte[64];//物体子类别,根据不同的物体类型,可以取以下子类型：
        // 同NET_MSG_OBJECT相应字段
        public byte[] byReserved1 = new byte[3];
        public byte bPicEnble;//是否有物体对应图片文件信息, 类型为bool, 取值0或1
        public NET_PIC_INFO stPicInfo;//物体对应图片信息
        public byte bShotFrame;//是否是抓拍张的识别结果, 类型为bool, 取值0或1
        public byte bColor;//物体颜色(rgbaMainColor)是否可用, 类型为bool, 取值0或1
        public byte bLowerBodyColor;//下半身颜色(rgbaLowerBodyColor)是否可用
        public byte byTimeType;//时间表示类型,详见EM_TIME_TYPE说明
        public NET_TIME_EX stuCurrentTime;//针对视频浓缩,当前时间戳（物体抓拍或识别时,会将此识别智能帧附在一个视频帧或jpeg图片中,此帧所在原始视频中的出现时间）
        public NET_TIME_EX stuStartTime;//开始时间戳（物体开始出现时）
        public NET_TIME_EX stuEndTime;//结束时间戳（物体最后出现时）
        public DH_RECT stuOriginalBoundingBox;//包围盒(绝对坐标)
        public DH_RECT stuSignBoundingBox;//车标坐标包围盒
        public int dwCurrentSequence;//当前帧序号（抓下这个物体时的帧）
        public int dwBeginSequence;//开始帧序号（物体开始出现时的帧序号）
        public int dwEndSequence;//结束帧序号（物体消逝时的帧序号）
        public long nBeginFileOffset;//开始时文件偏移,单位:字节（物体开始出现时,视频帧在原始视频文件中相对于文件起始处的偏移）
        public long nEndFileOffset;//结束时文件偏移,单位:字节（物体消逝时,视频帧在原始视频文件中相对于文件起始处的偏移）
        public byte[] byColorSimilar = new byte[EM_COLOR_TYPE.NET_COLOR_TYPE_MAX];//物体颜色相似度,取值范围：0-100,数组下标值代表某种颜色,详见EM_COLOR_TYPE
        public byte[] byUpperBodyColorSimilar = new byte[EM_COLOR_TYPE.NET_COLOR_TYPE_MAX];//上半身物体颜色相似度(物体类型为人时有效)
        public byte[] byLowerBodyColorSimilar = new byte[EM_COLOR_TYPE.NET_COLOR_TYPE_MAX];//下半身物体颜色相似度(物体类型为人时有效)
        public int nRelativeID;//相关物体ID
        public byte[] szSubText = new byte[20];//"ObjectType"为"Vehicle"或者"Logo"时,表示车标下的某一车系,比如奥迪A6L,由于车系较多,SDK实现时透传此字段,设备如实填写。
        public int nPersonStature;//入侵人员身高,单位cm
        public int emPersonDirection;//人员入侵方向, 取值为EM_MSG_OBJ_PERSON_DIRECTION中的值
        public int rgbaLowerBodyColor;//使用方法同rgbaMainColor,物体类型为人时有效

        public NET_MSG_OBJECT_EX()
        {
            this.dwSize = this.size();
        }

        protected int getNativeAlignment(Class<?> type, Object value, boolean isFirstElement) {
            int alignment = super.getNativeAlignment(type, value, isFirstElement);
            return Math.min(4, alignment);
        }
    }

    // 视频分析物体信息扩展结构体,扩展版本2
    public static class NET_MSG_OBJECT_EX2 extends SdkStructure
    {
        public int dwSize;
        public int nObjectID;//物体ID,每个ID表示一个唯一的物体
        public byte[] szObjectType = new byte[128];//物体类型
        public int nConfidence;//置信度(0~255),值越大表示置信度越高
        public int nAction;//物体动作:1:Appear2:Move3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
        public DH_RECT BoundingBox;//包围盒
        public NET_POINT Center;//物体型心
        public int nPolygonNum;//多边形顶点个数
        public NET_POINT[] Contour = (NET_POINT[])new NET_POINT().toArray(NET_MAX_POLYGON_NUM);//较精确的轮廓多边形
        public int rgbaMainColor;//表示车牌、车身等物体主要颜色；按字节表示,分别为红、绿、蓝和透明度,例如:RGB值为(0,255,0),透明度为0时,其值为0x00ff0000.
        public byte[] szText = new byte[128];//同NET_MSG_OBJECT相应字段
        public byte[] szObjectSubType = new byte[64];//物体子类别,根据不同的物体类型,可以取以下子类型：
        // 同NET_MSG_OBJECT相应字段
        public byte[] byReserved1 = new byte[3];
        public byte bPicEnble;//是否有物体对应图片文件信息, 类型为bool, 取值0或者1
        public NET_PIC_INFO stPicInfo;//物体对应图片信息
        public byte bShotFrame;//是否是抓拍张的识别结果, 类型为bool, 取值0或者1
        public byte bColor;//物体颜色(rgbaMainColor)是否可用, 类型为bool, 取值0或者1
        public byte bLowerBodyColor;//下半身颜色(rgbaLowerBodyColor)是否可用
        public byte byTimeType;//时间表示类型,详见EM_TIME_TYPE说明
        public NET_TIME_EX stuCurrentTime;//针对视频浓缩,当前时间戳（物体抓拍或识别时,会将此识别智能帧附在一个视频帧或jpeg图片中,此帧所在原始视频中的出现时间）
        public NET_TIME_EX stuStartTime;//开始时间戳（物体开始出现时）
        public NET_TIME_EX stuEndTime;//结束时间戳（物体最后出现时）
        public DH_RECT stuOriginalBoundingBox;//包围盒(绝对坐标)
        public DH_RECT stuSignBoundingBox;//车标坐标包围盒
        public int dwCurrentSequence;//当前帧序号（抓下这个物体时的帧）
        public int dwBeginSequence;//开始帧序号（物体开始出现时的帧序号）
        public int dwEndSequence;//结束帧序号（物体消逝时的帧序号）
        public long nBeginFileOffset;//开始时文件偏移,单位:字节（物体开始出现时,视频帧在原始视频文件中相对于文件起始处的偏移）
        public long nEndFileOffset;//结束时文件偏移,单位:字节（物体消逝时,视频帧在原始视频文件中相对于文件起始处的偏移）
        public byte[] byColorSimilar = new byte[EM_COLOR_TYPE.NET_COLOR_TYPE_MAX];//物体颜色相似度,取值范围：0-100,数组下标值代表某种颜色,详见EM_COLOR_TYPE
        public byte[] byUpperBodyColorSimilar = new byte[EM_COLOR_TYPE.NET_COLOR_TYPE_MAX];//上半身物体颜色相似度(物体类型为人时有效)
        public byte[] byLowerBodyColorSimilar = new byte[EM_COLOR_TYPE.NET_COLOR_TYPE_MAX];//下半身物体颜色相似度(物体类型为人时有效)
        public int nRelativeID;//相关物体ID
        public byte[] szSubText = new byte[20];//"ObjectType"为"Vehicle"或者"Logo"时,表示车标下的某一车系,比如奥迪A6L,由于车系较多,SDK实现时透传此字段,设备如实填写。
        public int nPersonStature;//入侵人员身高,单位cm
        public int emPersonDirection;//人员入侵方向, 取值为EM_MSG_OBJ_PERSON_DIRECTION中的值
        public int rgbaLowerBodyColor;//使用方法同rgbaMainColor,物体类型为人时有效
        //视频浓缩额外信息
        public int nSynopsisSpeed;//浓缩速度域值,共分1~10共十个档位,5表示浓缩后只保留5以上速度的物体。是个相对单位
        // 为0时,该字段无效
        public int nSynopsisSize;//浓缩尺寸域值,共分1~10共十个档位,3表示浓缩后只保留3以上大小的物体。是个相对单位
        // 为0时,该字段无效
        public int bEnableDirection;//为True时,对物体运动方向做过滤, 类型为BOOL, 取值0或者1
        // 为False时,不对物体运动方向做过滤,
        public NET_POINT stuSynopsisStartLocation;//浓缩运动方向,起始坐标点,点的坐标归一化到[0,8192)区间,bEnableDirection为True时有效
        public NET_POINT stuSynopsisEndLocation;//浓缩运动方向,终止坐标点,点的坐标归一化到[0,8192)区间,bEnableDirection为True时有效
        public byte[] byReserved = new byte[2048];//扩展字节

        public NET_MSG_OBJECT_EX2()
        {
            this.dwSize = this.size();
        }

        protected int getNativeAlignment(Class<?> type, Object value, boolean isFirstElement) {
            int alignment = super.getNativeAlignment(type, value, isFirstElement);
            return Math.min(4, alignment);
        }
    }

    // 设备协议类型
    public static class NET_DEVICE_PROTOCOL extends SdkStructure
    {
        public static final int NET_PROTOCOL_PRIVATE2 = 0; //私有2代协议
        public static final int NET_PROTOCOL_PRIVATE3 = NET_PROTOCOL_PRIVATE2+1; //私有3代协议
        public static final int NET_PROTOCOL_ONVIF = NET_PROTOCOL_PRIVATE3+1; //Onvif
        public static final int NET_PROTOCOL_VNC = NET_PROTOCOL_ONVIF+1; //虚拟网络计算机
        public static final int NET_PROTOCOL_TS = NET_PROTOCOL_VNC+1; //标准TS
        public static final int NET_PROTOCOL_PRIVATE = 100;//私有协议
        public static final int NET_PROTOCOL_AEBELL = NET_PROTOCOL_PRIVATE+1; //美电贝尔
        public static final int NET_PROTOCOL_PANASONIC = NET_PROTOCOL_AEBELL+1; //松下
        public static final int NET_PROTOCOL_SONY = NET_PROTOCOL_PANASONIC+1; //索尼
        public static final int NET_PROTOCOL_DYNACOLOR = NET_PROTOCOL_SONY+1; //Dynacolor
        public static final int NET_PROTOCOL_TCWS = NET_PROTOCOL_DYNACOLOR+1; //天城威视
        public static final int NET_PROTOCOL_SAMSUNG = NET_PROTOCOL_TCWS+1; //三星
        public static final int NET_PROTOCOL_YOKO = NET_PROTOCOL_SAMSUNG+1; //YOKO
        public static final int NET_PROTOCOL_AXIS = NET_PROTOCOL_YOKO+1; //安讯视
        public static final int NET_PROTOCOL_SANYO = NET_PROTOCOL_AXIS+1; //三洋
        public static final int NET_PROTOCOL_BOSH = NET_PROTOCOL_SANYO+1; //Bosch
        public static final int NET_PROTOCOL_PECLO = NET_PROTOCOL_BOSH+1; //Peclo
        public static final int NET_PROTOCOL_PROVIDEO = NET_PROTOCOL_PECLO+1; //Provideo
        public static final int NET_PROTOCOL_ACTI = NET_PROTOCOL_PROVIDEO+1; //ACTi
        public static final int NET_PROTOCOL_VIVOTEK = NET_PROTOCOL_ACTI+1; //Vivotek
        public static final int NET_PROTOCOL_ARECONT = NET_PROTOCOL_VIVOTEK+1; //Arecont
        public static final int NET_PROTOCOL_PRIVATEEH = NET_PROTOCOL_ARECONT+1; //PrivateEH
        public static final int NET_PROTOCOL_IMATEK = NET_PROTOCOL_PRIVATEEH+1; //IMatek
        public static final int NET_PROTOCOL_SHANY = NET_PROTOCOL_IMATEK+1; //Shany
        public static final int NET_PROTOCOL_VIDEOTREC = NET_PROTOCOL_SHANY+1; //动力盈科
        public static final int NET_PROTOCOL_URA = NET_PROTOCOL_VIDEOTREC+1; //Ura
        public static final int NET_PROTOCOL_BITICINO = NET_PROTOCOL_URA+1; //Bticino
        public static final int NET_PROTOCOL_ONVIF2 = NET_PROTOCOL_BITICINO+1; //Onvif协议类型,同NET_PROTOCOL_ONVIF
        public static final int NET_PROTOCOL_SHEPHERD = NET_PROTOCOL_ONVIF2+1; //视霸
        public static final int NET_PROTOCOL_YAAN = NET_PROTOCOL_SHEPHERD+1; //亚安
        public static final int NET_PROTOCOL_AIRPOINT = NET_PROTOCOL_YAAN+1; //Airpop
        public static final int NET_PROTOCOL_TYCO = NET_PROTOCOL_AIRPOINT+1; //TYCO
        public static final int NET_PROTOCOL_XUNMEI = NET_PROTOCOL_TYCO+1; //讯美
        public static final int NET_PROTOCOL_HIKVISION = NET_PROTOCOL_XUNMEI+1; //海康
        public static final int NET_PROTOCOL_LG = NET_PROTOCOL_HIKVISION+1; //LG
        public static final int NET_PROTOCOL_AOQIMAN = NET_PROTOCOL_LG+1; //奥奇曼
        public static final int NET_PROTOCOL_BAOKANG = NET_PROTOCOL_AOQIMAN+1; //宝康
        public static final int NET_PROTOCOL_WATCHNET = NET_PROTOCOL_BAOKANG+1; //Watchnet
        public static final int NET_PROTOCOL_XVISION = NET_PROTOCOL_WATCHNET+1; //Xvision
        public static final int NET_PROTOCOL_FUSITSU = NET_PROTOCOL_XVISION+1; //富士通
        public static final int NET_PROTOCOL_CANON = NET_PROTOCOL_FUSITSU+1; //Canon
        public static final int NET_PROTOCOL_GE = NET_PROTOCOL_CANON+1; //GE
        public static final int NET_PROTOCOL_Basler = NET_PROTOCOL_GE+1; //巴斯勒
        public static final int NET_PROTOCOL_Patro = NET_PROTOCOL_Basler+1; //帕特罗
        public static final int NET_PROTOCOL_CPKNC = NET_PROTOCOL_Patro+1; //CPPLUSK系列
        public static final int NET_PROTOCOL_CPRNC = NET_PROTOCOL_CPKNC+1; //CPPLUSR系列
        public static final int NET_PROTOCOL_CPUNC = NET_PROTOCOL_CPRNC+1; //CPPLUSU系列
        public static final int NET_PROTOCOL_CPPLUS = NET_PROTOCOL_CPUNC+1; //CPPLUSIPC
        public static final int NET_PROTOCOL_XunmeiS = NET_PROTOCOL_CPPLUS+1; //讯美s,实际协议为Onvif
        public static final int NET_PROTOCOL_GDDW = NET_PROTOCOL_XunmeiS+1; //广东电网
        public static final int NET_PROTOCOL_PSIA = NET_PROTOCOL_GDDW+1; //PSIA
        public static final int NET_PROTOCOL_GB2818 = NET_PROTOCOL_PSIA+1; //GB2818
        public static final int NET_PROTOCOL_GDYX = NET_PROTOCOL_GB2818+1; //GDYX
        public static final int NET_PROTOCOL_OTHER = NET_PROTOCOL_GDYX+1; //由用户自定义
    }

    // 雨刷来回循环刷,雨刷模式配置为手动模式时有效(对应命令 CTRLTYPE_CTRL_RAINBRUSH_MOVECONTINUOUSLY)
    public static class NET_CTRL_RAINBRUSH_MOVECONTINUOUSLY extends SdkStructure
    {
        public int dwSize;
        public int nChannel;//表示雨刷的索引
        public int nInterval;//雨刷间隔

        public NET_CTRL_RAINBRUSH_MOVECONTINUOUSLY()
        {
            this.dwSize = this.size();
        }
    }

    // 雨刷停止刷,雨刷模式配置为手动模式时有效(对应命令 CTRLTYPE_CTRL_RAINBRUSH_STOPMOVE)
    public static class NET_CTRL_RAINBRUSH_STOPMOVE extends SdkStructure
    {
        public int dwSize;
        public int nChannel;//表示雨刷的索引

        public NET_CTRL_RAINBRUSH_STOPMOVE()
        {
            this.dwSize = this.size();
        }
    }

    // 雨刷来回刷一次，雨刷模式配置为手动模式时有效(对应命令 CTRLTYPE_CTRL_RAINBRUSH_MOVEONCE)
    public static class NET_CTRL_RAINBRUSH_MOVEONCE extends SdkStructure
    {
        public int dwSize;
        public int nChannel;//表示雨刷的索引

        public NET_CTRL_RAINBRUSH_MOVEONCE()
        {
            this.dwSize = this.size();
        }
    }

    // DSP能力描述，扩展类型，对应CLIENT_QueryDevState接口
    public static class NET_DEV_DSP_ENCODECAP extends SdkStructure
    {
        public int dwVideoStandardMask; //视频制式掩码，按位表示设备能够支持的视频制式
        public int dwImageSizeMask;		//分辨率掩码，按位表示设备能够支持的分辨率
        public int dwEncodeModeMask;	//编码模式掩码，按位表示设备能够支持的编码模式
        public int dwStreamCap;			//按位表示设备支持的多媒体功能，
        // 第一位表示支持主码流
        // 第二位表示支持辅码流1
        // 第三位表示支持辅码流2
        // 第五位表示支持jpg抓图
        public int[] dwImageSizeMask_Assi = new int[32];//表示主码流为各分辨率时，支持的辅码流分辨率掩码。
        public int dwMaxEncodePower;	//DSP支持的最高编码能力
        public short wMaxSupportChannel;//每块DSP支持最多输入视频通道数
        public short wChannelMaxSetSync;//DSP每通道的最大编码设置是否同步；0：不同步，1：同步
        public byte[] bMaxFrameOfImageSize = new byte[32];//不同分辨率下的最大采集帧率，与dwVideoStandardMask按位对应
        public byte bEncodeCap;			//标志，配置时要求符合下面条件，否则配置不能生效；
        // 0：主码流的编码能力+辅码流的编码能力 <= 设备的编码能力，
        // 1：主码流的编码能力+辅码流的编码能力 <= 设备的编码能力，
        // 辅码流的编码能力 <= 主码流的编码能力，
        // 辅码流的分辨率 <= 主码流的分辨率，
        // 主码流和辅码流的帧率 <= 前端视频采集帧率
        // 2：N5的计算方法
        // 辅码流的分辨率 <= 主码流的分辨率
        // 查询支持的分辨率和相应最大帧率
        public byte[] reserved = new byte[95];
    }

    //云台控制坐标单元
    public static class PTZ_SPACE_UNIT extends SdkStructure
    {
        public int nPositionX;  // 云台水平运动位置,有效范围：0,3600]
        public int nPositionY;  // 云台垂直运动位置,有效范围：-1800,1800]
        public int nZoom;       // 云台光圈变动位置,有效范围：0,128]
        public byte[] szReserve = new byte[32];//预留32字节
    }

    //云台控制速度单元
    public static class PTZ_SPEED_UNIT extends SdkStructure
    {
        public float fPositionX;//云台水平方向速率,归一化到-1~1
        public float fPositionY;//云台垂直方向速率,归一化到-1~1
        public float fZoom;//云台光圈放大倍率,归一化到0~1
        public byte[] szReserve = new byte[32];//预留32字节
    }

    //持续控制云台对应结构
    public static class PTZ_CONTROL_CONTINUOUSLY extends SdkStructure
    {
        public PTZ_SPEED_UNIT 	  stuSpeed;							//云台运行速度
        public int 				  nTimeOut;							//连续移动超时时间,单位为秒
        public byte[] 			  szReserve = new byte[64];			//预留64字节
    }

    //绝对控制云台对应结构
    public static class PTZ_CONTROL_ABSOLUTELY extends SdkStructure
    {
        public PTZ_SPACE_UNIT 	 stuPosition;						//云台绝对移动位置
        public PTZ_SPEED_UNIT	 stuSpeed;							//云台运行速度
        public byte[] 			 szReserve = new byte[64];			//预留64字节
    }

    //带速度转动到预置位点云台控制对应结构
    public static class PTZ_CONTROL_GOTOPRESET extends SdkStructure
    {
        public int 				nPresetIndex;						//预置位索引
        public PTZ_SPEED_UNIT 	stuSpeed;							//云台运行速度
        public byte[] 			szReserve = new byte[64];			//预留64字节
    }

    //设置云台可视域信息
    public static class PTZ_VIEW_RANGE_INFO extends SdkStructure
    {
        public int 				nStructSize;
        public int 				nAzimuthH;							//水平方位角度,0~3600,单位:度

        public PTZ_VIEW_RANGE_INFO()
        {
            this.nStructSize = this.size();
        }
    }

    //云台绝对聚焦对应结构
    public static class PTZ_FOCUS_ABSOLUTELY extends SdkStructure
    {
        public int 			   dwValue;					 //云台聚焦位置,取值范围(0~8191)
        public int 			   dwSpeed;					 //云台聚焦速度,取值范围(0~7)
        public byte[]		   szReserve = new byte[64]; //预留64字节
    }

    // 云台控制-扇扫对应结构
    public static class PTZ_CONTROL_SECTORSCAN extends SdkStructure
    {
        public int 			 nBeginAngle;				//起始角度,范围:-180,180]
        public int			 nEndAngle;					//结束角度,范围:-180,180]
        public int 			 nSpeed;					//速度,范围:0,255]
        public byte[]		 szReserve = new byte[64];  //预留64字节
    }

    // 控制鱼眼电子云台信息
    public static class PTZ_CONTROL_SET_FISHEYE_EPTZ extends SdkStructure
    {
        public int 			 dwSize;					//结构体大小
        public int 			 dwWindowID;				//进行EPtz控制的窗口编号
        public int 			 dwCommand;					//电子云台命令
        public int 			 dwParam1;					//命令对应参数1
        public int 			 dwParam2;					//命令对应参数2
        public int 			 dwParam3;					//命令对应参数3
        public int 			 dwParam4;					//命令对应参数4
    }

    // 光照场景类型
    public static class EM_LIGHT_SCENE extends SdkStructure
    {
        public static final int EM_LIGHT_SCENE_UNKNOWN=0;             // 未知
        public static final int EM_LIGHT_SCENE_DAY=1;                 // 白天
        public static final int EM_LIGHT_SCENE_NIGHT=2;               // 夜晚
        public static final int EM_LIGHT_SCENE_NORMAL=3;              // 普通
        public static final int EM_LIGHT_SCENE_FRONT_LIGHT=4;         // 顺光
        public static final int EM_LIGHT_SCENE_BACK_LIGHT=5;          // 一般逆光
        public static final int EM_LIGHT_SCENE_STRONG_LIGHT=6;        // 强逆光
        public static final int EM_LIGHT_SCENE_LOW_LIGHT=7;           // 低照度
        public static final int EM_LIGHT_SCENE_CUSTOM=8;              // 自定义
    };

    // 变倍设置基本信息单元
    public static class CFG_VIDEO_IN_ZOOM_UNIT extends SdkStructure
    {
        public int nSpeed;//变倍速率(0~7)
        public int bDigitalZoom;//是否数字变倍, 类型为BOOL, 取值0或者1
        public int nZoomLimit;//当前速率下最大变倍上限(0~13)。
        public int  emLightScene;                        //光照场景名称
    }

    // 单通道变倍设置基本信息
    public static class CFG_VIDEO_IN_ZOOM extends SdkStructure
    {
        public int nChannelIndex;//通道号
        public int nVideoInZoomRealNum;//配置使用个数
        public CFG_VIDEO_IN_ZOOM_UNIT[] stVideoInZoomUnit = (CFG_VIDEO_IN_ZOOM_UNIT[])new CFG_VIDEO_IN_ZOOM_UNIT().toArray(MAX_VIDEO_IN_ZOOM);//通道变速配置单元信息
    }

    // 设备状态
    public static class CFG_TRAFFIC_DEVICE_STATUS extends SdkStructure
    {
        public byte[]                 szType = new byte[MAX_PATH];          // 设备类型 支持："Radar","Detector","SigDetector","StroboscopicLamp"," FlashLamp"
        public byte[]                 szSerialNo = new byte[MAX_PATH];      // 设备编号
        public byte[]                 szVendor = new byte[MAX_PATH];        // 生产厂商
        public int                    nWokingState;                         // 工作状态 0-故障,1-正常工作
        public byte				      byLightState;						    // RS485灯的亮灭状态，Type 为"DhrsStroboscopicLamp"或者"DhrsSteadyLamp"时有效
        // 0-未知, 1-灯亮, 2-灯灭
        public byte[]			      byReserved = new byte[3];             // 预留字节
    }

    // 获取设备工作状态是否正常 (对应命令 CFG_CAP_CMD_DEVICE_STATE )
    public static class CFG_CAP_TRAFFIC_DEVICE_STATUS extends SdkStructure
    {
        public int                          nStatus;                        // stuStatus 实际个数
        public CFG_TRAFFIC_DEVICE_STATUS[]  stuStatus = (CFG_TRAFFIC_DEVICE_STATUS[]) new CFG_TRAFFIC_DEVICE_STATUS().toArray(MAX_STATUS_NUM);
    }

    // 视频输入通道
    public static class CFG_RemoteDeviceVideoInput extends SdkStructure
    {
        public int				bEnable;
        public byte[]			szName = new byte[MAX_DEVICE_NAME_LEN];
        public byte[]			szControlID = new byte[MAX_DEV_ID_LEN_EX];
        public byte[]			szMainUrl = new byte[MAX_PATH];				// 主码流url地址
        public byte[]			szExtraUrl = new byte[MAX_PATH]; 			// 辅码流url地址
        public int				nServiceType; 								// 服务类型, 0-TCP, 1-UDP, 2-MCAST, -1-AUTO
    }

    // 远程设备
    public static class AV_CFG_RemoteDevice extends SdkStructure
    {
        public int 				nStructSize;
        public int 				bEnable; 									    // 使能
        public byte[]			szID = new byte[AV_CFG_Device_ID_Len]; 			// 设备ID
        public byte[]			szIP = new byte[AV_CFG_IP_Address_Len];			// 设备IP
        public int 				nPort; 											// 端口
        public byte[]			szProtocol = new byte[AV_CFG_Protocol_Len]; 	// 协议类型
        public byte[]			szUser = new byte[AV_CFG_User_Name_Len]; 		// 用户名
        public byte[]			szPassword = new byte[AV_CFG_Password_Len]; 	// 密码
        public byte[]			szSerial = new byte[AV_CFG_Serial_Len];			// 设备序列号
        public byte[]			szDevClass = new byte[AV_CFG_Device_Class_Len]; // 设备类型
        public byte[]			szDevType = new byte[AV_CFG_Device_Type_Len]; 	// 设备型号
        public byte[]			szName = new byte[AV_CFG_Device_Name_Len]; 		// 机器名称
        public byte[]			szAddress =  new byte[AV_CFG_Address_Len]; 		// 机器部署地点
        public byte[]			szGroup = new byte[AV_CFG_Group_Name_Len]; 		// 机器分组
        public int 				nDefinition; 									// 清晰度, 0-标清, 1-高清
        public int 				nVideoChannel; 									// 视频输入通道数
        public int 				nAudioChannel; 									// 音频输入通道数
        public int             	nRtspPort; 										// Rtsp端口号
        public byte[]           szVendor = new byte[MAX_PATH]; 					// 设备接入类型
        public Pointer 			pVideoInput; 									// 视频输入通道，用户申请nMaxVideoInputs个CFG_RemoteDeviceVideoInput空间
        public int              nMaxVideoInputs;
        public int              nRetVideoInputs;
        public int				nHttpPort; 										// http端口号

        /* 以下3项为国际接入方式相关  */
        public int 				bGB28181; 										// 是否有国际接入方式
        public int				nDevLocalPort; 									// 设备本地端口
        public byte[]			szDeviceNo = new byte[AV_CFG_DeviceNo_Len]; 	// 设备编号
        public int				nLoginType;										// 登录方式 0 : TCP直连(默认方式)  6 : 主动注册  7 : P2P方式，此方式时通过SerialNo与设备通过P2P连接
        public byte[]           szVersion=new byte[32];                  // 设备软件版本
        public boolean				bPoE;							// 是否由PoE端口连接, 该选项为只读, 只能由设备修改
        public int				nPoEPort;						// PoE物理端口号, 该选项为只读, 只能由设备修改
        public byte[]			szMac=new byte[18];						// 设备mac地址，冒号+大写
        public AV_CFG_RemoteDevice() {
            this.nStructSize = this.size();
        }
    }

    // 录像模式
    public static class AV_CFG_RecordMode extends SdkStructure
    {
        public int			nStructSize;
        public int			nMode;							// 录像模式, 0-自动录像，1-手动录像，2-关闭录像
        public int			nModeExtra1;					// 辅码流录像模式, 0-自动录像，1-手动录像，2-关闭录像
        public int			nModeExtra2;					// 辅码流2录像模式, 0-自动录像，1-手动录像，2-关闭录像

        public AV_CFG_RecordMode() {
            this.nStructSize = this.size();
        }
    }

    // 视频分析资源类型
    public static class CFG_VIDEO_SOURCE_TYPE extends SdkStructure {
        public static final int CFG_VIDEO_SOURCE_REALSTREAM = 0; // 实时流
        public static final int CFG_VIDEO_SOURCE_FILESTREAM = 1; // 文件流
    }

    // 分析源文件类型
    public static class CFG_SOURCE_FILE_TYPE extends SdkStructure {
        public static final int CFG_SOURCE_FILE_UNKNOWN = 0; // 未知类型
        public static final int CFG_SOURCE_FILE_RECORD = 1; // 录像文件
        public static final int CFG_SOURCE_FILE_PICTURE = 2; // 图片文件
    }

    // 视频分析源文件信息
    public static class CFG_SOURCE_FILE_INFO extends SdkStructure {
        public byte[]				szFilePath = new byte[MAX_PATH];// 文件路径
        public int 					emFileType; // 文件类型，详见 CFG_SOURCE_FILE_TYPE
    }

    // 每个视频输入通道对应的视频分析资源配置信息
    public static class CFG_ANALYSESOURCE_INFO extends SdkStructure {
        public byte					bEnable; 		 // 视频分析使能   1-使能， 0-禁用
        public byte[]				bReserved = new byte[3]; // 保留对齐
        public int					nChannelID;		 // 智能分析的前端视频通道号
        public int					nStreamType;	 // 智能分析的前端视频码流类型，0:抓图码流; 1:主码流; 2:子码流1; 3:子码流2; 4:子码流3; 5:物体流
        public byte[]				szRemoteDevice = new byte[MAX_NAME_LEN];// 设备名
        public int					abDeviceInfo; 	 // 设备信息是否有效 ; 1-有效，0-无效
        public AV_CFG_RemoteDevice  stuDeviceInfo;   // 设备信息
        public int                  emSourceType; 	 // 视频分析源类型，详见  CFG_VIDEO_SOURCE_TYPE
        public CFG_SOURCE_FILE_INFO stuSourceFile;   // 当视频分析源类型为 CFG_VIDEO_SOURCE_FILESTREAM 时，有效
    }

    public static class CFG_OVERSPEED_INFO extends SdkStructure {
        public int[]	nSpeedingPercentage = new int[2];                        // 超速百分比区间要求区间不能重叠。有效值为0,正数,-1，-1表示无穷大值
        // 如果是欠速：要求区间不能重叠。有效值为0,正数,-1，-1表示无穷大值，欠速百分比的计算方式：限低速-实际车速/限低速
        public byte[]   szCode = new byte[MAX_VIOLATIONCODE];                     // 违章代码
        public byte[]   szDescription = new byte[MAX_VIOLATIONCODE_DESCRIPT];     // 违章描述
    }

    // 违章代码配置表
    public static class VIOLATIONCODE_INFO extends SdkStructure {
        public byte[]	szRetrograde = new byte[MAX_VIOLATIONCODE];			                   // 逆行
        public byte[]	szRetrogradeDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];               // 违章描述信息
        public byte[]	szRetrogradeShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];           // 显示名称

        public byte[]	szRetrogradeHighway = new byte[MAX_VIOLATIONCODE];		               // 逆行-高速公路
        public byte[]	szRetrogradeHighwayDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];		   // 违章描述信息

        public byte[]	szRunRedLight = new byte[MAX_VIOLATIONCODE];			               // 闯红灯
        public byte[]	szRunRedLightDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];			   // 违章描述信息

        public byte[]	szCrossLane = new byte[MAX_VIOLATIONCODE];				               // 违章变道
        public byte[]	szCrossLaneDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];			       // 违章描述信息
        public byte[]	szCrossLaneShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];            // 违章变道显示名称

        public byte[]	szTurnLeft = new byte[MAX_VIOLATIONCODE];				               // 违章左转
        public byte[]   szTurnLeftDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];				   // 违章描述信息

        public byte[]   szTurnRight = new byte[MAX_VIOLATIONCODE];				               // 违章右转
        public byte[]   szTurnRightDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];				   // 违章描述信息

        public byte[]   szU_Turn = new byte[MAX_VIOLATIONCODE];				                   // 违章掉头
        public byte[]   szU_TurnDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];				   // 违章描述信息
        public byte[]   szU_TurnShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];               // 显示信息

        public byte[]   szJam = new byte[MAX_VIOLATIONCODE];					                // 交通拥堵
        public byte[]   szJamDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];					    // 违章描述信息

        public byte[]   szParking = new byte[MAX_VIOLATIONCODE];				                // 违章停车
        public byte[]   szParkingDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];		 	      	// 违章描述信息
        public byte[]   szParkingShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];               // 违章停车显示名称

        // 超速 和 超速比例 只需且必须有一个配置
        public byte[]    szOverSpeed = new byte[MAX_VIOLATIONCODE];				                // 超速
        public byte[]    szOverSpeedDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];				// 违章描述信息
        public CFG_OVERSPEED_INFO[]  stOverSpeedConfig = (CFG_OVERSPEED_INFO[])new CFG_OVERSPEED_INFO().toArray(5);                                               // 超速比例代码

        // 超速(高速公路) 和 超速比例(高速公路) 只需且必须有一个配置
        public byte[]    szOverSpeedHighway = new byte[MAX_VIOLATIONCODE];		                // 超速-高速公路
        public byte[]    szOverSpeedHighwayDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];	      	// 超速-违章描述信息
        public CFG_OVERSPEED_INFO[] stOverSpeedHighwayConfig = (CFG_OVERSPEED_INFO[])new CFG_OVERSPEED_INFO().toArray(5);                                 // 超速比例代码

        // 欠速 和 欠速比例 只需且必须有一个配置
        public byte[]    szUnderSpeed = new byte[MAX_VIOLATIONCODE];	                        // 欠速
        public byte[]    szUnderSpeedDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];	            // 违章描述信息
        public CFG_OVERSPEED_INFO[] stUnderSpeedConfig = (CFG_OVERSPEED_INFO[]) new CFG_OVERSPEED_INFO().toArray(5);                                              // 欠速配置信息是一个数组，不同的欠速比违章代码不同，为空表示违章代码不区分超速比

        public byte[]    szOverLine = new byte[MAX_VIOLATIONCODE];				                // 压线
        public byte[]    szOverLineDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];			    	// 违章描述信息
        public byte[]    szOverLineShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];             // 压线显示名称

        public byte[]    szOverYellowLine = new byte[MAX_VIOLATIONCODE];	                    // 压黄线
        public byte[]    szOverYellowLineDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];	    	// 违章描述信息

        public byte[]    szYellowInRoute = new byte[MAX_VIOLATIONCODE];			                // 黄牌占道
        public byte[]    szYellowInRouteDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];			// 黄牌占道违章描述信息

        public byte[]    szWrongRoute = new byte[MAX_VIOLATIONCODE];			                // 不按车道行驶
        public byte[]    szWrongRouteDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];				// 不按车道行驶违章描述信息

        public byte[]    szDrivingOnShoulder = new byte[MAX_VIOLATIONCODE];		                // 路肩行驶
        public byte[]    szDrivingOnShoulderDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];		// 路肩行驶违章描述信息

        public byte[]    szPassing = new byte[MAX_VIOLATIONCODE];                               // 正常行驶
        public byte[]    szPassingDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];               	// 正常行驶违章描述信息

        public byte[]    szNoPassing = new byte[MAX_VIOLATIONCODE];                             // 禁止行驶
        public byte[]    szNoPassingDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT]; 				// 禁止行驶违章描述信息

        public byte[]    szFakePlate = new byte[MAX_VIOLATIONCODE];                             // 套牌
        public byte[]    szFakePlateDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT]; 				// 套牌违章描述信息

        public byte[]    szParkingSpaceParking = new byte[MAX_VIOLATIONCODE];                   // 车位有车
        public byte[]    szParkingSpaceParkingDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT]; 		// 车位有车违章描述信息、

        public byte[]    szParkingSpaceNoParking = new byte[MAX_VIOLATIONCODE];                 // 车位无车
        public byte[]    szParkingSpaceNoParkingDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT]; 	// 车位无车违章描述信息

        public byte[]    szWithoutSafeBelt = new byte[MAX_VIOLATIONCODE];                       // 不系安全带
        public byte[]    szWithoutSafeBeltShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];      // 不系安全带显示名称
        public byte[]    szWithoutSafeBeltDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT]; 	        // 不系安全带违章描述信息

        public byte[]    szDriverSmoking = new byte[MAX_VIOLATIONCODE];                         // 驾驶员抽烟
        public byte[]    szDriverSmokingShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];        // 驾驶员抽烟显示名称
        public byte[]    szDriverSmokingDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT]; 	        // 驾驶员抽烟带违章描述信息

        public byte[]    szDriverCalling = new byte[MAX_VIOLATIONCODE];                         // 驾驶员打电话
        public byte[]    szDriverCallingShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];        // 驾驶员打电话显示名称
        public byte[]    szDriverCallingDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT]; 	        // 驾驶员打电话违章描述信息

        public byte[]    szBacking = new byte[MAX_VIOLATIONCODE];                               // 违章倒车
        public byte[]    szBackingShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];	            // 违章倒车显示名称
        public byte[]    szBackingDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];                  // 违章倒车描述信息

        public byte[]    szVehicleInBusRoute = new byte[MAX_VIOLATIONCODE];                     // 违章占道
        public byte[]    szVehicleInBusRouteShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];    // 违章占道显示名称
        public byte[]    szVehicleInBusRouteDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];        // 违章占道描述信息

        public byte[]    szPedestrianRunRedLight = new byte[MAX_VIOLATIONCODE];                 // 行人闯红灯
        public byte[]    szPedestrianRunRedLightShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];// 行人闯红灯显示名称
        public byte[]    szPedestrianRunRedLightDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];    // 行人闯红灯描述信息

        public byte[]    szPassNotInOrder = new byte[MAX_VIOLATIONCODE];                        // 未按规定依次通行
        public byte[]    szPassNotInOrderShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];       // 未按规定依次通行显示名称
        public byte[]    szPassNotInOrderDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];           // 未按规定依次通行描述信息

        public byte[]	 szTrafficBan = new byte[MAX_VIOLATIONCODE];							// 机动车违法禁令标识
        public byte[]	 szTrafficBanShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];			// 机动车违法禁令标识显示名称
        public byte[]	 szTrafficBanDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];				// 描述信息

        public byte[]    szParkingB = new byte[MAX_VIOLATIONCODE];								// B类违章停车
        public byte[]    szParkingBDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];		 			// B类违章描述信息
        public byte[]    szParkingBShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];   			// B类违章停车显示名称

        public byte[]    szParkingC = new byte[MAX_VIOLATIONCODE];								// C类违章停车
        public byte[]    szParkingCDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];		 			// C类违章描述信息
        public byte[]    szParkingCShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];   			// C类违章停车显示名称

        public byte[]    szParkingD = new byte[MAX_VIOLATIONCODE];								// D类违章停车
        public byte[]    szParkingDDesc = new byte[MAX_VIOLATIONCODE_DESCRIPT];		 			// D类违章描述信息
        public byte[]    szParkingDShowName = new byte[MAX_VIOLATIONCODE_DESCRIPT];   			// D类违章停车显示名称

        public byte[]                szNonMotorHoldUmbrella=new byte[MAX_VIOLATIONCODE];						// 非机动车装载伞具代码
        public byte[]                szNonMotorHoldUmbrellaDesc=new byte[MAX_VIOLATIONCODE_DESCRIPT];		 	// 非机动车装载伞具描述信息
        public byte[]                szNonMotorHoldUmbrellaShowName=new byte[MAX_VIOLATIONCODE_DESCRIPT];   	// 非机动车装载伞具显示名称
        public int                   nBigCarOverSpeedConfigNum;                  // 大车超速配置信息数量
        public CFG_OVERSPEED_INFO[]    stBigCarOverSpeedConfig=(CFG_OVERSPEED_INFO[])new CFG_OVERSPEED_INFO().toArray(5);       // 大车超速配置信息
    }

    // 违章抓拍时间配置表
    public static class TIME_SCHEDULE_INFO extends SdkStructure {
        public int                	 		bEnable;                                              // 是否启用时间表
        public TIME_SECTION_WEEK_DAY_6[]    stuTimeScheduleWeekDay =
                (TIME_SECTION_WEEK_DAY_6[])new TIME_SECTION_WEEK_DAY_6().toArray(WEEK_DAY_NUM);         // 时间表
    }

    // 违章抓拍自定义时间配置
    public static class VIOLATION_TIME_SCHEDULE extends SdkStructure
    {
        public int                abTrafficGate;                  // 是否携带交通卡口信息
        public TIME_SCHEDULE_INFO  stTrafficGate;                  // 交通卡口时间配置

        public int                abTrafficJunction;              // 是否携带交通路口信息
        public TIME_SCHEDULE_INFO  stTrafficJunction;              // 交通路口时间配置

        public int                abTrafficTollGate;              // 是否携带新交通卡口信息
        public TIME_SCHEDULE_INFO  stTrafficTollGate;              // 新交通卡口时间配置

        public int                abTrafficRunRedLight;           // 是否携带交通闯红灯信息
        public TIME_SCHEDULE_INFO  stTrafficRunRedLight;           // 交通闯红灯时间配置

        public int                abTrafficRunYellowLight;        // 是否携带交通闯黄灯信息
        public TIME_SCHEDULE_INFO  stTrafficRunYellowLight;        // 交通闯黄灯时间配置

        public int                abTrafficOverLine;              // 是否携带交通压线信息
        public TIME_SCHEDULE_INFO  stTrafficOverLine;              // 交通压线时间配置

        public int                abTrafficOverYellowLine;        // 是否携带交通压黄线信息
        public TIME_SCHEDULE_INFO  stTrafficOverYellowLine;        // 交通压黄线时间配置

        public int                abTrafficRetrograde;            // 是否携带交通逆行信息
        public TIME_SCHEDULE_INFO  stTrafficRetrograde;            // 交通逆行时间配置

        public int                abTrafficTurnLeft;              // 是否携带交通违章左转信息
        public TIME_SCHEDULE_INFO  stTrafficTurnLeft;              // 交通违章左转时间配置

        public int                abTrafficTurnRight;             // 是否携带交通违章右转信息
        public TIME_SCHEDULE_INFO  stTrafficTurnRight;             // 交通路口违章右转类型

        public int                abTrafficU_Turn;                // 是否携带交通违章掉头信息
        public TIME_SCHEDULE_INFO  stTrafficU_Turn;                // 交通违章掉头时间配置

        public int                abTrafficCrossLane;             // 是否携带交通违章变道信息
        public TIME_SCHEDULE_INFO  stTrafficCrossLane;             // 交通违章变道时间配置

        public int                abTrafficParking;               // 是否携带交通违章停车信息
        public TIME_SCHEDULE_INFO  stTrafficParking;               // 交通违章停车时间配置

        public int                abTrafficJam;                   // 是否携带交通拥堵信息
        public TIME_SCHEDULE_INFO  stTrafficJam;                   // 交通拥堵时间配置

        public int                abTrafficIdle;                  // 是否携带交通交通空闲信息
        public TIME_SCHEDULE_INFO  stTrafficIdle;                  // 交通交通空闲时间配置

        public int                abTrafficWaitingArea;           // 是否携带交通违章驶入待行区信息
        public TIME_SCHEDULE_INFO  stTrafficWaitingArea;           // 交通违章驶入待行区时间配置

        public int                abTrafficUnderSpeed;            // 是否携带交通欠速信息
        public TIME_SCHEDULE_INFO  stTrafficUnderSpeed;            // 交通欠速时间配置

        public int                abTrafficOverSpeed;             // 是否携带交通超速信息
        public TIME_SCHEDULE_INFO  stTrafficOverSpeed;             // 交通超速时间配置

        public int                abTrafficWrongRoute;            // 是否携带交通不按车道行驶信息
        public TIME_SCHEDULE_INFO  stTrafficWrongRoute;            // 交通不按车道行驶时间配置

        public int                abTrafficYellowInRoute;         // 是否携带交通黄牌占道信息
        public TIME_SCHEDULE_INFO  stTrafficYellowInRoute;         // 交通黄牌占道时间配置

        public int                abTrafficVehicleInRoute;        // 是否携带交通有车占道信息
        public TIME_SCHEDULE_INFO  stTrafficVehicleInRoute;        // 交通有车占道时间配置

        public int                abTrafficControl;               // 是否携带交通交通管制信息
        public TIME_SCHEDULE_INFO  stTrafficControl;               // 交通交通管制时间配置

        public int                abTrafficObjectAlarm;           // 是否携带交通指定类型抓拍信息
        public TIME_SCHEDULE_INFO  stTrafficObjectAlarm;           // 交通指定类型抓拍时间配置

        public int                abTrafficAccident;              // 是否携带交通交通事故信息
        public TIME_SCHEDULE_INFO  stTrafficAccident;              // 交通交通事故时间配置

        public int                abTrafficStay;                  // 是否携带交通交通停留/滞留信息
        public TIME_SCHEDULE_INFO  stTrafficStay;                  // 交通交通停留/滞留时间配置

        public int                abTrafficPedestrainPriority;    // 是否携带交通斑马线行人优先信息
        public TIME_SCHEDULE_INFO  stTrafficPedestrainPriority;    // 交通斑马线行人优先时间配置

        public int                abTrafficPedestrain;            // 是否携带交通交通行人事件信息
        public TIME_SCHEDULE_INFO  stTrafficPedestrain;            // 交通交通行人事件时间配置

        public int                abTrafficThrow;                 // 是否携带交通交通抛洒物品事件信息
        public TIME_SCHEDULE_INFO  stTrafficThrow;                 // 交通交通抛洒物品事件时间配置

        public int                abTrafficVehicleInBusRoute;     // 是否携带交通违章占道信息
        public TIME_SCHEDULE_INFO  stTrafficVehicleInBusRoute;     // 交通违章占道时间配置

        public int                abTrafficBacking;               // 是否携带交通违章倒车信息
        public TIME_SCHEDULE_INFO  stTrafficBacking;               // 交通违章倒车时间配置

        public int                abTrafficOverStopLine;          // 是否携带交通压停止线信息
        public TIME_SCHEDULE_INFO  stTrafficOverStopLine;          // 交通压停止线时间配置

        public int                abTrafficParkingOnYellowBox;    // 是否携带交通黄网格线抓拍信息
        public TIME_SCHEDULE_INFO  stTrafficParkingOnYellowBox;    // 交通黄网格线抓拍时间配置

        public int                abTrafficParkingSpaceParking;   // 是否携带交通车位有车信息
        public TIME_SCHEDULE_INFO  stTrafficParkingSpaceParking;   // 交通车位有车时间配置

        public int                abTrafficParkingSpaceNoParking; // 是否携带交通车位无车信息
        public TIME_SCHEDULE_INFO  stTrafficParkingSpaceNoParking; // 交通车位无车时间配置

        public int                abTrafficParkingSpaceOverLine;  // 是否携带交通车位有车压线信息
        public TIME_SCHEDULE_INFO  stTrafficParkingSpaceOverLine;  // 交通车位有车压线时间配置

        public int                abParkingSpaceDetection;        // 是否携带交通多停车位状态检测信息
        public TIME_SCHEDULE_INFO  stParkingSpaceDetection;        // 交通多停车位状态检测时间配置

        public int                abTrafficRestrictedPlate;       // 是否携带交通受限车牌信息
        public TIME_SCHEDULE_INFO  stTrafficRestrictedPlate;       // 交通受限车牌时间配置

        public int                abTrafficWithoutSafeBelt;       // 是否携带交通不系安全带信息
        public TIME_SCHEDULE_INFO  stTrafficWithoutSafeBelt;       // 交通不系安全带时间配置

        public int                abTrafficNoPassing;             // 是否携带交通禁行信息
        public TIME_SCHEDULE_INFO  stTrafficNoPassing;             // 交通禁行时间配置

        public int                abVehicleAnalyse;               // 是否携带交通车辆特征检测分析信息
        public TIME_SCHEDULE_INFO  stVehicleAnalyse;               // 交通车辆特征时间配置

        public int                abCrossLineDetection;           // 是否携带交通警戒线信息
        public TIME_SCHEDULE_INFO  stCrossLineDetection;           // 交通警戒线时间配置

        public int                abCrossFenceDetection;          // 是否携带交通穿越围栏信息
        public TIME_SCHEDULE_INFO  stCrossFenceDetection;          // 交通穿越围栏时间配置

        public int                abCrossRegionDetection;         // 是否携带交通警戒区信息
        public TIME_SCHEDULE_INFO  stCrossRegionDetection;         // 交通警戒区时间配置

        public int                abPasteDetection;               // 是否携带交通ATM贴条信息
        public TIME_SCHEDULE_INFO  stPasteDetection;               // 交通ATM贴条时间配置

        public int                abLeftDetection;                // 是否携带交通物品遗留信息
        public TIME_SCHEDULE_INFO  stLeftDetection;                // 交通物品遗留时间配置

        public int                abPreservation;                 // 是否携带交通物品保全信息
        public TIME_SCHEDULE_INFO  stPreservation;                 // 交通物品保全时间配置

        public int                abTakenAwayDetection;           // 是否携带交通物品搬移信息
        public TIME_SCHEDULE_INFO  stTakenAwayDetection;           // 交通物品搬移时间配置

        public int                abStayDetection;                // 是否携带交通停留/滞留信息
        public TIME_SCHEDULE_INFO  stStayDetection;                // 交通停留/滞留时间配置

        public int                abParkingDetection;             // 是否携带交通非法停车信息
        public TIME_SCHEDULE_INFO  stParkingDetection;             // 交通非法停车时间配置

        public int                abWanderDetection;              // 是否携带交通徘徊信息
        public TIME_SCHEDULE_INFO  stWanderDetection;              // 交通徘徊时间配置

        public int                abMoveDetection;                // 是否携带交通运动信息
        public TIME_SCHEDULE_INFO  stMoveDetection;                // 交通运动时间配置

        public int                abTailDetection;                // 是否携带交通尾随信息
        public TIME_SCHEDULE_INFO  stTailDetection;                // 交通尾随时间配置

        public int                abRioterDetection;              // 是否携带交通聚集信息
        public TIME_SCHEDULE_INFO  stRioterDetection;              // 交通聚集时间配置

        public int                abFightDetection;               // 是否携带交通打架信息
        public TIME_SCHEDULE_INFO  stFightDetection;               // 交通打架时间配置

        public int                abRetrogradeDetection;          // 是否携带交通逆行信息
        public TIME_SCHEDULE_INFO  stRetrogradeDetection;          // 交通逆行时间配置

        public int                abFireDetection;                // 是否携带交通火焰信息
        public TIME_SCHEDULE_INFO  stFireDetection;                // 交通火焰时间配置

        public int                abSmokeDetection;               // 是否携带交通烟雾信息
        public TIME_SCHEDULE_INFO  stSmokeDetection;               // 交通烟雾时间配置

        public int                abNumberStat;                   // 是否携带交通数量统计信息
        public TIME_SCHEDULE_INFO  stNumberStat;                   // 交通数量统计时间配置

        public int                abVideoAbnormalDetection;       // 是否携带交通视频异常信息
        public TIME_SCHEDULE_INFO  stVideoAbnormalDetection;       // 交通视频异常时间配置

        public int                abPrisonerRiseDetection;        // 是否携带看守所囚犯起身检测信息
        public TIME_SCHEDULE_INFO  stPrisonerRiseDetection;        // 看守所囚犯起身检测时间配置

        public int                abFaceDetection;                // 是否携带人脸检测信息
        public TIME_SCHEDULE_INFO  stFaceDetection;                // 人脸检测时间配置

        public int                abFaceRecognition;              // 是否携带人脸识别信息
        public TIME_SCHEDULE_INFO  stFaceRecognition;              // 人脸识别时间配置

        public int                abDensityDetection;             // 是否携带密集度检测信息
        public TIME_SCHEDULE_INFO  stDensityDetection;             // 密集度检测时间配置

        public int                abQueueDetection;               // 是否携带排队检测信息
        public TIME_SCHEDULE_INFO  stQueueDetection;               // 排队检测时间配置

        public int                abClimbDetection;               // 是否携带攀高检测信息
        public TIME_SCHEDULE_INFO  stClimbDetection;               // 攀高时间配置

        public int                abLeaveDetection;               // 是否携带离岗检测信息
        public TIME_SCHEDULE_INFO  stLeaveDetection;               // 离岗时间配置

        public int                abVehicleOnPoliceCar;           // 是否携带车载警车信息
        public TIME_SCHEDULE_INFO  stVehicleOnPoliceCar;           // 车载警车时间配置

        public int                abVehicleOnBus;                 // 是否携带车载公交信息
        public TIME_SCHEDULE_INFO  stVehicleOnBus;                 // 车载公交时间配置

        public int                abVehicleOnSchoolBus;           // 是否携带车载校车信息
        public TIME_SCHEDULE_INFO  stVehicleOnSchoolBus;           // 车载校车时间配置

        public Boolean                abTrafficNonMotorHoldUmbrella;  // 是否携带非机动车装载伞具时间配置
        public TIME_SCHEDULE_INFO  stTrafficNonMotorHoldUmbrella;  // 非机动车装载伞具时间配置
    }

    // 交通全局配置对应图片命名格式参数配置
    public static class TRAFFIC_NAMING_FORMAT extends SdkStructure {
        public byte[]               szFormat = new byte[CFG_COMMON_STRING_256];            // 图片格式
    }

    // CFG_NET_TIME 时间
    public static class CFG_NET_TIME extends SdkStructure {
        public int                 	nStructSize;
        public int					dwYear;					// 年
        public int					dwMonth;				// 月
        public int					dwDay;					// 日
        public int					dwHour;					// 时
        public int					dwMinute;				// 分
        public int					dwSecond;				// 秒

        public CFG_NET_TIME() {
            this.nStructSize = this.size();
        }
    }

    // PERIOD_OF_VALIDITY
    public static class PERIOD_OF_VALIDITY extends SdkStructure {
        public CFG_NET_TIME            stBeginTime;                    // 标定开始时间
        public CFG_NET_TIME            stEndTime;                      // 标定到期时间
    }

    // 交通全局配置对应标定相关配置
    public static class TRAFFIC_CALIBRATION_INFO extends SdkStructure {
        public byte[]               szUnit = new byte[CFG_COMMON_STRING_256];              // 标定单位
        public byte[]               szCertificate = new byte[CFG_COMMON_STRING_256];       // 标定证书
        public PERIOD_OF_VALIDITY   stPeriodOfValidity;                         // 标定有效期
    }

    // TRAFFIC_EVENT_CHECK_MASK
    public static class TRAFFIC_EVENT_CHECK_MASK extends SdkStructure {
        public int                abTrafficGate;                  // 是否携带交通卡口信息
        public int                 nTrafficGate;                   // 交通卡口检测模式掩码

        public int                abTrafficJunction;              // 是否携带交通路口信息
        public int                 nTrafficJunction;               // 交通路口检测模式掩码

        public int                abTrafficTollGate;              // 是否携带新交通卡口信息
        public int                 nTrafficTollGate;               // 新交通卡口检测模式掩码

        public int                abTrafficRunRedLight;           // 是否携带交通闯红灯信息
        public int                 nTrafficRunRedLight;            // 交通闯红灯检测模式掩码

        public int                abTrafficRunYellowLight;        // 是否携带交通闯黄灯信息
        public int                 nTrafficRunYellowLight;         // 交通闯黄灯检测模式掩码

        public int                abTrafficOverLine;              // 是否携带交通压线信息
        public int                 nTrafficOverLine;               // 交通压线检测模式掩码

        public int                abTrafficOverYellowLine;        // 是否携带交通压黄线信息
        public int                 nTrafficOverYellowLine;         // 交通压黄线检测模式掩码

        public int                abTrafficRetrograde;            // 是否携带交通逆行信息
        public int                 nTrafficRetrograde;             // 交通逆行检测模式掩码

        public int                abTrafficTurnLeft;              // 是否携带交通违章左转信息
        public int                 nTrafficTurnLeft;               // 交通违章左转检测模式掩码

        public int                abTrafficTurnRight;             // 是否携带交通违章右转信息
        public int                 nTrafficTurnRight;              // 交通路口违章右转类型

        public int                abTrafficU_Turn;                // 是否携带交通违章掉头信息
        public int                 nTrafficU_Turn;                 // 交通违章掉头检测模式掩码

        public int                abTrafficCrossLane;             // 是否携带交通违章变道信息
        public int                 nTrafficCrossLane;              // 交通违章变道检测模式掩码

        public int                abTrafficParking;               // 是否携带交通违章停车信息
        public int                 nTrafficParking;                // 交通违章停车检测模式掩码

        public int                abTrafficJam;                   // 是否携带交通拥堵信息
        public int                 nTrafficJam;                    // 交通拥堵检测模式掩码

        public int                abTrafficIdle;                  // 是否携带交通交通空闲信息
        public int                 nTrafficIdle;                   // 交通交通空闲检测模式掩码

        public int                abTrafficWaitingArea;           // 是否携带交通违章驶入待行区信息
        public int                 nTrafficWaitingArea;            // 交通违章驶入待行区检测模式掩码

        public int                abTrafficUnderSpeed;            // 是否携带交通欠速信息
        public int                 nTrafficUnderSpeed;             // 交通欠速检测模式掩码

        public int                abTrafficOverSpeed;             // 是否携带交通超速信息
        public int                 nTrafficOverSpeed;              // 交通超速检测模式掩码

        public int                abTrafficWrongRoute;            // 是否携带交通不按车道行驶信息
        public int                 nTrafficWrongRoute;             // 交通不按车道行驶检测模式掩码

        public int                abTrafficYellowInRoute;         // 是否携带交通黄牌占道信息
        public int                 nTrafficYellowInRoute;          // 交通黄牌占道检测模式掩码

        public int                abTrafficVehicleInRoute;        // 是否携带交通有车占道信息
        public int                 nTrafficVehicleInRoute;         // 交通有车占道检测模式掩码

        public int                abTrafficControl;               // 是否携带交通交通管制信息
        public int                 nTrafficControl;                // 交通交通管制检测模式掩码

        public int                abTrafficObjectAlarm;           // 是否携带交通指定类型抓拍信息
        public int                 nTrafficObjectAlarm;            // 交通指定类型抓拍检测模式掩码

        public int                abTrafficAccident;              // 是否携带交通交通事故信息
        public int                 nTrafficAccident;               // 交通交通事故检测模式掩码

        public int                abTrafficStay;                  // 是否携带交通交通停留/滞留信息
        public int                 nTrafficStay;                   // 交通交通停留/滞留检测模式掩码

        public int                abTrafficPedestrainPriority;    // 是否携带交通斑马线行人优先信息
        public int                 nTrafficPedestrainPriority;     // 交通斑马线行人优先检测模式掩码

        public int                abTrafficPedestrain;            // 是否携带交通交通行人事件信息
        public int                 nTrafficPedestrain;             // 交通交通行人事件检测模式掩码

        public int                abTrafficThrow;                 // 是否携带交通交通抛洒物品事件信息
        public int                 nTrafficThrow;                  // 交通交通抛洒物品事件检测模式掩码

        public int                abTrafficVehicleInBusRoute;     // 是否携带交通违章占道信息
        public int                 nTrafficVehicleInBusRoute;      // 交通违章占道检测模式掩码

        public int                abTrafficBacking;               // 是否携带交通违章倒车信息
        public int                 nTrafficBacking;                // 交通违章倒车检测模式掩码

        public int                abTrafficOverStopLine;          // 是否携带交通压停止线信息
        public int                 nTrafficOverStopLine;           // 交通压停止线检测模式掩码

        public int                abTrafficParkingOnYellowBox;    // 是否携带交通黄网格线抓拍信息
        public int                 nTrafficParkingOnYellowBox;     // 交通黄网格线抓拍检测模式掩码

        public int                abTrafficParkingSpaceParking;   // 是否携带交通车位有车信息
        public int                 nTrafficParkingSpaceParking;    // 交通车位有车检测模式掩码

        public int                abTrafficParkingSpaceNoParking; // 是否携带交通车位无车信息
        public int                 nTrafficParkingSpaceNoParking;  // 交通车位无车检测模式掩码

        public int                abTrafficParkingSpaceOverLine;  // 是否携带交通车位有车压线信息
        public int                 nTrafficParkingSpaceOverLine;   // 交通车位有车压线检测模式掩码

        public int                abParkingSpaceDetection;        // 是否携带交通多停车位状态检测信息
        public int                 nParkingSpaceDetection;         // 交通多停车位状态检测检测模式掩码

        public int                abTrafficRestrictedPlate;       // 是否携带交通受限车牌信息
        public int                 nTrafficRestrictedPlate;        // 交通受限车牌检测模式掩码

        public int                abTrafficWithoutSafeBelt;       // 是否携带交通不系安全带信息
        public int                 nTrafficWithoutSafeBelt;        // 交通不系安全带检测模式掩码

        public int                abTrafficNoPassing;             // 是否携带交通禁行信息
        public int                 nTrafficNoPassing;              // 交通禁行检测模式掩码

        public int                abVehicleAnalyse;               // 是否携带交通车辆特征检测分析信息
        public int                 nVehicleAnalyse;                // 交通车辆特征检测模式掩码

        public int                abCrossLineDetection;           // 是否携带交通警戒线信息
        public int                 nCrossLineDetection;            // 交通警戒线检测模式掩码

        public int                abCrossFenceDetection;          // 是否携带交通穿越围栏信息
        public int                 nCrossFenceDetection;           // 交通穿越围栏检测模式掩码

        public int                abCrossRegionDetection;         // 是否携带交通警戒区信息
        public int                 nCrossRegionDetection;          // 交通警戒区检测模式掩码

        public int                abPasteDetection;               // 是否携带交通ATM贴条信息
        public int                 nPasteDetection;                // 交通ATM贴条检测模式掩码

        public int                abLeftDetection;                // 是否携带交通物品遗留信息
        public int                 nLeftDetection;                 // 交通物品遗留检测模式掩码

        public int                abPreservation;                 // 是否携带交通物品保全信息
        public int                 nPreservation;                  // 交通物品保全检测模式掩码

        public int                abTakenAwayDetection;           // 是否携带交通物品搬移信息
        public int                 nTakenAwayDetection;            // 交通物品搬移检测模式掩码

        public int                abStayDetection;                // 是否携带交通停留/滞留信息
        public int                 nStayDetection;                 // 交通停留/滞留检测模式掩码

        public int                abParkingDetection;             // 是否携带交通非法停车信息
        public int                 nParkingDetection;              // 交通非法停车检测模式掩码

        public int                abWanderDetection;              // 是否携带交通徘徊信息
        public int                 nWanderDetection;               // 交通徘徊检测模式掩码

        public int                abMoveDetection;                // 是否携带交通运动信息
        public int                 nMoveDetection;                 // 交通运动检测模式掩码

        public int                abTailDetection;                // 是否携带交通尾随信息
        public int                 nTailDetection;                 // 交通尾随检测模式掩码

        public int                abRioterDetection;              // 是否携带交通聚集信息
        public int                 nRioterDetection;               // 交通聚集检测模式掩码

        public int                abFightDetection;               // 是否携带交通打架信息
        public int                 nFightDetection;                // 交通打架检测模式掩码

        public int                abRetrogradeDetection;          // 是否携带交通逆行信息
        public int                 nRetrogradeDetection;           // 交通逆行检测模式掩码

        public int                abFireDetection;                // 是否携带交通火焰信息
        public int                 nFireDetection;                 // 交通火焰检测模式掩码

        public int                abSmokeDetection;               // 是否携带交通烟雾信息
        public int                 nSmokeDetection;                // 交通烟雾检测模式掩码

        public int                abNumberStat;                   // 是否携带交通数量统计信息
        public int                 nNumberStat;                    // 交通数量统计检测模式掩码

        public int                abVideoAbnormalDetection;       // 是否携带交通视频异常信息
        public int                 nVideoAbnormalDetection;        // 交通视频异常检测模式掩码

        public int                abPrisonerRiseDetection;        // 是否携带看守所囚犯起身检测信息
        public int                 nPrisonerRiseDetection;         // 看守所囚犯起身检测检测模式掩码

        public int                abFaceDetection;                // 是否携带人脸检测信息
        public int                 nFaceDetection;                 // 人脸检测检测模式掩码

        public int                abFaceRecognition;              // 是否携带人脸识别信息
        public int                 nFaceRecognition;               // 人脸识别检测模式掩码

        public int                abDensityDetection;             // 是否携带密集度检测信息
        public int                 nDensityDetection;              // 密集度检测检测模式掩码

        public int                abQueueDetection;               // 是否携带排队检测信息
        public int                 nQueueDetection;                // 排队检测检测模式掩码

        public int                abClimbDetection;               // 是否携带攀高检测信息
        public int                 nClimbDetection;                // 攀高检测模式掩码

        public int                abLeaveDetection;               // 是否携带离岗检测信息
        public int                 nLeaveDetection;                // 离岗检测模式掩码

        public int                abVehicleOnPoliceCar;           // 是否携带车载警车信息
        public int                 nVehicleOnPoliceCar;            // 车载警车检测模式掩码

        public int                abVehicleOnBus;                 // 是否携带车载公交信息
        public int                 nVehicleOnBus;                  // 车载公交检测模式掩码

        public int                abVehicleOnSchoolBus;           // 是否携带车载校车信息
        public int                 nVehicleOnSchoolBus;            // 车载校车检测模式掩码

    }

    // 交通全局配置对应灯组状态配置
    public static class ENABLE_LIGHT_STATE_INFO extends SdkStructure {
        public int 				bEnable;      // 是否启动应用层收到的灯组状态给底层
    }

    // 车道检测类型
    public static class EM_CHECK_TYPE extends SdkStructure {
        public static final int EM_CHECK_TYPE_UNKNOWN = 0;             // 不识别的检测类型
        public static final int EM_CHECK_TYPE_PHYSICAL = 1;            // 物理检测
        public static final int EM_CHECK_TYPE_VIDEO = 2;               // 视频检测
    }

    // TRAFFIC_EVENT_CHECK_INFO
    public static class TRAFFIC_EVENT_CHECK_INFO extends SdkStructure {
        public int       abTrafficGate;                  // 是否携带交通卡口信息
        public int       emTrafficGate;                  // 交通卡口检测类型 EM_CHECK_TYPE

        public int       abTrafficJunction;              // 是否携带交通路口信息
        public int       emTrafficJunction;              // 交通路口检测类型

        public int       abTrafficTollGate;              // 是否携带新交通卡口信息
        public int       emTrafficTollGate;              // 新交通卡口检测类型

        public int       abTrafficRunRedLight;           // 是否携带交通闯红灯信息
        public int       emTrafficRunRedLight;           // 交通闯红灯检测类型

        public int       abTrafficRunYellowLight;        // 是否携带交通闯黄灯信息
        public int       emTrafficRunYellowLight;        // 交通闯黄灯检测类型

        public int       abTrafficOverLine;              // 是否携带交通压线信息
        public int       emTrafficOverLine;              // 交通压线检测类型

        public int       abTrafficOverYellowLine;        // 是否携带交通压黄线信息
        public int       emTrafficOverYellowLine;        // 交通压黄线检测类型

        public int       abTrafficRetrograde;            // 是否携带交通逆行信息
        public int       emTrafficRetrograde;            // 交通逆行检测类型

        public int       abTrafficTurnLeft;              // 是否携带交通违章左转信息
        public int       emTrafficTurnLeft;              // 交通违章左转检测类型

        public int       abTrafficTurnRight;             // 是否携带交通违章右转信息
        public int       emTrafficTurnRight;             // 交通路口违章右转类型

        public int       abTrafficU_Turn;                // 是否携带交通违章掉头信息
        public int       emTrafficU_Turn;                // 交通违章掉头检测类型

        public int       abTrafficCrossLane;             // 是否携带交通违章变道信息
        public int       emTrafficCrossLane;             // 交通违章变道检测类型

        public int       abTrafficParking;               // 是否携带交通违章停车信息
        public int       emTrafficParking;               // 交通违章停车检测类型

        public int       abTrafficJam;                   // 是否携带交通拥堵信息
        public int       emTrafficJam;                   // 交通拥堵检测类型

        public int       abTrafficIdle;                  // 是否携带交通交通空闲信息
        public int       emTrafficIdle;                  // 交通交通空闲检测类型

        public int       abTrafficWaitingArea;           // 是否携带交通违章驶入待行区信息
        public int       emTrafficWaitingArea;           // 交通违章驶入待行区检测类型

        public int       abTrafficUnderSpeed;            // 是否携带交通欠速信息
        public int       emTrafficUnderSpeed;            // 交通欠速检测类型

        public int       abTrafficOverSpeed;             // 是否携带交通超速信息
        public int       emTrafficOverSpeed;             // 交通超速检测类型

        public int       abTrafficWrongRoute;            // 是否携带交通不按车道行驶信息
        public int       emTrafficWrongRoute;            // 交通不按车道行驶检测类型

        public int       abTrafficYellowInRoute;         // 是否携带交通黄牌占道信息
        public int       emTrafficYellowInRoute;         // 交通黄牌占道检测类型

        public int       abTrafficVehicleInRoute;        // 是否携带交通有车占道信息
        public int       emTrafficVehicleInRoute;        // 交通有车占道检测类型

        public int       abTrafficControl;               // 是否携带交通交通管制信息
        public int       emTrafficControl;               // 交通交通管制检测类型

        public int       abTrafficObjectAlarm;           // 是否携带交通指定类型抓拍信息
        public int       emTrafficObjectAlarm;           // 交通指定类型抓拍检测类型

        public int       abTrafficAccident;              // 是否携带交通交通事故信息
        public int       emTrafficAccident;              // 交通交通事故检测类型

        public int       abTrafficStay;                  // 是否携带交通交通停留/滞留信息
        public int       emTrafficStay;                  // 交通交通停留/滞留检测类型

        public int       abTrafficPedestrainPriority;    // 是否携带交通斑马线行人优先信息
        public int       emTrafficPedestrainPriority;    // 交通斑马线行人优先检测类型

        public int       abTrafficPedestrain;            // 是否携带交通交通行人事件信息
        public int       emTrafficPedestrain;            // 交通交通行人事件检测类型

        public int       abTrafficThrow;                 // 是否携带交通交通抛洒物品事件信息
        public int       emTrafficThrow;                 // 交通交通抛洒物品事件检测类型

        public int       abTrafficVehicleInBusRoute;     // 是否携带交通违章占道信息
        public int       emTrafficVehicleInBusRoute;     // 交通违章占道检测类型

        public int       abTrafficBacking;               // 是否携带交通违章倒车信息
        public int       emTrafficBacking;               // 交通违章倒车检测类型

        public int       abTrafficOverStopLine;          // 是否携带交通压停止线信息
        public int       emTrafficOverStopLine;          // 交通压停止线检测类型

        public int       abTrafficParkingOnYellowBox;    // 是否携带交通黄网格线抓拍信息
        public int       emTrafficParkingOnYellowBox;    // 交通黄网格线抓拍检测类型

        public int       abTrafficParkingSpaceParking;   // 是否携带交通车位有车信息
        public int       emTrafficParkingSpaceParking;   // 交通车位有车检测类型

        public int       abTrafficParkingSpaceNoParking; // 是否携带交通车位无车信息
        public int       emTrafficParkingSpaceNoParking; // 交通车位无车检测类型

        public int       abTrafficParkingSpaceOverLine;  // 是否携带交通车位有车压线信息
        public int       emTrafficParkingSpaceOverLine;  // 交通车位有车压线检测类型

        public int       abParkingSpaceDetection;        // 是否携带交通多停车位状态检测信息
        public int       emParkingSpaceDetection;        // 交通多停车位状态检测检测类型

        public int       abTrafficRestrictedPlate;       // 是否携带交通受限车牌信息
        public int       emTrafficRestrictedPlate;       // 交通受限车牌检测类型

        public int       abTrafficWithoutSafeBelt;       // 是否携带交通不系安全带信息
        public int       emTrafficWithoutSafeBelt;       // 交通不系安全带检测类型

        public int       abTrafficNoPassing;             // 是否携带交通禁行信息
        public int       emTrafficNoPassing;             // 交通禁行检测类型

        public int       abVehicleAnalyse;               // 是否携带交通车辆特征检测分析信息
        public int       emVehicleAnalyse;               // 交通车辆特征检测类型

        public int       abCrossLineDetection;           // 是否携带交通警戒线信息
        public int       emCrossLineDetection;           // 交通警戒线检测类型

        public int       abCrossFenceDetection;          // 是否携带交通穿越围栏信息
        public int       emCrossFenceDetection;          // 交通穿越围栏检测类型

        public int       abCrossRegionDetection;         // 是否携带交通警戒区信息
        public int       emCrossRegionDetection;         // 交通警戒区检测类型

        public int       abPasteDetection;               // 是否携带交通ATM贴条信息
        public int       emPasteDetection;               // 交通ATM贴条检测类型

        public int       abLeftDetection;                // 是否携带交通物品遗留信息
        public int       emLeftDetection;                // 交通物品遗留检测类型

        public int       abPreservation;                 // 是否携带交通物品保全信息
        public int       emPreservation;                 // 交通物品保全检测类型

        public int       abTakenAwayDetection;           // 是否携带交通物品搬移信息
        public int       emTakenAwayDetection;           // 交通物品搬移检测类型

        public int       abStayDetection;                // 是否携带交通停留/滞留信息
        public int       emStayDetection;                // 交通停留/滞留检测类型

        public int       abParkingDetection;             // 是否携带交通非法停车信息
        public int       emParkingDetection;             // 交通非法停车检测类型

        public int       abWanderDetection;              // 是否携带交通徘徊信息
        public int       emWanderDetection;              // 交通徘徊检测类型

        public int       abMoveDetection;                // 是否携带交通运动信息
        public int       emMoveDetection;                // 交通运动检测类型

        public int       abTailDetection;                // 是否携带交通尾随信息
        public int       emTailDetection;                // 交通尾随检测类型

        public int       abRioterDetection;              // 是否携带交通聚集信息
        public int       emRioterDetection;              // 交通聚集检测类型

        public int       abFightDetection;               // 是否携带交通打架信息
        public int       emFightDetection;               // 交通打架检测类型

        public int       abRetrogradeDetection;          // 是否携带交通逆行信息
        public int       emRetrogradeDetection;          // 交通逆行检测类型

        public int       abFireDetection;                // 是否携带交通火焰信息
        public int       emFireDetection;                // 交通火焰检测类型

        public int       abSmokeDetection;               // 是否携带交通烟雾信息
        public int       emSmokeDetection;               // 交通烟雾检测类型

        public int       abNumberStat;                   // 是否携带交通数量统计信息
        public int       emNumberStat;                   // 交通数量统计检测类型

        public int       abVideoAbnormalDetection;       // 是否携带交通视频异常信息
        public int       emVideoAbnormalDetection;       // 交通视频异常检测类型

        public int       abPrisonerRiseDetection;        // 是否携带看守所囚犯起身检测信息
        public int       emPrisonerRiseDetection;        // 看守所囚犯起身检测检测类型

        public int       abFaceDetection;                // 是否携带人脸检测信息
        public int       emFaceDetection;                // 人脸检测检测类型

        public int       abFaceRecognition;              // 是否携带人脸识别信息
        public int       emFaceRecognition;              // 人脸识别检测类型

        public int       abDensityDetection;             // 是否携带密集度检测信息
        public int       emDensityDetection;             // 密集度检测检测类型

        public int       abQueueDetection;               // 是否携带排队检测信息
        public int       emQueueDetection;               // 排队检测检测类型

        public int       abClimbDetection;               // 是否携带攀高检测信息
        public int       emClimbDetection;               // 攀高检测类型

        public int       abLeaveDetection;               // 是否携带离岗检测信息
        public int       emLeaveDetection;               // 离岗检测类型

        public int       abVehicleOnPoliceCar;           // 是否携带车载警车信息
        public int       emVehicleOnPoliceCar;           // 车载警车检测类型

        public int       abVehicleOnBus;                 // 是否携带车载公交信息
        public int       emVehicleOnBus;                 // 车载公交检测类型

        public int       abVehicleOnSchoolBus;           // 是否携带车载校车信息
        public int       emVehicleOnSchoolBus;           // 车载校车检测类型

        public int		 abStandUpDetection;		     // 是否携带学生起立信息
        public int		 emStandUpDetection;		     // 学生起立检测类型
    }

    // MixModeConfig中关于车道配置信息
    public static class MIX_MODE_LANE_INFO extends SdkStructure {
        public  int                nLaneNum;                           // 车道配置个数
        public  TRAFFIC_EVENT_CHECK_INFO[]   stCheckInfo = (TRAFFIC_EVENT_CHECK_INFO[]) new TRAFFIC_EVENT_CHECK_INFO().toArray(MAX_LANE_CONFIG_NUMBER);     // 车道配置对应事件检测信息
    }

    // MixModeConfig 混合模式违章配置
    public static class MIX_MODE_CONFIG extends SdkStructure {
        public int                         bLaneDiffEnable;                    // 是否按车道区分
        public MIX_MODE_LANE_INFO          stLaneInfo;
        public TRAFFIC_EVENT_CHECK_INFO    stCheckInfo;

    }

    // CFG_CMD_TRAFFICGLOBAL 交通全局配置配置表
    public static class CFG_TRAFFICGLOBAL_INFO extends SdkStructure
    {
        public VIOLATIONCODE_INFO     stViolationCode;                             // 违章代码配置表
        public int                    bEnableRedList;                              // 使能红名单检测，使能后，名单内车辆违章不上报

        public int                    abViolationTimeSchedule;                     // 是否携带违章抓拍自定义时间配置
        public VIOLATION_TIME_SCHEDULE stViolationTimeSchedule;                    // 违章抓拍自定义时间配置

        public int                    abEnableBlackList;                           // 是否携带使能黑名单检测信息
        public int                    bEnableBlackList;                            // 使能黑名单检测

        public int                    abPriority;                                  // 是否携带违章优先级参数
        public int            		  nPriority;                                   // 违章优先级个数
        public byte[]                 szPriority = new byte[MAX_PRIORITY_NUMBER*CFG_COMMON_STRING_256]; // 违章优先级, 0为最高优先级

        public int                    abNamingFormat;                              // 是否携带图片命名格式参数
        public TRAFFIC_NAMING_FORMAT  stNamingFormat;                              // 图片命名格式参数配置

        public int                    abVideoNamingFormat;                         // 是否携带录像命名格式参数
        public TRAFFIC_NAMING_FORMAT  stVideoNamingFormat;                         // 录像命名格式参数配置

        public int                    abCalibration;                               // 是否携带标定信息
        public TRAFFIC_CALIBRATION_INFO stCalibration;                             // 标定信息

        public int                    abAddress;                                   // 是否携带查询地址参数
        public byte[]                 szAddress = new byte[CFG_COMMON_STRING_256]; // 查询地址，UTF-8编码

        public int                    abTransferPolicy;                            // 是否携带传输策略参数
        public int      			  emTransferPolicy;                            // 传输策略, EM_TRANSFER_POLICY

        public int                    abSupportModeMaskConfig;                     // 是否携带违章掩码
        public TRAFFIC_EVENT_CHECK_MASK stSupportModeMaskConfig;                   // 违章类型支持的检测模式掩码配置

        public int                    abIsEnableLightState;                        // 是否携带灯组状态
        public ENABLE_LIGHT_STATE_INFO stIsEnableLightState;                       // 交通全局配置对应图片命名格式参数配置

        public int                    abMixModeInfo;                               // 是否含有混合模式配置
        public MIX_MODE_CONFIG        stMixModeInfo;                               // 混合模式配置
    }

    // 手动抓拍参数
    public static class MANUAL_SNAP_PARAMETER extends SdkStructure
    {
        public int                   nChannel;               			// 抓图通道,从0开始
        public byte[]                bySequence = new byte[64];	        // 抓图序列号字符串
        public byte[]                byReserved = new byte[60];         // 保留字段
    }

    // 视频统计小计信息
    public static class NET_VIDEOSTAT_SUBTOTAL extends SdkStructure
    {
        public int                 nTotal;                         // 设备运行后人数统计总数
        public int                 nHour;                          // 小时内的总人数
        public int                 nToday;                         // 当天的总人数
        public int                 nOSD;							// 统计人数,用于OSD显示, 可手动清除
        public byte[]              reserved = new byte[252];
    }

    // 视频统计摘要信息
    public static class NET_VIDEOSTAT_SUMMARY extends SdkStructure
    {
        public int                      nChannelID;                 	// 通道号
        public byte[]                   szRuleName = new byte[32];		// 规则名称
        public NET_TIME_EX              stuTime;                    	// 统计时间
        public NET_VIDEOSTAT_SUBTOTAL   stuEnteredSubtotal;         	// 进入小计
        public NET_VIDEOSTAT_SUBTOTAL   stuExitedSubtotal;          	// 出去小计
        public int						nInsidePeopleNum;				// 区域内人数
        public int						emRuleType;						// 规则类型, 参考枚举 EM_RULE_TYPE
        public int						nRetExitManNum;					// 离开的人数个数
        public NET_EXITMAN_STAY_STAT[]	stuExitManStayInfo
                = (NET_EXITMAN_STAY_STAT[])new NET_EXITMAN_STAY_STAT().toArray(MAX_EXIT_MAN_NUM);	// 离开人员的滞留时间信息
        public byte[]                   reserved = new byte[1024];		// 保留字节
    }

    // 离开人员的滞留时间信息
    public static class NET_EXITMAN_STAY_STAT extends SdkStructure
    {
        public NET_TIME					stuEnterTime;					// 人员进入区域时间
        public NET_TIME					stuExitTime;					// 人员离开区域时间
        public byte[]					reserved = new byte[128];		// 保留字节
    }

    // CLIENT_AttachVideoStatSummary 入参
    public static class NET_IN_ATTACH_VIDEOSTAT_SUM extends SdkStructure
    {
        public int                   	dwSize;
        public int                     nChannel;                    // 视频通道号
        public Callback   		cbVideoStatSum;              // 视频统计摘要信息回调, fVideoStatSumCallBack 回调
        public Pointer              	dwUser;                      // 用户数据

        public NET_IN_ATTACH_VIDEOSTAT_SUM()
        {
            this.dwSize = this.size();
        }
    }
    // CLIENT_AttachVideoStatSummary 出参
    public static class NET_OUT_ATTACH_VIDEOSTAT_SUM extends SdkStructure
    {
        public int 					dwSize;

        public NET_OUT_ATTACH_VIDEOSTAT_SUM()
        {
            this.dwSize = this.size();
        }

    }

    public static class EM_OTHER_RULE_TYPE extends SdkStructure
    {
        public static final int EM_OTHER_RULE_TYPE_UNKOWN = 0;             // 未知
        public static final int EM_OTHER_RULE_TYPE_AVERAGE_STAYTIME = 1;   // 平均滞留时间
    }

    // 接口(CLIENT_StartFindNumberStat)输入参数
    public static class NET_IN_FINDNUMBERSTAT extends SdkStructure
    {
        public int                 dwSize;                     // 此结构体大小
        public int                 nChannelID;                 // 要进行查询的通道号
        public NET_TIME            stStartTime;                // 开始时间 暂时精确到小时
        public NET_TIME            stEndTime;                  // 结束时间 暂时精确到小时
        public int                 nGranularityType;           // 查询粒度0:分钟,1:小时,2:日,3:周,4:月,5:季,6:年
        // 7:即时, 8:人员 (7和8只在emRuleType为EM_RULE_MAN_NUM_DETECTION时有效)
        public int                 nWaittime;                  // 等待接收数据的超时时间
        public int                 nPlanID;                    // 计划ID,仅球机有效,从1开始
        public int				   emRuleType;				   // 规则类型
        public int				   nMinStayTime;			   // 参考枚举 EM_RULE_TYPE, 区域人数查询最小滞留时间，不填默认为0，返回滞留时长大于等于该时间的人数信息
        // NumberStat时不需要此参数
        public int					nAreaIDNum;				   // 区域ID个数
        public int[]  				nAreaID = new int[20];	   // 区域ID(一个预置点可以对应多个区域ID)
        public int               	emOtherRule;		       // 其他规则, 参考 EM_OTHER_RULE_TYPE

        public NET_IN_FINDNUMBERSTAT() {
            this.dwSize = this.size();
        }
    }

    // 规则类型
    public static class EM_RULE_TYPE extends SdkStructure
    {
        public static final int EM_RULE_UNKNOWN = 0;			// 未知
        public static final int EM_RULE_NUMBER_STAT = 1;		// 人数统计
        public static final int EM_RULE_MAN_NUM_DETECTION = 2;	// 区域内人数统计
    }

    // 接口(CLIENT_StartFindNumberStat)输出参数
    public static class NET_OUT_FINDNUMBERSTAT extends SdkStructure
    {
        public int               dwSize;                     // 此结构体大小
        public int               dwTotalCount;               // 符合此次查询条件的结果总条数

        public NET_OUT_FINDNUMBERSTAT() {
            this.dwSize = this.size();
        }
    }


    // 接口(CLIENT_DoFindNumberStat)输入参数
    public static class NET_IN_DOFINDNUMBERSTAT extends SdkStructure
    {
        public int               dwSize;                     // 此结构体大小
        public int        		 nBeginNumber;               // [0, totalCount-1], 查询起始序号,表示从beginNumber条记录开始,取count条记录返回;
        public int        		 nCount;                     // 每次查询的流量统计条数
        public int               nWaittime;                  // 等待接收数据的超时时间

        public NET_IN_DOFINDNUMBERSTAT() {
            this.dwSize = this.size();
        }
    }

    public static class NET_NUMBERSTAT extends SdkStructure
    {
        public int      		dwSize;
        public int      		nChannelID;                           	  // 统计通道号
        public byte[]   		szRuleName = new byte[NET_CHAN_NAME_LEN]; // 规则名称
        public NET_TIME 		stuStartTime;                        	  // 开始时间
        public NET_TIME 		stuEndTime;                          	  // 结束时间
        public int      		nEnteredSubTotal;                    	  // 进入人数小计
        public int      		nExitedSubtotal;                     	  // 出去人数小计
        public int      		nAvgInside;                          	  // 平均保有人数(除去零值)
        public int      		nMaxInside;                         	  // 最大保有人数
        public int      		nEnteredWithHelmet;                		  // 戴安全帽进入人数小计
        public int      		nEnteredWithoutHelmet;                	  // 不戴安全帽进入人数小计
        public int      		nExitedWithHelmet;                        // 戴安全帽出去人数小计
        public int      		nExitedWithoutHelmet;                     // 不戴安全帽出去人数小计
        public int				nInsideSubtotal;						  // 在区域内人数小计
        public int            	nPlanID;								  // 计划ID,仅球机有效,从1开始
        public int				nAreaID;								  // 区域ID(一个预置点可以对应多个区域ID)
        public int				nAverageStayTime;					      // 区域内平均滞留时间
        public NET_TEMPERATURE_STATISTICS_INFO	stuTempInfo;		// 温度统计信息(NET_IN_FINDNUMBERSTAT 字段 emRuleType 取值为 EM_RULE_ANATOMYTEMP_DETECT 时有效)
        public NET_NUMBERSTAT() {
            this.dwSize = this.size();
        }
    }

    // 接口(CLIENT_DoFindNumberStat)输出参数
    public static class NET_OUT_DOFINDNUMBERSTAT extends SdkStructure
    {
        public int                          dwSize;                // 此结构体大小
        public int                 			nCount;                // 查询返回人数统计信息个数
        public Pointer   					pstuNumberStat;        // 返回人数统计信息数组, NET_NUMBERSTAT 类型
        public int                 			nBufferLen;            // 用户申请的内存大小,以NET_NUMBERSTAT中的dwsize大小为单位
        public int							nMinStayTime;		   // 区域人数查询时指定的最小滞留时间

        public NET_OUT_DOFINDNUMBERSTAT() {
            this.dwSize = this.size();
        }
    }

    public static class CONNECT_STATE extends SdkStructure
    {
        public static final int CONNECT_STATE_UNCONNECT = 0;
        public static final int CONNECT_STATE_CONNECTING = 1;
        public static final int CONNECT_STATE_CONNECTED = 2;
        public static final int CONNECT_STATE_ERROR = 255;
    }

    // 虚拟摄像头状态查询
    public static class NET_DEV_VIRTUALCAMERA_STATE_INFO extends SdkStructure
    {
        public int 				 nStructSize;							 //结构体大小
        public int 				 nChannelID;							 //通道号
        public int 			 	 emConnectState;						 //连接状态, 取值范围为CONNECT_STATE中的值
        public int 				 uiPOEPort;								 //此虚拟摄像头所连接的POE端口号,0表示不是POE连接, 类型为unsigned int
        public byte[] 			 szDeviceName = new byte[64];			 //设备名称
        public byte[] 			 szDeviceType = new byte[128];			 //设备类型
        public byte[] 			 szSystemType = new byte[128];			 //系统版本
        public byte[] 			 szSerialNo = new byte[NET_SERIALNO_LEN];//序列号
        public int				 nVideoInput;							 //视频输入
        public int 				 nAudioInput;							 //音频输入
        public int     			 nAlarmOutput;							 //外部报警

        public NET_DEV_VIRTUALCAMERA_STATE_INFO()
        {
            this.nStructSize = this.size();
        }
    }

    // 录像文件类型
    public static class NET_RECORD_TYPE extends SdkStructure
    {
        public final static int NET_RECORD_TYPE_ALL = 0; 		 // 所有录像
        public final static int NET_RECORD_TYPE_NORMAL = 1; 	 // 普通录像
        public final static int NET_RECORD_TYPE_ALARM = 2; 		 // 外部报警录像
        public final static int NET_RECORD_TYPE_MOTION = 3; 	 // 动检报警录像
    }

    // 对讲方式
    public static class EM_USEDEV_MODE extends SdkStructure
    {
        public static final int NET_TALK_CLIENT_MODE 	  = 0;   // 设置客户端方式进行语音对讲
        public static final int NET_TALK_SERVER_MODE 	  = 1;   // 设置服务器方式进行语音对讲
        public static final int NET_TALK_ENCODE_TYPE 	  = 2;   // 设置语音对讲编码格式(对应 NETDEV_TALKDECODE_INFO)
        public static final int NET_ALARM_LISTEN_MODE 	  = 3;   // 设置报警订阅方式
        public static final int NET_CONFIG_AUTHORITY_MODE = 4;   // 设置通过权限进行配置管理
        public static final int NET_TALK_TALK_CHANNEL 	  = 5;   // 设置对讲通道(0~MaxChannel-1)
        public static final int NET_RECORD_STREAM_TYPE	  = 6;   // 设置待查询及按时间回放的录像码流类型(0-主辅码流,1-主码流,2-辅码流)
        public static final int NET_TALK_SPEAK_PARAM      = 7;   // 设置语音对讲喊话参数,对应结构体 NET_SPEAK_PARAM
        public static final int NET_RECORD_TYPE           = 8;   // 设置按时间录像回放及下载的录像文件类型(详见  NET_RECORD_TYPE)
        public static final int NET_TALK_MODE3            = 9;   // 设置三代设备的语音对讲参数, 对应结构体 NET_TALK_EX
        public static final int NET_PLAYBACK_REALTIME_MODE = 10; // 设置实时回放功能(0-关闭,1开启)
        public static final int NET_TALK_TRANSFER_MODE    = 11;  // 设置语音对讲是否为转发模式, 对应结构体 NET_TALK_TRANSFER_PARAM
        public static final int NET_TALK_VT_PARAM         = 12;  // 设置VT对讲参数, 对应结构体 NET_VT_TALK_PARAM
        public static final int NET_TARGET_DEV_ID         = 13;  // 设置目标设备标示符, 用以查询新系统能力(非0-转发系统能力消息)
    }

    // 语音编码类型
    public static class NET_TALK_CODING_TYPE extends SdkStructure
    {
        public static final int NET_TALK_DEFAULT = 0;            // 无头PCM
        public static final int NET_TALK_PCM = 1;                // 带头PCM
        public static final int	NET_TALK_G711a = 2;              // G711a
        public static final int NET_TALK_AMR = 3;                // AMR
        public static final int	NET_TALK_G711u = 4;              // G711u
        public static final int	NET_TALK_G726 = 5;               // G726
        public static final int	NET_TALK_G723_53 = 6;            // G723_53
        public static final int NET_TALK_G723_63 = 7;            // G723_63
        public static final int	NET_TALK_AAC = 8;                // AAC
        public static final int	NET_TALK_OGG = 9;                // OGG
        public static final int	NET_TALK_G729 = 10;              // G729
        public static final int	NET_TALK_MPEG2 = 11;             // MPEG2
        public static final int	NET_TALK_MPEG2_Layer2 = 12;      // MPEG2-Layer2
        public static final int	NET_TALK_G722_1 = 13;            // G.722.1
        public static final int	NET_TALK_ADPCM = 21;             // ADPCM
        public static final int	NET_TALK_MP3   = 22;             // MP3
    }

    // 设备支持的语音对讲类型
    public static class NETDEV_TALKFORMAT_LIST extends SdkStructure
    {
        public int 						 nSupportNum;                                                  				    // 个数
        public NETDEV_TALKDECODE_INFO[] type = (NETDEV_TALKDECODE_INFO[])new NETDEV_TALKDECODE_INFO().toArray(64);   // 编码类型

        public byte[] reserved = new byte[64];
    }

    // 语音编码信息
    public static class NETDEV_TALKDECODE_INFO extends SdkStructure
    {
        public int                 encodeType;                       // 编码类型, encodeType对应NET_TALK_CODING_TYPE
        public int                 nAudioBit;                        // 位数,如8或16等
        public int                 dwSampleRate;                     // 采样率,如8000或16000等
        public int                 nPacketPeriod;                    // 打包周期, 单位ms, 目前只能是25
        public byte[]    		   reserved = new byte[60];
    }

    // 语音对讲喊话参数
    public static class NET_SPEAK_PARAM extends SdkStructure
    {
        public int 				  dwSize;                     		// 结构体大小
        public int 				  nMode;                      		// 0：对讲（默认模式）,1：喊话；从喊话切换到对讲要重新设置
        public int 				  nSpeakerChannel;           		// 扬声器通道号,喊话时有效
        public boolean 			  bEnableWait;            			// 开启对讲时是否等待设备的响应,默认不等待.TRUE:等待;FALSE:不等待
        // 超时时间由CLIENT_SetNetworkParam设置,对应NET_PARAM的nWaittime字段
        public NET_SPEAK_PARAM()
        {
            this.dwSize = this.size();
        }
    }

    // 是否开启语音对讲的转发模式
    public static class NET_TALK_TRANSFER_PARAM extends SdkStructure
    {
        public int 				 dwSize;
        public int 			 	 bTransfer;                 	   // 是否开启语音对讲转发模式, TRUE: 开启转发

        public NET_TALK_TRANSFER_PARAM()
        {
            this.dwSize = this.size();
        }
    }

    // 预览类型,对应CLIENT_RealPlayEx接口
    public static class NET_RealPlayType extends SdkStructure
    {
        public static final int NET_RType_Realplay   = 0; 		// 实时预览
        public static final int NET_RType_Multiplay  = 1; 		// 多画面预览
        public static final int NET_RType_Realplay_0 = 2; 		// 实时监视-主码流 ,等同于NET_RType_Realplay
        public static final int NET_RType_Realplay_1 = 3; 		// 实时监视-从码流1
        public static final int NET_RType_Realplay_2 = 4; 		// 实时监视-从码流2
        public static final int NET_RType_Realplay_3 = 5; 		// 实时监视-从码流3
        public static final int NET_RType_Multiplay_1 = 6;		// 多画面预览－1画面
        public static final int NET_RType_Multiplay_4 = 7; 		// 多画面预览－4画面
        public static final int NET_RType_Multiplay_8 = 8; 		// 多画面预览－8画面
        public static final int NET_RType_Multiplay_9 = 9; 		// 多画面预览－9画面
        public static final int NET_RType_Multiplay_16 = 10; 	// 多画面预览－16画面
        public static final int NET_RType_Multiplay_6 = 11;  	// 多画面预览－6画面
        public static final int NET_RType_Multiplay_12 = 12; 	// 多画面预览－12画面
        public static final int NET_RType_Multiplay_25 = 13;	// 多画面预览－25画面
        public static final int NET_RType_Multiplay_36 = 14; 	// 多画面预览－36画面
        public static final int NET_RType_Multiplay_64 = 15;    // 多画面预览－64画面
        public static final int NET_RType_Multiplay_255 = 16;   // 不修改当前预览通道数
        public static final int NET_RType_Realplay_Audio = 17;  // 只拉音频, 非通用
        public static final int NET_RType_Realplay_Test = 255;  // 带宽测试码流
    }


    // 实时监视的实时数据标志, 对应 CLIENT_SetRealDataCallBackEx(Ex2) 中的 dwFlag 参数
    // 支持 '|' 运算符, 如 dwFlag = REALDATA_FLAG_RAW_DATA | REALDATA_FLAG_YUV_DATA
    public static class EM_REALDATA_FLAG extends SdkStructure
    {
        public static final int REALDATA_FLAG_RAW_DATA				= 0x01;	// 原始数据标志,			对应fRealDataCallBack(Ex/Ex2)回调函数中 dwDataType 为0, 0x01 = 0x01 << 0
        public static final int REALDATA_FLAG_DATA_WITH_FRAME_INFO	= 0x02;	// 带有帧信息的数据标志,		对应fRealDataCallBack(Ex/Ex2)回调函数中 dwDataType 为1, 0x02 = 0x01 << 1
        public static final int REALDATA_FLAG_YUV_DATA				= 0x04;	// YUV 数据标志,			对应fRealDataCallBack(Ex/Ex2)回调函数中 dwDataType 为2, 0x04 = 0x01 << 2
        public static final int REALDATA_FLAG_PCM_AUDIO_DATA		= 0x08;	// PCM 音频数据标志,		对应fRealDataCallBack(Ex/Ex2)回调函数中 dwDataType 为3, 0x08 = 0x01 << 3
    }

    // 回调视频数据帧的帧参数结构体
    public static class tagVideoFrameParam extends SdkStructure
    {
        public byte                  encode;                 // 编码类型
        public byte                  frametype;              // I = 0, P = 1, B = 2...
        public byte                  format;                 // PAL - 0, NTSC - 1
        public byte                  size;                   // CIF - 0, HD1 - 1, 2CIF - 2, D1 - 3, VGA - 4, QCIF - 5, QVGA - 6 ,
        // SVCD - 7,QQVGA - 8, SVGA - 9, XVGA - 10,WXGA - 11,SXGA - 12,WSXGA - 13,UXGA - 14,WUXGA - 15, LFT - 16, 720 - 17, 1080 - 18 ,1_3M-19
        // 2M-20, 5M-21;当size=255时，成员变量width,height 有效
        public int                   fourcc;                 // 如果是H264编码则总为0，否则值为*( DWORD*)"DIVX"，即0x58564944
        public short				 width;					 // 宽，单位是像素，当size=255时有效
        public short				 height;				 // 高，单位是像素，当size=255时有效
        public NET_TIME              struTime;               // 时间信息
    }

    // 回调音频数据帧的帧参数结构体
    public static class tagCBPCMDataParam extends SdkStructure
    {
        public byte                channels;                // 声道数
        public byte                samples;                 // 采样 0 - 8000, 1 - 11025, 2 - 16000, 3 - 22050, 4 - 32000, 5 - 44100, 6 - 48000
        public byte                depth;                   // 采样深度 取值8或者16等。直接表示
        public byte                param1;                  // 0 - 指示无符号,1-指示有符号
        public int                 reserved;                // 保留
    }

    // 视频监视断开事件类型
    public static class EM_REALPLAY_DISCONNECT_EVENT_TYPE extends SdkStructure
    {
        public static final int DISCONNECT_EVENT_REAVE 		= 0;                 // 表示高级用户抢占低级用户资源
        public static final int DISCONNECT_EVENT_NETFORBID  = 1;                 // 禁止入网
        public static final int DISCONNECT_EVENT_SUBCONNECT = 2;                 // 动态子链接断开
    }

    // 电池电压过低报警
    public static class ALARM_BATTERYLOWPOWER_INFO extends SdkStructure
    {
        public int dwSize;			//结构体大小
        public int nAction;			//0:开始1:停止
        public int nBatteryLeft;	//剩余电量百分比,单位%
        public NET_TIME stTime;		//事件发生时间
        public int nChannelID;		//通道号,标识子设备电池,从0开始
        public NET_GPS_STATUS_INFO stGPSStatus;					 // GPS信息

        public ALARM_BATTERYLOWPOWER_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 温度过高报警
    public static class ALARM_TEMPERATURE_INFO extends SdkStructure
    {
        public int      dwSize;					//结构体大小
        public byte[]   szSensorName = new byte[NET_MACHINE_NAME_NUM];//温度传感器名称
        public int      nChannelID;			    //通道号
        public int      nAction;				//0:开始1:停止
        public float    fTemperature;			//当前温度值,单位摄氏度
        public NET_TIME stTime;					//事件发生时间

        public ALARM_TEMPERATURE_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 普通报警信息
    public static class NET_CLIENT_STATE_EX extends SdkStructure
    {
        public int                channelcount;
        public int                alarminputcount;
        public byte[]             alarm       		= new byte[32];        // 外部报警
        public byte[]       	  motiondection 	= new byte[32];        // 动态检测
        public byte[]             videolost 		= new byte[32];        // 视频丢失
        public byte[]             bReserved 		= new byte[32];
    }

    // 视频遮挡报警状态信息对应结构体
    public static class NET_CLIENT_VIDEOBLIND_STATE extends SdkStructure
    {
        public int dwSize;
        public int channelcount;
        public int[] dwAlarmState = new int[NET_MAX_CHANMASK];//每一个int按位表示32通道的报警状态,0-表示无报警,1-表示有报警

        public NET_CLIENT_VIDEOBLIND_STATE()
        {
            this.dwSize = this.size();
        }
    }

    // 视频丢失报警状态信息对应结构体
    public static class NET_CLIENT_VIDEOLOST_STATE extends SdkStructure
    {
        public int	    dwSize;
        public int	    channelcount;
        public int[]	dwAlarmState = new int[NET_MAX_CHANMASK];//每一个int按位表示32通道的报警状态（只有dwAlarmState[0]有效）,0-表示无报警,1-表示有报警

        public NET_CLIENT_VIDEOLOST_STATE()
        {
            this.dwSize = this.size();
        }
    }

    // 门禁开门 CLIENT_ControlDevice接口的 CTRLTYPE_CTRL_ACCESS_OPEN 命令参数
    public static class NET_CTRL_ACCESS_OPEN extends SdkStructure {
        public int          dwSize;
        public int          nChannelID;            					  // 通道号(0开始)
        public Pointer      szTargetID;			    				  // 转发目标设备ID,为NULL表示不转发
        public byte[]       szUserID = new byte[MAX_COMMON_STRING_32];//远程用户ID
        public int			emOpenDoorType;                			  // 开门方式, 参考 EM_OPEN_DOOR_TYPE
        /**
         * EM_OPEN_DOOR_DIRECTION
         */
        public int		    emOpenDoorDirection;			// 开门方向
        /**
         * EM_REMOTE_CHECK_CODE
         */
        public int		    emRemoteCheckCode;				// 远程权限验证结果
        public NET_CTRL_ACCESS_OPEN() {
            this.dwSize = this.size();
        }
    }

    // 门禁控制--开门方式
    public static class EM_OPEN_DOOR_TYPE extends SdkStructure
    {
        public static final int EM_OPEN_DOOR_TYPE_UNKNOWN = 0;
        public static final int EM_OPEN_DOOR_TYPE_REMOTE = 1;			// 远程开门
        public static final int EM_OPEN_DOOR_TYPE_LOCAL_PASSWORD = 2;	// 本地密码开门
        public static final int EM_OPEN_DOOR_TYPE_LOCAL_CARD = 3;		// 本地刷卡开门
        public static final int EM_OPEN_DOOR_TYPE_LOCAL_BUTTON = 4;		// 本地按钮开门
    }

    // 门禁关门CLIENT_ControlDevice接口的 CTRLTYPE_CTRL_ACCESS_CLOSE 命令参数
    public static class NET_CTRL_ACCESS_CLOSE extends SdkStructure
    {
        public int dwSize;
        public int nChannelID;//通道号(0开始)

        public NET_CTRL_ACCESS_CLOSE() {
            this.dwSize = this.size();
        }
    }

    // 门禁状态类型
    public static class EM_NET_DOOR_STATUS_TYPE extends SdkStructure
    {
        public static final int EM_NET_DOOR_STATUS_UNKNOWN=0;
        public static final int EM_NET_DOOR_STATUS_OPEN=EM_NET_DOOR_STATUS_UNKNOWN+1; 	//门打开
        public static final int EM_NET_DOOR_STATUS_CLOSE=EM_NET_DOOR_STATUS_OPEN+1; 	//门关闭
        public static final int EM_NET_DOOR_STATUS_BREAK=EM_NET_DOOR_STATUS_CLOSE+1; 	//门异常打开
    }

    // 门禁状态信息(CLIENT_QueryDevState 接口输入参数)
    public static class NET_DOOR_STATUS_INFO extends SdkStructure
    {
        public int dwSize;
        public int nChannel;//门禁通道号
        public int emStateType;//门禁状态信息, 对应枚举EM_NET_DOOR_STATUS_TYPE

        public NET_DOOR_STATUS_INFO() {
            this.dwSize = this.size();
        }
    }

    // 开启道闸参数(对应 CTRLTYPE_CTRL_OPEN_STROBE 命令)
    public static class NET_CTRL_OPEN_STROBE extends SdkStructure
    {
        public int dwSize;
        public int nChannelId;                      // 通道号
        public byte[] szPlateNumber = new byte[64]; // 车牌号码
        public int	emOpenType;							// 开闸类型,EM_OPEN_STROBE_TYPE
        public NET_CTRL_OPEN_STROBE() {
            this.dwSize = this.size();
        }
    }

    // 刻录控制 (对应 CTRLTYPE_BURNING_START 命令)
    public static class BURNNG_PARM extends SdkStructure
    {
        public int	channelMask;						// 通道掩码,按位表示要刻录的通道
        public byte devMask;							// 刻录机掩码,根据查询到的刻录机列表,按位表示
        public byte bySpicalChannel;					// 画中画通道(通道数+31,例如对于4通道设备,该值应为35)
        public byte[] byReserved = new byte[2];			// 保留字段
    }

    // 关闭道闸参数(对应  CTRLTYPE_CTRL_CLOSE_STROBE 命令)
    public static class NET_CTRL_CLOSE_STROBE extends SdkStructure
    {
        public int	dwSize;
        public int	nChannelId; // 通道号

        public NET_CTRL_CLOSE_STROBE() {
            this.dwSize = this.size();
        }
    }

    // 道闸控制方式枚举
    public static class NET_EM_CFG_TRAFFICSTROBE_CTRTYPE extends SdkStructure
    {
        public static final int NET_EM_CFG_CTRTYPE_UNKNOWN = 0;                 // 未定义
        public static final int NET_EM_CFG_CTRTYPE_TRAFFICTRUSTLIST = 1;        // 通过白名单控制是否开闸；只有白名单内车辆才开闸
        public static final int NET_EM_CFG_CTRTYPE_ALLSNAPCAR = 2;              // 针对所有抓拍车辆都开闸
        public static final int NET_EM_CFG_CTRTYPE_ORDER = 3;                   // 通过上层下发的命令开闸
    }

    // 所有车开闸种类
    public static class NET_EM_CFG_ALL_SNAP_CAR extends SdkStructure
    {
        public static final int NET_EM_CFG_ALL_SNAP_CAR_UNKNOWN = 0;			// 未知开闸种类
        public static final int NET_EM_CFG_ALL_SNAP_CAR_PLATE = 1;				// 所有有牌车车辆
        public static final int NET_EM_CFG_ALL_SNAP_CAR_NOPLATE = 2;			// 所有无牌车车辆
    }

    // 道闸常开配置
    public static class NET_CFG_STATIONARY_OPEN extends SdkStructure
    {
        public int 					bEnable;										// 使能
        public CFG_TIME_SCHEDULE	stTimeShecule = new CFG_TIME_SCHEDULE();		// 常开模式执行时间段
    }

    // 道闸配置信息(对应 NET_EM_CFG_TRAFFICSTROBE 命令)
    public static class NET_CFG_TRAFFICSTROBE_INFO extends SdkStructure
    {
        public int							dwSize;											// 结构体大小
        public int							bEnable;										// 使能
        public int							nCtrlTypeCount;									// 道闸控制方式个数
        public int[]    					emCtrlType = new int[NET_CFG_MAX_CTRLTYPE_NUM];  // 道闸控制方式, 详见NET_EM_CFG_TRAFFICSTROBE_CTRTYPE
        public int							nAllSnapCarCount;								// 所有车开闸种类个数
        public int[]						emAllSnapCar = new int[NET_MAX_ALL_SNAP_CAR_COUNT];	// 所有车开闸种类, 详见NET_EM_CFG_ALL_SNAP_CAR
        public NET_ALARM_MSG_HANDLE			stuEventHandler;								// 开启道闸联动参数
        public NET_ALARM_MSG_HANDLE			stuEventHandlerClose;							// 关闭道闸联动参数
        public byte[]						szOrderIP = new byte[NET_MAX_IPADDR_EX_LEN];	// 负责命令开闸的平台IP
        public int							emCtrlTypeOnDisconnect;							// 平台IP与设备断开连接后，设备采用的开闸方式, 详见NET_EM_CFG_TRAFFICSTROBE_CTRTYPE
        public NET_CFG_STATIONARY_OPEN		stuStationaryOpen;								// 道闸常开配置

        public NET_CFG_TRAFFICSTROBE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 报警状态 (对应   CTRLTYPE_TRIGGER_ALARM_OUT 命令)
    public static class ALARMCTRL_PARAM extends SdkStructure
    {
        public int	dwSize;
        public int	nAlarmNo; // 报警通道号,从0开始
        public int	nAction; // 1：触发报警,0：停止报警

        public ALARMCTRL_PARAM() {
            this.dwSize = this.size();
        }
    }

    // 查询 IVS 前端设备入参
    public static class NET_IN_IVS_REMOTE_DEV_INFO extends SdkStructure
    {
        public int                     dwSize;                         // 该结构体大小
        public int                     nChannel;                       // 通道号

        public NET_IN_IVS_REMOTE_DEV_INFO() {
            this.dwSize = this.size();
        }
    }

    // 查询 IVS 前端设备出参
    public static class NET_OUT_IVS_REMOTE_DEV_INFO extends SdkStructure
    {
        public int                   dwSize;                         	// 该结构体大小
        public int     			     nPort;								// 端口
        public byte[]				 szIP = new byte[64];	            // 设备IP
        public byte[]				 szUser = new byte[64];	            // 用户名
        public byte[]				 szPassword = new byte[64];         // 密码
        public byte[]				 szAddress = new byte[128];	        // 机器部署地点

        public NET_OUT_IVS_REMOTE_DEV_INFO() {
            this.dwSize = this.size();
        }
    }


    // 获取视频通道属性命令的子类型
    public static class NET_VIDEO_CHANNEL_TYPE extends SdkStructure
    {
        public static final int NET_VIDEO_CHANNEL_TYPE_ALL = 0;    // 全部
        public static final int NET_VIDEO_CHANNEL_TYPE_INPUT = 1;  // 输入
        public static final int NET_VIDEO_CHANNEL_TYPE_OUTPUT = 2; // 输出
    }

    // CLIENT_QueryDevInfo , NET_QUERY_VIDEOCHANNELSINFO 命令输入参数
    public static class NET_IN_GET_VIDEOCHANNELSINFO extends SdkStructure
    {
        public int              dwSize;
        public int              emType;         // 需要获取的通道类型,详见NET_VIDEO_CHANNEL_TYPE

        public NET_IN_GET_VIDEOCHANNELSINFO() {
            this.dwSize = this.size();
        }
    }

    public static class NET_VIDEOCHANNELS_INPUT extends SdkStructure
    {
        public int                     nThermographyCount;         		// 热成像通道个数
        public int[]                   nThermography = new int[64];     // 热成像通道的通道号
        public int                     nMultiPreviewCount;         		// 多画面预览通道个数
        public int[]                   nMultiPreview = new int[4];	    // 多画面预览通道号
        public int                     nPIPCount;                  		// 画中画通道个数
        public int[]                   nPIP = new int[4];    	        // 画中画通道号
        public int                     nCompressPlayCount;         		// 二次压缩回放通道个数
        public int[]                   nCompressPlay = new int[4];	    // 二次压缩回放通道号
        public int					   nSDCount;						// 球机通道个数
        public int[]				   nSD = new int[64];				// 球机通道号
        public int                     nPTZCount;                  		// 支持云台程序的通道数量
        public short[]                 nPTZ = new short[64];            // 支持云台程序的通道号
        public int                     nFuseRadarCount;            // 支持融合雷达流，可见光叠加雷达流的通道数量
        public int[]				   nFuseRadar=new int[64];             // 支持融合雷达流，可见光叠加雷达流的通道号
        public int                     nPureRadarCount;            // 支持纯雷达流，无可见光的通道数量
        public int[]				   nPureRadar=new int[64];             // 支持纯雷达流，无可见光的通道号
        public byte[]                  reserved=new byte[4096];
    }

    public static class NET_VIDEOCHANNELS_OUTPUT extends SdkStructure
    {
        public int                       nVGACount;                  			// VGA输出个数
        public int[]                     nVGA = new int[128];                   // VGA输出
        public int                       nTVCount;                   			// TV输出个数
        public int[]                     nTV = new int[128];                    // TV输出
        public byte[]                    reserved = new byte[512];
    }

    //CLIENT_QueryDevInfo , NET_QUERY_VIDEOCHANNELSINFO 命令输出参数
    public static class NET_OUT_GET_VIDEOCHANNELSINFO extends SdkStructure
    {
        public int                         dwSize;
        public NET_VIDEOCHANNELS_INPUT     stInputChannels;        // 输入通道信息,获取类型为NET_VIDEO_CHANNEL_TYPE_ALL/INPUT时有效
        public NET_VIDEOCHANNELS_OUTPUT    stOutputChannels;       // 输出通道信息,获取类型为NET_VIDEO_CHANNEL_TYPE_ALL/OUTPUT时有效

        public NET_OUT_GET_VIDEOCHANNELSINFO() {
            this.dwSize = this.size();
        }
    }

    // 热成像色彩
    public static class NET_THERMO_COLORIZATION extends SdkStructure
    {
        public static final int NET_THERMO_COLORIZATION_UNKNOWN = 0;	// 未知
        public static final int NET_THERMO_COLORIZATION_WHITE_HOT = 1;	// 白热
        public static final int NET_THERMO_COLORIZATION_BLACK_HOT = 2;	// 黑热
        public static final int NET_THERMO_COLORIZATION_IRONBOW2 = 3;	// 铁虹2
        public static final int NET_THERMO_COLORIZATION_ICEFIRE = 4;	// 冰火
        public static final int NET_THERMO_COLORIZATION_FUSION = 5;		// 融合
        public static final int NET_THERMO_COLORIZATION_RAINBOW = 6;	// 彩虹
        public static final int NET_THERMO_COLORIZATION_GLOBOW = 6;		// ..
        public static final int NET_THERMO_COLORIZATION_IRONBOW1 = 7;	// 铁虹1
        public static final int NET_THERMO_COLORIZATION_SEPIA = 8;		// 深褐
        public static final int NET_THERMO_COLORIZATION_COLOR1 = 9;		// 彩色1
        public static final int NET_THERMO_COLORIZATION_COLOR2 = 10;	// 彩色2
        public static final int NET_THERMO_COLORIZATION_RAIN = 11;		// 雨天
        public static final int NET_THERMO_COLORIZATION_RED_HOT = 12;	// 红热
        public static final int NET_THERMO_COLORIZATION_GREEN_HOT = 13;	// 绿热
    }

    // 热成像感兴趣区域模式
    public static class NET_THERMO_ROI extends SdkStructure
    {
        public static final int NET_THERMO_ROI_UNKNOWN = 0;			// 未知
        public static final int NET_THERMO_ROI_FULL_SCREEN = 1;		// 全屏
        public static final int NET_THERMO_ROI_SKY = 2;				// 顶部
        public static final int NET_THERMO_ROI_GROUND = 3;			// 中部
        public static final int NET_THERMO_ROI_HORIZONTAL = 4;		// 底部
        public static final int NET_THERMO_ROI_CENTER_75 = 5;		// 中心点 75%
        public static final int NET_THERMO_ROI_CENTER_50 = 6;		// 中心点 50%
        public static final int NET_THERMO_ROI_CENTER_25 = 7;		// 中心点 25%
        public static final int NET_THERMO_ROI_CUSTOM = 8;			// 自定义
    }

    // 热成像模式
    public static class NET_THERMO_MODE extends SdkStructure
    {
        public static final int NET_THERMO_MODE_UNKNOWN = 0;	// 未知
        public static final int NET_THERMO_MODE_DEFAULT	= 1; 	// 默认
        public static final int NET_THERMO_MODE_INDOOR = 2; 	// 室内
        public static final int NET_THERMO_MODE_OUTDOOR = 3; 	// 室外
    }

    // CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_THERMO_GRAPHY_PRESET 命令入参
    public static class NET_IN_THERMO_GET_PRESETINFO extends SdkStructure
    {
        public int              dwSize;
        public int              nChannel;                           // 通道号
        public int     			emMode;                             // 模式, 参考NET_THERMO_MODE

        public NET_IN_THERMO_GET_PRESETINFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_THERMO_GRAPHY_PRESET 命令出参
    public static class NET_OUT_THERMO_GET_PRESETINFO extends SdkStructure
    {
        public int              		dwSize;
        public NET_THERMO_GRAPHY_INFO   stInfo;     // 热成像信息

        public NET_OUT_THERMO_GET_PRESETINFO() {
            this.dwSize = this.size();
        }
    }

    // 热成像优化区域
    public static class NET_THERMO_GRAPHY_OPTREGION extends SdkStructure
    {
        public int                 bOptimizedRegion;                   // 是否开启优化区域
        public int                 nOptimizedROIType;                  // 优化区域类型,见NET_THERMO_ROI
        public int                 nCustomRegion;                      // 自定义区域个数
        public NET_RECT[] 		   stCustomRegions = (NET_RECT[])new NET_RECT().toArray(64); // 自定义区域,仅在 nOptimizedROIType 为 NET_THERMO_ROI_CUSTOM 时有效
        public byte[]              Reserved = new byte[256];
    }

    // 热成像信息
    public static class NET_THERMO_GRAPHY_INFO extends SdkStructure
    {
        public int                         nBrightness;                // 亮度
        public int                         nSharpness;                 // 锐度
        public int                         nEZoom;                     // 倍数
        public int                         nThermographyGamma;         // 伽马值
        public int                         nColorization;              // 色彩,见NET_THERMO_COLORIZATION
        public int                         nSmartOptimizer;            // 优化指数
        public NET_THERMO_GRAPHY_OPTREGION stOptRegion; 			   // 优化区域
        public int                         nAgc;                       // 自动增益控制
        public int                         nAgcMaxGain;                // 最大自动增益
        public int                         nAgcPlateau;                // 增益均衡
        public byte[]                      reserved = new byte[244];   // 保留字段
    }

    // CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION 命令入参
    public static class NET_IN_THERMO_GET_OPTREGION extends SdkStructure
    {
        public int                 dwSize;
        public int                 nChannel;                           // 通道号

        public NET_IN_THERMO_GET_OPTREGION() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_THERMO_GRAPHY_OPTREGION 命令出参
    public static class NET_OUT_THERMO_GET_OPTREGION extends SdkStructure
    {
        public int                       dwSize;
        public NET_THERMO_GRAPHY_OPTREGION stInfo;                     // 优化区域信息

        public NET_OUT_THERMO_GET_OPTREGION() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO 命令入参
    public static class NET_IN_THERMO_GET_EXTSYSINFO extends SdkStructure
    {
        public int               dwSize;
        public int               nChannel;                           // 通道号

        public NET_IN_THERMO_GET_EXTSYSINFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_THERMO_GRAPHY_EXTSYSINFO 命令出参
    public static class NET_OUT_THERMO_GET_EXTSYSINFO extends SdkStructure
    {
        public int               	dwSize;
        public NET_THERMO_SYSINFO   stInfo;                           // 通道号

        public NET_OUT_THERMO_GET_EXTSYSINFO() {
            this.dwSize = this.size();
        }
    }

    // 外部系统信息
    public static class NET_THERMO_SYSINFO extends SdkStructure
    {
        public byte[]                szSerialNumber = new byte[64];                 // 序列号
        public byte[]                szSoftwareVersion = new byte[64];              // 软件版本
        public byte[]                szFirmwareVersion = new byte[64];              // 固件版本
        public byte[]                szLibVersion = new byte[64];                   // 库版本
        public byte[]                reserved = new byte[256];
    }

    // CLIENT_GetDevCaps 接口 NET_THERMO_GRAPHY_CAPS 命令入参
    public static class NET_IN_THERMO_GETCAPS extends SdkStructure
    {
        public int               dwSize;
        public int               nChannel;                           // 通道号

        public NET_IN_THERMO_GETCAPS() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_GetDevCaps 接口 NET_THERMO_GRAPHY_CAPS 命令出参
    public static class NET_OUT_THERMO_GETCAPS extends SdkStructure
    {
        public int               dwSize;
        public int               dwModes;                           // 支持的预置模式掩码
        public int               dwColorization;                    // 预置着色模式掩码
        public int               dwROIModes;                        // 预置感兴趣区域模式掩码
        public RANGE             stBrightness;         				// 亮度相关能力
        public RANGE             stSharpness;          				// 锐度相关能力
        public RANGE             stEZoom;              				// 倍数相关能力
        public RANGE             stThermographyGamma;  				// 伽马相关能力
        public RANGE             stSmartOptimizer;     				// 优化参数相关能力
        public NET_FFCPERIOD_RANGE stFFCPeriod;                        // 平场聚焦校准相关能力
        public NET_OUT_THERMO_GETCAPS() {
            this.dwSize = this.size();
        }
    }

    // range
    public static class RANGE extends SdkStructure
    {
        public float               fMax;                               // 最大值
        public float               fMin;                               // 最小值
        public boolean                 abStep;                             // 是否启用步长
        public float               fStep;                              // 步长
        public boolean                 abDefault;                          // 是否启用默认值
        public float               fDefault;                           // 默认值
        public byte[] 			   reserved = new byte[16];
    }

    // CLIENT_GetDevCaps 接口 NET_RADIOMETRY_CAPS 命令入参
    public static class NET_IN_RADIOMETRY_GETCAPS extends SdkStructure
    {
        public int               dwSize;
        public int               nChannel;                           // 通道号

        public NET_IN_RADIOMETRY_GETCAPS() {
            this.dwSize = this.size();
        }
    }

    // 测温模式的类型
    public static class NET_RADIOMETRY_METERTYPE extends SdkStructure
    {
        public static final int NET_RADIOMETRY_METERTYPE_UNKNOWN = 0;
        public static final int NET_RADIOMETRY_METERTYPE_SPOT = 1; // 点
        public static final int NET_RADIOMETRY_METERTYPE_LINE = 2; // 线
        public static final int NET_RADIOMETRY_METERTYPE_AREA = 3; // 区域
    }

    // 点,线,区域总个数能力
    public static class NET_RADIOMETRY_TOTALNUM extends SdkStructure
    {
        public int               dwMaxNum;                           // 最多支持个数
        public int               dwMaxSpots;                         // 最多点的个数
        public int               dwMaxLines;                         // 最多划线的条数
        public int               dwMaxAreas;                         // 最多区域的个数
        public byte[]			 reserved = new byte[32]; 			 // 保留字节
    }

    // CLIENT_GetDevCaps 接口 NET_RADIOMETRY_CAPS 命令出参
    public static class NET_OUT_RADIOMETRY_GETCAPS extends SdkStructure
    {
        public int                         dwSize;
        public NET_RADIOMETRY_TOTALNUM     stTotalNum;                 // 点,线,区域总个数能力
        public int                         dwMaxPresets;               // 最多测温预置点的个数
        public int                         dwMeterType;                // 测温模式的类型掩码,见NET_RADIOMETRY_METERTYPE
        public RANGE                       stObjectEmissivity;         // 辐射系数相关能力
        public RANGE                       stObjectDistance;           // 距离相关能力
        public RANGE                       stReflectedTemperature;     // 反射温度相关能力
        public RANGE                       stRelativeHumidity;         // 相对湿度相关能力
        public RANGE                       stAtmosphericTemperature;   // 大气温度相关能力
        public int                         nStatisticsMinPeriod;       // 测温点统计功能最小存储数据间隔  单位为秒
        public float                       fIsothermMaxTemp;           // 色标条最高温度值
        public float                       fIsothermMinTemp;           // 色标条最低温度值

        public NET_OUT_RADIOMETRY_GETCAPS() {
            this.dwSize = this.size();
        }
    }

    // 测温信息
    public static class NET_RADIOMETRYINFO extends SdkStructure
    {
        public int                 nMeterType;                         // 返回测温类型,见NET_RADIOMETRY_METERTYPE
        public int                 nTemperUnit;                        // 温度单位(当前配置的温度单位),见 NET_TEMPERATURE_UNIT
        public float               fTemperAver;                        // 点的温度或者平均温度   点的时候 只返回此字段
        public float               fTemperMax;                         // 最高温度
        public float               fTemperMin;                         // 最低温度
        public float               fTemperMid;                         // 中间温度值
        public float               fTemperStd;                         // 标准方差值
        public byte[]              reserved = new byte[64];
    }

    // 获取测温项温度的条件
    public static class NET_RADIOMETRY_CONDITION extends SdkStructure
    {
        public int                 nPresetId;                          // 预置点编号
        public int                 nRuleId;                            // 规则编号
        public int                 nMeterType;                         // 测温项类别,见NET_RADIOMETRY_METERTYPE
        public byte[]              szName = new byte[64];              // 测温项的名称,从测温配置规则名字中选取
        public int                 nChannel;                           // 通道号
        public byte[]              reserved = new byte[256];
    }

    // CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER 命令入参
    public static class NET_IN_RADIOMETRY_GETPOINTTEMPER extends SdkStructure
    {
        public int               dwSize;
        public int               nChannel;                           // 通道号
        public NET_POINT         stCoordinate;                       // 测温点的坐标,坐标值 0~8192

        public NET_IN_RADIOMETRY_GETPOINTTEMPER() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER 命令出参
    public static class NET_OUT_RADIOMETRY_GETPOINTTEMPER extends SdkStructure
    {
        public int               	dwSize;
        public NET_RADIOMETRYINFO   stPointTempInfo;                    // 获取测温点的参数值

        public NET_OUT_RADIOMETRY_GETPOINTTEMPER() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_RADIOMETRY_TEMPER 命令入参
    public static class NET_IN_RADIOMETRY_GETTEMPER extends SdkStructure
    {
        public int                         dwSize;
        public NET_RADIOMETRY_CONDITION    stCondition;                // 获取测温项温度的条件

        public NET_IN_RADIOMETRY_GETTEMPER() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_QueryDevInfo 接口 NET_QUERY_DEV_RADIOMETRY_TEMPER 命令出参
    public static class NET_OUT_RADIOMETRY_GETTEMPER extends SdkStructure
    {
        public int               	dwSize;
        public NET_RADIOMETRYINFO   stTempInfo;                         // 获取测温参数值

        public NET_OUT_RADIOMETRY_GETTEMPER() {
            this.dwSize = this.size();
        }
    }

    // 云台预置点
    public static class NET_PTZ_PRESET extends SdkStructure
    {
        public int                     nIndex;                         			  // 编号
        public byte[]                  szName = new byte[PTZ_PRESET_NAME_LEN];    // 名称
        public byte[]                  szReserve = new byte[64];                  // 预留64字节
    }

    // 云台预置点列表
    public static class NET_PTZ_PRESET_LIST extends SdkStructure
    {
        public int                   dwSize;
        public int                   dwMaxPresetNum;                 // 预置点最大个数
        public int                   dwRetPresetNum;                 // 返回预置点个数
        public Pointer          	 pstuPtzPorsetList;              // 预置点列表(入参需要根据最大个数申请内存),内存大小为sizeof(NET_PTZ_PRESET)*dwMaxPresetNum

        public NET_PTZ_PRESET_LIST() {
            this.dwSize = this.size();
        }
    }

    //-------------------------------报警属性---------------------------------
    // 云台联动
    public static class SDK_PTZ_LINK extends SdkStructure
    {
        public int iType;//0-None,1-Preset,2-Tour,3-Pattern
        public int iValue;
    }

    ////////////////////////////////HDVR专用//////////////////////////////////
    // 报警联动扩展结构体
    public static class NET_MSG_HANDLE_EX extends SdkStructure
    {
        /* 消息处理方式,可以同时多种处理方式,包括
         * 0x00000001 - 报警上传
         * 0x00000002 - 联动录象
         * 0x00000004 - 云台联动
         * 0x00000008 - 发送邮件
         * 0x00000010 - 本地轮巡
         * 0x00000020 - 本地提示
         * 0x00000040 - 报警输出
         * 0x00000080 - Ftp上传
         * 0x00000100 - 蜂鸣
         * 0x00000200 - 语音提示
         * 0x00000400 - 抓图
         */
        /*当前报警所支持的处理方式,按位掩码表示*/
        public int dwActionMask;
        /*触发动作,按位掩码表示,具体动作所需要的参数在各自的配置中体现*/
        public int dwActionFlag;
        /*报警触发的输出通道,报警触发的输出,为1表示触发该输出*/
        public byte[] byRelAlarmOut = new byte[NET_MAX_ALARMOUT_NUM_EX];
        public int dwDuration;/*报警持续时间*/
        /*联动录象*/
        public byte[] byRecordChannel = new byte[NET_MAX_VIDEO_IN_NUM_EX];/*报警触发的录象通道,为1表示触发该通道*/
        public int dwRecLatch;/*录象持续时间*/
        /*抓图通道*/
        public byte[] bySnap = new byte[NET_MAX_VIDEO_IN_NUM_EX];
        /*轮巡通道*/
        public byte[] byTour = new byte[NET_MAX_VIDEO_IN_NUM_EX];/*轮巡通道0-31路*/
        /*云台联动*/
        public SDK_PTZ_LINK[] struPtzLink = (SDK_PTZ_LINK[])new SDK_PTZ_LINK().toArray(NET_MAX_VIDEO_IN_NUM_EX);
        public int dwEventLatch;/*联动开始延时时间,s为单位,范围是0~15,默认值是0*/
        /*报警触发的无线输出通道,报警触发的输出,为1表示触发该输出*/
        public byte[] byRelWIAlarmOut = new byte[NET_MAX_ALARMOUT_NUM_EX];
        public byte bMessageToNet;
        public byte bMMSEn;/*短信报警使能*/
        public byte bySnapshotTimes;/*短信发送抓图张数*/
        public byte bMatrixEn;/*!<矩阵使能*/
        public int dwMatrix;/*!<矩阵掩码*/
        public byte bLog;/*!<日志使能,目前只有在WTN动态检测中使用*/
        public byte bSnapshotPeriod;/*!<抓图帧间隔,每隔多少帧抓一张图片,一定时间内抓拍的张数还与抓图帧率有关。0表示不隔帧,连续抓拍。*/
        public byte[] byTour2 = new byte[NET_MAX_VIDEO_IN_NUM_EX];/*轮巡通道32-63路*/
        public byte byEmailType;/*<0,图片附件,1,录像附件>*/
        public byte byEmailMaxLength;/*<附件录像时的最大长度,单位MB>*/
        public byte byEmailMaxTime;/*<附件是录像时最大时间长度,单位秒>*/
        public byte[] byReserved = new byte[475];
    }

    public static class EM_NET_DEFENCE_AREA_TYPE extends SdkStructure
    {
        public static final int EM_NET_DEFENCE_AREA_TYPE_UNKNOW = 0; //未知
        public static final int EM_NET_DEFENCE_AREA_TYPE_INTIME = 1; //即时防区
        public static final int EM_NET_DEFENCE_AREA_TYPE_DELAY = 2; //延时防区
        public static final int EM_NET_DEFENCE_AREA_TYPE_FULLDAY = 3; //24小时防区
        public static final int EM_NET_DEFENCE_AREA_TYPE_Follow = 4; //跟随防区
        public static final int EM_NET_DEFENCE_AREA_TYPE_MEDICAL = 5; //医疗紧急防区
        public static final int EM_NET_DEFENCE_AREA_TYPE_PANIC = 6; //恐慌防区
        public static final int EM_NET_DEFENCE_AREA_TYPE_FIRE = 7; //火警防区
        public static final int EM_NET_DEFENCE_AREA_TYPE_FULLDAYSOUND = 8; //24小时有声防区
        public static final int EM_NET_DEFENCE_AREA_TYPE_FULLDATSLIENT = 9; //24小时无声防区
        public static final int EM_NET_DEFENCE_AREA_TYPE_ENTRANCE1 = 10; //出入防区1
        public static final int EM_NET_DEFENCE_AREA_TYPE_ENTRANCE2 = 11; //出入防区2
        public static final int EM_NET_DEFENCE_AREA_TYPE_INSIDE = 12; //内部防区
        public static final int EM_NET_DEFENCE_AREA_TYPE_OUTSIDE = 13; //外部防区
        public static final int EN_NET_DEFENCE_AREA_TYPE_PEOPLEDETECT = 14; //人员检测防区
    }

    // 本地报警事件(对NET_ALARM_ALARM_EX升级)
    public static class ALARM_ALARM_INFO_EX2 extends SdkStructure
    {
        public int dwSize;
        public int nChannelID;						//通道号
        public int nAction;							//0:开始, 1:停止
        public NET_TIME stuTime;					//报警事件发生的时间
        public int emSenseType;						//传感器类型, 取值范围为  NET_SENSE_METHOD 中的值
        public NET_MSG_HANDLE_EX stuEventHandler;	//联动信息
        public int emDefenceAreaType;				//防区类型, 取值类型为EM_NET_DEFENCE_AREA_TYPE中的值
        public int nEventID;					    //事件ID
        public byte[]     szName = new byte[NET_COMMON_STRING_32];  // 通道名称
        public int nCount;                 			// 事件发生次数
        public NET_GPS_STATUS_INFO            stuGPS;                               // GPS信息
        public byte[]                         byReserved = new byte[1024];          // 保留字节

        public ALARM_ALARM_INFO_EX2() {
            this.dwSize = this.size();
        }
    }

    // 布撤防状态变化事件的信息
    public static class ALARM_ARMMODE_CHANGE_INFO extends SdkStructure
    {
        public int                 dwSize;
        public NET_TIME            stuTime;        // 报警事件发生的时间
        public int                 bArm;           // 变化后的状态,对应  NET_ALARM_MODE
        public int 			       emSceneMode;    // 情景模式，对应  NET_SCENE_MODE
        public int                 dwID;           // ID号, 遥控器编号或键盘地址, emTriggerMode为NET_EM_TRIGGER_MODE_NET类型时为0
        public int       		   emTriggerMode;  // 触发方式,对应  NET_EM_TRIGGER_MODE
        public byte[] 			   szNetClientAddr = new byte[64]; //网络用户IP地址或网络地址
        public int            	   nUserCode;      //用户ID，0:管理员，1~20：普通用户，21：安装员，22：挟持用户

        public ALARM_ARMMODE_CHANGE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 布撤防模式
    public static class NET_ALARM_MODE extends SdkStructure
    {
        public static final int NET_ALARM_MODE_UNKNOWN    = -1;          // 未知
        public static final int NET_ALARM_MODE_DISARMING  = 0;           // 撤防
        public static final int NET_ALARM_MODE_ARMING	  = 1;           // 布防
        public static final int NET_ALARM_MODE_FORCEON	  = 2;           // 强制布防
        public static final int NET_ALARM_MODE_PARTARMING = 3;           // 部分布防
    }

    // 布撤防场景模式
    public static class NET_SCENE_MODE extends SdkStructure
    {
        public static final int NET_SCENE_MODE_UNKNOWN   = 0;            // 未知场景
        public static final int NET_SCENE_MODE_OUTDOOR   = 1;            // 外出模式
        public static final int NET_SCENE_MODE_INDOOR    = 2;            // 室内模式
        public static final int NET_SCENE_MODE_WHOLE     = 3;            // 全局模式
        public static final int NET_SCENE_MODE_RIGHTNOW  = 4;            // 立即模式
        public static final int NET_SCENE_MODE_SLEEPING  = 5;            // 就寝模式
        public static final int NET_SCENE_MODE_CUSTOM    = 6;            // 自定义模式
    }

    // 触发方式
    public static class NET_EM_TRIGGER_MODE extends SdkStructure
    {
        public static final int NET_EM_TRIGGER_MODE_UNKNOWN 		= 0;
        public static final int NET_EM_TRIGGER_MODE_NET			    = 1;   // 网络用户(平台或Web)
        public static final int NET_EM_TRIGGER_MODE_KEYBOARD		= 2;   // 键盘
        public static final int NET_EM_TRIGGER_MODE_REMOTECONTROL	= 3;   // 遥控器
    }

    // 紧急救助事件详情
    public static class ALARM_RCEMERGENCY_CALL_INFO extends SdkStructure
    {
        public int                       dwSize;
        public int                       nAction;                // -1:未知 0:开始 1:停止
        public int                  	 emType;                 // 紧急类型,对应 EM_RCEMERGENCY_CALL_TYPE
        public NET_TIME                  stuTime;                // 事件发生时间
        public int   					 emMode;                 // 报警方式，对应 EM_RCEMERGENCY_MODE_TYPE
        public int                       dwID;                   // 用于标示不同的紧急事件(只有emMode是遥控器类型时有效, 表示遥控器的编号, 0表示无效ID)

        public ALARM_RCEMERGENCY_CALL_INFO() {
            this.dwSize = this.size();
        }
    }

    // 紧急救助事件类型
    public static class EM_RCEMERGENCY_CALL_TYPE extends SdkStructure
    {
        public static final int EM_RCEMERGENCY_CALL_UNKNOWN   = 0;
        public static final int EM_RCEMERGENCY_CALL_FIRE	  = 1;             // 火警
        public static final int EM_RCEMERGENCY_CALL_DURESS	  = 2;             // 胁迫
        public static final int EM_RCEMERGENCY_CALL_ROBBER	  = 3;             // 匪警
        public static final int EM_RCEMERGENCY_CALL_MEDICAL	  = 4;             // 医疗
        public static final int EM_RCEMERGENCY_CALL_EMERGENCY = 5;             // 紧急
    }

    // 报警方式
    public static class EM_RCEMERGENCY_MODE_TYPE extends SdkStructure
    {
        public static final int EM_RCEMERGENCY_MODE_UNKNOWN          = 0;
        public static final int EM_RCEMERGENCY_MODE_KEYBOARD		 = 1;       // 键盘
        public static final int EM_RCEMERGENCY_MODE_WIRELESS_CONTROL = 2;       // 遥控器
    }

    /////////////////////////////////////////////////////
    ////////用户信息管理对应接口CLIENT_QueryUserInfoNew/////////
    // 用户信息表
    public static class USER_MANAGE_INFO_NEW extends SdkStructure {
        public int 						dwSize; 																// 结构体大小
        public int 						dwRightNum;  															// 权限信息有效个数
        public OPR_RIGHT_NEW[] 			rightList = new OPR_RIGHT_NEW[NET_NEW_MAX_RIGHT_NUM]; 		 			// 权限信息，有效个数由 dwRightNum 成员决定, 用户权限个数上限NET_NEW_MAX_RIGHT_NUM = 1024
        public int 						dwGroupNum; 															// 用户组信息有效个数
        public USER_GROUP_INFO_NEW[] 	groupList = new USER_GROUP_INFO_NEW[NET_MAX_GROUP_NUM]; 				// 用户组信息，此参数废弃，请使用groupListEx
        public int 						dwUserNum;  															// 用户数
        public USER_INFO_NEW[] 			userList = new USER_INFO_NEW[NET_MAX_USER_NUM]; 				 		// 用户列表， 用户个数上限NET_MAX_USER_NUM=200
        public int 						dwFouctionMask; 														// 掩码： 0x00000001 - 支持用户复用， 0x00000002 - 密码修改需要校验
        public byte 					byNameMaxLength;  														// 支持的用户名最大长度
        public byte 					byPSWMaxLength; 														// 支持的密码最大长度
        public byte[] 					byReserve = new byte[254];
        public USER_GROUP_INFO_EX2[]    groupListEx = new USER_GROUP_INFO_EX2[NET_MAX_GROUP_NUM]; 				// 用户组信息扩展, 用户组个数上限NET_MAX_GROUP_NUM=20

        public USER_MANAGE_INFO_NEW() {
            this.dwSize = this.size();

            for(int i = 0; i < NET_NEW_MAX_RIGHT_NUM; i++) {
                rightList[i] = new OPR_RIGHT_NEW();
            }

            for(int i = 0; i < NET_MAX_USER_NUM; i++) {
                userList[i] = new USER_INFO_NEW();
            }

            for(int i = 0; i < NET_MAX_GROUP_NUM; i++) {
                groupList[i] = new USER_GROUP_INFO_NEW();
                groupListEx[i] = new USER_GROUP_INFO_EX2();
            }
        }
    }

    // 权限信息
    public static class OPR_RIGHT_NEW extends SdkStructure {
        public int 						dwSize;										  //结构体大小
        public int 						dwID; 										  //权限ID，每个 权限都有各自的ID
        public byte[] 					name = new byte[NET_RIGHT_NAME_LENGTH]; 	  //名称 权限名长度 NET_RIGHT_NAME_LENGTH=32
        public byte[] 					memo = new byte[NET_MEMO_LENGTH];			  //说明备注长度NET_MEMO_LENGTH=32

        public OPR_RIGHT_NEW() {
            this.dwSize = this.size();
        }
    }

    // 用户组信息
    public static class USER_GROUP_INFO_NEW extends SdkStructure {
        public int 						dwSize;
        public int 						dwID; 											// 用户组ID， 每个用户组都有各自的ID
        public byte[] 					name = new byte[NET_USER_NAME_LENGTH_EX]; 		// 用户组名称/NET_USER_NAME_LENGTH_EX=16
        public int 						dwRightNum; 									// 用户组权限有效个数
        public int[] 					rights = new int[NET_NEW_MAX_RIGHT_NUM];		// 用户组支持权限数组
        public byte[] 					memo = new byte[NET_MEMO_LENGTH]; 				// 用户组备注说明
        public USER_GROUP_INFO_NEW() {
            this.dwSize = this.size();
        }
    }

    // 用户组信息扩展，用户组名加长
    public static class USER_GROUP_INFO_EX2 extends SdkStructure {
        public int 						 dwSize; 										// 结构体大小
        public int 						 dwID; 											// ID
        public byte[] 					 name = new byte[NET_NEW_USER_NAME_LENGTH];     // 用户名 长度NET_NEW_USER_NAME_LENGTH=128
        public int 						 dwRightNum;  									// 权限数量
        public int[] 					 rights = new int[NET_NEW_MAX_RIGHT_NUM]; 		// 用户权限 个数上限 NET_NEW_MAX_RIGHT_NUM = 1024
        public byte[]					 memo = new byte[NET_MEMO_LENGTH]; 				// 说明， 备注长度NET_MEMO_LENGTH=32

        public USER_GROUP_INFO_EX2() {
            this.dwSize = this.size();
        }
    }

    // 用户信息结构体
    public static class USER_INFO_NEW extends SdkStructure {
        public int 						dwSize; 									   // 结构体大小
        public int 						dwID; 										   // 用户ID
        public int 						dwGroupID; 									   // 用户组组ID
        public byte[] 					name = new byte[NET_NEW_USER_NAME_LENGTH];     // 用户名称，长度NET_NEW_USER_NAME_LENGTH=128
        public byte[] 					passWord = new byte[NET_NEW_USER_PSW_LENGTH];  // 用户密码，NET_NEW_USER_PSW_LENGTH=128
        public int 						dwRightNum;  								   // 用户权限有效个数
        public int[] 					rights = new int[NET_NEW_MAX_RIGHT_NUM];       // 用户支持权限数组，个数上限 NET_NEW_MAX_RIGHT_NUM = 1024
        public byte[] 					memo = new byte[NET_MEMO_LENGTH]; 			   // 用户备注说明， 备注长度NET_MEMO_LENGTH=32
        public int 						dwFouctionMask;          					   // 掩码,0x00000001 - 支持用户复用
        public NET_TIME 				stuTime;           							   // 最后修改时间
        public byte 					byIsAnonymous;         					       // 是否可以匿名登录, 0:不可匿名登录, 1: 可以匿名登录
        public byte[] 					byReserve = new byte[7];  					   // 保留字节

        public USER_INFO_NEW() {
            this.dwSize = this.size();
        }
    }


    //------------------------白名单相关结构体-------------------------
    // CLIENT_FindRecord接口输入参数
    public static class NET_IN_FIND_RECORD_PARAM extends SdkStructure {
        public int                       dwSize;          							 // 结构体大小
        public int                       emType;          							 // 待查询记录类型,emType对应  EM_NET_RECORD_TYPE
        public Pointer                   pQueryCondition;							 // 查询类型对应的查询条件

        public NET_IN_FIND_RECORD_PARAM() {
            this.dwSize = this.size();
        }
    }

    // 交通黑白名单账户记录查询条件
    public static class FIND_RECORD_TRAFFICREDLIST_CONDITION extends SdkStructure {
        public int          dwSize;
        public byte[]       szPlateNumber = new byte[NET_MAX_PLATE_NUMBER_LEN];      // 车牌号
        public byte[]       szPlateNumberVague = new byte[NET_MAX_PLATE_NUMBER_LEN]; // 车牌号码模糊查询
        public int          nQueryResultBegin;                          			 // 第一个条返回结果在查询结果中的偏移量
        public boolean      bRapidQuery;       										 // 是否快速查询, TRUE:为快速,快速查询时不等待所有增、删、改操作完成。默认为非快速查询

        public FIND_RECORD_TRAFFICREDLIST_CONDITION() {
            this.dwSize = this.size();
        }
    }

    // 交通流量记录查询条件
    public static class FIND_RECORD_TRAFFICFLOW_CONDITION extends SdkStructure {
        public int                     dwSize;
        public int                     abChannelId;                      // 通道号查询条件是否有效
        public int                     nChannelId;                       // 通道号
        public int                     abLane;                           // 车道号查询条件是否有效
        public int                     nLane;                            // 车道号
        public int                     bStartTime;                       // 开始时间查询条件是否有效
        public NET_TIME                stStartTime;                      // 开始时间
        public int					   bEndTime;                         // 结束时间查询条件是否有效
        public NET_TIME                stEndTime;                        // 结束时间
        public int                     bStatisticsTime;                  // 查询是否为统计时间,为BOOL类型，bStartTime及bEndTime均为1
        public FIND_RECORD_TRAFFICFLOW_CONDITION() {
            this.dwSize = this.size();
        }
    }

    // 门禁出入记录查询条件
    public static class FIND_RECORD_ACCESSCTLCARDREC_CONDITION_EX extends SdkStructure {
        public int                     dwSize;
        public int                     bCardNoEnable;                    					// 启用卡号查询, 为BOOL类型
        public byte[]                  szCardNo = new byte[NET_MAX_CARDNO_LEN];     		// 卡号
        public int                     bTimeEnable;                      					// 启用时间段查询, 为BOOL类型
        public NET_TIME                stStartTime;                      					// 起始时间
        public NET_TIME                stEndTime;                        					// 结束时间
        public int					   nOrderNum;						 					// 规则数
        public FIND_RECORD_ACCESSCTLCARDREC_ORDER[]   stuOrders =
                (FIND_RECORD_ACCESSCTLCARDREC_ORDER[])new FIND_RECORD_ACCESSCTLCARDREC_ORDER().toArray(MAX_ORDER_NUMBER);	// 规则数组

        public FIND_RECORD_ACCESSCTLCARDREC_CONDITION_EX() {
            this.dwSize = this.size();
        }
    }

    // 门禁出入记录排序规则详情
    public static class FIND_RECORD_ACCESSCTLCARDREC_ORDER extends SdkStructure
    {
        public int					emField;												// 排序字段, 对应枚举 EM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD
        public int					emOrderType;    										// 排序类型, 对应枚举 EM_RECORD_ORDER_TYPE
        public byte[]				byReverse = new byte[64];  								// 保留字节
    }

    // 门禁出入记录排序字段
    public static class EM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD extends SdkStructure
    {
        public static final int EM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD_UNKNOWN = 0;			// 未知
        public static final int EM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD_RECNO = 1;			// 记录集编号
        public static final int EM_RECORD_ACCESSCTLCARDREC_ORDER_FIELD_CREATETIME = 2;		// 创建时间
    }

    // 排序类型
    public static class EM_RECORD_ORDER_TYPE extends SdkStructure
    {
        public static final int EM_RECORD_ORDER_TYPE_UNKNOWN = 0;                           // 未知
        public static final int EM_RECORD_ORDER_TYPE_ASCENT = 1;                            // 升序
        public static final int EM_RECORD_ORDER_TYPE_DESCENT = 2;                           // 降序
    }

    // 开门方式(门禁事件,门禁出入记录,实际的开门方式)
    public static class NET_ACCESS_DOOROPEN_METHOD extends SdkStructure {
        public static final int NET_ACCESS_DOOROPEN_METHOD_UNKNOWN = 0;
        public static final int NET_ACCESS_DOOROPEN_METHOD_PWD_ONLY = 1;                    				// 密码开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_CARD = 2;                        				// 刷卡开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_CARD_FIRST = 3;                  				// 先刷卡后密码开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_PWD_FIRST = 4;                   				// 先密码后刷卡开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_REMOTE = 5;                      				// 远程开锁,如通过室内机或者平台对门口机开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_BUTTON = 6;                      				// 开锁按钮进行开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT = 7;                 				// 指纹开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_PWD_CARD_FINGERPRINT = 8;        				// 密码+刷卡+指纹组合开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_PWD_FINGERPRINT = 10;	        				// 密码+指纹组合开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_CARD_FINGERPRINT = 11;	       					// 刷卡+指纹组合开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_PERSONS = 12;                					// 多人开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_KEY = 13;                    					// 钥匙开门
        public static final int NET_ACCESS_DOOROPEN_METHOD_COERCE_PWD = 14;             					// 胁迫密码开门
        public static final int NET_ACCESS_DOOROPEN_METHOD_QRCODE = 15;                     				// 二维码开门
        public static final int NET_ACCESS_DOOROPEN_METHOD_FACE_RECOGNITION = 16;       					// 人脸识别开门
        public static final int NET_ACCESS_DOOROPEN_METHOD_FACEIDCARD = 18;                				    // 人证对比
        public static final int NET_ACCESS_DOOROPEN_METHOD_FACEIDCARD_AND_IDCARD = 19;	    				// 身份证+ 人证比对
        public static final int NET_ACCESS_DOOROPEN_METHOD_BLUETOOTH = 20;									// 蓝牙开门
        public static final int NET_ACCESS_DOOROPEN_METHOD_CUSTOM_PASSWORD = 21;        					// 个性化密码开门
        public static final int  NET_ACCESS_DOOROPEN_METHOD_USERID_AND_PWD = 22;         					// UserID+密码
        public static final int NET_ACCESS_DOOROPEN_METHOD_FACE_AND_PWD = 23;           					// 人脸+密码开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_AND_PWD = 24;    					// 指纹+密码开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_AND_FACE = 25;   					// 指纹+人脸开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_CARD_AND_FACE = 26;          					// 刷卡+人脸开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_FACE_OR_PWD = 27;            					// 人脸或密码开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_OR_PWD = 28;     					// 指纹或密码开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_OR_FACE = 29;    					// 指纹或人脸开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_CARD_OR_FACE = 30;           					// 刷卡或人脸开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_CARD_OR_FINGERPRINT = 31;    					// 刷卡或指纹开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_AND_FACE_AND_PWD = 32;             	// 指纹+人脸+密码开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_CARD_AND_FACE_AND_PWD = 33;                      // 刷卡+人脸+密码开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_CARD_AND_FINGERPRINT_AND_PWD = 34;               // 刷卡+指纹+密码开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_CARD_AND_PWD_AND_FACE = 35;                      // 卡+指纹+人脸组合开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_FINGERPRINT_OR_FACE_OR_PWD = 36;                 // 指纹或人脸或密码
        public static final int NET_ACCESS_DOOROPEN_METHOD_CARD_OR_FACE_OR_PWD = 37;                        // 卡或人脸或密码开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_CARD_OR_FINGERPRINT_OR_FACE = 38;                // 卡或指纹或人脸开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_CARD_AND_FINGERPRINT_AND_FACE_AND_PWD = 39;      // 卡+指纹+人脸+密码组合开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_CARD_OR_FINGERPRINT_OR_FACE_OR_PWD     = 40;     // 卡或指纹或人脸或密码开锁
        public static final int NET_ACCESS_DOOROPEN_METHOD_FACEIPCARDANDIDCARD_OR_CARD_OR_FACE    = 41;     // (身份证+人证比对)或 刷卡 或 人脸
        public static final int NET_ACCESS_DOOROPEN_METHOD_FACEIDCARD_OR_CARD_OR_FACE = 42;                 // 人证比对 或 刷卡(二维码) 或 人脸
        public static final int NET_ACCESS_DOOROPEN_METHOD_DTMF      = 43;  								// DTMF开锁(包括SIPINFO,RFC2833,INBAND)
        public static final int NET_ACCESS_DOOROPEN_METHOD_REMOTE_QRCODE = 44;  							// 远程二维码开门
        public static final int NET_ACCESS_DOOROPEN_METHOD_REMOTE_FACE = 45;  								// 远程人脸开门
        public static final int NET_ACCESS_DOOROPEN_METHOD_CITIZEN_FINGERPRINT = 46;  						// 人证比对开门(指纹)
    }

    // 卡类型
    public static class NET_ACCESSCTLCARD_TYPE {
        public static final int NET_ACCESSCTLCARD_TYPE_UNKNOWN = -1;
        public static final int NET_ACCESSCTLCARD_TYPE_GENERAL = 0;                     // 一般卡
        public static final int NET_ACCESSCTLCARD_TYPE_VIP     = 1;                     // VIP卡
        public static final int NET_ACCESSCTLCARD_TYPE_GUEST   = 2;                     // 来宾卡
        public static final int NET_ACCESSCTLCARD_TYPE_PATROL  = 3;                     // 巡逻卡
        public static final int NET_ACCESSCTLCARD_TYPE_BLACKLIST = 4;                   // 黑名单卡
        public static final int NET_ACCESSCTLCARD_TYPE_CORCE	= 5;                    // 胁迫卡
        public static final int NET_ACCESSCTLCARD_TYPE_POLLING  = 6;                    // 巡检卡
        public static final int NET_ACCESSCTLCARD_TYPE_MOTHERCARD = 0xff;           	// 母卡
    }

    // 门禁刷卡记录记录集信息
    public static class NET_RECORDSET_ACCESS_CTL_CARDREC extends SdkStructure {
        public int           		dwSize;
        public int             		nRecNo;                                 // 记录集编号,只读
        public byte[]            	szCardNo = new byte[NET_MAX_CARDNO_LEN];// 卡号
        public byte[]            	szPwd = new byte[NET_MAX_CARDPWD_LEN];  // 密码
        public NET_TIME        		stuTime;                                // 刷卡时间
        public int            		bStatus;                                // 刷卡结果,TRUE表示成功,FALSE表示失败
        public int    				emMethod;                 				// 开门方式 NET_ACCESS_DOOROPEN_METHOD
        public int             		nDoor;                                  // 门号,即CFG_CMD_ACCESS_EVENT配置CFG_ACCESS_EVENT_INFO的数组下标
        public byte[]            	szUserID = new byte[NET_MAX_USERID_LEN];// 用户ID
        public int             		nReaderID;                              // 读卡器ID (废弃,不再使用)
        public byte[]				szSnapFtpUrl = new byte[MAX_PATH];		// 开锁抓拍上传的FTP地址

        public byte[]            	szReaderID = new byte[NET_COMMON_STRING_32];// 读卡器ID													// 开门并上传抓拍照片,在记录集记录存储地址,成功才有
        public int       			emCardType;                 			// 卡类型 NET_ACCESSCTLCARD_TYPE

        public int                  nErrorCode;                 			// 开门失败的原因,仅在bStatus为FALSE时有效
        // 0x00 没有错误
        // 0x10 未授权
        // 0x11 卡挂失或注销
        // 0x12 没有该门权限
        // 0x13 开门模式错误
        // 0x14 有效期错误
        // 0x15 防反潜模式
        // 0x16 胁迫报警未打开
        // 0x17 门常闭状态
        // 0x18 AB互锁状态
        // 0x19 巡逻卡
        // 0x1A 设备处于闯入报警状态
        // 0x20 时间段错误
        // 0x21 假期内开门时间段错误
        // 0x30 需要先验证有首卡权限的卡片
        // 0x40 卡片正确,输入密码错误
        // 0x41 卡片正确,输入密码超时
        // 0x42 卡片正确,输入指纹错误
        // 0x43 卡片正确,输入指纹超时
        // 0x44 指纹正确,输入密码错误
        // 0x45 指纹正确,输入密码超时
        // 0x50 组合开门顺序错误
        // 0x51 组合开门需要继续验证
        // 0x60 验证通过,控制台未授权
        // 0x61 卡片正确,人脸错误
        // 0x62 卡片正确,人脸超时
        // 0x63 重复进入
        // 0x64 未授权,需要后端平台识别
        // 0x65 体温过高
        // 0x66	未戴口罩
        // 0x67 健康码获取失败
        // 0x68 黄码禁止通行
        // 0x69 红码禁止通行
        // 0x6a 健康码无效
        // 0x6b 绿码验证通过
        // 0x70 获取健康码信息
        public byte[]           	szRecordURL = new byte[NET_COMMON_STRING_128];	// 刷卡录像的地址
        public int            		nNumbers;                   					// 抓图的张数
        public int  				emAttendanceState;          					// 考勤状态 ,参考  NET_ATTENDANCESTATE
        public int   				emDirection;               				 		// 开门方向, 参考  NET_ENUM_DIRECTION_ACCESS_CTL
        public byte[]				szClassNumber = new byte[MAX_CLASS_NUMBER_LEN];	// 班级（考勤肯尼亚定制）
        public byte[]				szPhoneNumber = new byte[MAX_PHONENUMBER_LEN];	// 电话（考勤肯尼亚定制）
        public byte[]				szCardName = new byte[NET_MAX_CARDNAME_LEN];	// 卡命名
        public byte[]               szSN = new byte[NET_COMMON_STRING_32];          // 智能锁序列号,无线配件需要该字段
        public int					bCitizenIDResult;								// 人证比对结果
        public byte[]				szCitizenIDName = new byte[30];					// 名字
        public byte[]				byReserved1 = new byte[2];						// 字节对齐
        public int					emCitizenIDSex;									// 性别, 详见EM_CITIZENIDCARD_SEX_TYPE
        public int					emCitizenIDEthnicity;							// 民族, 详见EM_CITIZENIDCARD_ETHNICITY_TYPE
        public NET_TIME				stuCitizenIDBirth;								// 出生日期(时分秒无效)
        public byte[]				szCitizenIDAddress = new byte[108];				// 住址
        public byte[]				szCitizenIDAuthority = new byte[48];			// 签发机关
        public NET_TIME				stuCitizenIDStart;								// 有效起始日期(时分秒无效)
        public NET_TIME				stuCitizenIDEnd;								// 有效截止日期(时分秒无效, 年为负数时表示长期有效)
        public int					bIsEndless;										// 是否长期有效
        public byte[]				szSnapFaceURL = new byte[NET_COMMON_STRING_128];// 人脸图片保存地址
        public byte[]				szCitizenPictureURL = new byte[NET_COMMON_STRING_128];	// 身份证图片保存地址
        public byte[]				szCitizenIDNo = new byte[20];					// 身份证号码

        public int       			emSex;                                      	// 性别, 详见NET_ACCESSCTLCARD_SEX
        public byte[]               szRole = new byte[MAX_COMMON_STRING_32];        // 角色
        public byte[]               szProjectNo = new byte[MAX_COMMON_STRING_32];   // 项目ID
        public byte[]               szProjectName = new byte[MAX_COMMON_STRING_64]; // 项目名称
        public byte[]               szBuilderName = new byte[MAX_COMMON_STRING_64]; // 施工单位全称
        public byte[]               szBuilderID = new byte[MAX_COMMON_STRING_32];   // 施工单位ID
        public byte[]               szBuilderType = new byte[MAX_COMMON_STRING_32]; // 施工单位类型
        public byte[]               szBuilderTypeID = new byte[MAX_COMMON_STRING_8];// 施工单位类别ID
        public byte[]               szPictureID = new byte[MAX_COMMON_STRING_64];   // 人员照片ID
        public byte[]               szContractID = new byte[MAX_COMMON_STRING_16];  // 原合同系统合同编号
        public byte[]               szWorkerTypeID = new byte[MAX_COMMON_STRING_8]; // 工种ID
        public byte[]               szWorkerTypeName = new byte[MAX_COMMON_STRING_32];  // 工种名称
        public int                  bPersonStatus;                              	// 人员状态, TRUE:启用, FALSE:禁用
        public int				    emHatStyle;									    // 帽子类型
        public int		            emHatColor;									    // 帽子颜色
        public NET_MAN_TEMPERATURE_INFO	stuManTemperatureInfo;						// 人员温度信息
        public int					nCompanionInfo;								     // 陪同人员 stuCompanionInfo 个数
        public NET_COMPANION_INFO[]	stuCompanionInfo = new NET_COMPANION_INFO[12];	 // 陪同人员信息（定制）：姓名、卡号字段有效
        public int			        emMask;										     // 口罩状态（EM_MASK_STATE_UNKNOWN、EM_MASK_STATE_NOMASK、EM_MASK_STATE_WEAR 有效） EM_MASK_STATE_TYPE
        public int					nFaceIndex;									     // 一人多脸的人脸序号
        public int					nScore;										     // 人脸质量评分
        public int					nLiftNo;									// 电梯编号
        public byte[]               szQRCode=new byte[512];                              // 二维码
        /**
         * EM_FACE_CHECK
         */
        public int				    emFaceCheck;								// 定制功能，刷卡开门时，门禁后台校验人脸是否是同一个人
        /**
         * EM_QRCODE_IS_EXPIRED
         */
        public int		            emQRCodeIsExpired;							// 二维码是否过期。默认值0 (北美测温定制)
        /**
         * EM_QRCODE_STATE
         */
        public int				    emQRCodeState;								// 二维码状态(北美测试定制)
        public NET_TIME        		stuQRCodeValidTo;							// 二维码截止日期
        /**
         * EM_LIFT_CALLER_TYPE
         */
        public int			        emLiftCallerType;							// 梯控方式触发者
        public NET_RECORDSET_ACCESS_CTL_CARDREC() {
            this.dwSize = this.size();
            for(int i = 0; i<stuCompanionInfo.length;i++){
                stuCompanionInfo[i] = new NET_COMPANION_INFO();
            }
        }
    }



    // 性别
    public static class NET_ACCESSCTLCARD_SEX extends SdkStructure
    {
        public static final int NET_ACCESSCTLCARD_SEX_UNKNOWN = 0;		// 未知
        public static final int NET_ACCESSCTLCARD_SEX_MALE = 1;         // 男
        public static final int NET_ACCESSCTLCARD_SEX_FEMALE = 2;       // 女
    }

    // 民族
    public static class EM_CITIZENIDCARD_ETHNICITY_TYPE extends SdkStructure
    {
        public static final int EM_CITIZENIDCARD_ETHNICITY_Unknown = 0;					// 未知
        public static final int EM_CITIZENIDCARD_ETHNICITY_Han = 1;						// 汉族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Mongolian = 2;				// 蒙古族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Hui = 3;						// 回族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Tibetan = 4;					// 藏族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Uygur = 5;					// 维吾尔族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Miao = 6;					// 苗族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Yi = 7;						// 彝族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Zhuang = 8;					// 壮族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Bouyei = 9;					// 布依族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Korean = 10;					// 朝鲜族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Manchu = 11;					// 满族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Dong = 12;					// 侗族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Yao = 13;					// 瑶族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Bai = 14;					// 白族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Tujia = 15;					// 土家族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Hani = 16;					// 哈尼族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Kazak = 17;					// 哈萨克族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Dai = 18;					// 傣族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Li = 19;						// 黎族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Lisu = 20;					// 傈僳族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Va = 21;						// 佤族
        public static final int EM_CITIZENIDCARD_ETHNICITY_She = 22;					// 畲族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Gaoshan = 23;				// 高山族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Lahu = 24;					// 拉祜族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Shui = 25;					// 水族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Dongxiang = 26;				// 东乡族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Naxi = 27;					// 纳西族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Jingpo = 28;					// 景颇族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Kirgiz = 29;					// 柯尔克孜族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Tu = 30;						// 土族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Daur = 31;					// 达斡尔族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Mulam = 32;					// 仫佬族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Qoiang = 33;					// 羌族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Blang = 34;					// 布朗族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Salar = 35;					// 撒拉族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Maonan = 36;					// 毛南族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Gelo = 37;					// 仡佬族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Xibe = 38;					// 锡伯族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Achang = 39;					// 阿昌族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Pumi = 40;					// 普米族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Tajik = 41;					// 塔吉克族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Nu = 42;						// 怒族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Ozbek = 43;					// 乌孜别克族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Russian = 44;				// 俄罗斯族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Ewenkl = 45;					// 鄂温克族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Deang = 46;					// 德昂族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Bonan = 47;					// 保安族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Yugur = 48;					// 裕固族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Jing = 49;					// 京族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Tatar = 50;					// 塔塔尔族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Drung = 51;					// 独龙族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Oroqen = 52;					// 鄂伦春族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Hezhen = 53;					// 赫哲族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Moinba = 54;					// 门巴族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Lhoba = 55;					// 珞巴族
        public static final int EM_CITIZENIDCARD_ETHNICITY_Jino = 56;					// 基诺族
    }

    //考勤状态
    public static class NET_ATTENDANCESTATE extends SdkStructure {
        public static final int NET_ATTENDANCESTATE_UNKNOWN = 0;
        public static final int NET_ATTENDANCESTATE_SIGNIN	= 1;                   // 签入
        public static final int NET_ATTENDANCESTATE_GOOUT   = 2;                   // 外出
        public static final int NET_ATTENDANCESTATE_GOOUT_AND_RETRUN = 3;          // 外出归来
        public static final int NET_ATTENDANCESTATE_SIGNOUT = 4;                   // 签出
        public static final int NET_ATTENDANCESTATE_WORK_OVERTIME_SIGNIN = 5;      // 加班签到
        public static final int NET_ATTENDANCESTATE_WORK_OVERTIME_SIGNOUT = 6;     // 加班签出
    }

    // 开门方向
    public static class NET_ENUM_DIRECTION_ACCESS_CTL extends SdkStructure {
        public static final int NET_ENUM_DIRECTION_UNKNOWN = 0;
        public static final int NET_ENUM_DIRECTION_ENTRY   = 1;                     // 进门
        public static final int NET_ENUM_DIRECTION_EXIT    = 2;                     // 出门
    }

    // 记录集类型
    public static class EM_NET_RECORD_TYPE extends SdkStructure {
        public static final int NET_RECORD_UNKNOWN = 0;
        public static final int NET_RECORD_TRAFFICREDLIST = 1; 					 // 交通白名单账户记录, 查询条件对应 FIND_RECORD_TRAFFICREDLIST_CONDITION 结构体,记录信息对应 NET_TRAFFIC_LIST_RECORD 结构体
        public static final int NET_RECORD_TRAFFICBLACKLIST = 2;  				 // 交通黑名单账号记录,查询条件对应 FIND_RECORD_TRAFFICREDLIST_CONDITION 结构体,记录信息对应 NET_TRAFFIC_LIST_RECORD 结构体
        public static final int NET_RECORD_BURN_CASE = 3;      					 // 刻录案件记录,查询条件对应 FIND_RECORD_BURN_CASE_CONDITION 结构体,记录信息对应 NET_BURN_CASE_INFO 结构体
        public static final int NET_RECORD_ACCESSCTLCARD = 4;  					 // 门禁卡,查询条件对应 FIND_RECORD_ACCESSCTLCARD_CONDITION 结构体,记录信息对应 NET_RECORDSET_ACCESS_CTL_CARD 结构体
        public static final int NET_RECORD_ACCESSCTLPWD = 5;      				 // 门禁密码,查询条件对应 FIND_RECORD_ACCESSCTLPWD_CONDITION 结构体,记录信息对应 NET_RECORDSET_ACCESS_CTL_PWD
        public static final int NET_RECORD_ACCESSCTLCARDREC = 6; 				 // 门禁出入记录（必须同时按卡号和时间段查询,建议用 NET_RECORD_ACCESSCTLCARDREC_EX 查询）,查询条件对应 FIND_RECORD_ACCESSCTLCARDREC_CONDITION 结构体,记录信息对应 NET_RECORDSET_ACCESS_CTL_CARDREC 结构体
        public static final int NET_RECORD_ACCESSCTLHOLIDAY = 7; 				 // 假日记录集,查询条件对应 FIND_RECORD_ACCESSCTLHOLIDAY_CONDITION 结构体,记录信息对应 NET_RECORDSET_HOLIDAY 结构体
        public static final int NET_RECORD_TRAFFICFLOW_STATE = 8;  				 // 查询交通流量记录,查询条件对应 FIND_RECORD_TRAFFICFLOW_CONDITION 结构体,记录信息对应 NET_RECORD_TRAFFIC_FLOW_STATE 结构体
        public static final int NET_RECORD_VIDEOTALKLOG = 9;    				 // 通话记录,查询条件对应 FIND_RECORD_VIDEO_TALK_LOG_CONDITION 结构体,记录信息对应 NET_RECORD_VIDEO_TALK_LOG 结构体
        public static final int NET_RECORD_REGISTERUSERSTATE = 10;  			 // 状态记录,查询条件对应 FIND_RECORD_REGISTER_USER_STATE_CONDITION 结构体,记录信息对应 NET_RECORD_REGISTER_USER_STATE 结构体
        public static final int NET_RECORD_VIDEOTALKCONTACT = 11;  				 // 联系人记录,查询条件对应 FIND_RECORD_VIDEO_TALK_CONTACT_CONDITION 结构体,记录信息对应 NET_RECORD_VIDEO_TALK_CONTACT 结构体
        public static final int NET_RECORD_ANNOUNCEMENT = 12;					 // 公告记录,查询条件对应 FIND_RECORD_ANNOUNCEMENT_CONDITION 结构体,记录信息对应 NET_RECORD_ANNOUNCEMENT_INFO 结构体
        public static final int NET_RECORD_ALARMRECORD = 13; 					 // 报警记录,查询条件对应 FIND_RECORD_ALARMRECORD_CONDITION 结构体,记录信息对应 NET_RECORD_ALARMRECORD_INFO 结构体
        public static final int NET_RECORD_COMMODITYNOTICE = 14;  				 // 下发商品记录,查询条件对应 FIND_RECORD_COMMODITY_NOTICE_CONDITION 结构体,记录信息对应 NET_RECORD_COMMODITY_NOTICE 结构体
        public static final int NET_RECORD_HEALTHCARENOTICE = 15;  				 // 就诊信息记录,查询条件对应 FIND_RECORD_HEALTH_CARE_NOTICE_CONDITION 结构体,记录信息对应 NET_RECORD_HEALTH_CARE_NOTICE 结构体
        public static final int NET_RECORD_ACCESSCTLCARDREC_EX = 16; 			 // 门禁出入记录(可选择部分条件查询,建议替代NET_RECORD_ACCESSCTLCARDREC),查询条件对应 FIND_RECORD_ACCESSCTLCARDREC_CONDITION_EX 结构体,记录信息对应 NET_RECORDSET_ACCESS_CTL_CARDREC 结构体
        public static final int NET_RECORD_GPS_LOCATION = 17;  					 // GPS位置信息记录, 只实现import和clear,记录信息对应 NET_RECORD_GPS_LOCATION_INFO 结构体
        public static final int NET_RECORD_RESIDENT = 18;      					 // 公租房租户信息,查询条件对应 FIND_RECORD_RESIDENT_CONDTION结构体, 记录信息对应 NET_RECORD_RESIDENT_INFO 结构体
        public static final int NET_RECORD_SENSORRECORD = 19;   			 	 // 监测量数据记录,查询条件对应 FIND_RECORD_SENSORRECORD_CONDITION 结构体,记录信息对应 NET_RECORD_SENSOR_RECORD 结构体
        public static final int NET_RECORD_ACCESSQRCODE = 20;  					 // 开门二维码记录集,记录信息对应 NET_RECORD_ACCESSQRCODE_INFO结构体
        public static final int NET_RECORD_ACCESS_BLUETOOTH = 22;				 // 蓝牙开门记录集, 查询条件对应 FIND_RECORD_ACCESS_BLUETOOTH_INFO_CONDITION 结构体, 记录信息对应 NET_RECORD_ACCESS_BLUETOOTH_INFO 结构体
    }

    //交通黑白名单记录信息
    public static class NET_TRAFFIC_LIST_RECORD extends SdkStructure {
        public int                      dwSize;
        public int                	  	nRecordNo;                                		     // 之前查询到的记录号
        public byte[]      			  	szMasterOfCar = new byte[NET_MAX_NAME_LEN];          // 车主姓名
        public byte[]      			  	szPlateNumber = new byte[NET_MAX_PLATE_NUMBER_LEN];  // 车牌号码
        public int          			emPlateType;                               		     // 车牌类型,对应EM_NET_PLATE_TYPE
        public int          			emPlateColor;                              		     // 车牌颜色 ，对应EM_NET_PLATE_COLOR_TYPE
        public int          			emVehicleType;                             		     // 车辆类型 ，对应EM_NET_VEHICLE_TYPE
        public int        			  	emVehicleColor;                         		     // 车身颜色，对应EM_NET_VEHICLE_COLOR_TYPE
        public NET_TIME                 stBeginTime;                       				     // 开始时间
        public NET_TIME                 stCancelTime;                       				 // 撤销时间
        public int                      nAuthrityNum;                       				 // 权限个数
        public NET_AUTHORITY_TYPE[]  	stAuthrityTypes = (NET_AUTHORITY_TYPE[])new NET_AUTHORITY_TYPE().toArray(NET_MAX_AUTHORITY_LIST_NUM); // 权限列表 , 白名单仅有
        public int           		  	emControlType;                    			         // 布控类型 ,黑名单仅有，对应EM_NET_TRAFFIC_CAR_CONTROL_TYPE

        public static class ByReference extends NET_TRAFFIC_LIST_RECORD implements Structure.ByReference {}

        public NET_TRAFFIC_LIST_RECORD() {
            this.dwSize = this.size();
        }
    }

    //车牌类型
    public static class EM_NET_PLATE_TYPE extends SdkStructure
    {
        public static final int NET_PLATE_TYPE_UNKNOWN               = 0;
        public static final int NET_PLATE_TYPE_NORMAL                = 1;   // "Normal" 蓝牌黑牌
        public static final int NET_PLATE_TYPE_YELLOW                = 2;   // "Yellow" 黄牌
        public static final int NET_PLATE_TYPE_DOUBLEYELLOW          = 3;   // "DoubleYellow" 双层黄尾牌
        public static final int NET_PLATE_TYPE_POLICE                = 4;   // "Police" 警牌
        public static final int NET_PLATE_TYPE_ARMED                 = 5;   // "Armed" 武警牌
        public static final int NET_PLATE_TYPE_MILITARY              = 6;   // "Military" BD号牌
        public static final int NET_PLATE_TYPE_DOUBLEMILITARY        = 7;   // "DoubleMilitary" BD双层
        public static final int NET_PLATE_TYPE_SAR                   = 8;   // "SAR" 港澳特区号牌
        public static final int NET_PLATE_TYPE_TRAINNING             = 9;   // "Trainning" 教练车号牌
        public static final int NET_PLATE_TYPE_PERSONAL              = 10;  // "Personal" 个性号牌
        public static final int NET_PLATE_TYPE_AGRI                  = 11;  // "Agri" 农用牌
        public static final int NET_PLATE_TYPE_EMBASSY               = 12;  // "Embassy" 使馆号牌
        public static final int NET_PLATE_TYPE_MOTO                  = 13;  // "Moto" 摩托车号牌
        public static final int NET_PLATE_TYPE_TRACTOR               = 14;  // "Tractor" 拖拉机号牌
        public static final int NET_PLATE_TYPE_OFFICIALCAR           = 15;  // "OfficialCar " 公务车
        public static final int NET_PLATE_TYPE_PERSONALCAR           = 16;  // "PersonalCar" 私家车
        public static final int NET_PLATE_TYPE_WARCAR                = 17;  // "WarCar"  军用
        public static final int NET_PLATE_TYPE_OTHER                 = 18;  // "Other" 其他号牌
        public static final int NET_PLATE_TYPE_CIVILAVIATION         = 19;  // "Civilaviation" 民航号牌
        public static final int NET_PLATE_TYPE_BLACK                 = 20;  // "Black" 黑牌
        public static final int NET_PLATE_TYPE_PURENEWENERGYMICROCAR = 21;  // "PureNewEnergyMicroCar" 纯电动新能源小车
        public static final int NET_PLATE_TYPE_MIXEDNEWENERGYMICROCAR = 22;  // "MixedNewEnergyMicroCar" 混合新能源小车
        public static final int NET_PLATE_TYPE_PURENEWENERGYLARGECAR = 23;  // "PureNewEnergyLargeCar" 纯电动新能源大车
        public static final int NET_PLATE_TYPE_MIXEDNEWENERGYLARGECAR = 24;  // "MixedNewEnergyLargeCar" 混合新能源大车
    }

    //车牌颜色
    public static class EM_NET_PLATE_COLOR_TYPE extends SdkStructure
    {
        public static final int NET_PLATE_COLOR_OTHER                = 0;   // 其他颜色
        public static final int NET_PLATE_COLOR_BLUE                 = 1;   // 蓝色 "Blue"
        public static final int NET_PLATE_COLOR_YELLOW               = 2;   // 黄色 "Yellow"
        public static final int NET_PLATE_COLOR_WHITE                = 3;   // 白色 "White"
        public static final int NET_PLATE_COLOR_BLACK                = 4;   // 黑色 "Black"
        public static final int NET_PLATE_COLOR_YELLOW_BOTTOM_BLACK_TEXT = 5;   // 黄底黑字 "YellowbottomBlackText"
        public static final int NET_PLATE_COLOR_BLUE_BOTTOM_WHITE_TEXT = 6;   // 蓝底白字 "BluebottomWhiteText"
        public static final int NET_PLATE_COLOR_BLACK_BOTTOM_WHITE_TEXT = 7;   // 黑底白字 "BlackBottomWhiteText"
        public static final int NET_PLATE_COLOR_SHADOW_GREEN         = 8;   // 渐变绿 "ShadowGreen"
        public static final int NET_PLATE_COLOR_YELLOW_GREEN         = 9;   // 黄绿双拼 "YellowGreen"
    }

    //车辆类型
    public static class EM_NET_VEHICLE_TYPE extends SdkStructure
    {
        public static final int NET_VEHICLE_TYPE_UNKNOW              = 0;   // 未知类型
        public static final int NET_VEHICLE_TYPE_MOTOR               = 1;   // "Motor" 机动车
        public static final int NET_VEHICLE_TYPE_NON_MOTOR           = 2;   // "Non-Motor"非机动车
        public static final int NET_VEHICLE_TYPE_BUS                 = 3;   // "Bus"公交车
        public static final int NET_VEHICLE_TYPE_BICYCLE             = 4;   // "Bicycle" 自行车
        public static final int NET_VEHICLE_TYPE_MOTORCYCLE          = 5;   // "Motorcycle"摩托车
        public static final int NET_VEHICLE_TYPE_UNLICENSEDMOTOR     = 6;   // "UnlicensedMotor": 无牌机动车
        public static final int NET_VEHICLE_TYPE_LARGECAR            = 7;   // "LargeCar"  大型汽车
        public static final int NET_VEHICLE_TYPE_MICROCAR            = 8;   // "MicroCar" 小型汽车
        public static final int NET_VEHICLE_TYPE_EMBASSYCAR          = 9;   // "EmbassyCar" 使馆汽车
        public static final int NET_VEHICLE_TYPE_MARGINALCAR         = 10;  // "MarginalCar" 领馆汽车
        public static final int NET_VEHICLE_TYPE_AREAOUTCAR          = 11;  // "AreaoutCar" 境外汽车
        public static final int NET_VEHICLE_TYPE_FOREIGNCAR          = 12;  // "ForeignCar" 外籍汽车
        public static final int NET_VEHICLE_TYPE_DUALTRIWHEELMOTORCYCLE = 13;  // "DualTriWheelMotorcycle"两、三轮摩托车
        public static final int NET_VEHICLE_TYPE_LIGHTMOTORCYCLE     = 14;  // "LightMotorcycle" 轻便摩托车
        public static final int NET_VEHICLE_TYPE_EMBASSYMOTORCYCLE   = 15;  // "EmbassyMotorcycle "使馆摩托车
        public static final int NET_VEHICLE_TYPE_MARGINALMOTORCYCLE  = 16;  // "MarginalMotorcycle "领馆摩托车
        public static final int NET_VEHICLE_TYPE_AREAOUTMOTORCYCLE   = 17;  // "AreaoutMotorcycle "境外摩托车
        public static final int NET_VEHICLE_TYPE_FOREIGNMOTORCYCLE   = 18;  // "ForeignMotorcycle "外籍摩托车
        public static final int NET_VEHICLE_TYPE_FARMTRANSMITCAR     = 19;  // "FarmTransmitCar" 农用运输车
        public static final int NET_VEHICLE_TYPE_TRACTOR             = 20;  // "Tractor" 拖拉机
        public static final int NET_VEHICLE_TYPE_TRAILER             = 21;  // "Trailer"  挂车
        public static final int NET_VEHICLE_TYPE_COACHCAR            = 22;  // "CoachCar"教练汽车
        public static final int NET_VEHICLE_TYPE_COACHMOTORCYCLE     = 23;  // "CoachMotorcycle "教练摩托车
        public static final int NET_VEHICLE_TYPE_TRIALCAR            = 24;  // "TrialCar" 试验汽车
        public static final int NET_VEHICLE_TYPE_TRIALMOTORCYCLE     = 25;  // "TrialMotorcycle "试验摩托车
        public static final int NET_VEHICLE_TYPE_TEMPORARYENTRYCAR   = 26;  // "TemporaryEntryCar"临时入境汽车
        public static final int NET_VEHICLE_TYPE_TEMPORARYENTRYMOTORCYCLE = 27;  // "TemporaryEntryMotorcycle"临时入境摩托车
        public static final int NET_VEHICLE_TYPE_TEMPORARYSTEERCAR   = 28;  // "TemporarySteerCar"临时行驶车
        public static final int NET_VEHICLE_TYPE_PASSENGERCAR        = 29;  // "PassengerCar" 客车
        public static final int NET_VEHICLE_TYPE_LARGETRUCK          = 30;  // "LargeTruck" 大货车
        public static final int NET_VEHICLE_TYPE_MIDTRUCK            = 31;  // "MidTruck" 中货车
        public static final int NET_VEHICLE_TYPE_SALOONCAR           = 32;  // "SaloonCar" 轿车
        public static final int NET_VEHICLE_TYPE_MICROBUS            = 33;  // "Microbus"面包车
        public static final int NET_VEHICLE_TYPE_MICROTRUCK          = 34;  // "MicroTruck"小货车
        public static final int NET_VEHICLE_TYPE_TRICYCLE            = 35;  // "Tricycle"三轮车
        public static final int NET_VEHICLE_TYPE_PASSERBY            = 36;  // "Passerby" 行人
    }

    //车身颜色
    public static class EM_NET_VEHICLE_COLOR_TYPE extends SdkStructure
    {
        public static final int NET_VEHICLE_COLOR_OTHER              = 0;   // 其他颜色
        public static final int NET_VEHICLE_COLOR_WHITE              = 1;   // 白色	"White"
        public static final int NET_VEHICLE_COLOR_BLACK              = 2;   // 黑色	"Black"
        public static final int NET_VEHICLE_COLOR_RED                = 3;   // 红色	"Red"
        public static final int NET_VEHICLE_COLOR_YELLOW             = 4;   // 黄色	"Yellow"
        public static final int NET_VEHICLE_COLOR_GRAY               = 5;   // 灰色	"Gray"
        public static final int NET_VEHICLE_COLOR_BLUE               = 6;   // 蓝色	"Blue"
        public static final int NET_VEHICLE_COLOR_GREEN              = 7;   // 绿色	"Green"
        public static final int NET_VEHICLE_COLOR_PINK               = 8;   // 粉红色 "Pink"
        public static final int NET_VEHICLE_COLOR_PURPLE             = 9;   // 紫色	"Purple"
        public static final int NET_VEHICLE_COLOR_BROWN              = 10;  // 棕色	"Brown"
    }

    // 交通流量记录
    public static class NET_RECORD_TRAFFIC_FLOW_STATE extends SdkStructure {
        public int                       dwSize;
        public int                       nRecordNum;                 // 记录编号
        public int                       nChannel;                   // 通道号
        public int                       nLane;                      // 车道号
        public int                       nVehicles;                  // 通过车辆总数
        public float                     fAverageSpeed;              // 平均车速,单位km/h
        public float                     fTimeOccupyRatio;           // 时间占有率,即单位时间内通过断面的车辆所用时间的总和占单位时间的比例
        public float                     fSpaceOccupyRatio;          // 空间占有率,即按百分率计量的车辆长度总和除以时间间隔内车辆平均行驶距离
        public float                     fSpaceHeadway;              // 车头间距,相邻车辆之间的距离,单位米/辆
        public float                     fTimeHeadway;               // 车头时距,单位秒/辆
        public int                       nLargeVehicles;             // 大车交通量(9米<车长<12米),辆/单位时间
        public int                       nMediumVehicles;            // 中型车交通量(6米<车长<9米),辆/单位时间
        public int                       nSmallVehicles;             // 小车交通量(4米<车长<6米),辆/单位时间,
        public float                     fBackOfQueue;               // 排队长度,单位：米, 从信号交叉口停车线到上游排队车辆末端之间的距离
        public int                             nPasserby;                  // 通过行人数
        public NET_RECORD_TRAFFIC_FLOW_STATE() {
            this.dwSize = this.size();
        }
    }

    //权限列表 , 白名单仅有
    public static class NET_AUTHORITY_TYPE extends SdkStructure {
        public int                     dwSize;
        public int              		 emAuthorityType;                 		 //权限类型，对应EM_NET_AUTHORITY_TYPE
        public boolean         		 bAuthorityEnable;                 		 //权限使能

        public NET_AUTHORITY_TYPE() {
            this.dwSize = this.size();
        }
    }

    //权限类型
    public static class EM_NET_AUTHORITY_TYPE extends SdkStructure {
        public static final int     	NET_AUTHORITY_UNKNOW = 0;
        public static final int		    NET_AUTHORITY_OPEN_GATE = 1;             //开闸权限
    }

    //布控类型
    public static class EM_NET_TRAFFIC_CAR_CONTROL_TYPE extends SdkStructure
    {
        public static final int NET_CAR_CONTROL_OTHER                = 0;
        public static final int NET_CAR_CONTROL_OVERDUE_NO_CHECK     = 1;   // 过期未检	"OverdueNoCheck"
        public static final int NET_CAR_CONTROL_BRIGANDAGE_CAR       = 2;   // 盗抢车辆	"BrigandageCar"
        public static final int NET_CAR_CONTROL_BREAKING             = 3;   // 违章		"Breaking"
        public static final int NET_CAR_CONTROL_CAUSETROUBLE_ESCAPE  = 4;   // 肇事逃逸  "CausetroubleEscape"
    }

    // 呼叫类型
    public static class EM_VIDEO_TALK_LOG_CALLTYPE extends SdkStructure {
        public static final int EM_VIDEO_TALK_LOG_CALLTYPE_UNKNOWN = 0;         // 未知
        public static final int EM_VIDEO_TALK_LOG_CALLTYPE_INCOMING = 1;        // 呼入
        public static final int EM_VIDEO_TALK_LOG_CALLTYPE_OUTGOING = 2;        // 呼出
        public static final int EM_VIDEO_TALK_LOG_CALLTYPE_MAX = 3;
    }

    // 最终状态
    public static class EM_VIDEO_TALK_LOG_ENDSTATE extends SdkStructure {
        public static final int EM_VIDEO_TALK_LOG_ENDSTATE_UNKNOWN = 0;         // 未知
        public static final int EM_VIDEO_TALK_LOG_ENDSTATE_MISSED = 1;        	// 未接
        public static final int EM_VIDEO_TALK_LOG_ENDSTATE_RECEIVED = 2;        // 已接
        public static final int EM_VIDEO_TALK_LOG_ENDSTATE_MAX = 3;
    }

    // 对方类型
    public static class EM_VIDEO_TALK_LOG_PEERTYPE extends SdkStructure {
        public static final int EM_VIDEO_TALK_LOG_PEERTYPE_UNKNOWN = 0;     // 未知
        public static final int EM_VIDEO_TALK_LOG_PEERTYPE_VTO = 1;        	// 门口机
        public static final int EM_VIDEO_TALK_LOG_PEERTYPE_VTH = 2;         // 室内机
        public static final int EM_VIDEO_TALK_LOG_PEERTYPE_VTS = 3; 		// 管理中心
    }

    // 通话记录查询条件
    public static class FIND_RECORD_VIDEO_TALK_LOG_CONDITION extends SdkStructure {
        public int                          dwSize;
        public int                          bCallTypeEnable;                            // 呼叫类型查询条件是否有效
        public int                          nCallTypeListNum;                           // 对应 emCallTypeList 中有效枚举个数
        public int[]      					emCallTypeList = new int[NET_MAX_CALLTYPE_LIST_NUM];   // 呼叫类型使能列表, 详见EM_VIDEO_TALK_LOG_CALLTYPE
        public int                          bEndStateEnable;                            // 最终状态查询条件是否有效
        public int                          nEndStateListNum;                           // 对应 emEndStateList 中有效枚举个数
        public int[]      					emEndStateList = new int[NET_MAX_ENDSTATE_LIST_NUM];   // 最终状态使能列表, 详见EM_VIDEO_TALK_LOG_ENDSTATE
        public int                          bTimeEnable;                                // 启用时间段查询
        public NET_TIME                     stStartTime;                                // 起始时间
        public NET_TIME                     stEndTime;                                  // 结束时间

        public FIND_RECORD_VIDEO_TALK_LOG_CONDITION() {
            this.dwSize = this.size();
        }
    }

    // 通话记录记录集信息
    public static class NET_RECORD_VIDEO_TALK_LOG extends SdkStructure {
        public int                      dwSize;
        public int                      nRecNo;                             // 记录集编号,只读
        public NET_TIME                 stuCreateTime;                      // 开始时间
        public int      				emCallType;                         // 呼叫类型,详见EM_VIDEO_TALK_LOG_CALLTYPE
        public int      				emEndState;                         // 最终状态,详见EM_VIDEO_TALK_LOG_ENDSTATE
        public byte[]                   szPeerNumber = new byte[NET_COMMON_STRING_64];  // 对方号码 可以是短号,中号或长号
        public int      				emPeerType;                         // 对方类型,详见EM_VIDEO_TALK_LOG_PEERTYPE
        public byte[]                   szLocalNumber = new byte[NET_COMMON_STRING_64]; // 本机号码 可以是短号,中号或长号
        public int                      nTalkTime;                          // 通话时间 单位秒
        public int                      nMessageTime;                       // 留言时间 单位秒
        public byte[]                   szPicturePath = new byte[NET_COMMON_STRING_128]; // 图片路径
        public int		                emOfflineCall;						// 平台断线是否呼出,NET_EM_OFFLINE_CALL_TYPE
        public NET_RECORD_VIDEO_TALK_LOG() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_FindRecord接口输出参数
    public static class NET_OUT_FIND_RECORD_PARAM extends SdkStructure {
        public int                     dwSize;          						// 结构体大小
        public LLong                   lFindeHandle; 						    // 查询记录句柄,唯一标识某次查询

        public NET_OUT_FIND_RECORD_PARAM() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_FindNextRecord接口输入参数
    public static class NET_IN_FIND_NEXT_RECORD_PARAM extends SdkStructure {
        public int                      dwSize;          						// 结构体大小
        public LLong              		lFindeHandle;    						// 查询句柄
        public int                      nFileCount;      						// 当前想查询的记录条数

        public NET_IN_FIND_NEXT_RECORD_PARAM() {
            this.dwSize = this.size();
        }
    }

    //CLIENT_FindNextRecord接口输出参数
    public static class NET_OUT_FIND_NEXT_RECORD_PARAM extends SdkStructure {
        public int                     dwSize;          						// 结构体大小
        public Pointer                 pRecordList;     				   	 	// 记录列表,用户分配内存，对应 交通黑白名单记录信息 NET_TRAFFIC_LIST_RECORD
        public int                     nMaxRecordNum;   						// 列表记录数
        public int                     nRetRecordNum;   						// 查询到的记录条数,当查询到的条数小于想查询的条数时,查询结束

        public NET_OUT_FIND_NEXT_RECORD_PARAM() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_QueryRecordCount接口输入参数
    public static class NET_IN_QUEYT_RECORD_COUNT_PARAM extends SdkStructure
    {
        public int dwSize;//结构体大小
        public LLong lFindeHandle;//查询句柄

        public NET_IN_QUEYT_RECORD_COUNT_PARAM() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_QueryRecordCount接口输出参数
    public static class NET_OUT_QUEYT_RECORD_COUNT_PARAM extends SdkStructure
    {
        public int dwSize;//结构体大小
        public int nRecordCount;//设备返回的记录条数

        public NET_OUT_QUEYT_RECORD_COUNT_PARAM() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_OperateTrafficList接口输入参数,
    public static class NET_IN_OPERATE_TRAFFIC_LIST_RECORD extends SdkStructure {
        public int                       dwSize;
        public int                       emOperateType;  					 // emOperateType对应EM_RECORD_OPERATE_TYPE
        public int                       emRecordType;    					 // 要操作记录信息类型,emRecordType对应EM_NET_RECORD_TYPE
        public Pointer                   pstOpreateInfo;  				    // 对应 添加NET_INSERT_RECORD_INFO/ 删除NET_REMOVE_RECORD_INFO / 修改NET_UPDATE_RECORD_INFO

        public NET_IN_OPERATE_TRAFFIC_LIST_RECORD() {
            this.dwSize = this.size();
        }
    }
    // 添加
    public static class NET_INSERT_RECORD_INFO extends SdkStructure {
        public int                       			dwSize;
        public NET_TRAFFIC_LIST_RECORD.ByReference  pRecordInfo = new NET_TRAFFIC_LIST_RECORD.ByReference();      		// 记录内容信息

        public NET_INSERT_RECORD_INFO () {
            this.dwSize = this.size();
        }
    }
    // 删除
    public static class NET_REMOVE_RECORD_INFO extends SdkStructure {
        public int                      dwSize;
        public int                      nRecordNo;      			    	 // 之前查询到的记录号，对应NET_TRAFFIC_LIST_RECORD里的nRecordNo

        public NET_REMOVE_RECORD_INFO() {
            this.dwSize = this.size();
        }
    }
    // 修改
    public static class NET_UPDATE_RECORD_INFO extends SdkStructure{
        public int                  			    dwSize;
        public NET_TRAFFIC_LIST_RECORD.ByReference 	pRecordInfo;    	   // 记录内容信息 ，对应  NET_TRAFFIC_LIST_RECORD

        public NET_UPDATE_RECORD_INFO() {
            this.dwSize = this.size();
        }
    }

    // 黑白名单操作类型
    public static class EM_RECORD_OPERATE_TYPE extends SdkStructure {
        public static final int NET_TRAFFIC_LIST_INSERT = 0;               // 增加记录操作
        public static final int NET_TRAFFIC_LIST_UPDATE = 1;               // 更新记录操作
        public static final int NET_TRAFFIC_LIST_REMOVE = 2;               // 删除记录操作
        public static final int NET_TRAFFIC_LIST_MAX = 3;
    }

    // CLIENT_OperateTrafficList接口输出参数,现阶段实现的操作接口中,只有返回nRecordNo的操作,stRetRecord暂时不可用,是null
    public static class NET_OUT_OPERATE_TRAFFIC_LIST_RECORD extends SdkStructure {
        public int                     dwSize;
        public int                     nRecordNo;        //记录号

        public NET_OUT_OPERATE_TRAFFIC_LIST_RECORD() {
            this.dwSize = this.size();
        }
    }

    // 记录集操作参数
    public static class NET_CTRL_RECORDSET_PARAM extends SdkStructure {
        public int               dwSize;
        public int 			     emType;                         // 记录集信息类型,对应EM_NET_RECORD_TYPE
        public Pointer           pBuf;                           // 新增\更新\查询\导入时,为记录集信息缓存,详见EM_NET_RECORD_TYPE注释
        // 删除时,为记录编号(int型)
        public int               nBufLen;                        // 记录集信息缓存大小

        public NET_CTRL_RECORDSET_PARAM() {
            this.dwSize = this.size();
        }
    }

    // 黑白名单上传
    public static class NETDEV_BLACKWHITE_LIST_INFO extends SdkStructure {
        public byte[]        						  szFile = new byte[MAX_PATH_STOR];      // 黑白名单文件路径
        public int                                    nFileSize;            				 // 升级文件大小
        public byte                  			      byFileType;         					 // 当前文件类型,0-黑名单,1-白名单
        public byte                   			      byAction;            					 // 动作,0-覆盖,1-追加
        public byte[]      		   					  byReserved = new byte[126];            // 保留
    }

    // GPS信息(车载设备)
    public static class GPS_Info extends SdkStructure {
        public NET_TIME           revTime;                          // 定位时间
        public byte[]             DvrSerial = new byte[50];         // 设备序列号
        public double             longitude;                     	// 经度(单位是百万分之度,范围0-360度)
        public double             latidude;                     	// 纬度(单位是百万分之度,范围0-180度)
        public double             height;                      	    // 高度(米)
        public double             angle;                        	// 方向角(正北方向为原点,顺时针为正)
        public double             speed;                        	// 速度(单位是海里,speed/1000*1.852公里/小时)
        public short              starCount;                     	// 定位星数,无符号
        public int           	  antennaState;                 	// 天线状态(true 好,false 坏)
        public int                orientationState;              	// 定位状态(true 定位,false 不定位)

        public static class ByValue extends GPS_Info implements SdkStructure.ByValue { }
    }

    // 报警状态信息
    public static class ALARM_STATE_INFO extends SdkStructure {
        public int                nAlarmCount;                       // 发生的报警事件个数
        public int[]              nAlarmState = new int[128];        // 发生的报警事件类型
        public byte[]             byRserved   = new byte[128];       // 保留字节

        public static class ByValue extends ALARM_STATE_INFO implements SdkStructure.ByValue { }
    }

    // 对应CLIENT_SearchDevicesByIPs接口
    public static class DEVICE_IP_SEARCH_INFO extends SdkStructure {
        public int               dwSize;                                    		 		    // 结构体大小
        public int               nIpNum;                                				    	// 当前搜索的IP个数
        public DEVICE_IP[]       szIPArr
                = (DEVICE_IP[])new DEVICE_IP().toArray(NET_MAX_SAERCH_IP_NUM); // 具体待搜索的IP信息数组

        public DEVICE_IP_SEARCH_INFO() {
            this.dwSize = this.size();
        }
    }

    // 具体待搜索的IP信息
    public static class DEVICE_IP extends SdkStructure {
        public byte[]            szIP        = new byte[64];          // 具体待搜索的IP信息
    }

    // CLIENT_UploadRemoteFile 接口输入参数(上传文件到设备)
    public static class NET_IN_UPLOAD_REMOTE_FILE extends SdkStructure {
        public int               dwSize;
        public Pointer           pszFileSrc;                     	// 源文件路径
        public Pointer         	 pszFileDst;                     	// 目标文件路径
        public Pointer         	 pszFolderDst;                   	// 目标文件夹路径：可为NULL, NULL时设备使用默认路径
        public int          	 nPacketLen;                     	// 文件分包大小(字节): 0表示不分包

        public NET_IN_UPLOAD_REMOTE_FILE(){
            this.dwSize = this.size();
        }
    }

    // CLIENT_UploadRemoteFile 接口输出参数(上传文件到设备)
    public static class NET_OUT_UPLOAD_REMOTE_FILE extends SdkStructure {
        public int               dwSize;

        public NET_OUT_UPLOAD_REMOTE_FILE() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_ListRemoteFile 接口输入参数
    public static class NET_IN_LIST_REMOTE_FILE extends SdkStructure
    {
        public int               	dwSize;
        public String         		pszPath;                        // 路径
        public int                	bFileNameOnly;                  // 只获取文件名称, 不返回文件夹信息, 文件信息中只有文件名有效, BOOL类型
        public int 					emCondition;                    // 指定获取文件的条件, 对应  NET_REMOTE_FILE_COND

        public NET_IN_LIST_REMOTE_FILE() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_ListRemoteFile 接口输出参数
    public static class NET_OUT_LIST_REMOTE_FILE extends SdkStructure
    {
        public int                   dwSize;
        public Pointer    			 pstuFiles;                  // 文件信息数组, 用户分配内存, 对应 NET_REMOTE_FILE_INFO[],大小为sizeof(NET_REMOTE_FILE_INFO)*nMaxFileCount
        public int                   nMaxFileCount;              // 文件信息数组大小, 用户填写
        public int                   nRetFileCount;              // 返回的文件数量

        public NET_OUT_LIST_REMOTE_FILE() {
            this.dwSize = this.size();
        }
    }

    // 文件/目录信息
    public static class SDK_REMOTE_FILE_INFO extends SdkStructure
    {
        public int               	dwSize;
        public int               	bDirectory;                     			// 是否文件夹, BOOL类型
        public byte[]               szPath = new byte[MAX_PATH];                // 路径
        public NET_TIME             stuCreateTime;                  			// 创建时间
        public NET_TIME             stuModifyTime;                  			// 修改时间
        public long                 nFileSize;                      			// 文件大小
        public byte[]               szFileType = new byte[NET_FILE_TYPE_LEN];   // 文件类型

        public SDK_REMOTE_FILE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 获取文件的条件
    public static class NET_REMOTE_FILE_COND extends SdkStructure
    {
        public static final int NET_REMOTE_FILE_COND_NONE = 0;              // 无条件
        public static final int NET_REMOTE_FILE_COND_VOICE = 1;             // 语音联动的文件,*无法*按路径获取,*只能*获取获取文件名称
    }

    // CLIENT_RemoveRemoteFiles 接口输入参数
    public static class NET_IN_REMOVE_REMOTE_FILES extends SdkStructure
    {
        public int                 dwSize;
        public Pointer             pszPathPointer;         // 文件路径数组指针,对应 FILE_PATH[]
        public int                 nFileCount;             // 文件路径数量

        public NET_IN_REMOVE_REMOTE_FILES() {
            this.dwSize = this.size();
        }
    }

    public static class FILE_PATH extends SdkStructure {
        public String pszPath;
    }

    // CLIENT_RemoveRemoteFiles 接口输出参数
    public static class NET_OUT_REMOVE_REMOTE_FILES extends SdkStructure
    {
        public int               dwSize;

        public NET_OUT_REMOVE_REMOTE_FILES() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_ParkingControlAttachRecord()接口输入参数
    public static class NET_IN_PARKING_CONTROL_PARAM extends SdkStructure {
        public int                              dwSize;
        public Callback					cbCallBack;                 // 数据回调函数,fParkingControlRecordCallBack 回调
        public Pointer                      	dwUser;                     // 用户定义参数

        public NET_IN_PARKING_CONTROL_PARAM() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_ParkingControlDetachRecord()接口输出参数
    public static class NET_OUT_PARKING_CONTROL_PARAM extends SdkStructure {
        public int    							dwSize;

        public NET_OUT_PARKING_CONTROL_PARAM() {
            this.dwSize = this.size();
        }
    }

    // 过车记录信息
    public static class NET_CAR_PASS_ITEM extends SdkStructure {
        public int                      dwSize;
        public NET_TIME                 stuTime;          // 过车时间
        public int                      dwCardNo;         // 卡号
        public int      			    emCardType;       // 智能停车系统出入口机IC卡用户类型,对应 NET_ECK_IC_CARD_USER_TYPE
        public int     				    emFlag;           // 过车记录类型，对应 NET_ECK_CAR_PASS_FLAG

        public NET_CAR_PASS_ITEM(){
            this.dwSize = this.size();
        }
    }

    // 智能停车系统出入口机IC卡用户类型
    public static class NET_ECK_IC_CARD_USER_TYPE extends SdkStructure {
        public static final int NET_ECK_IC_CARD_USER_UNKNOWN     = 0;
        public static final int NET_ECK_IC_CARD_USER_ALL         = 1;               // 全部类型
        public static final int NET_ECK_IC_CARD_USER_TEMP		 = 2;               // 临时用户
        public static final int NET_ECK_IC_CARD_USER_LONG		 = 3;               // 长期用户
        public static final int NET_ECK_IC_CARD_USER_ADMIN		 = 4;               // 管理员
        public static final int NET_ECK_IC_CARD_USER_BLACK_LIST  = 5;               // 黑名单
    }

    // 智能停车系统出入口机异常过车记录类型
    public static class NET_ECK_CAR_PASS_FLAG extends SdkStructure {
        public static final int NET_ECK_CAR_PASS_FLAG_NORMAL   = 0;                 // 正常
        public static final int NET_ECK_CAR_PASS_FLAG_ABNORMAL = 1;                 // 异常
        public static final int NET_ECK_CAR_PASS_FLAG_ALL      = 2;                 // 全部
    }

    // CLIENT_ParkingControlStartFind接口输入参数******************
    public static class NET_IN_PARKING_CONTROL_START_FIND_PARAM extends SdkStructure {
        public int                      dwSize;          // 结构体大小
        public int                      bSearchCount;    // 查询记录调试是否有效
        public int                      dwSearchCount;   // 查询记录条数, 数值范围1~100
        public int                      bBegin;          // 查询开始时间是否有效
        public NET_TIME                 stuBegin;        // 查询开始时间
        public int                      bEnd;            // 查询结束时间是否有效
        public NET_TIME                 stuEnd;          // 查询结束时间
        public int                      bCardType;       // 卡类型是否有效
        public int 					    emCardType;      // 卡类型,对应 NET_ECK_IC_CARD_USER_TYPE
        public int                      bFlag;           // 过车标记是否有效
        public int                      emFlag;          // 过车标记，对应 NET_ECK_CAR_PASS_FLAG

        public NET_IN_PARKING_CONTROL_START_FIND_PARAM() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_ParkingControlStartFind接口输出参数
    public static class NET_OUT_PARKING_CONTROL_START_FIND_PARAM extends SdkStructure {
        public int                     dwSize;          // 结构体大小
        public int                     dwTotalCount;    // 符合此次查询条件的结果总条数

        public NET_OUT_PARKING_CONTROL_START_FIND_PARAM(){
            this.dwSize = this.size();
        }
    }

    // CLIENT_ParkingControlDoFind接口输入参数*******************
    public static class NET_IN_PARKING_CONTROL_DO_FIND_PARAM extends SdkStructure {
        public int                     dwSize;          // 结构体大小
        public int                     dwFileCount;     // 当前想查询的记录条数

        public NET_IN_PARKING_CONTROL_DO_FIND_PARAM(){
            this.dwSize = this.size();
        }
    }

    // CLIENT_ParkingControlDoFind接口输出参数
    public static class NET_OUT_PARKING_CONTROL_DO_FIND_PARAM extends SdkStructure{
        public int                             dwSize;          // 结构体大小
        public Pointer      				   pstuRecordList;  // 记录列表,用户分配内存,对应NET_CAR_PASS_ITEM[],大小nMaxRecordNum个NET_CAR_PASS_ITEM
        public int                     		   nMaxRecordNum;   // 列表记录数
        public int                     	 	   nRetRecordNum;   // 查询到的记录条数,当查询到的条数小于想查询的条数时,查询结束

        public NET_OUT_PARKING_CONTROL_DO_FIND_PARAM(){
            this.dwSize = this.size();
        }
    }

    // CLIENT_ParkingControlAttachParkInfo()接口输入参数
    public static class NET_IN_PARK_INFO_PARAM extends SdkStructure
    {
        public int                             dwSize;
        public NET_PARK_INFO_FILTER            stuFilter;
        public Callback			       cbCallBack;        // 数据回调函数,fParkInfoCallBack 回调
        public Pointer                         dwUser;            // 用户定义参数

        public NET_IN_PARK_INFO_PARAM() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_ParkingControlAttachParkInfo()接口输出参数
    public static class NET_OUT_PARK_INFO_PARAM extends SdkStructure
    {
        public int    				dwSize;

        public NET_OUT_PARK_INFO_PARAM() {
            this.dwSize = this.size();
        }
    }

    // 车位检测器信息查询条件
    public static class NET_PARK_INFO_FILTER extends SdkStructure
    {
        public int           dwSize;
        public int           dwNum;                               // 车位检测器类型数量
        public int[] 		 emType = new int[NET_ECK_PARK_DETECTOR_TYPE.NET_ECK_PARK_DETECTOR_TYPE_ALL];   // 车位检测器类型

        public NET_PARK_INFO_FILTER() {
            this.dwSize = this.size();
        }
    }

    // 车位检测器类型
    public static class NET_ECK_PARK_DETECTOR_TYPE extends SdkStructure
    {
        public static final int NET_ECK_PARK_DETECTOR_TYPE_SONIC  = 0;         // 超声波探测器
        public static final int NET_ECK_PARK_DETECTOR_TYPE_CAMERA = 1;         // 相机检测器
        public static final int NET_ECK_PARK_DETECTOR_TYPE_ALL	  = 2;
    }

    // 车位信息
    public static class NET_PARK_INFO_ITEM extends SdkStructure
    {
        public int                 dwSize;
        public byte[]              szParkNo = new byte[NET_COMMON_STRING_32];   // 车位号
        public int  			   emState;                         			// 车位状态,对应  NET_ECK_PARK_STATE
        public int                 dwScreenIndex;                   			// 车位号显示对应的诱导屏分屏号
        public int                 dwFreeParkNum;                   			// 屏号显示的当前空余车位数目

        public NET_PARK_INFO_ITEM(){
            this.dwSize = this.size();
        }
    }

    // 智能停车系统车位状态
    public static class NET_ECK_PARK_STATE extends SdkStructure
    {
        public static final int NET_ECK_PARK_STATE_UNKOWN = 0;
        public static final int NET_ECK_PARK_STATE_PARK   = 1;       // 车位有车
        public static final int NET_ECK_PARK_STATE_NOPARK = 2;       // 车位无车
    }

    // 智能停车系统出入口机设置车位信息 参数 NET_CTRL_ECK_SET_PARK_INFO
    public static class NET_CTRL_ECK_SET_PARK_INFO_PARAM extends SdkStructure
    {
        public int           	dwSize;
        public int              nScreenNum;                                     // 屏数量, 不超过 ECK_SCREEN_NUM_MAX
        public int[]            nScreenIndex = new int[ECK_SCREEN_NUM_MAX];     // 屏号, 每个元素表示屏序号
        public int[]            nFreeParkNum = new int[ECK_SCREEN_NUM_MAX];     // 对应屏管理下的空余车位数
        // 长度和下标与nScreenIndex一致,每个元素表示对应屏号下的空余车位
        public NET_CTRL_ECK_SET_PARK_INFO_PARAM(){
            this.dwSize = this.size();
        }
    }

    // CLIENT_PowerControl接口输入参数(电视墙电源控制)
    public static class NET_IN_WM_POWER_CTRL extends SdkStructure
    {
        public int              	dwSize;
        public int                  nMonitorWallID;             // 电视墙序号
        public String          		pszBlockID;                 // 区块ID, NULL/""-所有区块
        public int                  nTVID;                      // 显示单元序号, -1表示区块中所有显示单元
        public int                  bPowerOn;                   // 是否打开电源

        public NET_IN_WM_POWER_CTRL() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_PowerControl接口输出参数(电视墙电源控制)
    public static class NET_OUT_WM_POWER_CTRL extends SdkStructure
    {
        public int                 dwSize;

        public NET_OUT_WM_POWER_CTRL() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_LoadMonitorWallCollection接口输入参数(载入电视墙预案)
    public static class NET_IN_WM_LOAD_COLLECTION extends SdkStructure
    {
        public int                dwSize;
        public int                nMonitorWallID;             // 电视墙序号
        public Pointer         	  pszName;                    // 预案名称

        public NET_IN_WM_LOAD_COLLECTION() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_LoadMonitorWallCollection接口输出参数(载入电视墙预案)
    public static class NET_OUT_WM_LOAD_COLLECTION extends SdkStructure
    {
        public int               dwSize;

        public NET_OUT_WM_LOAD_COLLECTION() {
            this.dwSize = this.size();
        }
    }


    // CLIENT_SaveMonitorWallCollection接口输入参数(保存电视墙预案)
    public static class NET_IN_WM_SAVE_COLLECTION extends SdkStructure
    {
        public int               dwSize;
        public int               nMonitorWallID;             // 电视墙序号
        public Pointer           pszName;                    // 预案名称
        public String            pszControlID;               // 控制id
        public int emType;                     // 预案类型
        public NET_IN_WM_SAVE_COLLECTION() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_SaveMonitorWallCollection接口输出参数(保存电视墙预案)
    public static class NET_OUT_WM_SAVE_COLLECTION extends SdkStructure
    {
        public int               dwSize;

        public NET_OUT_WM_SAVE_COLLECTION() {
            this.dwSize = this.size();
        }
    }

    // 分割模式
    public static class NET_SPLIT_MODE extends SdkStructure
    {
        public static final int NET_SPLIT_1 = 1;                                   // 1画面
        public static final int NET_SPLIT_2 = 2;                                   // 2画面
        public static final int NET_SPLIT_4 = 4;                                   // 4画面
        public static final int NET_SPLIT_6 = 6;                                   // 6画面
        public static final int NET_SPLIT_8 = 8;                                   // 8画面
        public static final int NET_SPLIT_9 = 9;                                   // 9画面
        public static final int NET_SPLIT_12 = 12;                                 // 12画面
        public static final int NET_SPLIT_16 = 16;                                 // 16画面
        public static final int NET_SPLIT_20 = 20;                                 // 20画面
        public static final int NET_SPLIT_25 = 25;                                 // 25画面
        public static final int NET_SPLIT_36 = 36;                                 // 36画面
        public static final int NET_SPLIT_64 = 64;                                 // 64画面
        public static final int NET_SPLIT_144 = 144;                               // 144画面
        public static final int NET_PIP_1 = NET_SPLIT_PIP_BASE + 1;                // 画中画模式, 1个全屏大画面+1个小画面窗口
        public static final int NET_PIP_3 = NET_SPLIT_PIP_BASE + 3;                // 画中画模式, 1个全屏大画面+3个小画面窗口
        public static final int NET_SPLIT_FREE = NET_SPLIT_PIP_BASE * 2;           // 自由开窗模式,可以自由创建、关闭窗口,自由设置窗口位置和Z轴次序
        public static final int NET_COMPOSITE_SPLIT_1 = NET_SPLIT_PIP_BASE * 3 + 1;// 融合屏成员1分割
        public static final int NET_COMPOSITE_SPLIT_4 = NET_SPLIT_PIP_BASE * 3 + 4;// 融合屏成员4分割
    }

    // 区块窗口信息
    public static class NET_WINDOW_COLLECTION extends SdkStructure
    {
        public int               dwSize;
        public int               nWindowID;                      // 窗口ID
        public int               bWndEnable;                     // 窗口是否有效
        public DH_RECT           stuRect;                        // 窗口区域, 自由分割模式下有效
        public int               bDirectable;                    // 坐标是否满足直通条件
        public int               nZOrder;                        // 窗口Z次序
        public int               bSrcEnable;                     // 显示源是否有效
        public byte[]            szDeviceID = new byte[NET_DEV_ID_LEN_EX]; // 设备ID
        public int               nVideoChannel;                  // 视频通道号
        public int               nVideoStream;                   // 视频码流类型
        public int               nAudioChannel;                  // 音频通道
        public int               nAudioStream;                   // 音频码流类型
        public int               nUniqueChannel;                 // 设备内统一编号的唯一通道号

        public NET_WINDOW_COLLECTION() {
            this.dwSize = this.size();
        }
    }

    // 分割窗口OSD信息
    public static class NET_SPLIT_OSD extends SdkStructure
    {
        public int               dwSize;
        public Boolean                bEnable;                    // 使能
        public NET_COLOR_RGBA       stuFrontColor;              // 前景颜色
        public NET_COLOR_RGBA       stuBackColor;               // 背景颜色
        public DH_RECT             stuFrontRect;               // 前景区域
        public DH_RECT             stuBackRect;                // 背景区域
        public Boolean                bRoll;                      // 是否滚动显示, 只对文本有效
        public  byte                byRollMode;                 // 滚动模式, 只对文本有效, 0-从左往右, 1-从右往左, 2-从上往下滚动, 3-从下往上滚动
        public  byte                byRoolSpeed;                // 滚动速率, 只对文本有效, 0~4, 数值越大滚动越快
        public  byte                byFontSize;                 // 字体大小, 只对文本有效
        public byte                byTextAlign;                // 对齐方式, 0-靠左, 1-居中, 2-靠右
        public byte                byType;                     // OSD类型, 0-文本, 1-图标, 2-时间
        public byte[]                Reserved=new byte[3];                // 保留字节
        public byte[]                szContent=new byte[MAX_PATH];        // OSD内容
        // 若类型为图标, 内容为图标名称
        // 若类型为Time，内容为”Date”(日期),”Week”(星期),”Time”(时间),”\n”(换行)的自由组合。
        // 例如：不同行显示，需要将此字段填为"Date\nTime",在屏幕上就会显示
        // 2018年4月23日
        // 16:49:15
        // 同行显示，需要将此字段填为"DateTime",在屏幕上就会显示
        // 2018年4月23日16:49:15
        public float               fPitch;                     // 字符间距, 0.0 ~ 5.0
        public byte[]               szFontType=new byte[NET_COMMON_STRING_64]; // 字体类型
    };

    // 拼接区底图信息
    public static class NET_SCREEEN_BACKGROUD extends SdkStructure
    {
        public Boolean            bEnable;                        // 底图是否开启
        public byte[]            szName=new byte[130];                    // 底图名称,底图是已经上传的文件，不带路径名称
        public byte[]             byReserved=new byte[130];                // 保留字节用
    } ;

    // 区块收藏
    public static class NET_BLOCK_COLLECTION extends SdkStructure
    {
        public int                	 			  dwSize;
        public int        			  			  emSplitMode;                      						  // 分割模式，对应  NET_SPLIT_MODE
        public NET_WINDOW_COLLECTION[] 			  stuWnds       = new NET_WINDOW_COLLECTION[NET_MAX_SPLIT_WINDOW];  // 窗口信息数组
        public int                   			  nWndsCount;                    							  // 窗口数量
        public byte[]                			  szName        = new byte[NET_DEVICE_NAME_LEN];    		  // 收藏夹名称
        public int                   			  nScreen;                       							  // 输出通道号, 包括拼接屏
        public byte[]                  			  szCompositeID = new byte[NET_DEV_ID_LEN_EX]; 				  // 拼接屏ID
        public Pointer  		  				  pstuWndsEx;                  							      // 窗口信息数组指针 NET_WINDOW_COLLECTION[] , 由用户分配内存. 当stuWnds数组大小不够用时可以使用
        public int                  			  nMaxWndsCountEx;               							  // 最大窗口数量, 用户填写. pstuWndsEx数组的元素个数
        public int                  			  nRetWndsCountEx;               							  // 返回窗口数量
        public int                   nSplitOsdCount;               // OSD的个数
        public NET_SPLIT_OSD[]         stuSplitOsd=new NET_SPLIT_OSD[20];              // 拼接区OSD叠加信息，
        public NET_SCREEEN_BACKGROUD stuScreenBackground;          // 拼接区底图信息，目前仅预案获取时使用

        public NET_BLOCK_COLLECTION() {
            this.dwSize = this.size();
            for (int i = 0; i < stuWnds.length; ++i) {
                stuWnds[i] = new NET_WINDOW_COLLECTION();
            }
        }
    }

    // 电视墙显示单元
    public static class NET_MONITORWALL_OUTPUT extends SdkStructure
    {
        public int               dwSize;
        public byte[]            szDeviceID = new byte[NET_DEV_ID_LEN];          // 设备ID, 本机时为""
        public int               nChannel;                           		     // 通道号
        public byte[]            szName 	= new byte[NET_DEV_NAME_LEN];        // 屏幕名称
        public boolean			 bIsVirtual;							// 是否是虚拟屏（虚拟屏表示在本设备上不存在的屏）TRUE:虚拟屏 FALSE:非虚拟屏
        public byte[]			 szAddress=new byte[40];						// 归属设备地址IP
        public NET_MONITOR_WALL_OUT_MODE_INFO	stuOutMode;				// 输出模式信息
        public NET_MONITORWALL_OUTPUT() {
            this.dwSize = this.size();
        }
    }

    // 电视墙显示区块
    public static class NET_MONITORWALL_BLOCK extends SdkStructure
    {
        public int               dwSize;
        public byte[]            szName 	   = new byte[NET_DEV_NAME_LEN];   // 区块名称
        public byte[]            szCompositeID = new byte[NET_DEV_ID_LEN];     // 拼接屏ID
        public byte[]            szControlID   = new byte[NET_DEV_ID_LEN];     // 控制ID
        public int               nSingleOutputWidth;             			   // 单个显示单元所占的网格列数
        public int               nSingleOutputHeight;            			   // 单个显示单元所占的网格行数
        public DH_RECT           stuRect;                        			   // 区域坐标
        public NET_TSECT_WEEK_DAY[]   stuPowerSchedule = (NET_TSECT_WEEK_DAY[])new NET_TSECT_WEEK_DAY().toArray(NET_TSCHE_DAY_NUM); // 开机时间表, 第一维各元素表示周日~周六和节假日
        public Pointer			 pstuOutputs;                				   // 显示单元数组 NET_MONITORWALL_OUTPUT[] , 用户分配内存
        public int               nMaxOutputCount;                			   // 显示单元数组大小, 用户填写
        public int               nRetOutputCount;                			   // 返回的显示单元数量
        public byte[]            szBlockType = new byte[NET_COMMON_STRING_32]; // 显示单元组类型,为支持由接收卡组成单元的小间距LED区块而增加该字段,其他类型
        public int				 nOutputDelay;					// 输出延迟,单位：毫秒
        public NET_MONITORWALL_BLOCK() {
            this.dwSize = this.size();
        }
    }

    public static class NET_TSECT_WEEK_DAY extends SdkStructure
    {
        public NET_TSECT[]       stuPowerSchedule = (NET_TSECT[])new NET_TSECT().toArray(NET_TSCHE_SEC_NUM);
    }

    // 电视墙配置
    public static class NET_MONITORWALL extends SdkStructure
    {
        public int                dwSize;
        public byte[]             szName = new byte[NET_DEV_NAME_LEN];      // 名称
        public int                nGridLine;                      			// 网格行数
        public int                nGridColume;                   		 	// 网格列数
        public Pointer   		  pstuBlocks;              		            // 显示区块数组 NET_MONITORWALL_BLOCK[] , 用户分配内存
        public int                nMaxBlockCount;                 			// 显示区块数组大小, 用户填写
        public int                nRetBlockCount;                 			// 返回的显示区块数量
        public int                bDisable;                       			// 是否禁用, 0-该电视墙有效, 1-该电视墙无效
        public byte[]             szDesc = new byte[NET_COMMON_STRING_256]; // 电视墙描述信息

        public NET_MONITORWALL() {
            this.dwSize = this.size();
        }
    }

    // 电视墙预案
    public static class NET_MONITORWALL_COLLECTION extends SdkStructure
    {
        public int                	  dwSize;
        public byte[]                 szName 	  = new byte[NET_DEVICE_NAME_LEN];    			// 电视墙预案名称
        public NET_BLOCK_COLLECTION[] stuBlocks	  = new NET_BLOCK_COLLECTION[NET_MAX_BLOCK_NUM];// 区块数组
        public int                 	  nBlocksCount;                  							// 区块数量
        public byte[]                 szControlID = new byte[NET_DEV_ID_LEN_EX]; 				// 控制ID
        public NET_MONITORWALL        stuMonitorWall;                							// 电视墙配置
        public int                    emType;                                                   // 预案类型
        public byte[]                 byReserved=new byte[4];                                   // 保留字节用，于字节对齐
        public NET_MONITORWALL_COLLECTION() {
            this.dwSize = this.size();

            for(int i = 0; i < NET_MAX_BLOCK_NUM; i++) {
                stuBlocks[i] = new NET_BLOCK_COLLECTION();
            }
        }
    }

    // CLIENT_GetMonitorWallCollections接口输入参数(获取电视墙预案信息)
    public static class NET_IN_WM_GET_COLLECTIONS extends SdkStructure
    {
        public int                	dwSize;
        public int                  nMonitorWallID;                // 电视墙ID

        public NET_IN_WM_GET_COLLECTIONS() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_GetMonitorWallCollections接口输出参数(获取电视墙预案信息)
    public static class NET_OUT_WM_GET_COLLECTIONS extends SdkStructure
    {
        public int                   dwSize;
        public Pointer			   	 pCollections;  		      // 电视墙预案数组, 对应   NET_MONITORWALL_COLLECTION 指针
        public int                   nMaxCollectionsCount;   	  // 电视墙预案数组大小
        public int                   nCollectionsCount;      	  // 电视墙预案数量

        public NET_OUT_WM_GET_COLLECTIONS() {
            this.dwSize = this.size();
        }
    }

    // 级联权限验证信息
    public static class SDK_CASCADE_AUTHENTICATOR extends SdkStructure
    {
        public int                  dwSize;
        public byte[]               szUser	   = new byte[NET_NEW_USER_NAME_LENGTH];    // 用户名
        public byte[]               szPwd  	   = new byte[NET_NEW_USER_PSW_LENGTH];     // 密码
        public byte[]               szSerialNo = new byte[NET_SERIALNO_LEN];        	// 设备序列号

        public SDK_CASCADE_AUTHENTICATOR() {
            this.dwSize = this.size();
        }
    }


    public static class EM_SRC_PUSHSTREAM_TYPE extends SdkStructure
    {
        public static final int EM_SRC_PUSHSTREAM_AUTO			= 0;       // 设备端根据码流头自动识别，默认值
        public static final int EM_SRC_PUSHSTREAM_HIKVISION		= 1;       // 海康私有码流
        public static final int EM_SRC_PUSHSTREAM_PS			= 2;       // PS流
        public static final int EM_SRC_PUSHSTREAM_TS			= 3;       // TS流
        public static final int EM_SRC_PUSHSTREAM_SVAC			= 4;       // SVAC码流
    }

    // 显示源
    public static class NET_SPLIT_SOURCE extends SdkStructure
    {
        public int               	dwSize;
        public int                  bEnable;                                	// 使能
        public byte[]               szIp 	= new byte[NET_MAX_IPADDR_LEN]; 	// IP, 空表示没有设置
        public byte[]               szUser  = new byte[NET_USER_NAME_LENGTH];	// 用户名, 建议使用szUserEx
        public byte[]               szPwd 	= new byte[NET_USER_PSW_LENGTH]; 	// 密码, 建议使用szPwdEx
        public int                  nPort;                                  	// 端口
        public int                  nChannelID;                             	// 通道号
        public int                  nStreamType;                            	// 视频码流, -1-自动, 0-主码流, 1-辅码流1, 2-辅码流2, 3-辅码流3, 4-snap, 5-预览
        public int                  nDefinition;                            	// 清晰度, 0-标清, 1-高清
        public int  				emProtocol;                             	// 协议类型,对应   NET_DEVICE_PROTOCOL
        public byte[]               szDevName  = new byte[NET_DEVICE_NAME_LEN]; // 设备名称
        public int                  nVideoChannel;                          	// 视频输入通道数
        public int                  nAudioChannel;                          	// 音频输入通道数
        //--------------------------------------------------------------------------------------
        // 以下只对解码器有效
        public int                 bDecoder;                                	// 是否是解码器
        public byte                byConnType;                              	// -1: auto, 0：TCP；1：UDP；2：组播
        public byte                byWorkMode;                              	// 0：直连；1：转发
        public short               wListenPort;                             	// 指示侦听服务的端口,转发时有效; byConnType为组播时,则作为多播端口
        public byte[]              szDevIpEx  = new byte[NET_MAX_IPADDR_OR_DOMAIN_LEN]; // szDevIp扩展,前端DVR的IP地址(可以输入域名)
        public byte                bySnapMode;                              	// 抓图模式(nStreamType==4时有效) 0：表示请求一帧,1：表示定时发送请求
        public byte                byManuFactory;                           	// 目标设备的生产厂商, 具体参考EM_IPC_TYPE类
        public byte                byDeviceType;                            	// 目标设备的设备类型, 0:IPC
        public byte                byDecodePolicy;                          	// 目标设备的解码策略, 0:兼容以前
        // 1:实时等级高 2:实时等级中
        // 3:实时等级低 4:默认等级
        // 5:流畅等级高 6:流畅等级中
        // 7:流畅等级低
        //--------------------------------------------------------------------------------------
        public int                dwHttpPort;                               	// Http端口号, 0-65535
        public int                dwRtspPort;                               	// Rtsp端口号, 0-65535
        public byte[]             szChnName  = new byte[NET_DEVICE_NAME_LEN];   // 远程通道名称, 只有读取到的名称不为空时才可以修改该通道的名称
        public byte[]             szMcastIP  = new byte[NET_MAX_IPADDR_LEN];    // 多播IP地址, byConnType为组播时有效
        public byte[]             szDeviceID = new byte[NET_DEV_ID_LEN_EX];     // 设备ID, ""-null, "Local"-本地通道, "Remote"-远程通道, 或者填入具体的RemoteDevice中的设备ID
        public int                bRemoteChannel;                           	// 是否远程通道(只读)
        public int        		  nRemoteChannelID;                         	// 远程通道ID(只读), bRemoteChannel=TRUE时有效
        public byte[]             szDevClass = new byte[NET_DEV_TYPE_LEN];  	// 设备类型, 如IPC, DVR, NVR等
        public byte[]             szDevType  = new byte[NET_DEV_TYPE_LEN];  	// 设备具体型号, 如IPC-HF3300
        public byte[]             szMainStreamUrl = new byte[MAX_PATH];     	// 主码流url地址, byManuFactory为NET_IPC_OTHER时有效
        public byte[]             szExtraStreamUrl = new byte[MAX_PATH];    	// 辅码流url地址, byManuFactory为NET_IPC_OTHER时有效
        public int                nUniqueChannel;                           	// 设备内统一编号的唯一通道号, 只读
        public SDK_CASCADE_AUTHENTICATOR stuCascadeAuth;                   	// 级联认证信息, 设备ID为"Local/Cascade/SerialNo"时有效, 其中SerialNo是设备序列号
        public int                nHint;                                    	// 0-普通视频源, 1-报警视频源
        public int                nOptionalMainUrlCount;                    	// 备用主码流地址数量
        public byte[]             szOptionalMainUrls = new byte[NET_MAX_OPTIONAL_URL_NUM * MAX_PATH];  // 备用主码流地址列表
        public int                nOptionalExtraUrlCount;                   	// 备用辅码流地址数量
        public byte[]             szOptionalExtraUrls = new byte[NET_MAX_OPTIONAL_URL_NUM * MAX_PATH]; // 备用辅码流地址列表
        //--------------------------------------------------------------------------------------
        //协议后续添加字段
        public int                nInterval;                                	// 轮巡时间间隔   单位：秒
        public byte[]             szUserEx = new byte[NET_NEW_USER_NAME_LENGTH];// 用户名
        public byte[]             szPwdEx  = new byte[NET_NEW_USER_PSW_LENGTH]; // 密码
        public int  			  emPushStream;          			        	// 推流方式的码流类型,只有byConnType为TCP-Push或UDP-Push才有该字段,对应  EM_SRC_PUSHSTREAM_TYPE
        public NET_RECT			  stuSRect;										// 视频源区域,当szDeviceID不为空时有效
        public NET_SOURCE_STREAM_ENCRYPT stuSourceStreamEncrypt;           // 码流加密方式
        public byte[]                szSerialNo=new byte[NET_SERIALNO_LEN];            // 设备序列号,当连接设备的协议类型为云睿接入，该字段必填

        public NET_SPLIT_SOURCE() {
            this.dwSize = this.size();
        }
    }

    // 显示源码流加密方式
    public static class NET_SOURCE_STREAM_ENCRYPT extends SdkStructure
    {
        public int            emEncryptLevel;         // 加密等级
        public int            emAlgorithm;            // 加密算法
        public int            emExchange;             // 密钥交换方式
        public Boolean        bUnvarnished;           // MTS使用场景,true为交互MIKEY后让数据不进行加/解密
        public byte[]         szPSK=new byte[1032];            // 密钥
        public byte[]         byReserved=new byte[1024];       // 保留字节
    };

    // 矩阵子卡信息
    public static class NET_MATRIX_CARD extends SdkStructure
    {
        public int               dwSize;
        public int               bEnable;                                // 是否有效
        public int               dwCardType;                             // 子卡类型
        public byte[]            szInterface = new byte[NET_MATRIX_INTERFACE_LEN];   // 信号接口类型, "CVBS", "VGA", "DVI"...
        public byte[]            szAddress   = new byte[NET_MAX_IPADDR_OR_DOMAIN_LEN]; // 设备ip或域名, 无网络接口的子卡可以为空
        public int               nPort;                                  // 端口号, 无网络接口的子卡可以为0
        public int               nDefinition;                            // 清晰度, 0=标清, 1=高清
        public int               nVideoInChn;                            // 视频输入通道数
        public int               nAudioInChn;                            // 音频输入通道数
        public int               nVideoOutChn;                           // 视频输出通道数
        public int               nAudioOutChn;                           // 音频输出通道数
        public int               nVideoEncChn;                           // 视频编码通道数
        public int               nAudioEncChn;                           // 音频编码通道数
        public int               nVideoDecChn;                           // 视频解码通道数
        public int               nAudioDecChn;                           // 音频解码通道数
        public int               nStauts;                                // 状态: -1-未知, 0-正常, 1-无响应, 2-网络掉线, 3-冲突, 4-正在升级, 5-链路状态异常, 6-子板背板未插好, 7-程序版本出错
        public int               nCommPorts;                             // 串口数
        public int               nVideoInChnMin;                         // 视频输入通道号最小值
        public int               nVideoInChnMax;                         // 视频输入通道号最大值
        public int               nAudioInChnMin;                         // 音频输入通道号最小值
        public int               nAudioInChnMax;                         // 音频输入通道号最大值
        public int               nVideoOutChnMin;                        // 视频输出通道号最小值
        public int               nVideoOutChnMax;                        // 视频输出通道号最大值
        public int               nAudioOutChnMin;                        // 音频输出通道号最小值
        public int               nAudioOutChnMax;                        // 音频输出通道号最大值
        public int               nVideoEncChnMin;                        // 视频编码通道号最小值
        public int               nVideoEncChnMax;                        // 视频编码通道号最大值
        public int               nAudioEncChnMin;                        // 音频编码通道号最小值
        public int               nAudioEncChnMax;                        // 音频编码通道号最大值
        public int               nVideoDecChnMin;                        // 视频解码通道号最小值
        public int               nVideoDecChnMax;                        // 视频解码通道号最大值
        public int               nAudioDecChnMin;                        // 音频解码通道号最小值
        public int               nAudioDecChnMax;                        // 音频解码通道号最大值
        public int               nCascadeChannels;                       // 级联通道数
        public int               nCascadeChannelBitrate;                 // 级联通道带宽, 单位Mbps
        public int               nAlarmInChnCount;                       // 报警输入通道数
        public int               nAlarmInChnMin;                         // 报警输入通道号最小值
        public int               nAlarmInChnMax;                         // 报警输入通道号最大值
        public int               nAlarmOutChnCount;                      // 报警输出通道数
        public int               nAlarmOutChnMin;                        // 报警输入通道号最小值
        public int               nAlarmOutChnMax;                        // 报警输入通道号最大值
        public int               nVideoAnalyseChnCount;                  // 智能分析通道数
        public int               nVideoAnalyseChnMin;                    // 智能分析通道号最小值
        public int               nVideoAnalyseChnMax;                    // 智能分析通道号最大值
        public int               nCommPortMin;                           // 串口号最小值
        public int               nCommPortMax;                           // 串口号最大值
        public byte[]            szVersion 	   = new byte[NET_COMMON_STRING_32];    // 版本信息
        public NET_TIME          stuBuildTime;                           // 编译时间
        public byte[]            szBIOSVersion = new byte[NET_COMMON_STRING_64];    // BIOS版本号
        public byte[]			 szMAC         = new byte[NET_MACADDR_LEN];			// MAC地址

        public NET_MATRIX_CARD() {
            this.dwSize = this.size();
        }
    }

    // 矩阵子卡列表
    public static class NET_MATRIX_CARD_LIST extends SdkStructure
    {
        public int               dwSize;
        public int               nCount;                                 				  // 子卡数量
        public NET_MATRIX_CARD[] stuCards = new NET_MATRIX_CARD[NET_MATRIX_MAX_CARDS];    // 子卡列表

        public NET_MATRIX_CARD_LIST() {
            this.dwSize = this.size();
            for(int i = 0; i < NET_MATRIX_MAX_CARDS; i++) {
                stuCards[i] = new NET_MATRIX_CARD();
            }
        }
    }

    // CLIENT_FindFramInfo 接口输入参数
    public static class NET_IN_FIND_FRAMEINFO_PRAM extends SdkStructure
    {
        public int                 dwSize;                   // 结构体大小
        public boolean             abFileName;               // 文件名是否作为有效的查询条件,若文件名有效,则不用填充文件信息（stRecordInfo）
        public byte[]              szFileName = new byte[MAX_PATH];     // 文件名
        public NET_RECORDFILE_INFO stuRecordInfo;            // 文件信息
        public int                 dwFramTypeMask;           // 帧类型掩码,详见“帧类型掩码定义”

        public NET_IN_FIND_FRAMEINFO_PRAM() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_FindFramInfo 接口输出参数
    public static class NET_OUT_FIND_FRAMEINFO_PRAM extends SdkStructure
    {
        public int                 dwSize;                 // 结构体大小
        public LLong          	   lFindHandle;            // 文件查找句柄

        public NET_OUT_FIND_FRAMEINFO_PRAM() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_FileStreamClearTags / CLIENT_FileStreamSetTags 接口输入参数
    public static class NET_IN_FILE_STREAM_TAGS_INFO extends SdkStructure
    {
        public int				   dwSize;					// 结构体大小
        public int				   nArrayCount;				// 标签数组个数
        public Pointer			   pstuTagInfo;  			// 标签数组，各项内容关系为"且", 用户分配内存,大小为sizeof( NET_FILE_STREAM_TAG_INFO )*nArrayCount

        public NET_IN_FILE_STREAM_TAGS_INFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_FileStreamClearTags / CLIENT_FileStreamSetTags 接口输出参数
    public static class NET_OUT_FILE_STREAM_TAGS_INFO extends SdkStructure
    {
        public int				  dwSize;			       // 结构体大小

        public NET_OUT_FILE_STREAM_TAGS_INFO() {
            this.dwSize = this.size();
        }
    }

    // 标签数组
    public static class NET_FILE_STREAM_TAG_INFO extends SdkStructure
    {
        public int				dwSize;											// 结构体大小
        public NET_TIME			stuTime;										// 标签时间
        public byte[]			szContext = new byte[NET_COMMON_STRING_64];		// 标签内容，中文必须使用utf8编码
        public byte[]			szUserName = new byte[NET_COMMON_STRING_32];	// 用户名，中文必须使用utf8编码，EVS定制增加
        public byte[]			szChannelName = new byte[NET_COMMON_STRING_64]; // 通道名称，中文必须使用utf8编码，EVS定制增加
        public int 				nDuration;							            // 打标的录像持续时间，单位秒

        public NET_FILE_STREAM_TAG_INFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_FileStreamGetTags 接口输入参数
    public static class NET_IN_FILE_STREAM_GET_TAGS_INFO extends SdkStructure
    {
        public int			   dwSize;					// 结构体大小

        public NET_IN_FILE_STREAM_GET_TAGS_INFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_FileStreamGetTags 接口输出参数
    public static class NET_OUT_FILE_STREAM_GET_TAGS_INFO extends SdkStructure
    {
        public int			  dwSize;					// 结构体大小
        public int			  nMaxNumber;				// 标签数组最大个数
        public int			  nRetTagsCount;	        // 实际返回的标签信息个数
        public Pointer	 	  pstuTagInfo; 				// 标签数组  NET_FILE_STREAM_TAG_INFO_EX

        public NET_OUT_FILE_STREAM_GET_TAGS_INFO() {
            this.dwSize = this.size();
        }
    }

    // 查询到的标签信息
    public static class NET_FILE_STREAM_TAG_INFO_EX extends SdkStructure
    {
        public int				dwSize;										// 结构体大小
        public NET_TIME			stuTime;									// 标签所对于视频的时间，精确到秒
        public int				nMillisecond;								// 毫秒
        public int				nSequence;									// 视频序列号
        public byte[]			szContext = new byte[NET_COMMON_STRING_64];	// 标签内容，中文必须使用utf8编码
        public NET_TIME			stuStartTime;								// 录像文件开始时间
        public NET_TIME			stuEndTime;									// 录像文件结束时间
        public int				emType;										// 文件类型,对应   NET_FILE_STREAM_TYPE
        public byte[]			szUserName = new byte[NET_COMMON_STRING_32];	// 用户名，中文必须使用utf8编码，EVS定制增加
        public byte[]			szChannelName = new byte[NET_COMMON_STRING_64]; // 通道名称，中文必须使用utf8编码，EVS定制增加
        public int				nDuration;								   // 打标的录像持续时间，单位秒

        public NET_FILE_STREAM_TAG_INFO_EX() {
            this.dwSize = this.size();
        }
    }

    // 文件类型
    public static class NET_FILE_STREAM_TYPE extends SdkStructure
    {
        public static final int NET_FILE_STREAM_TYPE_UNKNOWN   = 0;			// 未知
        public static final int NET_FILE_STREAM_TYPE_NORMAL    = 1;			// 普通
        public static final int NET_FILE_STREAM_TYPE_ALARM     = 2;			// 报警
        public static final int NET_FILE_STREAM_TYPE_DETECTION = 3;			// 动检
    }

    // 一屏幕的分割模式信息， CLIENT_GetSplitMode/CLIENT_SetSplitMode参数
    public static class NET_SPLIT_MODE_INFO extends SdkStructure
    {
        public int               dwSize;
        public int               emSplitMode;            // 分割模式, NET_SPLIT_MODE
        public int               nGroupID;               // 分组序号
        public int               dwDisplayType;          // 显示类型；具体见NET_SPLIT_DISPLAY_TYPE（注释各模式下显示内容由"PicInPic"决定, 各模式下显示内容按NVD旧有规则决定（即DisChn字段决定）。兼容,没有这一个项时,默认为普通显示类型,即"General"）

        public NET_SPLIT_MODE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 分割能力， CLIENT_GetSplitCaps 参数
    public static class NET_SPLIT_CAPS extends SdkStructure
    {
        public int               dwSize;
        public int               nModeCount;                                     	// 支持的分割模式数量
        public int[]             emSplitMode = new int[NET_MAX_SPLIT_MODE_NUM];  	// 支持的分割模式, 见 NET_SPLIT_MODE
        public int               nMaxSourceCount;                        		 	// 最大显示源配置数
        public int               nFreeWindowCount;                       		 	// 支持的最大自由开窗数目
        public int               bCollectionSupported;                   		 	// 是否支持区块收藏, BOOL类型，0或1
        public int               dwDisplayType;                         		 	// 掩码表示多个显示类型,具体见NET_SPLIT_DISPLAY_TYPE（注释各模式下显示内容由"PicInPic"决定, 各模式下显示内容按NVD旧有规则决定（即DisChn字段决定）。兼容,没有这一个项时,默认为普通显示类型,即"General"）
        public int               nPIPModeCount;                          		 	// 画中画支持的分割模式数量
        public int[]             emPIPSplitMode = new int[NET_MAX_SPLIT_MODE_NUM];  // 画中画支持的分割模式, 见 NET_SPLIT_MODE
        public int[]             nInputChannels = new int[NET_SPLIT_INPUT_NUM];     // 支持的输入通道
        public int               nInputChannelCount;                     			// 支持的输入通道个数, 0表示没有输入通道限制
        public int               nBootModeCount;                         			// 启动分割模式数量
        public int[]             emBootMode = new int[NET_MAX_SPLIT_MODE_NUM];      // 支持的启动默认画面分割模式, 见 NET_SPLIT_MODE

        public NET_SPLIT_CAPS() {
            this.dwSize = this.size();
        }
    }

    // (设置显示源, 支持同时设置多个窗口)CLIENT_SplitSetMultiSource 接口的输入参数
    public static class NET_IN_SPLIT_SET_MULTI_SOURCE extends SdkStructure
    {
        public int              	dwSize;
        public int  				emCtrlType;         // 视频输出控制方式,见 EM_VIDEO_OUT_CTRL_TYPE
        public int              	nChannel;           // 视频输出逻辑通道号, emCtrlType为EM_VIDEO_OUT_CTRL_CHANNEL时有效
        public String            	pszCompositeID;     // 拼接屏ID, emCtrlType为EM_VIDEO_OUT_CTRL_COMPOSITE_ID时有效
        public int               	bSplitModeEnable;   // 是否改变分割模式, BOOL类型，0或1
        public int               	emSplitMode;        // 分割模式, bSplitModeEnable=TRUE时有效,见 NET_SPLIT_MODE
        public int               	nGroupID;           // 分割分组号, bSplitModeEnable=TRUE时有效
        public Pointer             	pnWindows;          // 窗口号数组 int[],由用户申请内存，大小为sizeof(int)*nWindowCount
        public int               	nWindowCount;       // 窗口数量
        public Pointer	   		    pstuSources;        // 视频源信息, 分别对应每个窗口, 数量同窗口数  NET_SPLIT_SOURCE[] ,由用户申请内存，大小为sizeof(NET_SPLIT_SOURCE)*nWindowCount

        public NET_IN_SPLIT_SET_MULTI_SOURCE() {
            this.dwSize = this.size();
        }
    }

    // (设置显示源, 支持同时设置多个窗口) CLIENT_SplitSetMultiSource 接口的输出参数
    public static class NET_OUT_SPLIT_SET_MULTI_SOURCE extends SdkStructure
    {
        public int                  dwSize;

        public NET_OUT_SPLIT_SET_MULTI_SOURCE() {
            this.dwSize = this.size();
        }
    }

    // (下位矩阵切换) CLIENT_MatrixSwitch 输入参数
    public static class NET_IN_MATRIX_SWITCH extends SdkStructure
    {
        public int           dwSize;
        public int           emSplitMode;                // 分割模式,见 NET_SPLIT_MODE
        public Pointer       pnOutputChannels;           // 输出通道, 可同时指定多个输出通道一起切换, 内容一致
        // 由用户申请内存 int[] ，大小为sizeof(int)*nOutputChannelCount
        public int           nOutputChannelCount;        // 输出通道数
        public Pointer       pnInputChannels;            // 输入通道, 每个分割窗口一个对应一个输入通道
        // 由用户申请内存 int[] ，大小为sizeof(int)*nInputChannelCount
        public int           nInputChannelCount;         // 输入通道数

        public NET_IN_MATRIX_SWITCH() {
            this.dwSize = this.size();
        }
    }

    // (下位矩阵切换) CLIENT_MatrixSwitch 输出参数
    public static class NET_OUT_MATRIX_SWITCH extends SdkStructure
    {
        public int            dwSize;

        public NET_OUT_MATRIX_SWITCH() {
            this.dwSize = this.size();
        }
    }

    // 刻录模式
    public static class NET_BURN_MODE extends SdkStructure
    {
        public static final int BURN_MODE_SYNC 	= 0;                    // 同步
        public static final int BURN_MODE_TURN 	= 1;                    // 轮流
        public static final int BURN_MODE_CYCLE = 2;                    // 循环
    }

    // 刻录流格式
    public static class NET_BURN_RECORD_PACK extends SdkStructure
    {
        public static final int BURN_PACK_DHAV = 0;                     // DHAV
        public static final int BURN_PACK_PS   = 1;                     // PS
        public static final int BURN_PACK_ASF  = 2;                     // ASF
        public static final int BURN_PACK_MP4  = 3;                     // MP4
        public static final int BURN_PACK_TS   = 4;                     // TS
    }

    // 刻录扩展模式
    public static class NET_BURN_EXTMODE extends SdkStructure
    {
        public static final int BURN_EXTMODE_UNKNOWN = 0;			    // 未知
        public static final int BURN_EXTMODE_NORMAL  = 1;               // 正常刻录
        public static final int BURN_EXTMODE_NODISK  = 2;               // 无盘刻录
    }

    // (开始刻录) CLIENT_StartBurn 接口输入参数
    public static class NET_IN_START_BURN extends SdkStructure
    {
        public int             dwSize;
        public int             dwDevMask;                             // 刻录设备掩码, 按位表示多个刻录设备组合
        public int[]           nChannels = new int[NET_MAX_BURN_CHANNEL_NUM];    // 刻录通道数组
        public int             nChannelCount;                         // 刻录通道数
        public int             emMode;                                // 刻录模式,见  NET_BURN_MODE
        public int             emPack;                                // 刻录流格式,见  NET_BURN_RECORD_PACK
        public int   		   emExtMode;                             // 刻录扩展模式, 见  NET_BURN_EXTMODE

        public NET_IN_START_BURN() {
            this.dwSize = this.size();
        }
    }

    // (开始刻录)CLIENT_StartBurn 接口输出参数
    public static class NET_OUT_START_BURN extends SdkStructure
    {
        public int               dwSize;

        public NET_OUT_START_BURN() {
            this.dwSize = this.size();
        }
    }

    // (打开会话)CLIENT_StartBurnSession 接口输入参数
    public static class NET_IN_START_BURN_SESSION extends SdkStructure
    {
        public int              dwSize;
        public int              nSessionID;                         // 会话ID

        public NET_IN_START_BURN_SESSION() {
            this.dwSize = this.size();
        }
    }

    // (打开会话)CLIENT_StartBurnSession 接口输出参数
    public static class NET_OUT_START_BURN_SESSION extends SdkStructure
    {
        public int               dwSize;

        public NET_OUT_START_BURN_SESSION() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_ControlDevice接口的 CTRLTYPE_CTRL_EJECT_BURNER、CTRLTYPE_CTRL_CLOSE_BURNER 等 命令参数
    public static class NET_CTRL_BURNERDOOR extends SdkStructure
    {
        public int                dwSize;
        public Pointer         	  szBurnerName;                       // 光盘名称,如“/dev/sda”, 用户申请内存
        public int                bResult;                            // 操作结果
        public int                bSafeEject;                         // 是否安全弹出光驱, 1-弹出前做数据保存, 0-直接弹出

        public NET_CTRL_BURNERDOOR() {
            this.dwSize = this.size();
        }
    }

    // 光驱托盘状态
    public static class EM_NET_BURN_DEV_TRAY_TYPE extends SdkStructure
    {
        public static final int EM_NET_BURN_DEV_TRAY_TYPE_UNKNOWN = 0;                     // 未知
        public static final int EM_NET_BURN_DEV_TRAY_TYPE_READY   = 1;                     // 光盘就绪
        public static final int EM_NET_BURN_DEV_TRAY_TYPE_OPEN  = 2;                       // 托盘弹出
        public static final int EM_NET_BURN_DEV_TRAY_TYPE_NODISK  = 3;                     // 无盘
        public static final int EM_NET_BURN_DEV_TRAY_TYPE_NOT_READY   = 4;                 // 光盘未就绪
    }

    // 光驱使用状态
    public static class EM_NET_BURN_DEV_OPERATE_TYPE extends SdkStructure
    {
        public static final int EM_NET_BURN_DEV_OPERATE_TYPE_UNKNOWN = 0;                     // 未知
        public static final int EM_NET_BURN_DEV_OPERATE_TYPE_WRITE   = 1;                     // 执行写
        public static final int EM_NET_BURN_DEV_OPERATE_TYPE_READ  = 2;                       // 执行读
        public static final int EM_NET_BURN_DEV_OPERATE_TYPE_IDLE  = 3;                       // 空闲
    }

    // 刻录机信息
    public static class NET_DEV_BURNING extends SdkStructure
    {
        public int               dwDriverType;               // 刻录驱动器类型；0：DHFS,1：DISK,2：CDRW
        public int               dwBusType;                  // 总线类型；0：USB,1：1394,2：IDE, 3: SATA, 4: ESATA
        public int               dwTotalSpace;               // 总容量(KB)
        public int               dwRemainSpace;              // 剩余容量(KB)
        public byte[]            dwDriverName = new byte[NET_BURNING_DEV_NAMELEN];    // 刻录驱动器名称
        public int  			 emTrayType;			     // 光驱托盘状态, 详见EM_NET_BURN_DEV_TRAY_TYPE
        public int 				 emOperateType;			     // 光盘使用状态, 详见EM_NET_BURN_DEV_OPERATE_TYPE
    }

    // 设备刻录机信息
    public static class NET_BURNING_DEVINFO extends SdkStructure
    {
        public int               	dwDevNum;                           // 刻录设备个数
        public NET_DEV_BURNING[]    stuList = (NET_DEV_BURNING[])new NET_DEV_BURNING().toArray(NET_MAX_BURNING_DEV_NUM); // 各刻录设备信息
    }

    // CLIENT_AttachBurnState()输入参数
    public static class NET_IN_ATTACH_STATE extends SdkStructure
    {
        public int                   dwSize;
        public Pointer             	 szDeviceName;                  // 光盘名称,如"/dev/sda"
        public fAttachBurnStateCB    cbAttachState;                 // 刻录监听回调
        public Pointer               dwUser;                        // 用户数据
        public LLong                 lBurnSession;                  // 刻录会话句柄, CLIENT_StartBurnSession的返回值. 该值为0时, szDeviceName有效, 此时按刻录设备订阅刻录状态
        public fAttachBurnStateCBEx  cbAttachStateEx;               // 扩展刻录监听回调
        public Pointer               dwUserEx;                      // 扩展刻录监听回调用户数据

        public NET_IN_ATTACH_STATE() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_AttachBurnState 输出参数
    public static class NET_OUT_ATTACH_STATE extends SdkStructure
    {
        public int                   dwSize;

        public NET_OUT_ATTACH_STATE() {
            this.dwSize = this.size();
        }
    }

    //CLIENT_StartUploadFileBurned 输入参数
    public static class NET_IN_FILEBURNED_START extends SdkStructure{
        public int                   dwSize;
        public Pointer             	 szMode;                  		// 文件上传方式
        // "append", 追加模式,此时刻录文件名固定为" FILE.zip ",filename被忽略
        // "evidence", 证据等大附件, 要求单独刻录的光盘内
        public Pointer             	 szDeviceName;                  // 光盘名称,如"/dev/sda"
        public Pointer             	 szFilename;   					// 本地文件名称
        public fBurnFileCallBack     cbBurnPos;                 	// 刻录进度回调
        public Pointer               dwUser;                        // 用户数据
        public LLong                 lBurnSession;                  // 刻录会话句柄, CLIENT_StartBurnSession的返回值. 该值为0时, szDeviceName有效, 此时按刻录设备订阅刻录状态


        public NET_IN_FILEBURNED_START() {
            this.dwSize = this.size();
        }
    }

    //CLIENT_StartUploadFileBurned 输出参数
    public static class NET_OUT_FILEBURNED_START extends SdkStructure{
        public int                   dwSize;
        public byte[]				 szState = new byte[MAX_COMMON_STRING_16];  //char[]
        // "start"：系统准备就绪,可以开始上传; "busy"：系统忙,稍后在试。"error"：系统未在刻录中,返回出错,请求失败
        public NET_OUT_FILEBURNED_START() {
            this.dwSize = this.size();
        }
    }

    // fAttachBurnStateCB 参数
    public static class NET_CB_BURNSTATE extends SdkStructure
    {
        public int               	dwSize;
        public Pointer         		szState;                        // 消息类型
        //"UploadFileStart"：可以开始附件上传
        //"InitBurnDevice":初始化刻录设备
        //"Burning":刻录中
        //"BurnExtraFileStop"：刻录停止
        //"BurnFilePause":刻录暂停
        //"SpaceFull":刻录空间满
        //"BurnFileError":刻录出错
        public Pointer         		szFileName;                     // 当前刻录附件文件名,用于"UploadFileStart"开始附件上传消息
        public int        			dwTotalSpace;                   // 总容量,单位KB,用于"Burning"刻录中,显示容量或计算进度
        public int        			dwRemainSpace;                  // 剩余容量,单位KB,用于"Burning"刻录中
        public Pointer         		szDeviceName;                   // 刻录设备名称,用于区分不同的刻录设备
        public int                  nRemainTime;                    // 刻录剩余时间, 单位秒, -1代表无效
    }

    // 刻录状态
    public static class NET_BURN_STATE extends SdkStructure
    {
        public static final int BURN_STATE_STOP = 0;                    // 停止
        public static final int BURN_STATE_STOPING = 1;                 // 停止中
        public static final int BURN_STATE_INIT = 2;                    // 初始化
        public static final int BURN_STATE_BURNING = 3;                 // 刻录中
        public static final int BURN_STATE_PAUSE = 4;                   // 暂停
        public static final int BURN_STATE_CHANGE_DISK = 5;             // 换盘中
        public static final int BURN_STATE_PREPARE_EXTRA_FILE = 6;      // 附件初始化
        public static final int BURN_STATE_WAIT_EXTRA_FILE = 7;         // 等待附件刻录
        public static final int BURN_STATE_UPLOAD_FILE_START = 8;       // 附件刻录中
        public static final int BURN_STATE_CHECKING_DISK = 9;           // 检测光盘中
        public static final int BURN_STATE_DISK_READY = 10;             // 光盘准备就绪
    }

    // 刻录错误码
    public static class NET_BURN_ERROR_CODE extends SdkStructure
    {
        public static final int BURN_CODE_NORMAL = 0;                   // 正常
        public static final int BURN_CODE_UNKNOWN_ERROR = 1;            // 未知错误
        public static final int BURN_CODE_SPACE_FULL = 2;               // 刻录满
        public static final int BURN_CODE_START_ERROR = 3;              // 开始刻录出错
        public static final int BURN_CODE_STOP_ERROR = 4;               // 停止刻录出错
        public static final int BURN_CODE_WRITE_ERROR = 5;              // 刻录出错
        public static final int BURN_CODE_UNKNOWN = 6;					// 未知
    }

    // CLIENT_BurnGetState 接口输入参数
    public static class NET_IN_BURN_GET_STATE extends SdkStructure
    {
        public int                dwSize;

        public NET_IN_BURN_GET_STATE() {
            this.dwSize = this.size();
        }
    }

    // 光驱使用状态
    public static class EM_NET_BURN_DEV_USED_STATE extends SdkStructure
    {
        public static final int EM_NET_BURN_DEV_USED_STATE_UNKNOWN = 0; //未知
        public static final int EM_NET_BURN_DEV_USED_STATE_STOP = 1;	//停止
        public static final int EM_NET_BURN_DEV_USED_STATE_BURNING = 2;	//刻录中
    }

    // 刻录设备状态
    public static class NET_BURN_DEV_STATE extends SdkStructure
    {
        public int                dwSize;
        public int                nDeviceID;                             // 光驱设备ID
        public byte[]             szDevName = new byte[NET_BURNING_DEV_NAMELEN];     // 光驱设备名称
        public int                dwTotalSpace;                          // 光驱总容量, 单位KB
        public int                dwRemainSpace;                         // 光驱剩余容量, 单位KB
        public int	              emUsedType;							 // 光驱使用状态, 详见EM_NET_BURN_DEV_USED_STATE
        public int				  emError;								 // 单个光驱出错状态, 详见NET_BURN_ERROR_CODE
        public int		          emDiskState;							// 光盘状态,EM_DISK_STATE
        public NET_BURN_DEV_STATE() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_BurnGetState 接口输出参数
    public static class NET_OUT_BURN_GET_STATE extends SdkStructure
    {
        public int                dwSize;
        public int       		  emState;                               // 刻录状态, 详见NET_BURN_STATE
        public int  			  emErrorCode;                           // 错误码, 详见NET_BURN_ERROR_CODE
        public int                dwDevMask;                             // 刻录设备掩码, 按位表示多个刻录设备组合
        public int[]              nChannels = new int[NET_MAX_BURN_CHANNEL_NUM];    // 刻录通道数组
        public int                nChannelCount;                         // 刻录通道数
        public int        		  emMode;                                // 刻录模式, 详见NET_BURN_MODE
        public int 				  emPack;                                // 刻录流格式, 详见NET_BURN_RECORD_PACK
        public int                nFileIndex;                            // 当前刻录文件编号
        public NET_TIME           stuStartTime;                          // 刻录开始时间
        public NET_BURN_DEV_STATE[] stuDevState = (NET_BURN_DEV_STATE[])new NET_BURN_DEV_STATE().toArray(NET_MAX_BURNING_DEV_NUM); // 刻录设备状态
        public int                nRemainTime;                           // 刻录剩余时间, 单位秒, -1代表无效
        public int	 			  emExtMode;							 // 扩展模式,当为无盘刻录时，stuDevState可能无效, 详见NET_BURN_EXTMODE

        public NET_OUT_BURN_GET_STATE() {
            this.dwSize = this.size();
        }
    }

    // 雷达监测超速报警事件 智能楼宇专用 ( NET_ALARM_RADAR_HIGH_SPEED )
    public static class ALARM_RADAR_HIGH_SPEED_INFO extends SdkStructure
    {
        public NET_TIME_EX             stuTime;  // 事件发生时间
        public float                   fSpeed;                       // 速度(单位:km/h)
        public byte[]				   szPlateNumber = new byte[16]; // 车牌
        public boolean						bRealUTC;					// RealUTC 是否有效，bRealUTC 为 TRUE 时，用 RealUTC，否则用 stuTime 字段
        public NET_TIME_EX         		RealUTC;                    // 事件发生的时间（标准UTC）
        public byte[]                   byReserved=new byte[958];			// 预留字段
    }

    // 设备巡检报警事件 智网专用 ( NET_ALARM_POLLING_ALARM )
    public static class ALARM_POLLING_ALARM_INFO extends SdkStructure
    {
        public NET_TIME_EX              stuTime;  // 事件发生时间
        public boolean					bRealUTC;					// RealUTC 是否有效，bRealUTC 为 TRUE 时，用 RealUTC，否则用 stuTime 字段
        public NET_TIME_EX         		RealUTC;                    // 事件发生的时间（标准UTC）
        public byte[]                   byReserved=new byte[974];            // 预留字段
    }

    // 门禁事件 ALARM_ACCESS_CTL_EVENT
    public static class ALARM_ACCESS_CTL_EVENT_INFO extends SdkStructure {
        public int                      dwSize;
        public int                      nDoor;                              // 门通道号
        public byte[]                   szDoorName = new byte[NET_MAX_DOORNAME_LEN];    // 门禁名称
        public NET_TIME                 stuTime;                            // 报警事件发生的时间
        public int   					emEventType;                        // 门禁事件类型 参考 NET_ACCESS_CTL_EVENT_TYPE
        public int                      bStatus;                            // 刷卡结果,TRUE表示成功,FALSE表示失败
        public int      				emCardType;                         // 卡类型, 参考 NET_ACCESSCTLCARD_TYPE
        public int   					emOpenMethod;                       // 开门方式, 参考 NET_ACCESS_DOOROPEN_METHOD
        public byte[]                   szCardNo = new byte[NET_MAX_CARDNO_LEN];        // 卡号
        public byte[]                   szPwd = new byte[NET_MAX_CARDPWD_LEN];          // 密码
        public byte[]                   szReaderID = new byte[NET_COMMON_STRING_32];    // 门读卡器ID
        public byte[]                   szUserID = new byte[NET_COMMON_STRING_64];      // 开门用户
        public byte[]                   szSnapURL = new byte[NET_COMMON_STRING_256];    // 抓拍照片存储地址
        public int                      nErrorCode;                         // 开门失败的原因,仅在bStatus为FALSE时有效
        // 0x00 没有错误
        // 0x10 未授权
        // 0x11 卡挂失或注销
        // 0x12 没有该门权限
        // 0x13 开门模式错误
        // 0x14 有效期错误
        // 0x15 防反潜模式
        // 0x16 胁迫报警未打开
        // 0x17 门常闭状态
        // 0x18 AB互锁状态
        // 0x19 巡逻卡
        // 0x1A 设备处于闯入报警状态
        // 0x20 时间段错误
        // 0x21 假期内开门时间段错误
        // 0x30 需要先验证有首卡权限的卡片
        // 0x40 卡片正确,输入密码错误
        // 0x41 卡片正确,输入密码超时
        // 0x42 卡片正确,输入指纹错误
        // 0x43 卡片正确,输入指纹超时
        // 0x44 指纹正确,输入密码错误
        // 0x45 指纹正确,输入密码超时
        // 0x50 组合开门顺序错误
        // 0x51 组合开门需要继续验证
        // 0x60 验证通过,控制台未授权
        public int                       nPunchingRecNo;                	// 刷卡记录集中的记录编号
        public int						 nNumbers;					    	// 抓图张数
        public int					     emStatus;		                	// 卡状态     NET_ACCESSCTLCARD_STATE
        public byte[]                    szSN = new byte[32];           	// 智能锁序列号
        public int         				 emAttendanceState;                 // 考勤状态, 参考  NET_ATTENDANCESTATE
        public byte[]                    szQRCode = new byte[512];          // 二维码
        public byte[]                    szCallLiftFloor = new byte[16];	// 呼梯楼层号
        public int						 emCardState;						// 是否为采集卡片,参考  EM_CARD_STATE
        public byte[]                    szCitizenIDNo = new byte[20];      // 身份证号
        public COMPANION_CARD[]			 szCompanionCards = new COMPANION_CARD[MAX_COMPANION_CARD_NUM]; // 陪同者卡号信息
        public int                       nCompanionCardCount;                // 陪同者卡号个数
        public int				         emHatStyle;						 // 帽子类型
        public int		                 emHatColor;						 // 帽子颜色
        public int			             emLiftCallerType;					 // 梯控方式触发者
        public int				   		 bManTemperature;					 // 人员温度信息是否有效
        public NET_MAN_TEMPERATURE_INFO	 stuManTemperatureInfo;				 // 人员温度信息, bManTemperature 为TRUE 时有效
        public byte[]					 szCitizenName = new byte[256];		 // 身份证姓名
        public int			             emMask;							 // 口罩状态（EM_MASK_STATE_UNKNOWN、EM_MASK_STATE_NOMASK、EM_MASK_STATE_WEAR 有效）参考EM_MASK_STATE_TYPE
        public byte[]					 szCardName = new byte[NET_MAX_CARDNAME_LEN];	// 卡命名
        public int						 nFaceIndex;						 // 一人脸时的人脸序号
        public int                       emUserType;						 // 用户类型( EM_USER_TYPE_ORDINARY 至 EM_USER_TYPE_DISABLED 有效 ) 参考EM_USER_TYPE
        public int						 bRealUTC;							 // RealUTC 是否有效，bRealUTC 为 TRUE 时，用 RealUTC，否则用 stuTime 字段
        public NET_TIME_EX         		 RealUTC;                            // 事件发生的时间（标准UTC）
        public byte[]					 szCompanyName = new byte[200];		 // 公司名称
        public int						 nScore;                             // 人脸质量评分
        public int						 nLiftNo;							// 电梯编号
        public int		                 emQRCodeIsExpired;					// 二维码是否过期。默认值0 (北美测温定制),EM_QRCODE_IS_EXPIRED
        public int			             emQRCodeState;						// 二维码状态(北美测试定制),EM_QRCODE_STATE
        public NET_TIME        			 stuQRCSodeValidTo;                   // 二维码截止日期
        //public byte[]					 szDynPWD=new byte[32];						// 平台通过密码校验权限。用于动态密码校验，动态密码由手机APP生成，设备仅透传给平台
        public ALARM_ACCESS_CTL_EVENT_INFO() {
            super();
            this.dwSize = this.size();
            for (int i = 0; i < szCompanionCards.length; ++i) {
                szCompanionCards[i] = new COMPANION_CARD();
            }
        }
        @Override
        public String toString() {
            return "ALARM_ACCESS_CTL_EVENT_INFO [dwSize=" + dwSize + ", nDoor="
                    + nDoor + ", szDoorName=" + Arrays.toString(szDoorName)
                    + ", stuTime=" + stuTime + ", emEventType=" + emEventType
                    + ", bStatus=" + bStatus + ", emCardType=" + emCardType
                    + ", emOpenMethod=" + emOpenMethod + ", szCardNo="
                    + Arrays.toString(szCardNo) + ", szPwd="
                    + Arrays.toString(szPwd) + ", szReaderID="
                    + Arrays.toString(szReaderID) + ", szUserID="
                    + Arrays.toString(szUserID) + ", szSnapURL="
                    + Arrays.toString(szSnapURL) + ", nErrorCode=" + nErrorCode
                    + ", nPunchingRecNo=" + nPunchingRecNo + "]";
        }
    }

    // 消警事件
    public static class ALARM_ALARMCLEAR_INFO extends SdkStructure
    {
        public int                    dwSize;
        public int             		  nChannelID;                   // 通道号
        public NET_TIME        		  stuTime;                      // 报警事件发生的时间
        public int                    bEventAction;                 // 事件动作，0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public ALARM_ALARMCLEAR_INFO() {
            this.dwSize = this.size();
        }
        @Override
        public String toString() {
            return "ALARM_ALARMCLEAR_INFO [dwSize=" + dwSize + ", nChannelID="
                    + nChannelID + ", stuTime=" + stuTime + ", bEventAction="
                    + bEventAction + "]";
        }
    }

    public static class NET_ALARM_TYPE
    {
        public static final int NET_ALARM_LOCAL = 0;                //开关量防区的报警事件(对应 NET_ALARM_ALARM_EX2 事件)
        public static final int NET_ALARM_ALARMEXTENDED = 1;        //扩展模块报警事件(对应 NET_ALARM_ALARMEXTENDED 事件)
        public static final int NET_ALARM_TEMP = 2;                 //温度报警事件(对应 NET_ALARM_TEMPERATURE 事件)
        public static final int NET_ALARM_URGENCY = 3;              //紧急报警事件(对应 NET_URGENCY_ALARM_EX 事件)
        public static final int NET_ALARM_RCEMERGENCYCALL = 4;      //紧急呼叫报警事件(对应 NET_ALARM_RCEMERGENCY_CALL 事件)
        public static final int NET_ALARM_ALL = 5;                  //所有报警事件
    }

    // CLIENT_ControlDevice 接口的 NET_CTRL_CLEAR_ALARM 命令参数
    public static class NET_CTRL_CLEAR_ALARM extends SdkStructure	{
        public int               	dwSize;
        public int                 	nChannelID;             // 防区通道号, -1 表示所有通道
        public int       			emAlarmType;            // 事件类型(支持的类型较少,建议用nEventType字段) NET_ALARM_TYPE
        public String               szDevPwd;               // 登陆设备的密码,如不使用加密消警,直接赋值为NULL
        public int                  bEventType;             // 表示是否启用nEventType字段, TRUE:nEventType代替emAlarmType字段, FALSE:沿用emAlarmType字段,忽略nEventType字段
        public int                  nEventType;             // 事件类型, 对应 fMessCallBack 回调来上的lCommand字段, 即CLIENT_StartListenEx接口获得事件类型
        // 比如NET_ALARM_ALARM_EX2表示本地报警事件
        public NET_CTRL_CLEAR_ALARM() {
            this.dwSize = this.size();
        }
        @Override
        public String toString() {
            return "NET_CTRL_CLEAR_ALARM [dwSize=" + dwSize + ", nChannelID="
                    + nChannelID + ", emAlarmType=" + emAlarmType + ", szDevPwd="
                    + szDevPwd + ", bEventType=" + bEventType + ", nEventType="
                    + nEventType + "]";
        }
    }

    // CLIENT_ControlDevice接口的 CTRLTYPE_CTRL_START_ALARMBELL / CTRLTYPE_CTRL_STOP_ALARMBELL命令参数
    public static class NET_CTRL_ALARMBELL extends SdkStructure
    {
        public int                    dwSize;
        public int                    nChannelID;                   // 通道号(0开始)

        public NET_CTRL_ALARMBELL(){
            this.dwSize = this.size();
        }
    }

    // 警灯配置(对应 CFG_CMD_ALARMLAMP)
    public static class CFG_ALARMLAMP_INFO extends SdkStructure
    {
        public int     	         emAlarmLamp;                  // 警灯状态,参考  EM_ALARMLAMP_MODE
    }

    // 警灯状态
    public static class EM_ALARMLAMP_MODE extends SdkStructure
    {
        public static final int EM_ALARMLAMP_MODE_UNKNOWN = -1;    // 未知
        public static final int EM_ALARMLAMP_MODE_OFF = 0;         // 灭
        public static final int EM_ALARMLAMP_MODE_ON = 1;          // 亮
        public static final int EM_ALARMLAMP_MODE_BLINK = 2;       // 闪烁
    }

    // 发送的通知类型,对应CLIENT_SendNotifyToDev接口
    public static class NET_EM_NOTIFY_TYPE extends SdkStructure
    {
        public static final int NET_EM_NOTIFY_PATROL_STATUS = 1;   // 发送巡更通知 (对应结构体 NET_IN_PATROL_STATUS_INFO, NET_OUT_PATROL_STATUS_INFO )
    }

    // 巡更状态
    public static class NET_EM_PATROL_STATUS extends SdkStructure
    {
        public static final int NET_EM_PATROL_STATUS_UNKNOWN = 0;  // 未知状态
        public static final int NET_EM_PATROL_STATUS_BEGIN = 1;    // 巡更开始
        public static final int NET_EM_PATROL_STATUS_END = 2;      // 巡更结束
        public static final int NET_EM_PATROL_STATUS_FAIL = 3;     // 巡更失败
    }

    // CLIENT_SendNotifyToDev 入参 (对应枚举 NET_EM_NOTIFY_PATROL_STATUS)
    public static class NET_IN_PATROL_STATUS_INFO extends SdkStructure
    {
        public int                    dwSize;                       // 结构体大小
        public int                    emPatrolStatus;               // 巡更状态,参考  NET_EM_PATROL_STATUS

        public NET_IN_PATROL_STATUS_INFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_SendNotifyToDev 出参 (对应枚举 NET_EM_NOTIFY_PATROL_STATUS)
    public static class NET_OUT_PATROL_STATUS_INFO extends SdkStructure
    {
        public int                    dwSize;                       // 结构体大小

        public NET_OUT_PATROL_STATUS_INFO() {
            this.dwSize = this.size();
        }
    }

    // 报警事件类型  NET_ALARM_TALKING_INVITE (设备请求对方发起对讲事件)对应的数据描述信息
    public static class ALARM_TALKING_INVITE_INFO extends SdkStructure
    {
        public int                    dwSize;
        public int                    emCaller;                                    // 设备希望的对讲发起方,取值参考   EM_TALKING_CALLER
        public NET_TIME               stuTime;                   				   // 事件触发时间
        public byte[]                 szCallID = new byte[NET_COMMON_STRING_64];   // 呼叫惟一标识符
        public int                    nLevel;                         			   // 表示所呼叫设备所处层级
        public TALKINGINVITE_REMOTEDEVICEINFO       stuRemoteDeviceInfo;   	       // 远端设备信息
        public boolean 							    bRealUTC;						// RealUTC 是否有效，bRealUTC 为 TRUE 时，用 RealUTC，否则用 stuTime 字段
        public NET_TIME_EX         					RealUTC;                        // 事件发生的时间（标准UTC）
        public ALARM_TALKING_INVITE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 对讲发起方
    public static class EM_TALKING_CALLER extends SdkStructure
    {
        public static final int EM_TALKING_CALLER_UNKNOWN  = 0;                   // 未知发起方
        public static final int EM_TALKING_CALLER_PLATFORM = 1;                   // 对讲发起方为平台
    }

    // Invite事件远程设备协议
    public static class TALKINGINVITE_REMOTEDEVICE_PROTOCOL extends SdkStructure
    {
        public static final int EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL_UNKNOWN   = 0;    // 未知
        public static final int EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL_HIKVISION = 1;    // 海康
    }

    // Invite事件远端设备信息
    public static class TALKINGINVITE_REMOTEDEVICEINFO extends SdkStructure
    {
        public byte[]		         szIP = new byte[MAX_REMOTEDEVICEINFO_IPADDR_LEN];	        // 设备IP
        public int	                 nPort;					                                    // 端口
        public int                   emProtocol;                                                // 协议类型,取值参考 EM_TALKINGINVITE_REMOTEDEVICE_PROTOCOL
        public byte[]		         szUser = new byte[MAX_REMOTEDEVICEINFO_USERNAME_LEN];	    // 用户名
        public byte[]		         szPassword = new byte[MAX_REMOTEDEVICEINFO_USERPSW_LENGTH];// 密码
        public byte[]                szReverse = new byte[1024];                                // 保留字段
    }

    // IO控制命令,对应 CLIENT_QueryIOControlState 接口  和  CLIENT_IOControl 接口
    public static class NET_IOTYPE extends SdkStructure
    {
        public static final int NET_ALARMINPUT = 1;                             // 控制报警输入,对应结构体为  ALARM_CONTROL
        public static final int NET_ALARMOUTPUT = 2;                            // 控制报警输出，对应结构体为  ALARM_CONTROL
        public static final int NET_DECODER_ALARMOUT = 3;                       // 控制报警解码器输出，对应结构体为  DECODER_ALARM_CONTROL
        public static final int NET_WIRELESS_ALARMOUT = 5;                      // 控制无线报警输出，对应结构体为  ALARM_CONTROL
        public static final int NET_ALARM_TRIGGER_MODE = 7;                     // 报警触发方式（手动,自动,关闭）,使用  TRIGGER_MODE_CONTROL 结构体
    }

    // 报警IO控制
    public static class ALARM_CONTROL extends SdkStructure
    {
        public short       			index;                    		// 端口序号
        public short       			state;                   	    // 端口状态，0 - 关闭，1 - 打开
    }

    // 报警解码器控制
    public static class DECODER_ALARM_CONTROL extends SdkStructure
    {
        public int                  decoderNo;               		// 报警解码器号,从0开始
        public short      			alarmChn;                		// 报警输出口,从0开始
        public short      		    alarmState;             	    // 报警输出状态；1：打开,0：关闭
    }

    // 触发方式
    public static class TRIGGER_MODE_CONTROL extends SdkStructure
    {
        public short      			index;                    		// 端口序号
        public short       			mode;                     		// 触发方式(0关闭1手动2自动);不设置的通道,sdk默认将保持原来的设置。
        public byte[]     			bReserved = new byte[28];
    }

    // 报警输出通道的状态的配置, 对应 命令  CFG_CMD_ALARMOUT
    public static class CFG_ALARMOUT_INFO extends SdkStructure
    {
        public int					nChannelID;									 // 报警通道号(0开始)
        public byte[]				szChnName = new byte[MAX_CHANNELNAME_LEN];	 // 报警通道名称
        public byte[]				szOutputType = new byte[MAX_NAME_LEN];		 // 输出类型, 用户自定义
        public int					nOutputMode;								 // 输出模式, 0-自动报警, 1-强制报警, 2-关闭报警
        public int                  nPulseDelay;                                 // 脉冲模式输出时间, 单位为秒(0-255秒)
        public int                  nSlot;                                       // 根地址, 0表示本地通道, 1表示连接在第一个串口上的扩展通道, 2、3...以此类推, -1表示无效
        public int                  nLevel1;                                     // 第一级级联地址, 表示连接在第nSlot串口上的第nLevel1个探测器或仪表, 从0开始, -1表示无效
        public byte                 abLevel2;                                    // 类型为bool, 表示nLevel2字段是否存在
        public int                  nLevel2;                                     // 第二级级联地址, 表示连接在第nLevel1个的仪表上的探测器序号, 从0开始
        public int                  emPole;                                     // 输出有效模式,EM_ALARMOUT_POLE
    }

    // 检测采集设备报警事件, 对应事件类型 NET_ALARM_SCADA_DEV_ALARM
    public static class ALARM_SCADA_DEV_INFO extends SdkStructure
    {
        public int                   dwSize;
        public int                   nChannel;                                       // 通道号
        public NET_TIME              stuTime;                       // 事件发生的时间
        public byte[]                szDevName = new byte[NET_COMMON_STRING_64];     // 故障设备名称
        public byte[]                szDesc = new byte[NET_COMMON_STRING_256];       // 报警描述
        public int                   nAction;                            			 // -1:未知 0:脉冲 1:开始 2:停止
        public byte[]                szID = new byte[NET_COMMON_STRING_32];          // 点位ID, 目前使用16字节
        public byte[]                szSensorID = new byte[NET_COMMON_STRING_32];    // 探测器ID, 目前使用16字节
        public byte[]                szDevID = new byte[NET_COMMON_STRING_32];       // 设备ID, 目前使用16字节
        public byte[]                szPointName = new byte[NET_COMMON_STRING_64];   // 点位名,与点表匹配
        public int                   nAlarmFlag;                         			 // 0:开始, 1:结束
        public int                   emDevType;                            			// 设备类型，详见EM_ALARM_SCADA_DEV_TYPE
        public int                   emDevStatus;                          			// 设备状态，详见EM_SCADA_DEVICE_STATUS

        public ALARM_SCADA_DEV_INFO() {
            this.dwSize = this.size();
        }
    }

    //SCADA类型
    public static class EM_ALARM_SCADA_DEV_TYPE extends SdkStructure
    {
        public static final int EM_ALARM_SCADA_DEV_UNKNOWN           = 0;   // 未知
        public static final int EM_ALARM_SCADA_DEV_LEAKAGE           = 1;   // 漏水检测
        public static final int EM_ALARM_SCADA_DEV_THCONTROLLER      = 2;   // 湿温度
        public static final int EM_ALARM_SCADA_DEV_UPS               = 3;   // UPS
        public static final int EM_ALARM_SCADA_DEV_SWITCH            = 4;   // 开关电源
        public static final int EM_ALARM_SCADA_DEV_ELECTRICMETER     = 5;   // 智能电表
        public static final int EM_ALARM_SCADA_DEV_COMMERCIALPOWER   = 6;   // 市电检测
        public static final int EM_ALARM_SCADA_DEV_BATTERY           = 7;   // 蓄电池
        public static final int EM_ALARM_SCADA_DEV_AIRCONDITION      = 8;   // 空调
        public static final int EM_ALARM_SCADA_DEV_ACCESS            = 9;   // 门禁
        public static final int EM_ALARM_SCADA_DEV_SMOKINGSENSOR     = 10;  // 烟感
        public static final int EM_ALARM_SCADA_DEV_INFRARED          = 11;  // 红外
        public static final int EM_ALARM_SCADA_DEV_CHEMICAL          = 12;  // 化工
        public static final int EM_ALARM_SCADA_DEV_PERIMETER         = 13;  // 周界
        public static final int EM_ALARM_SCADA_DEV_DOORMAGNETISM     = 14;  //
        public static final int EM_ALARM_SCADA_DEV_DISTANCE          = 15;  // 测距
        public static final int EM_ALARM_SCADA_DEV_WINDSENSOR        = 16;  // 风速
        public static final int EM_ALARM_SCADA_DEV_LOCATION          = 17;  // 位置
        public static final int EM_ALARM_SCADA_DEV_ATMOSPHERE        = 18;  // 大气
        public static final int EM_ALARM_SCADA_DEV_SOLARPOWER        = 19;  // 太阳能
    }

    //设备状态
    public static class EM_SCADA_DEVICE_STATUS extends SdkStructure
    {
        public static final int EM_SCADA_DEVICE_STATUS_KNOWN         = -1;  // 未知
        public static final int EM_SCADA_DEVICE_STATUS_NORMAL        = 0;   // 正常
        public static final int EM_SCADA_DEVICE_STATUS_ALARM         = 1;   // 报警
        public static final int EM_SCADA_DEVICE_STATUS_OFFLINE       = 2;   // 离线
    }

    // 点位类型
    public static class EM_NET_SCADA_POINT_TYPE extends SdkStructure
    {
        public static final int EM_NET_SCADA_POINT_TYPE_UNKNOWN = 0;                  // 未知
        public static final int EM_NET_SCADA_POINT_TYPE_ALL		= 1;                  // 所有类型
        public static final int EM_NET_SCADA_POINT_TYPE_YC      = 2;                  // 遥测 模拟量输入
        public static final int EM_NET_SCADA_POINT_TYPE_YX		= 3;                  // 遥信 开关量输入
        public static final int EM_NET_SCADA_POINT_TYPE_YT		= 4;                  // 遥调 模拟量输出
        public static final int EM_NET_SCADA_POINT_TYPE_YK		= 5;                  // 遥控 开关量输出
    }

    // CLIENT_SCADAAttachInfo()接口输入参数
    public static class NET_IN_SCADA_ATTACH_INFO extends SdkStructure
    {
        public int                          dwSize;
        public Callback				cbCallBack;                 // 数据回调函数, fSCADAAttachInfoCallBack 回调
        public int         					emPointType;                // 点位类型,取值参考  EM_NET_SCADA_POINT_TYPE
        public Pointer                   	dwUser;                     // 用户定义参数

        public NET_IN_SCADA_ATTACH_INFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_SCADAAttachInfo()接口输出参数
    public static class NET_OUT_SCADA_ATTACH_INFO extends SdkStructure
    {
        public int    					   dwSize;

        public NET_OUT_SCADA_ATTACH_INFO() {
            this.dwSize = this.size();
        }
    }

    // 监测点位信息列表
    public static class NET_SCADA_NOTIFY_POINT_INFO_LIST extends SdkStructure
    {
        public int                           	dwSize;
        public int                              nList;                        // 监测点位信息个数
        public NET_SCADA_NOTIFY_POINT_INFO[]    stuList = (NET_SCADA_NOTIFY_POINT_INFO[])new NET_SCADA_NOTIFY_POINT_INFO().toArray(MAX_SCADA_POINT_LIST_INFO_NUM); // 监测点位信息

        public NET_SCADA_NOTIFY_POINT_INFO_LIST() {
            this.dwSize = this.size();
        }
    }

    // 监测点位信息
    public static class NET_SCADA_NOTIFY_POINT_INFO extends SdkStructure
    {
        public int                       		dwSize;
        public byte[]                        	szDevName = new byte[NET_COMMON_STRING_64];     // 设备名称,与getInfo获取的名称一致
        public int     							emPointType;                        			// 点位类型,取值参考 EM_NET_SCADA_POINT_TYPE
        public byte[]                        	szPointName = new byte[NET_COMMON_STRING_64];   // 点位名,与点位表的取值一致
        public float                       		fValue;                            				// Type为YC时为浮点数
        public int                         		nValue;                             			// Type为YX时为整数
        public byte[]                        	szFSUID = new byte[NET_COMMON_STRING_64];       // 现场监控单元ID(Field Supervision Unit), 即设备本身
        public byte[]                        	szID = new byte[NET_COMMON_STRING_64];          // 点位ID
        public byte[]                        	szSensorID = new byte[NET_COMMON_STRING_64];    // 探测器ID
        public NET_TIME_EX                 		stuCollectTime;             					// 采集时间

        public NET_SCADA_NOTIFY_POINT_INFO() {
            this.dwSize = this.size();
        }
    }

    public static class CFG_TRAFFICSNAPSHOT_NEW_INFO extends SdkStructure
    {
        public int									nCount;											// 有效成员个数
        public CFG_TRAFFICSNAPSHOT_INFO[]	stInfo = (CFG_TRAFFICSNAPSHOT_INFO[])new CFG_TRAFFICSNAPSHOT_INFO().toArray(8);		// 交通抓拍表数组
    }

    // CFG_CMD_INTELLECTIVETRAFFIC
    public static class CFG_TRAFFICSNAPSHOT_INFO extends SdkStructure
    {
        public byte[]                   szDeviceAddress = new byte[MAX_DEVICE_ADDRESS];   	// 设备地址	UTF-8编码，256字节
        public int                      nVideoTitleMask;                      			  	// OSD叠加类型掩码	从低位到高位分别表示：0-时间 1-地点 2-车牌3-车长 4-车速 5-限速6-大车限速 7-小车限速8-超速 9-违法代码10-车道号 11-车身颜色 12-车牌类型 13-车牌颜色14-红灯点亮时间 15-违章类型 16-雷达方向 17-设备编号 18-标定到期时间 19-车型 20-行驶方向
        public int                      nRedLightMargin;                      			  	// 红灯冗余间隔时间	红灯开始的一段时间内，车辆通行不算闯红灯，单位：秒
        public float				    fLongVehicleLengthLevel;              			  	// 超长车长度最小阈值	单位：米，包含
        public float[]					arfLargeVehicleLengthLevel = new float[2];        	// 大车长度阈值	单位：米，包含小值
        public float[]					arfMediumVehicleLengthLevel = new float[2];       	// 中型车长度阈值	单位：米，包含小值
        public float[]					arfSmallVehicleLengthLevel = new float[2];        	// 小车长度阈值	单位：米，包含小值
        public float					fMotoVehicleLengthLevel;              			  	// 摩托车长度最大阈值	单位：米，不包含
        public BREAKINGSNAPTIMES_INFO   stBreakingSnapTimes; 								// 违章抓拍张数
        public DETECTOR_INFO[]          arstDetector = (DETECTOR_INFO[])new DETECTOR_INFO().toArray(MAX_DETECTOR);     // 车检器配置，下标是车道号
        public int 					 	nCarType;			               	   				// 抓拍车辆类型	0-大小车都抓拍1-抓拍小车2-抓拍大车3-大小车都不抓拍
        public int						nMaxSpeed;			               	   				// 当测得的速度超过最大速度时，则以最大速度计	0~255km/h
        public int						nFrameMode;		               	   					// 帧间隔模式	1-速度自适应（超过速度上限取0间隔，低于速度下限取2间隔，中间取1间隔）2-由联动参数决定
        public int[]                    arnAdaptiveSpeed = new int[2];                  	// 速度自适应下限和上限
        public CFG_ALARM_MSG_HANDLE     stuEventHandler;	    							// 交通抓拍联动参数
        public int                      abSchemeRange;                        				// BOOL类型,TRUE:方案针对相机,以车到0的值为准;FALSE:方案针对车道。不可以修改此字段数据, 只内部使用
        public int                      nVideoTitleMask1;					   				// 从低位到高位分别表示：0-车标 1-红灯结束时间 2-设备制造厂商 3-小车低限速 4-大车低限速 5-小车高限速 6-大车高限速 7-设备工作模式 8-通用自定义 9-车道自定义 10-抓拍触发源 11-停车场区域12-车辆类型(面包车、轿车等等) 13-中车低限速 14-中车高限速 15-道路方向 16-GPS信息
        public int				        nMergeVideoTitleMask;                 				// 合成图片OSD叠加类型掩码	参照nVideoTitleMask字段
        public int				        nMergeVideoTitleMask1;				  				// 合成图片OSD叠加类型掩码	参照nVideoTitleMask1字段
        public int                      nTriggerSource;					   					// 触发源掩码 0-RS232 1-RS485 2-IO 3-Video 4-Net
        public int						nSnapMode;							   				// 抓拍模式 0-全部抓拍 1-超速抓拍 2-逆向抓拍 3-PK模式
        public int                      nWorkMode;							   				// 工作模式 0-自动模式，1-线圈抓拍模式，2-线圈抓拍识别，3-视频抓拍，4-视频识别, 5-混合抓拍（带识别）
        public int                      nCarThreShold;						   				// 车长阈值  区分大小车长的阈值，单位: cm
        public int                      nSnapType;							   				// 抓拍或抓录选择 0-正常抓拍模式 1-视频抓拍模式 2-黑屏快抓模式
        public int[]                    nCustomFrameInterval = new int[3];			   		// 自定义抓拍帧间隔 第一个元素指车速小于速度自适应下限时的抓拍帧间隔，依次类推
        public int                      nKeepAlive;				           					// 与雷达、车检器的默认保活周期 单位秒
        public OSD_INFO				    stOSD;												// 原始图片OSD参数配置
        public OSD_INFO                 stMergeOSD;                       				 	// 合成图片OSD参数配置
        public CFG_NET_TIME             stValidUntilTime;									// 标定到期时间，指该时间点之前抓拍照片有效
        public RADAR_INFO               stRadar;
        public byte[]                   szRoadwayCode = new byte[MAX_ROADWAYNO];        	// 道路代码
        public int                      nVideoTitleMask2;					   				// 原始图片OSD叠加类型掩码2 从低位到高位分别表示：0-国别 1-尾气数据
        public int				        nMergeVideoTitleMask2;				   				// 合成图片OSD叠加类型掩码2 参照nVideoTitleMask2字段
        public int                      nParkType;                            				// 出入口类型，0-默认( 兼容以前，不区分出口/入口 )，1-入口相机， 2-出口相机
        public int					    nCoilSpeedAdjustDelayFrameTime;	   // 线圈速度校正等待时间，范围【500, 4000】，单位：毫秒
        public boolean					bCoilSpeedAdjustEnable;			   // 线圈速度校正使能，TRUE：校正 FALSE：不校正
        public int					    nSnapSigMinConfidence;				   // 触发雷达信号抓拍值，范围【0~100】
        public int                      emMixSnapSpeedSource;				   // 视频抓拍速度来源,EM_MIX_SNAP_SPEED_SOURCE
    }

    public static class COIL_MAP_INFO extends SdkStructure
    {
        public int        				nPhyCoilID;         // 物理线圈号
        public int        				nLogicCoilID;       // 逻辑线圈号
    }

    // 车检器配置
    public static class DETECTOR_INFO extends SdkStructure
    {
        public int                		nDetectBreaking;                   		 			// 违章类型掩码	从低位到高位依次是：0-正常1-闯红灯2-压线3-逆行4-欠速5-超速6-有车占道
        // 7-黄牌占道 8-闯黄灯 9-违章占公交车道 10-不系安全带 11-驾驶员抽烟 12-驾驶员打电话
        public COILCONFIG_INFO[]    	arstCoilCfg = (COILCONFIG_INFO[])new COILCONFIG_INFO().toArray(MAX_COILCONFIG);    // 线圈配置数组
        public int				    	nRoadwayNumber;				      		 			// 车道号	1-16 ; 0表示不启用
        public int                  	nRoadwayDirection;                		 			// 车道方向（车开往的方向）	0-南向北 1-西南向东北 2-东 3-西北向东南 4-北向南 5-东北向西南 6-东向西 7-东南向西北 8-忽略
        public int                  	nRedLightCardNum;                 		 			// 卡口图片序号	表示将电警中的某一张图片作为卡口图片（共三张），0表示不采用，1~3,表示采用对应序号的图片
        public int                  	nCoilsNumber;                     		 			// 线圈个数	1-3
        public int                  	nOperationType;                   		 			// 业务模式	0-卡口电警1-电警2-卡口
        public int[]                	arnCoilsDistance = new int[3];    		 			// 两两线圈的间隔	范围0-1000，单位为厘米
        public int                  	nCoilsWidth;                      		 			// 每个线圈的宽度	0~200cm
        public int[]                	arnSmallCarSpeedLimit = new int[2];      			// 小型车辆速度下限和上限	0~255km/h，不启用大小车限速时作为普通车辆限速
        public int[]					arnBigCarSpeedLimit = new int[2];        			// 大型车辆速度下限和上限	0~255km/h，启用大小车限速时有效
        public int				    	nOverSpeedMargin;			     	     			// 限高速宽限值	单位：km/h
        public int                  	nBigCarOverSpeedMargin;           	     			// 大车限高速宽限值	单位：km/h，启用大小车限速时有效
        public int				    	nUnderSpeedMargin;			     		 			// 限低速宽限值	单位：km/h
        public int                  	nBigCarUnderSpeedMargin;          		 			// 大车限低速宽限值	单位：km/h，启用大小车限速时有效
        public byte                 	bSpeedLimitForSize;               		 			// bool类型,是否启用大小车限速
        public byte			        	bMaskRetrograde;				     	 			// bool类型,逆行是否视为违章行为
        public byte[]               	byReserved = new byte[2];                			// 保留对齐
        public byte[]            		szDrivingDirection = new byte[3*MAX_DRIVINGDIRECTION]; // "DrivingDirection" : ["Approach", "上海", "杭州"],行驶方向
        // "Approach"-上行，即车辆离设备部署点越来越近；"Leave"-下行，
        // 即车辆离设备部署点越来越远，第二和第三个参数分别代表上行和
        // 下行的两个地点，UTF-8编码
        public int                  	nOverPercentage;                  		 			// 超速百分比，超过限速百分比后抓拍
        public int                  	nCarScheme;                       		 			// 具体的方案Index,具体方案含义参参考打包环境local.png;根据CFG_TRAFFICSNAPSHOT_INFO.abSchemeRange字段区分作用范围
        public int                  	nSigScheme;                       		 			// 同上，非卡口使用
        public int                  	bEnable;                          					// BOOL类型,车道是否有效，只有有效时才抓拍
        public int[]			    	nYellowSpeedLimit = new int[2];			 			//黄牌车限速上限和下限 范围0~255km/h
        public int				    	nRoadType;						 		 			//工作路段 0 普通公路 1 高速公路
        public int				    	nSnapMode;						 		 			//抓拍模式 0-全部抓拍 1-超速抓拍 2-逆向抓拍（鄞州项目用）
        public int                  	nDelayMode;						 		 			//延时抓拍方案 0-使DelaySnapshotDistance，1-使用DelayTime
        public int                  	nDelayTime;						 		 			//延时抓拍时间 闯红灯第三张抓拍位置距离最后一个线圈的时间，单位毫秒
        public int				    	nTriggerMode;					 		 			//触发模式 0-入线圈触发 1-出线圈触发 2-出入都抓拍 3-关闭
        public int			        	nErrorRange;						 	 			//速度误差值，进线圈2与进线圈3之间的速度误差值，若实际误差大于或等于该值，视速度无效，否则取平均速度 0-20
        public double			    	dSpeedCorrection;				 		 			//速度校正系数，即速度值为测出的值乘以该系数
        public int[]                	nDirection = new int[2];                 			//相对车道方向需要上报车辆行驶方向,nDirection[0] 0--空 1--正向 ; nDirection[1] 0--空 1--反向
        public byte[]               	szCustomParkNo = new byte[CFG_COMMON_STRING_32 + 1];// 自定义车位号（停车场用）
        public byte[]               	btReserved = new byte[3];
        public int                		nCoilMap;                        					// 有多少对线圈映射关系
        public COIL_MAP_INFO[]          stuCoilMap = (COIL_MAP_INFO[])new COIL_MAP_INFO().toArray(16);;                  // 线圈号映射关系
    }

    // 线圈配置
    public static class COILCONFIG_INFO extends SdkStructure
    {
        public int                 		nDelayFlashID;                 						// 延时闪光灯序号	每个线圈对应的延时闪关灯序号，范围0~5，0表示不延时任何闪光灯
        public int                 		nFlashSerialNum;               						// 闪光灯序号	范围0~5，0表示不打开闪光灯（鄞州项目用）
        public int                 		nRedDirection;                 						// 红灯方向	每个线圈对应的红灯方向：0-不关联,1-左转红灯,2-直行红灯,3-右转红灯,4-待左,5-待直,6-待右, 只在电警中有效
        public int                 		nTriggerMode ;                 						// 线圈触发模式	触发模式：0-入线圈触发1-出线圈触发（鄞州项目用）
        public int				   		nFlashSerialNum2;				 					//多抓第二张对应闪光灯序号 范围0~5，0表示不打开闪光灯
        public int				   		nFlashSerialNum3;				 					//多抓第三张对应闪光灯序号 范围0~5，0表示不打开闪光灯
    }

    // 违章抓拍张数
    public static class BREAKINGSNAPTIMES_INFO extends SdkStructure
    {
        public int               		nNormal;                          					// 正常
        public int               		nRunRedLight;                     					// 闯红灯
        public int			      		nOverLine;											// 压线
        public int				  		nOverYellowLine;			  	    				// 压黄线
        public int				  		nRetrograde;			    	    				// 逆向
        public int				  		nUnderSpeed;					    				// 欠速
        public int				  		nOverSpeed;											// 超速
        public int			      		nWrongRunningRoute;									// 有车占道
        public int			      		nYellowInRoute;										// 黄牌占道
        public int		    	  		nSpecialRetrograde;									// 特殊逆行
        public int			      		nTurnLeft;											// 违章左转
        public int			      		nTurnRight;											// 违章右转
        public int			      		nCrossLane;											// 违章变道
        public int			      		nU_Turn;						    				// 违章调头
        public int			      		nParking;						    				// 违章停车
        public int               		nWaitingArea;										// 违章进入待行区
        public int			      		nWrongRoute;					   				    // 不按车道行驶
        public int               		nParkingSpaceParking;             					// 车位有车
        public int               		nParkingSpaceNoParking;           					// 车位无车
        public int               		nRunYellowLight;									// 闯黄灯
        public int               		nStay;												// 违章停留
        public int               		nPedestrainPriority;	            				// 斑马线行人优先违章
        public int               		nVehicleInBusRoute;               					// 违章占道
        public int               		nBacking;                         					// 违章倒车
        public int				  		nOverStopLine;										// 压停止线
        public int               		nParkingOnYellowBox;           						// 黄网格线停车
        public int               		nRestrictedPlate;									// 受限车牌
        public int               		nNoPassing;											// 禁行
        public int               		nWithoutSafeBelt;                					// 不系安全带
        public int               		nDriverSmoking;                   					// 驾驶员抽烟
        public int               		nDriverCalling;                   					// 驾驶员打电话
        public int               		nPedestrianRunRedLight;           					// 行人闯红灯
        public int               		nPassNotInOrder;                  					// 未按规定依次通行
    }

    // OSD属性
    public static class OSD_INFO extends SdkStructure
    {
        public BLACK_REGION_INFO		stBackRegionInfo;									//OSD黑边属性
        public int						nOSDAttrScheme;		    							//OSD属性配置方案 0=未知 , 1=全体OSD项共用属性 , 2=每个OSD项一个属性
        public OSD_ATTR_SCHEME			stOSDAttrScheme;									//OSD属性配置方案内容
        public OSD_CUSTOM_SORT[]     	stOSDCustomSorts = (OSD_CUSTOM_SORT[])new OSD_CUSTOM_SORT().toArray(MAX_OSD_CUSTOM_SORT_NUM);    //OSD叠加内容自定义排序
        public int                 		nOSDCustomSortNum;
        public int                 		nRedLightTimeDisplay;  					 			//OSD红灯时间配置 0=未知,1=违法最后一张,2=所有张
        public byte                		cSeperater;             							//OSD不同项之间的分隔符
        public byte[]		        	bReserved = new byte[3];           					//字节对齐
        public byte[]                	szOSDOrder = new byte[MAX_CONF_CHAR];
        public int                 		nOSDContentScheme;      							//0=未知, 1=Mask , 2=CustomizeSort
        public OSD_CUSTOM_INFO     		stOSDCustomInfo;        							//OSD自定义项
    }

    // OSD黑边
    public static class BLACK_REGION_INFO extends SdkStructure
    {
        public int 						nHeight;											//黑边高度 取值范围：0 ~ ( 8192-原图片高度)
        public int 						nOSDPosition;										//黑边位置 0=未知 , 1=顶部 , 2=底部
    }

    // OSD属性配置方案内容
    public static class OSD_ATTR_SCHEME extends SdkStructure
    {
        public OSD_WHOLE_ATTR 			stWholeAttr;										//全体OSD项共用属性
    }

    // 全体OSD项共用属性
    public static class OSD_WHOLE_ATTR extends SdkStructure
    {
        public int        				bPositionAsBlackRegion;     						//BOOL类型,位置是否同黑边相同,true时，下面的Position无效,BOOL类型
        public CFG_RECT    				stPostion;                  						//位置,不能超过图片范围
        public int        				bNewLine;                   						//BOOL类型,超出矩形范围是否换行,bPositionAsBlackRegion为true时有效,BOOL类型
        public int        				bLoneVehicle;               						//BOOL类型,车辆信息独立显示,true 一行显示一辆车信息,false 允许多辆车信息显示在一行,BOOL类型
    }

    // OSD叠加内容自定义排序
    public static class OSD_CUSTOM_SORT extends SdkStructure
    {
        public OSD_CUSTOM_ELEMENT[]   	stElements = (OSD_CUSTOM_ELEMENT[])new OSD_CUSTOM_ELEMENT().toArray(MAX_OSD_CUSTOM_SORT_ELEM_NUM);     //具体叠加元素
        public int                  	nElementNum;
    }

    // OSD具体叠加元素
    public static class OSD_CUSTOM_ELEMENT extends SdkStructure
    {
        public int  					nNameType;                          				//名称类型,	0:szName字段含义参照szOSDOrder字段定义的项
        //          1:"Name"字段表示自定义项，无需解析
        public byte[] 					szName = new byte[MAX_OSD_CUSTOM_VALUE_LEN];        // 该项名称
        public byte[] 					szPrefix = new byte[MAX_PRE_POX_STR_LEN];      		// 叠加前缀字符串
        public byte[] 					szPostfix = new byte[MAX_PRE_POX_STR_LEN];     		// 叠加后缀字符串
        public int  					nSeperaterCount;                    				// 后面添加分隔符个数

    }

    // OSD自定义项
    public static class OSD_CUSTOM_INFO extends SdkStructure
    {
        public OSD_CUSTOM_GENERAL_INFO[]  stGeneralInfos = (OSD_CUSTOM_GENERAL_INFO[])new OSD_CUSTOM_GENERAL_INFO().toArray(MAX_OSD_CUSTOM_GENERAL_NUM);     //具体叠加元素
        public int                        nGeneralInfoNum;
    }

    public static class OSD_CUSTOM_GENERAL_INFO extends SdkStructure
    {
        public int    					bEnable;            							//BOOL类型,是否叠加
    }

    public static class RADAR_INFO extends SdkStructure
    {
        public int     					nAngle;                 						//角度,用于修正雷达探头安装的角度造成的速度误差,范围[0,90]
        public int     					nAntiJammingValue;      						//抗干扰门槛值
        public int     					nComeInValue;           						//来向进入门槛值,取值范围[0,65535]
        public int     					nComeOutValue;          						//来向离开门槛值
        public int     					nDelayTime;             						//雷达延时,单位ms，范围[0,255]
        public int   					nDetectBreaking;        						//违章类型掩码,从低位到高位依次是:
        //0-正常,1-闯红灯, 2-压线, 3-逆行,4-欠速
        //5-超速,6-有车占道,7-黄牌占道,8-闯黄灯,9-违章占公交车道
        public int     					nDetectMode;            						//检测模式  0-车头检测 1-车尾检测 2-双向检测
        public int     					nInstallMode;           						//雷达安装方式  0-侧面安装 1-上方安装
        public int     					nLevel;                 						//灵敏度,0级灵敏度最高,范围[0,5]
        public int     					nMultiTargetFilter;     						//多目标过滤模式,0-正常 1-过滤
        public int     					nWentEndValue;          						//去向信号结束门槛值
        public int     					nWentInValue;           						//去向进入门槛值
        public int     					nWentOutValue;          						//去向离开门槛值
    }

    // 串口状态
    public static class NET_COMM_STATE extends SdkStructure
    {
        public int        				uBeOpened; 										// 串口是否打开,0:未打开 1:打开.
        public int        				uBaudRate;										// 波特率, 1~8分别表示 1200 2400  4800 9600 19200 38400 57600 115200
        public int        				uDataBites;										// 数据位，4~8表示4位~8位
        public int        				uStopBits;										// 停止位, 232串口 ： 数值0 代表停止位1; 数值1 代表停止位1.5; 数值2 代表停止位2.    485串口 ： 数值1 代表停止位1; 数值2 代表停止位2.
        public int        				uParity;										// 检验, 0：无校验，1：奇校验；2：偶校验;
        public byte[]                	bReserved = new byte[32];
    }


    // 门禁卡记录查询条件
    public static class FIND_RECORD_ACCESSCTLCARD_CONDITION extends SdkStructure
    {
        public int                      dwSize;
        public byte[]                   szCardNo = new byte[NET_MAX_CARDNO_LEN];       // 卡号
        public byte[]                   szUserID = new byte[NET_MAX_USERID_LEN];       // 用户ID
        public int                      bIsValid;                         			   // 是否有效, 1:有效, 0:无效 , boolean类型，为1或者0
        public int                  	abCardNo;                         			   // 卡号查询条件是否有效,针对成员 szCardNo,boolean类型，为1或者0
        public int                  	abUserID;                         			   // 用户ID查询条件是否有效,针对成员 szUserID, boolean类型，为1或者0
        public int                  	abIsValid;                        			   // IsValid查询条件是否有效,针对成员 bIsValid, boolean类型，为1或者0

        public FIND_RECORD_ACCESSCTLCARD_CONDITION() {
            this.dwSize = this.size();
        }
    }

    // 门禁卡记录集信息
    public static class NET_RECORDSET_ACCESS_CTL_CARD extends SdkStructure
    {
        public int           		  dwSize;
        public int             		  nRecNo;                                 		   // 记录集编号,只读
        public NET_TIME        		  stuCreateTime = new NET_TIME();                  // 创建时间
        public byte[]            	  szCardNo = new byte[NET_MAX_CARDNO_LEN];         // 卡号
        public byte[]            	  szUserID = new byte[NET_MAX_USERID_LEN];         // 用户ID, 设备暂不支持
        public int       			  emStatus;                 					   // 卡状态   NET_ACCESSCTLCARD_STATE
        public int        			  emType;                        			       // 卡类型   NET_ACCESSCTLCARD_TYPE
        public byte[]            	  szPsw = new byte[NET_MAX_CARDPWD_LEN];           // 卡密码
        public int             		  nDoorNum;                               		   // 有效的门数目;
        public int[]              	  sznDoors = new int[NET_MAX_DOOR_NUM];            // 有权限的门序号,即CFG_CMD_ACCESS_EVENT配置的数组下标
        public int             		  nTimeSectionNum;                        		   // 有效的的开门时间段数目
        public int[]             	  sznTimeSectionNo = new int[NET_MAX_TIMESECTION_NUM];  // 开门时间段索引,即CFG_ACCESS_TIMESCHEDULE_INFO的数组下标
        public int             		  nUserTime;                              		   // 使用次数,仅当来宾卡时有效
        public NET_TIME        		  stuValidStartTime = new NET_TIME();              // 开始有效期, 设备暂不支持时分秒
        public NET_TIME        		  stuValidEndTime = new NET_TIME();                // 结束有效期, 设备暂不支持时分秒
        public int            	  	  bIsValid;                               		   // 是否有效,1有效; 0无效, boolean类型，为1或者0
        public NET_ACCESSCTLCARD_FINGERPRINT_PACKET stuFingerPrintInfo;			   	   // 下发指纹数据信息，仅为兼容性保留，请使用 stuFingerPrintInfoEx, 如果使用，内部的 pPacketData，请初始化
        public int            	  	  bFirstEnter;                            		   // 是否拥有首卡权限, boolean类型，为1或者0
        public byte[]            	  szCardName = new byte[NET_MAX_CARDNAME_LEN];     // 卡命名
        public byte[]            	  szVTOPosition = new byte[NET_COMMON_STRING_64];  // 门口机关联位置
        public int            	  	  bHandicap;                              		   // 是否为残疾人卡, boolean类型，为1或者0
        public int            	  	  bEnableExtended;                        		   // 启用成员 stuFingerPrintInfoEx, boolean类型，为1或者0
        public NET_ACCESSCTLCARD_FINGERPRINT_PACKET_EX     stuFingerPrintInfoEx;	   // 指纹数据信息, 如果使用，内部的 pPacketData，请初始化
        public int             		  nFaceDataNum;                          		   // 人脸数据个数不超过20
        public NET_FACE_FACEDATA[]	  szFaceDataArr = (NET_FACE_FACEDATA[])new NET_FACE_FACEDATA().toArray(MAX_FACE_COUTN);// 人脸模板数据
        public byte[]				  szDynamicCheckCode = new byte[MAX_COMMON_STRING_16];// 动态校验码。
        // VTO等设备会保存此校验码，以后每次刷卡都以一定的算法生成新校验码并写入IC卡中，同时更新VTO设备的校验码，只有卡号和此校验码同时验证通过时才可开门。
        public int             		  nRepeatEnterRouteNum;                            // 反潜路径个数
        public int[]            	  arRepeatEnterRoute = new int[MAX_REPEATENTERROUTE_NUM]; // 反潜路径
        public int            		  nRepeatEnterRouteTimeout;                        // 反潜超时时间
        public int            		  bNewDoor;                                        // 是否启动新开门授权字段，TRUE表示使用nNewDoorNum和nNewDoors字段下发开门权限, BOOL类型
        public int             		  nNewDoorNum;                                     // 有效的门数目;
        public int[]             	  nNewDoors = new int[MAX_ACCESSDOOR_NUM];         // 有权限的门序号,即CFG_CMD_ACCESS_EVENT配置的数组下标
        public int             		  nNewTimeSectionNum;                              // 有效的的开门时间段数目
        public int[]             	  nNewTimeSectionNo = new int[MAX_ACCESSDOOR_NUM]; // 开门时间段索引,即CFG_ACCESS_TIMESCHEDULE_INFO的数组下标
        public byte[]				  szCitizenIDNo = new byte[MAX_COMMON_STRING_32];  // 身份证号码
        public int					  nSpecialDaysScheduleNum;						   // 假日计划表示数量
        public int[]				  arSpecialDaysSchedule = new int[MAX_ACCESSDOOR_NUM];// 假日计划标识// 缺点：目前方案只支持一卡刷一个设备。
        public int            		  nUserType;                                       // 用户类型, 0 普通用户, 1 黑名单用户
        public int             		  nFloorNum;                                       // 有效的楼层数量
        public FLOOR_NO[]             szFloorNoArr = (FLOOR_NO[])new FLOOR_NO().toArray(MAX_ACCESS_FLOOR_NUM);   // 楼层号
        public byte[]				  szSection = new byte[MAX_COMMON_STRING_64];	//部门名称
        public int             		  nScore;                                       //信用积分
        public byte[]            	  szCompanyName = new byte[MAX_COMPANY_NAME_LEN];//单位名称
        public int					  nSectionID;									//部门ID

        public int       			emSex;                                      	// 性别, 详见NET_ACCESSCTLCARD_SEX
        public byte[]               szRole = new byte[MAX_COMMON_STRING_32];        // 角色
        public byte[]               szProjectNo = new byte[MAX_COMMON_STRING_32];   // 项目ID
        public byte[]               szProjectName = new byte[MAX_COMMON_STRING_64]; // 项目名称
        public byte[]               szBuilderName = new byte[MAX_COMMON_STRING_64]; // 施工单位全称
        public byte[]               szBuilderID = new byte[MAX_COMMON_STRING_32];   // 施工单位ID
        public byte[]               szBuilderType = new byte[MAX_COMMON_STRING_32]; // 施工单位类型
        public byte[]               szBuilderTypeID = new byte[MAX_COMMON_STRING_8];// 施工单位类别ID
        public byte[]               szPictureID = new byte[MAX_COMMON_STRING_64];   // 人员照片ID
        public byte[]               szContractID = new byte[MAX_COMMON_STRING_16];  // 原合同系统合同编号
        public byte[]               szWorkerTypeID = new byte[MAX_COMMON_STRING_8]; // 工种ID
        public byte[]               szWorkerTypeName = new byte[MAX_COMMON_STRING_32];  // 工种名称
        public int                  bPersonStatus;                              	// 人员状态, TRUE:启用, FALSE:禁用
        public int                  emAuthority;                          			// 用户权限，详见NET_ACCESSCTLCARD_AUTHORITY
        public byte[]			szCompanionName=new byte[120];							// 陪同人姓名
        public byte[]			szCompanionCompany=new byte[200];						// 陪同人单位
        public NET_TIME		stuTmpAuthBeginTime;							// 临时授权开始时间,当该时间和其他时间同时生效时，以此时间为最高优先级
        public NET_TIME		stuTmpAuthEndTime;								// 临时授权结束时间,当该时间和其他时间同时生效时，以此时间为最高优先级
        public int			bFloorNoExValid;								// 楼层号扩展 szFloorNoEx 是否有效
        public int             nFloorNumEx;									// 有效的楼层数量扩展
        public byte[]            szFloorNoEx=new byte[512*NET_COMMON_STRING_4];			// 楼层号扩展
        public byte[]			szSubUserID=new byte[32];								// 用户ID（定制）
        public byte[]           szPhoneNumber=new byte[32];                              // 人员电话号码
        public byte[]           szPhotoPath=new byte[256];                               // 人员照片对应在ftp上的路径
        public byte[]           szCause=new byte[64];                                    // 来访原因
        public byte[]			szCompanionCard=new byte[32];							// 陪同人员证件号（定制）
        public byte[]			szCitizenAddress=new byte[128];							// 身份证地址
        public NET_TIME		    stuBirthDay;									// 出生日期（年月日有效）
        public boolean			bFloorNoEx2Valid;								// stuFloors2 是否有效
        /**
         * 对应结构体{@link NET_FLOORS_INFO}
         */
        public Pointer	        pstuFloorsEx2;								// 楼层号（再次扩展）
        public byte[]			szDefaultFloor=new byte[8];								// 默认楼层号（梯控需求)
        public int				nUserTimeSectionNum;							// 用户时间段有效个数
        public USER_TIME_SECTION[]			szUserTimeSections=
                (USER_TIME_SECTION[])new USER_TIME_SECTION().toArray(6);	//针对用户自身的开门时间段校验，最多支持6个时间段
        public NET_RECORDSET_ACCESS_CTL_CARD() {
            this.dwSize = this.size();
        }
    }

    // 用户权限
    public static class NET_ACCESSCTLCARD_AUTHORITY extends SdkStructure
    {
        public static final int NET_ACCESSCTLCARD_AUTHORITY_UNKNOWN  = 0;   // 未知
        public static final int NET_ACCESSCTLCARD_AUTHORITY_ADMINISTRATORS = 1;   // 管理员
        public static final int NET_ACCESSCTLCARD_AUTHORITY_CUSTOMER = 2;   // 普通用户
    }

    public static class FLOOR_NO extends SdkStructure
    {
        public byte[]            szFloorNo = new byte[NET_COMMON_STRING_4];   // 楼层号
    }

    // 卡状态
    public static class NET_ACCESSCTLCARD_STATE extends SdkStructure
    {
        public static final int NET_ACCESSCTLCARD_STATE_UNKNOWN = -1;
        public static final int NET_ACCESSCTLCARD_STATE_NORMAL = 0;                 // 正常
        public static final int NET_ACCESSCTLCARD_STATE_LOSE   = 0x01;              // 挂失
        public static final int NET_ACCESSCTLCARD_STATE_LOGOFF = 0x02;              // 注销
        public static final int NET_ACCESSCTLCARD_STATE_FREEZE = 0x04;              // 冻结
        public static final int NET_ACCESSCTLCARD_STATE_ARREARAGE = 0x08;           // 欠费
        public static final int NET_ACCESSCTLCARD_STATE_OVERDUE = 0x10;             // 逾期
        public static final int NET_ACCESSCTLCARD_STATE_PREARREARAGE = 0x20;        // 预欠费(还是可以开门,但有语音提示)
    }

    // 指纹数据，只用于下发信息
    public static class NET_ACCESSCTLCARD_FINGERPRINT_PACKET extends SdkStructure
    {
        public int   			 dwSize;
        public int     			 nLength;        			// 单个数据包长度,单位字节
        public int     			 nCount;         			// 包个数
        public Pointer   		 pPacketData;    			// 所有指纹数据包，用户申请内存并填充，长度为 nLength*nCount

        public NET_ACCESSCTLCARD_FINGERPRINT_PACKET() {
            this.dwSize = this.size();
        }
    }

    // 指纹数据扩展，可用于下发和获取信息
    public static class NET_ACCESSCTLCARD_FINGERPRINT_PACKET_EX extends SdkStructure
    {
        public int     			 nLength;        // 单个数据包长度,单位字节
        public int     			 nCount;         // 包个数
        public Pointer   		 pPacketData;    // 所有指纹数据包, 用户申请内存,大小至少为nLength * nCount
        public int     		     nPacketLen;     // pPacketData 指向内存区的大小，用户填写
        public int     			 nRealPacketLen; // 返回给用户实际指纹总大小
        public int	    		 nDuressIndex;   // 胁迫指纹序号，范围1~nCount
        public byte[]    		 byReverseed = new byte[1020]; //保留大小
    }


    // 查询记录能力集能力集
    public static class CFG_CAP_RECORDFINDER_INFO extends SdkStructure
    {
        public int nMaxPageSize;//最大分页条数
    }

    // 时间同步服务器配置
    public static class CFG_NTP_INFO extends SdkStructure
    {
        public int					bEnable;									// 使能开关,BOOL类型
        public byte[]				szAddress = new byte[MAX_ADDRESS_LEN];		// IP地址或网络名
        public int					nPort;										// 端口号
        public int					nUpdatePeriod;								// 更新周期，单位为分钟
        public int 					emTimeZoneType;								// 时区, 参考 EM_CFG_TIME_ZONE_TYPE
        public byte[]				szTimeZoneDesc = new byte[MAX_NAME_LEN];	// 时区描述
        public int                  nSandbyServerNum;                           // 实际备用NTP服务器个数
        public CFG_NTP_SERVER[]     stuStandbyServer = (CFG_NTP_SERVER[])new CFG_NTP_SERVER().toArray(MAX_NTP_SERVER);  // 备选NTP服务器地址
        public int                 nTolerance;                                 // (机器人使用)表示设置的时间和当前时间的容差，单位为秒，如果设置的时间和当前的时间在容差范围内，则不更新当前时间。0 表示每次都修改。
    }

    // NTP服务器
    public static class CFG_NTP_SERVER extends SdkStructure
    {
        public int                	bEnable;   									// BOOL类型
        public byte[]				szAddress = new byte[MAX_ADDRESS_LEN];		// IP地址或网络名
        public int					nPort;										// 端口号
    }

    // 时区定义(NTP)
    public static class EM_CFG_TIME_ZONE_TYPE extends SdkStructure
    {
        public static final int EM_CFG_TIME_ZONE_0 = 0;								// {0, 0*3600,"GMT+00:00"}
        public static final int EM_CFG_TIME_ZONE_1 = 1;								// {1, 1*3600,"GMT+01:00"}
        public static final int EM_CFG_TIME_ZONE_2 = 2;								// {2, 2*3600,"GMT+02:00"}
        public static final int EM_CFG_TIME_ZONE_3 = 3;								// {3, 3*3600,"GMT+03:00"}
        public static final int EM_CFG_TIME_ZONE_4 = 4;								// {4, 3*3600+1800,"GMT+03:30"}
        public static final int EM_CFG_TIME_ZONE_5 = 5;								// {5, 4*3600,"GMT+04:00"}
        public static final int EM_CFG_TIME_ZONE_6 = 6;								// {6, 4*3600+1800,"GMT+04:30"}
        public static final int EM_CFG_TIME_ZONE_7 = 7;								// {7, 5*3600,"GMT+05:00"}
        public static final int EM_CFG_TIME_ZONE_8 = 8;								// {8, 5*3600+1800,"GMT+05:30"}
        public static final int EM_CFG_TIME_ZONE_9 = 9;								// {9, 5*3600+1800+900,"GMT+05:45"}
        public static final int EM_CFG_TIME_ZONE_10 = 10;							// {10, 6*3600,"GMT+06:00"}
        public static final int EM_CFG_TIME_ZONE_11 = 11;							// {11, 6*3600+1800,"GMT+06:30"}
        public static final int EM_CFG_TIME_ZONE_12 = 12;							// {12, 7*3600,"GMT+07:00"}
        public static final int EM_CFG_TIME_ZONE_13 = 13;							// {13, 8*3600,"GMT+08:00"}
        public static final int EM_CFG_TIME_ZONE_14 = 14;							// {14, 9*3600,"GMT+09:00"}
        public static final int EM_CFG_TIME_ZONE_15 = 15;							// {15, 9*3600+1800,"GMT+09:30"}
        public static final int EM_CFG_TIME_ZONE_16 = 16;							// {16, 10*3600,"GMT+10:00"}
        public static final int EM_CFG_TIME_ZONE_17 = 17;							// {17, 11*3600,"GMT+11:00"}
        public static final int EM_CFG_TIME_ZONE_18 = 18;							// {18, 12*3600,"GMT+12:00"}
        public static final int EM_CFG_TIME_ZONE_19 = 19;							// {19, 13*3600,"GMT+13:00"}
        public static final int EM_CFG_TIME_ZONE_20 = 20;							// {20, -1*3600,"GMT-01:00"}
        public static final int EM_CFG_TIME_ZONE_21 = 21;							// {21, -2*3600,"GMT-02:00"}
        public static final int EM_CFG_TIME_ZONE_22 = 22;							// {22, -3*3600,"GMT-03:00"}
        public static final int EM_CFG_TIME_ZONE_23 = 23;							// {23, -3*3600-1800,"GMT-03:30"}
        public static final int EM_CFG_TIME_ZONE_24 = 24;							// {24, -4*3600,"GMT-04:00"}
        public static final int EM_CFG_TIME_ZONE_25 = 25;							// {25, -5*3600,"GMT-05:00"}
        public static final int EM_CFG_TIME_ZONE_26 = 26;							// {26, -6*3600,"GMT-06:00"}
        public static final int EM_CFG_TIME_ZONE_27 = 27;							// {27, -7*3600,"GMT-07:00"}
        public static final int EM_CFG_TIME_ZONE_28 = 28;							// {28, -8*3600,"GMT-08:00"}
        public static final int EM_CFG_TIME_ZONE_29 = 29;							// {29, -9*3600,"GMT-09:00"}
        public static final int EM_CFG_TIME_ZONE_30 = 30;							// {30, -10*3600,"GMT-10:00"}
        public static final int EM_CFG_TIME_ZONE_31 = 31;							// {31, -11*3600,"GMT-11:00"}
        public static final int EM_CFG_TIME_ZONE_32 = 32;							// {32, -12*3600,"GMT-12:00"}
    }


    // 事件信息
    public static class EVENT_INFO extends SdkStructure
    {
        public int                  nEvent;								// 事件类型,参见智能事件类型，如 EVENT_IVS_ALL
        public int	[]	            arrayObejctType=new int[16];				// 支持的物体类型，当前支持 EM_OBJECT_TYPE_HUMAN, EM_OBJECT_TYPE_VECHILE, EM_OBJECT_TYPE_NOMOTOR, EM_OBJECT_TYPE_ALL
        public int				    nObjectCount;						// szObejctType 数量
        public byte[]				byReserved=new byte[512];					// 预留字段
    };

    // 录像信息对应 CLIENT_FindFileEx 接口的 NET_FILE_QUERY_FILE 命令 查询条件
    // 目前支持通过路径查询
    public static class NET_IN_MEDIA_QUERY_FILE extends SdkStructure
    {
        public int               	dwSize;                 // 结构体大小
        public String            	szDirs;                 // 工作目录列表,一次可查询多个目录,为空表示查询所有目录。目录之间以分号分隔,如“/mnt/dvr/sda0;/mnt/dvr/sda1”,szDirs==null 或"" 表示查询所有
        public int                  nMediaType;             // 文件类型,0:查询任意类型,1:查询jpg图片,2:查询dav
        public int                  nChannelID;             // 通道号从0开始,-1表示查询所有通道
        public NET_TIME             stuStartTime;           // 开始时间
        public NET_TIME             stuEndTime;             // 结束时间
        public int[]                nEventLists = new int[MAX_IVS_EVENT_NUM]; // 事件类型列表,参见智能分析事件类型
        public int                  nEventCount;            // 事件总数
        public byte                 byVideoStream;          // 视频码流 0-未知 1-主码流 2-辅码流1 3-辅码流2 4-辅码流3
        public byte[]               bReserved 	= new byte[3];           	  // 字节对齐
        public int[]     			emFalgLists = new int[EM_RECORD_SNAP_FLAG_TYPE.FLAG_TYPE_MAX]; // 录像或抓图文件标志, 不设置标志表示查询所有文件, 参考 EM_RECORD_SNAP_FLAG_TYPE
        public int                  nFalgCount;             // 标志总数
        public NET_RECORD_CARD_INFO stuCardInfo;            // 卡号录像信息, emFalgLists包含卡号录像时有效
        public int                  nUserCount;             // 用户名有效个数
        public byte[]               szUserName  = new byte[MAX_QUERY_USER_NUM * NET_NEW_USER_NAME_LENGTH]; // 用户名
        public int 					emResultOrder;          // 查询结果排序方式, 参考 EM_RESULT_ORDER_TYPE
        public int                  bTime;                  // 是否按时间查询
        public int			        emCombination;			// 查询结果是否合并录像文件
        public EVENT_INFO[]			stuEventInfo=(EVENT_INFO[])new EVENT_INFO().toArray(16);		// 事件信息（定制），当查询为 DH_FILE_QUERY_FILE_EX 类型时有效
        public int					nEventInfoCount;		// stuEventInfo 个数
        public NET_IN_MEDIA_QUERY_FILE() {
            this.dwSize = this.size();
        }
    }

    // 录像信息对应 CLIENT_FindFileEx 接口的 NET_FILE_QUERY_FILE 命令 查询结果
    public static class NET_OUT_MEDIA_QUERY_FILE extends SdkStructure
    {
        public int                 	 dwSize;                 // 结构体大小
        public int                 	 nChannelID;             // 通道号从0开始,-1表示查询所有通道
        public NET_TIME            	 stuStartTime;           // 开始时间
        public NET_TIME            	 stuEndTime;             // 结束时间
        public int        		   	 nFileSize;              // 文件长度
        public byte                	 byFileType;             // 文件类型 1:jpg图片, 2: dav
        public byte                	 byDriveNo;              // 该字段已废弃,后续开发使用 nDriveNo成员
        public byte                	 byPartition;            // 分区号
        public byte                	 byVideoStream;          // 视频码流 0-未知 1-主码流 2-辅码流1 3-辅码流 4-辅码流
        public int        		   	 nCluster;               // 簇号
        public byte[]              	 szFilePath = new byte[MAX_PATH];   				  // 文件路径
        public int[]               	 nEventLists = new int[MAX_IVS_EVENT_NUM];  		  // 关联的事件列表,事件类型列表,参见智能分析事件类型
        public int                 	 nEventCount;            //事件总数
        public int[]  			   	 emFalgLists = new int[EM_RECORD_SNAP_FLAG_TYPE.FLAG_TYPE_MAX]; // 录像或抓图文件标志, 参考  EM_RECORD_SNAP_FLAG_TYPE
        public int                 	 nFalgCount;             //标志总数
        public int        		   	 nDriveNo;               // 磁盘号

        //频浓缩文件相关信息
        public byte[]			   	 szSynopsisPicPath = new byte[NET_COMMON_STRING_512]; // 预处理文件提取到的快照	文件路径
        // 支持HTTP URL表示:"http://www.dahuate.com/1.jpg"
        // 支持FTP URL表示: "ftp://ftp.dahuate.com/1.jpg"
        // 支持服务器本地路径
        // a)"C:/pic/1.jpg"
        // b)"/mnt//2010/8/11/dav/15:40:50.jpg"
        public int                 	 nSynopsisMaxTime;                      			  // 支持浓缩视频最大时间长度,单位 秒
        public int                 	 nSynopsisMinTime;                     				  // 支持浓缩视频最小时间长度,单位 秒

        //文件摘要信息
        public int                 	 nFileSummaryNum;                                     // 文件摘要信息数
        public NET_FILE_SUMMARY_INFO[]   stFileSummaryInfo = (NET_FILE_SUMMARY_INFO[])new NET_FILE_SUMMARY_INFO().toArray(MAX_FILE_SUMMARY_NUM);   // 文件摘要信息
        public long                  nFileSizeEx;                           			  // 文件长度扩展,支持文件长度大于4G，单位字节
        public int					 nTotalFrame;									      // 查询录像段内所有帧总和，不区分帧类型(定制)
        public int                   emFileState;                       // 录像文件的状态,EM_VIDEO_FILE_STATE
        public byte[]                   szWorkDir=new byte[256];                    // 录像文件的存储目录
        public byte[]					szThumbnail=new byte[260];				   // 缩略图路径，可根据该路径下载缩略图
        public NET_OUT_MEDIA_QUERY_FILE() {
            this.dwSize = this.size();
        }
    }

    // 卡号录像信息
    public static class NET_RECORD_CARD_INFO extends SdkStructure
    {
        public int               	 dwSize;
        public int                   nType;                                          // 类型, 0-Card, 1-Field
        public byte[]                szCardNo = new byte[NET_MAX_CARD_INFO_LEN];     // 卡号
        public int   				 emTradeType;                                    // 交易类型, 参考 EM_ATM_TRADE_TYPE
        public byte[]                szAmount = new byte[NET_COMMON_STRING_64];      // 交易金额, 空字符串表示不限金额
        public int                   nError;                                         // 错误码, 0-所有错误, 1-吞钞, 2-吞卡
        public int                   nFieldCount;                                    // 域数量, 按域查询时有效
        public byte[]                szFields  = new byte[MAX_CARD_RECORD_FIELD_NUM * NET_COMMON_STRING_256];   // 域信息, 按域查询时有效
        public byte[]				 szChange  = new byte[NET_COMMON_STRING_32];	 // 零钱

        public NET_RECORD_CARD_INFO() {
            this.dwSize = this.size();
        }
    }

    // 文件摘要信息
    public static class NET_FILE_SUMMARY_INFO extends SdkStructure
    {
        public byte[]	 			 szKey = new byte[NET_COMMON_STRING_64];          // 摘要名称
        public byte[] 	 			 szValue = new byte[NET_COMMON_STRING_512];       // 摘要内容
        public byte[] 				 bReserved = new byte[256];                       // 保留字段
    }

    // 录像或抓图文件标志
    public static class EM_RECORD_SNAP_FLAG_TYPE extends SdkStructure
    {
        public static final int FLAG_TYPE_TIMING  = 0;                  //定时文件
        public static final int FLAG_TYPE_MANUAL  = 1;                  //手动文件
        public static final int FLAG_TYPE_MARKED  = 2;                  //重要文件
        public static final int FLAG_TYPE_EVENT   = 3;                  //事件文件
        public static final int FLAG_TYPE_MOSAIC  = 4;                  //合成图片
        public static final int FLAG_TYPE_CUTOUT  = 5;                  //抠图图片
        public static final int FLAG_TYPE_LEAVE_WORD  = 6;              //留言文件
        public static final int FLAG_TYPE_TALKBACK_LOCAL_SIDE  = 7;     //对讲本地方文件
        public static final int FLAG_TYPE_TALKBACK_REMOTE_SIDE = 8;     //对讲远程方文件
        public static final int FLAG_TYPE_SYNOPSIS_VIDEO  = 9;          //浓缩视频
        public static final int FLAG_TYPE_ORIGINAL_VIDEO  = 10;         //原始视频
        public static final int FLAG_TYPE_PRE_ORIGINAL_VIDEO = 11;      //已经预处理的原始视频
        public static final int FLAG_TYPE_BLACK_PLATE  = 12;            //黑名单图片
        public static final int FLAG_TYPE_ORIGINAL_PIC = 13;            //原始图片
        public static final int FLAG_TYPE_CARD = 14;                    //卡号录像
        public static final int FLAG_TYPE_MAX  = 128;
    }

    // 交易类型
    public static class EM_ATM_TRADE_TYPE extends SdkStructure
    {
        public static final int ATM_TRADE_ALL = 0;                      // 所有类型
        public static final int ATM_TRADE_ENQUIRY  = 1;                 // 查询
        public static final int ATM_TRADE_WITHDRAW = 2;                 // 取款
        public static final int ATM_TRADE_MODIFY_PASSWORD = 3;          // 修改密码
        public static final int ATM_TRADE_TRANSFER = 4;                 // 转账
        public static final int ATM_TRADE_DEPOSIT  = 5;                 // 存款
        public static final int ATM_TRADE_CARDLESS_ENQUIRY = 6;         // 无卡查询
        public static final int ATM_TRADE_CARDLESS_DEPOSIT = 7;         // 无卡存款
        public static final int ATM_TRADE_OTHER = 8;                    // 其他
    }

    // 查询结果排序方式
    public static class EM_RESULT_ORDER_TYPE extends SdkStructure
    {
        public static final int EM_RESULT_ORDER_UNKNOWN = 0;            // 未知
        public static final int EM_RESULT_ORDER_ASCENT_BYTIME  = 1;     // 按时间升序排序
        public static final int EM_RESULT_ORDER_DESCENT_BYTIME = 2;     // 按时间降序排序
    }

    // CLIENT_ControlDevice 接口的 CTRLTYPE_CTRL_START_VIDEO_ANALYSE 命令参数, 开始视频智能分析
    public static class NET_CTRL_START_VIDEO_ANALYSE extends SdkStructure
    {
        public int               dwSize;
        public int               nChannelId;             				// 通道号

        public NET_CTRL_START_VIDEO_ANALYSE() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_ControlDevice 接口的 CTRLTYPE_CTRL_STOP_VIDEO_ANALYSE 命令参数, 停止视频智能分析
    public static class NET_CTRL_STOP_VIDEO_ANALYSE extends SdkStructure
    {
        public int          	dwSize;
        public int              nChannelId;             			  // 通道号

        public NET_CTRL_STOP_VIDEO_ANALYSE() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_AttachVideoAnalyseState 接口输入参数
    public static class NET_IN_ATTACH_VIDEOANALYSE_STATE extends SdkStructure
    {
        public int              	dwSize;
        public int                  nChannleId;            			// 通道号
        public Callback      cbVideoAnalyseState;   			// 视频分析状态回调函数,fVideoAnalyseState 回调
        public Pointer              dwUser;                			// 用户信息

        public NET_IN_ATTACH_VIDEOANALYSE_STATE() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_AttachVideoAnalyseState 接口输出参数
    public static class NET_OUT_ATTACH_VIDEOANALYSE_STATE extends SdkStructure
    {
        public int              	dwSize;
        public LLong           		lAttachHandle;         			// 分析进度句柄,唯一标识某一通道的分析进度

        public NET_OUT_ATTACH_VIDEOANALYSE_STATE() {
            this.dwSize = this.size();
        }
    }

    public static class NET_VIDEOANALYSE_STATE extends SdkStructure
    {
        public int            	   dwSize;
        public int            	   dwProgress;                        			  // 分析进度,0-100
        public byte[]              szState = new byte[NET_COMMON_STRING_64];      // 通道状态,Running"：运行,"Stop"：停止,"NoStart"：未启动,"Failed"：失败,"Successed"：成功
        public byte[]              szFailedCode = new byte[NET_COMMON_STRING_64]; // 错误码

        public NET_VIDEOANALYSE_STATE() {
            this.dwSize = this.size();
        }
    }

    // 热成像火情报警信息上报事件, 对应事件  NET_ALARM_FIREWARNING_INFO TODO // 热成像火情报警信息上报事件 #define DH_ALARM_FIREWARNING_INFO 0x31da // 热成像火情报警信息上报(对应结构体 ALARM_FIREWARNING_INFO_DETAIL)
    public static class ALARM_FIREWARNING_INFO_DETAIL extends SdkStructure
    {
        public int                       nChannel;                                             // 对应视频通道号
        public int                       nWarningInfoCount;                                    // 报警信息个数
        public NET_FIREWARNING_INFO[]    stuFireWarningInfo
                = new NET_FIREWARNING_INFO[MAX_FIREWARNING_INFO_NUM]; // 具体报警信息
        public byte[]                    reserved = new byte[256];

        public ALARM_FIREWARNING_INFO_DETAIL() {
            for(int i = 0; i < stuFireWarningInfo.length; i++) {
                stuFireWarningInfo[i] = new NET_FIREWARNING_INFO();
            }
        }
    }

    //热成像火情报警信息
    public static class NET_FIREWARNING_INFO extends SdkStructure
    {
        public int                 nPresetId;                          // 预置点编号	从测温规则配置 CFG_RADIOMETRY_RULE_INFO 中选择
        public NET_RECT            stuBoundingBox;                     // 着火点矩形框
        public int                 nTemperatureUnit;                   // 温度单位(当前配置的温度单位),见 NET_TEMPERATURE_UNIT
        public float               fTemperature;                       // 最高点温度值	同帧检测和差分检测提供
        public int                 nDistance;                          // 着火点距离,单位米 0表示无效
        public GPS_POINT           stuGpsPoint;                        // 着火点经纬度
        public PTZ_POSITION_UNIT   stuPTZPosition;                     // 云台运行信息
        public float               fAltitude;                          // 高度(单位：米)
        public int                 nThermoHFOV;						   // Uint32 热成像横向视角
        public int                 nThermoVFOV;						   // Uint32 热成像纵向视角
        public int                 nFSID;						       // 火情编号ID
        public NET_FIRING_GPS_INFO	stuFiringGPS;						// 着火点的GPS坐标
        public byte[]               reserved=new byte[148];
    }

    // 着火点经纬度
    public static class GPS_POINT extends SdkStructure
    {
        public int         		  dwLongitude;                         // 经度(单位是百万分之度,范围0-360度)如东经120.178274度表示为300178274
        public int         		  dwLatidude;                          // 纬度(单位是百万分之度,范围0-180度)如北纬30.183382度表示为120183382
        // 经纬度的具体转换方式可以参考结构体  NET_WIFI_GPS_INFO 中的注释
    }

    //云台控制坐标单元
    public static class PTZ_POSITION_UNIT extends SdkStructure
    {
        public int                 nPositionX;                        // 云台水平方向角度,归一化到-1~1
        public int                 nPositionY;                        // 云台垂直方向角度,归一化到-1~1
        public int                 nZoom;                             // 云台光圈放大倍率,归一化到 0~1
        public byte[]              szReserve = new byte[32];          // 预留32字节
    }

    // 搜索到的地点信息
    public static class NET_WIFI_GPS_INFO extends SdkStructure
    {
        public int	 			  emPositioningResult;			      // 定位结果, 参考   NET_GPS_POSITION_RESULT
        public int 				  nLongitude;				 		  // 经度(单位是百万分之一度)
        // 西经：0 - 180000000				实际值应为: 180*1000000 – dwLongitude
        // 东经：180000000 - 360000000		实际值应为: dwLongitude – 180*1000000
        // 如: 300168866应为（300168866 - 180*1000000）/1000000 即东经120.168866度
        public int				  nLatidude;				     	  // 纬度(单位是百万分之一度)
        // 南纬：0 - 90000000				实际值应为: 90*1000000 – dwLatidude
        // 北纬：90000000 – 180000000		实际值应为: dwLatidude – 90*1000000
        // 如: 120186268应为 (120186268 - 90*1000000)/1000000 即北纬30. 186268度
        public int				  nSpeed;					 		  // 速度, 单位千分之一km/H
        public byte[]			  reserved = new byte[112];	 		  // 保留字段
    }

    // 定位结果
    public static class NET_GPS_POSITION_RESULT extends SdkStructure
    {
        public static final int NET_GPS_POSITION_RESULT_UNKNOWN = 0;  // 未知
        public static final int NET_GPS_POSITION_RESULT_FAILED = 1;	  // 有GPS数据,但定位失败,此时定位数据无意义
        public static final int NET_GPS_POSITION_RESULT_SUCCEED = 2;  // 有GPS数据,且定位成功,此时定位数据有意义
    }

    // 热成像增益模式
    public static class CFG_THERMO_GAIN_MODE extends SdkStructure
    {
        public static final int CFG_THERMO_GAIN_MODE_UNKNOWN = 0;
        public static final int CFG_THERMO_GAIN_MODE_HIGHTEMP = 1;	// 高温
        public static final int CFG_THERMO_GAIN_MODE_LOWTEMP = 2;	// 低温
        public static final int CFG_THERMO_GAIN_MODE_AUTO = 3;		// 自动
    }

    // 热成像自动增益设置
    public static class CFG_THERMO_AUTO_GAIN extends SdkStructure
    {
        public int                         nLowToHigh;             // 温度超过此设定值时，自动切换到高温模式
        public int                         nLHROI;                 // 由低温切换到高温时的ROI 百分比0~100
        public int                         nHighToLow;             // 温度下降到此设定值时，自动切换到低温模式
        public int                         nHLROI;             	   // 由高温切换到低温时的ROI 百分比0~100
    }

    // 热成像配置，单个模式的配置
    public static class CFG_THERMOGRAPHY_OPTION extends SdkStructure
    {
        public int                         nEZoom;                 // 倍数
        public int                         nThermographyGamma;     // 伽马值
        public int                         nColorization;	       // 伪彩色，见 NET_THERMO_COLORIZATION
        public int                         nSmartOptimizer;        // 智能场景优化指数 0 ~100， 具体取值范围由能力决定
        public int                         bOptimizedRegion;       // 是否开启感兴趣区域，只有感兴趣区域内的信息会被纳入统计用来做自动亮度调整（AGC）
        public int                         nOptimizedROIType;      // 感兴趣区域类型，见 NET_THERMO_ROI
        public int                         nCustomRegion;          // 自定义区域个数
        public CFG_RECT[]                  stCustomRegions = (CFG_RECT[])new CFG_RECT().toArray(64);    // 自定义区域，仅在 nOptimizedROIType 为 NET_THERMO_ROI_CUSTOM 时有效
        public byte[]                      Reserved = new byte[256];          // 此保留字段确保此结构布局与 NET_THERMO_GRAPHY_INFO 相同
        public int                         nAgc;                   // 自动增益控制 [0-255]具体取值范围由能力决定
        public int                         nAgcMaxGain;            // 最大自动增益 [0-255]具体取值范围由能力决定
        public int                         nAgcPlateau;            // 增益均衡 具体取值范围由能力决定
        public int                         nGainMode;              // 增益模式，参见 CFG_THERMO_GAIN_MODE
        public CFG_THERMO_AUTO_GAIN        stAutoGain;             // 自动增益设置，只在增益模式为 CFG_THERMO_GAIN_MODE_AUTO 有效
        public CFG_THERMO_GAIN             stuHighTempGain;        // 高温下的增益设置
        public int                         nBaseBrightness;        // 基准亮度
        public int                         nStretchIntensity;      // 拉伸强度
        public CFG_RECT                    stuContrastRect;        // 区域增强位置,增加本区域与周边的对比度,8192坐标系
    }

    // 热成像配置
    public static class CFG_THERMOGRAPHY_INFO extends SdkStructure
    {
        public int                         nModeCount;             // 模式个数，目前只有一个
        public CFG_THERMOGRAPHY_OPTION[]   stOptions = new CFG_THERMOGRAPHY_OPTION[16]; // 对应不同模式的配置

        public CFG_THERMOGRAPHY_INFO() {
            for(int i = 0; i < stOptions.length; i++) {
                stOptions[i] = new CFG_THERMOGRAPHY_OPTION();
            }
        }
    }

    // 温度单位
    public static class NET_TEMPERATURE_UNIT extends SdkStructure
    {
        public static final int NET_TEMPERATURE_UNIT_UNKNOWN = 0;
        public static final int NET_TEMPERATURE_UNIT_CENTIGRADE = 1;  // 摄氏度
        public static final int NET_TEMPERATURE_UNIT_FAHRENHEIT = 2;  // 华氏度
    }

    // 测温规则配置结构, 对应命令  CFG_CMD_THERMOMETRY_RULE
    public static class CFG_RADIOMETRY_RULE_INFO extends SdkStructure
    {
        public int                         nCount;                 				  // 规则个数
        public CFG_RADIOMETRY_RULE[]       stRule = new CFG_RADIOMETRY_RULE[512]; // 测温规则

        public CFG_RADIOMETRY_RULE_INFO() {
            for(int i = 0; i < stRule.length; i++) {
                stRule[i] = new CFG_RADIOMETRY_RULE();
            }
        }
    }

    // 区域测温的子类型
    public static class EM_CFG_AREA_SUBTYPE extends SdkStructure
    {
        public static final int EM_CFG_AREA_SUBTYPE_UNKNOWN = 0;
        public static final int EM_CFG_AREA_SUBTYPE_RECT = 1;		// 矩形
        public static final int EM_CFG_AREA_SUBTYPE_ELLIPSE = 2;	// 椭圆
        public static final int EM_CFG_AREA_SUBTYPE_POLYGON = 3;	// 多边形
    }

    // 测温规则
    public static class CFG_RADIOMETRY_RULE extends SdkStructure
    {
        public int                            bEnable;                // 测温使能, BOOL类型
        public int                            nPresetId;              // 预置点编号
        public int                            nRuleId;                // 规则编号
        public byte[]                         szName = new byte[128]; // 自定义名称
        public int                            nMeterType;             // 测温模式的类型，见 NET_RADIOMETRY_METERTYPE
        public CFG_POLYGON[]                  stCoordinates = new CFG_POLYGON[64];      // 测温点坐标	使用相对坐标体系，取值均为0~8191
        public int                         	  nCoordinateCnt;         // 测温点坐标实际个数
        public int                            nSamplePeriod;          // 温度采样周期	单位 : 秒
        public CFG_RADIOMETRY_ALARMSETTING[]  stAlarmSetting = new CFG_RADIOMETRY_ALARMSETTING[64];     // 测温点报警设置
        public int                            nAlarmSettingCnt;       // 测温点报警设置实际个数
        public CFG_RADIOMETRY_LOCALPARAM      stLocalParameters;      // 本地参数配置
        public int							  emAreaSubType;		  // 区域测温的子类型, 见EM_CFG_AREA_SUBTYPE
        public CFG_RADIOMETRY_RULE() {
            for(int i = 0; i < stCoordinates.length; i++) {
                stCoordinates[i] = new CFG_POLYGON();
            }

            for(int i = 0; i < stAlarmSetting.length; i++) {
                stAlarmSetting[i] = new CFG_RADIOMETRY_ALARMSETTING();
            }
        }
    }

    // 温度统计
    public static class CFG_TEMP_STATISTICS extends SdkStructure
    {
        public int                        bEnable;                // 是否开启温度统计
        public byte[]                     szName = new byte[128]; // 测温项的名字
        public int                        nMeterType;             // 测温模式的类型，见 NET_RADIOMETRY_METERTYPE
        public int                        nPeriod;                // 保存温度数据周期
    }

    // 温度统计配置结构
    public static class CFG_TEMP_STATISTICS_INFO extends SdkStructure
    {
        public int                         nCount;                 // 个数
        public CFG_TEMP_STATISTICS[]       stStatistics = new CFG_TEMP_STATISTICS[64]; // 温度统计

        public CFG_TEMP_STATISTICS_INFO() {
            for(int i = 0; i < stStatistics.length; i++) {
                stStatistics[i] = new CFG_TEMP_STATISTICS();
            }
        }
    }

    // 温度单位
    public static class CFG_TEMPERATURE_UNIT extends SdkStructure
    {
        public static final int TEMPERATURE_UNIT_UNKNOWN = 0;
        public static final int TEMPERATURE_UNIT_CENTIGRADE = 1;	// 摄氏度
        public static final int TEMPERATURE_UNIT_FAHRENHEIT = 2;	// 华氏度
    }

    // 热成像测温全局配置
    public static class CFG_THERMOMETRY_INFO extends SdkStructure
    {
        public int                         nRelativeHumidity;          // 相对湿度
        public float                       fAtmosphericTemperature;    // 大气温度
        public float                       fObjectEmissivity;          // 物体辐射系数
        public int                         nObjectDistance;            // 物体距离
        public float                       fReflectedTemperature;      // 物体反射温度
        public int                         nTemperatureUnit;           // 温度单位，见 TEMPERATURE_UNIT
        public int                         bIsothermEnable;            // 色标功能使能
        public int                         nMinLimitTemp;              // 等温线下限温度值
        public int                         nMediumTemp;                // 等温线中位温度值
        public int                         nMaxLimitTemp;              // 等温线上限温度值
        public int                         nSaturationTemp;            // 等温线饱和温度值
        public CFG_RECT                    stIsothermRect;             // 色温条矩形区域（OSD 位置），使用相对坐标体系，取值均为0-8191
        public int                         bColorBarDisplay;           // 是否显示色标条（OSD 叠加）
        public int                         bHotSpotFollow;             // 是否开启热点探测追踪使能
        public int                         bTemperEnable;              // 测温开关
        public CFG_RGBA                    stHighCTMakerColor;         // 高色温标注颜色
        public CFG_RGBA                    stLowCTMakerColor;          // 低色温标注颜色
    }

    // 测温点报警设置
    public static class CFG_RADIOMETRY_ALARMSETTING extends SdkStructure
    {
        public int                         nId;                    // 报警唯一编号	报警编号统一编码
        public int                         bEnable;                // 是否开启该点报警, BOOL类型
        public int                         nResultType;            // 测温报警结果类型，见 CFG_STATISTIC_TYPE，可取值：
        // 点测温：具体值，
        // 线测温：最大, 最小, 平均
        // 区域测温：最大, 最小, 平均, 标准, 中间, ISO
        public int                         nAlarmCondition;        // 报警条件，见 CFG_COMPARE_RESULT
        public float                       fThreshold;             // 报警阈值温度	浮点数
        public float                       fHysteresis;            // 温度误差，浮点数，比如0.1 表示正负误差在0.1范围内
        public int                         nDuration;              // 阈值温度持续时间	单位：秒
    }

    // 测温规则本地参数配置
    public static class CFG_RADIOMETRY_LOCALPARAM extends SdkStructure
    {
        public int                         bEnable;                // 是否启用本地配置, BOOL类型
        public float                       fObjectEmissivity;      // 目标辐射系数	浮点数 0~1
        public int                         nObjectDistance;        // 目标距离
        public int                         nRefalectedTemp;        // 目标反射温度
    }

    // 通道录像组状态
    public static class CFG_DEVRECORD_INFO extends SdkStructure
    {
        public byte[]                   szDevName = new byte[MAX_NAME_LEN];               // 设备名称
        public byte[]                   szIP = new byte[MAX_ADDRESS_LEN];                 // 设备IP
        public byte[]                   szChannel = new byte[MAX_NAME_LEN];               // 通道号
        public byte[]                   szChannelName = new byte[MAX_NAME_LEN];           // 通道名称
        public byte[]                   szStoragePosition = new byte[MAX_NAME_LEN];       // 存储位置信息
        public byte                   	byStatus;                              			  // 状态 0:未知 1:录像 2:停止
        public byte[]                   byReserved = new byte[3];                         // 字节对齐
    }

    public static class CFG_DEVRECORDGROUP_INFO extends SdkStructure
    {
        public int                    nChannelNum;                          // 通道个数
        public CFG_DEVRECORD_INFO[]   stuDevRecordInfo = (CFG_DEVRECORD_INFO[])new CFG_DEVRECORD_INFO().toArray(MAX_CHAN_NUM);       // 通道录像状态信息
    }

    // 存储组通道相关配置
    public static class AV_CFG_StorageGroupChannel extends SdkStructure
    {
        public int			nStructSize;
        public int			nMaxPictures;					// 每个通道文件夹图片存储上限, 超过就覆盖
        public byte[]		szPath = new byte[AV_CFG_Max_ChannelRule];	// 通道在命名规则里的字符串表示, %c对应的内容

        public AV_CFG_StorageGroupChannel() {
            this.nStructSize = this.size();
        }
    }

    public static class DEVICE_NAME extends SdkStructure
    {
        public byte[]    szDeviceName = new byte[MAX_DEVICE_NAME_LEN];	// 历史SSID
    }

    // 存储组配置
    public static class AV_CFG_StorageGroup extends SdkStructure
    {
        public int							nStructSize;
        public byte[]						szName = new byte[AV_CFG_Group_Name_Len];	// 分组名称
        public byte[]						szMemo = new byte[AV_CFG_Group_Memo_Len];	// 分组说明
        public int							nFileHoldTime;								// 文件保留时间
        public int							bOverWrite;									// 存储空间满是否覆盖
        public byte[]						szRecordPathRule = new byte[AV_CFG_Max_Path];	// 录像文件路径命名规则
        public byte[]						szPicturePathRule = new byte[AV_CFG_Max_Path];	// 图片文件路径命名规则 %y年, %M月, %d日, %h时, %m分, %s秒, %c通道路径
        // 如果年月日时分秒出现两次, 第一次表示开始时间, 第二次表示结束时间
        public AV_CFG_StorageGroupChannel[]	stuChannels = new AV_CFG_StorageGroupChannel[AV_CFG_Max_Channel_Num];// 通道相关配置
        public int							nChannelCount;				       								 // 通道配置数
        public byte[]                		szCustomName = new byte[AV_CFG_Group_Name_Len];        			// 自定义名称，若为空使用szName
        public DEVICE_NAME[]                szSubDevices = new DEVICE_NAME[MAX_DEV_NUM];     // 子设备列表
        public int            				nSubDevices;                        // 子设备数量

        public AV_CFG_StorageGroup() {
            this.nStructSize = this.size();

            for (int i = 0; i < stuChannels.length; ++i) {
                stuChannels[i] = new AV_CFG_StorageGroupChannel();
            }

            for (int i = 0; i < szSubDevices.length; ++i) {
                szSubDevices[i] = new DEVICE_NAME();
            }
        }
    };

    // 巡航路径中的预置点
    public static class CFG_PTZTOUR_PRESET extends SdkStructure
    {
        public int             nPresetID;              // 预置点编号
        public int             nDuration;              // 在改预置点的停留时间, 单位秒
        public int             nSpeed;                 // 到达该预置点的转动速度, 1~10
    }

    // 巡航路径
    public static class CFG_PTZTOUR_SINGLE extends SdkStructure
    {
        public int                         bEnable;                                    // 使能
        public byte[]                      szName = new byte[CFG_COMMON_STRING_64];               // 名称
        public int                         nPresetsNum;                                // 预置点数量
        public CFG_PTZTOUR_PRESET[]        stPresets = new CFG_PTZTOUR_PRESET[CFG_MAX_PTZTOUR_PRESET_NUM];      // 该路径包含的预置点参数

        public CFG_PTZTOUR_SINGLE() {
            for (int i = 0; i < stPresets.length; ++i) {
                stPresets[i] = new CFG_PTZTOUR_PRESET();
            }
        }
    }

    // 云台巡航路径配置
    public static class CFG_PTZTOUR_INFO extends SdkStructure
    {
        public int                         nCount;                                     // 巡航路径数量
        public CFG_PTZTOUR_SINGLE[]        stTours = new CFG_PTZTOUR_SINGLE[CFG_MAX_PTZTOUR_NUM];               // 巡航路径, 每个通道包含多条巡航路径

        public CFG_PTZTOUR_INFO() {
            for (int i = 0; i < stTours.length; ++i) {
                stTours[i] = new CFG_PTZTOUR_SINGLE();
            }
        }
    }


    // 云台控制坐标单元
    public static class CFG_PTZ_SPACE_UNIT extends SdkStructure
    {
        public int                 nPositionX;           //云台水平运动位置，有效范围：[0,3600]
        public int                 nPositionY;           //云台垂直运动位置，有效范围：[-1800,1800]
        public int                 nZoom;                //云台光圈变动位置，有效范围：[0,128]
    }

    // 云台控制预置点结构
    public static class PTZ_PRESET extends SdkStructure
    {
        public int                 bEnable;                             			// 该预置点是否生效
        public byte[]              szName = new byte[MAX_PTZ_PRESET_NAME_LEN];      // 预置点名称
        public CFG_PTZ_SPACE_UNIT  stPosition;                          		    // 预置点的坐标和放大倍数
    }

    // 云台预置点配置对应结构
    public static class PTZ_PRESET_INFO extends SdkStructure
    {
        public int              dwMaxPtzPresetNum;                     // 最大预置点个数
        public int              dwRetPtzPresetNum;                     // 实际使用预置点个数
        public Pointer          pstPtzPreset;                          // 预置点信息(根据最大个数申请内存，大小sizeof(PTZ_PRESET)*dwMaxPtzPresetNum)
    }

    // 统计量类型
    public static class CFG_STATISTIC_TYPE extends SdkStructure
    {
        public static final int CFG_STATISTIC_TYPE_UNKNOWN = 0;
        public static final int CFG_STATISTIC_TYPE_VAL = 1; 	   // 具体值
        public static final int CFG_STATISTIC_TYPE_MAX = 2; 	   // 最大
        public static final int CFG_STATISTIC_TYPE_MIN = 3; 	   // 最小
        public static final int CFG_STATISTIC_TYPE_AVR = 4; 	   // 平均
        public static final int CFG_STATISTIC_TYPE_STD = 5; 	   // 标准
        public static final int CFG_STATISTIC_TYPE_MID = 6; 	   // 中间
        public static final int CFG_STATISTIC_TYPE_ISO = 7; 	   // ISO
    }

    // 比较运算结果
    public static class CFG_COMPARE_RESULT extends SdkStructure
    {
        public static final int CFG_COMPARE_RESULT_UNKNOWN = 0;
        public static final int CFG_COMPARE_RESULT_BELOW = 1; 	  // 低于
        public static final int CFG_COMPARE_RESULT_MATCH = 2; 	  // 匹配
        public static final int CFG_COMPARE_RESULT_ABOVE = 3; 	  // 高于
    }

    // 记录集新增操作(insert)参数
    public static class NET_CTRL_RECORDSET_INSERT_PARAM extends SdkStructure
    {
        public int                             dwSize;
        public NET_CTRL_RECORDSET_INSERT_IN    stuCtrlRecordSetInfo;       // 记录集信息(用户填写)
        public NET_CTRL_RECORDSET_INSERT_OUT   stuCtrlRecordSetResult;     // 记录集信息(设备返回)

        public NET_CTRL_RECORDSET_INSERT_PARAM() {
            this.dwSize = this.size();
        }
    }

    // 记录集新增操作(insert)输入参数
    public static class NET_CTRL_RECORDSET_INSERT_IN extends SdkStructure
    {
        public int          		 dwSize;
        public int 	 				 emType;                             // 记录集信息类型, 取值参考  EM_NET_RECORD_TYPE
        public Pointer          	 pBuf;                               // 记录集信息缓存,详见EM_NET_RECORD_TYPE注释，由用户申请内存.
        public int             		 nBufLen;                            // 记录集信息缓存大小,大小参照记录集信息类型对应的结构体

        public NET_CTRL_RECORDSET_INSERT_IN() {
            this.dwSize = this.size();
        }
    }

    // 记录集新增操作(insert)输出参数
    public static class NET_CTRL_RECORDSET_INSERT_OUT extends SdkStructure
    {
        public int           		dwSize;
        public int             		nRecNo;                             // 记录编号(新增insert时设备返回)

        public NET_CTRL_RECORDSET_INSERT_OUT() {
            this.dwSize = this.size();
        }
    }

    // 门禁密码记录查询条件
    public static class FIND_RECORD_ACCESSCTLPWD_CONDITION extends SdkStructure
    {
        public int                     dwSize;
        public byte[]                  szUserID = new byte[NET_MAX_USERID_LEN];      // 用户ID

        public FIND_RECORD_ACCESSCTLPWD_CONDITION() {
            this.dwSize = this.size();
        }
    }

    // 门禁密码记录集信息
    public static class NET_RECORDSET_ACCESS_CTL_PWD extends SdkStructure
    {
        public int           		  dwSize;
        public int             		  nRecNo;                                 		      // 记录集编号,只读
        public NET_TIME        		  stuCreateTime;                          			  // 创建时间
        public byte[]            	  szUserID = new byte[NET_MAX_USERID_LEN];            // 用户ID, 设备暂不支持
        public byte[]            	  szDoorOpenPwd = new byte[NET_MAX_CARDPWD_LEN];      // 开门密码
        public byte[]            	  szAlarmPwd = new byte[NET_MAX_CARDPWD_LEN];         // 报警密码
        public int             		  nDoorNum;                               			  // 有效的的门数目
        public int[]             	  sznDoors = new int[NET_MAX_DOOR_NUM];               // 有权限的门序号,即 CFG_CMD_ACCESS_EVENT 配置CFG_ACCESS_EVENT_INFO的数组下标
        public byte[]            	  szVTOPosition = new byte[NET_COMMON_STRING_64];     // 门口机关联位置
        public int             		  nTimeSectionNum;                        			  // 开门时间段个数
        public int[]                  nTimeSectionIndex = new int[NET_MAX_TIMESECTION_NUM];  // 开门时间段索引,是个数组，每个元素与sznDoors中的门对应
        public int             		  bNewDoor;                               			  // BOOL类型, 是否启动新开门授权字段，TRUE表示使用 nNewDoorNum 和 nNewDoors 字段下发开门权限
        public int             		  nNewDoorNum;                            			  // 有效的门数目;
        public int[]                  nNewDoors = new int[MAX_ACCESSDOOR_NUM];            // 有权限的门序号,即 CFG_CMD_ACCESS_EVENT 配置的数组下标
        public int             		  nNewTimeSectionNum;                    			  // 有效的的开门时间段数目
        public int[]             	  nNewTimeSectionNo = new int[MAX_ACCESSDOOR_NUM];    // 开门时间段索引,即 CFG_ACCESS_TIMESCHEDULE_INFO 的数组下标
        public NET_TIME        		  stuValidStartTime;                      			  // 开始有效期
        public NET_TIME        		  stuValidEndTime;                       			  // 结束有效期
        public int        		      nValidCounts;							              // 有效次数
        public byte[] 			szCitizenIDNo=new byte[20];						// 身份证号码
        public NET_RECORDSET_ACCESS_CTL_PWD() {
            this.dwSize = this.size();
        }
    }

    // 开门二维码记录集信息
    public static class NET_RECORD_ACCESSQRCODE_INFO extends SdkStructure
    {
        public int                     dwSize;                                   // 结构体大小
        public int                     nRecNo;                                   // 记录集编号,只读
        public byte[]				   szQRCode = new byte[NET_MAX_QRCODE_LEN];  // 二维码
        public int					   nLeftTimes;                               // 剩余的有效次数
        public NET_TIME        		   stuStartTime;                             // 有效期开始时间
        public NET_TIME        		   stuEndTime;                               // 有效期截止时间
        public byte[]                  szRoomNumber = new byte[16];              // 房间号
        public byte[]                  szUserID=new byte[32];					// 用户ID
        public NET_RECORD_ACCESSQRCODE_INFO(){
            this.dwSize = this.size();
        }
    }

    // 查询盒子工作状态, 对应命令  NET_DEVSTATE_GET_WORK_STATE
    public static class NET_QUERY_WORK_STATE extends SdkStructure
    {
        public int                    dwSize;                            // 保留字段
        public NET_WORKSTATE          stuWorkState;                      // 运行状态

        public NET_QUERY_WORK_STATE() {
            this.dwSize = this.size();
        }
    }

    // 设备工作状态
    public static class NET_WORKSTATE extends SdkStructure
    {
        public int                     bOnline;                           // 设备是否在线,BOOL类型
        public byte[]                  szFirmwareVersion = new byte[NET_COMMON_STRING_128];  // 固件版本号
        public float                   fTemperature;                      // 温度值, 单位摄氏度
        public float                   fPowerDissipation;                 // 功耗, 单位W
        public int                     nUtilizationOfCPU;                 // CPU 使用率
        public int                     nStorageNum;                       // 存储设备个数
        public NET_STORAGE_INFO[]      stuStorages = new NET_STORAGE_INFO[MAX_STORAGE_NUM];      // 存储设备信息
        public int					   nUpTimeLast;						 // 上次上电时间, 单位: 秒
        public int					   nUpTimeTotal;				     // 总共上电时间, 单位: 秒
        public double				   dbMemInfoTotal;					 // 总内存大小, 单位: 字节
        public double				   dbMemInfoFree;				     // 剩余内存大小, 单位: 字节
        public byte[]				   byReserved1 = new byte[4];	     // 字节对齐，非保留字节
        public byte[]				   szDevType = new byte[32];		 // 设备型号
        public NET_RESOURCE_STATE	   stuResourceStat;					 // 网络资源
        public byte[]                  byReserved = new byte[8];         // 保留字节

        public NET_WORKSTATE() {
            for(int i = 0; i < MAX_STORAGE_NUM; i++) {
                stuStorages[i] = new NET_STORAGE_INFO();
            }
        }
    }

    // 存储设备信息
    public static class NET_STORAGE_INFO extends SdkStructure
    {
        public int      			    emState;                           // 存储设备状态, ENUM_STORAGE_STATE
        public int                      nPartitonNum;                      // 分区个数
        public NET_PARTITION_INFO[]     stuPartions = new NET_PARTITION_INFO[MAX_PARTITION_NUM];    // 分区信息
        public byte[]                   byReserved = new byte[128];                   // 保留字段

        public NET_STORAGE_INFO() {
            for(int i = 0; i < MAX_PARTITION_NUM; i++) {
                stuPartions[i] = new NET_PARTITION_INFO();
            }
        }
    }

    // 网络资源
    public static class NET_RESOURCE_STATE extends SdkStructure
    {
        public int						nIPChanneIn;					// IP通道接入速度, 单位: kbps
        public int						nNetRemain;						// 网络接收剩余能力, 单位: kbps
        public int						nNetCapability;					// 网络接收总能力, 单位: kbps
        public int						nRemotePreview;					// 远程预览能力, 单位: kbps
        public int						nRmtPlayDownload;				// 远程回放及下载能力, 单位: kbps
        public int						nRemoteSendRemain;				// 远程发送剩余能力, 单位: kbps
        public int						nRemoteSendCapability;			// 远程发送总能力, 单位: kbps
        public byte[]                   byReserved = new byte[32];      // 保留字节
    }

    // 存储设备分区信息
    public static class NET_PARTITION_INFO extends SdkStructure
    {
        public double                    dbTotalBytes;                   // 分区总空间
        public double                    dbUsedBytes;                    // 分区使用的空间
        public int                       bError;                         // 是否异常, BOOL类型
        public byte[]                    byReserved = new byte[64];      // 保留字段
    }

    // CLIENT_GetSelfCheckInfo 输入参数
    public static class NET_IN_GET_SELTCHECK_INFO extends SdkStructure
    {
        public int               		dwSize;                  				// 用户使用该结构体时,dwSize 需赋值为 sizeof (NET_IN_GET_SELTCHECK_INFO)

        public NET_IN_GET_SELTCHECK_INFO() {
            this.dwSize = this.size();
        }
    }

    // 设备自检信息
    public static class NET_SELFCHECK_INFO extends SdkStructure
    {
        public int             		  dwSize;
        public int               	  nAlarmIn;                 // 报警输入通道数
        public int               	  nAlarmOut;                // 报警输出通道数
        public NET_TIME          	  stuTime;                  // 上报时间
        public byte[]                 szPlateNo = new byte[NET_MAX_PLATE_NUMBER_LEN]; // 车牌
        public byte[]                 szICCID = new byte[NET_MAX_SIM_LEN];  // SIM卡号,建议使用szICCIDExInfo字段
        public byte              	  byOrientation;            // 定位状态,0-未定位,1-定位
        public byte              	  byACCState;               // ACC 状态,0-关闭,1-打开
        public byte               	  byConstantElecState;      // 常电状态,0-正常连接,1-断开,2-欠压,3-高压
        public byte              	  byAntennaState;           // 通信信号状态,0-正常,1-未知故障,2-未接,3-短路

        // 外部设备状态
        public byte              	  byReportStation;          // 报站器状态,0-未接,1-正常,2-异常
        public byte              	  byControlScreen;          // 调度屏状态,0-未接,1-正常,2-异常
        public byte              	  byPOS;                    // POS机状态,0-未接,1-正常,2-异常
        public byte              	  byCoinBox;                // 投币箱状态,0-未接,1-正常,2-异常

        // 能力集
        public int              	  bTimerSnap;               // 定时抓图,TRUE-支持,FALSE-不支持, BOOL类型
        public int              	  bElectronEnclosure;       // 电子围栏,TRUE-支持,FALSE-不支持, BOOL类型
        public int              	  bTeleUpgrade;             // 远程升级,TRUE-支持,FALSE-不支持, BOOL类型

        public int               	  nHddNum;                  // 硬盘个数
        public NET_HDD_STATE[]        stuHddStates = new NET_HDD_STATE[NET_MAX_DISKNUM]; // 硬盘状态

        public Pointer 				  pChannleState;           // 通道状态,是一个 NET_CHANNLE_STATE 数组,
        // CLIENT_AttachMission接口,NET_MISSION_TYPE_SELFCHECK类型,回调函数,内存由SDK申请,SDK释放
        // CLIENT_GetSelfCheckInfo接口,出参,内存由用户申请,用户释放,大小为sizeof(NET_CHANNLE_STATE)*nChannelMax
        public int               	  nChannleNum;             // 实际上报的通道个数
        public int               	  nChannelMax;             // CLIENT_GetSelfCheckInfo接口,pChannleState内存的最大NET_CHANNLE_STATE个数
        public int         			  emConnState;             // PAD/DVR连接状态, 参考 NET_PAD_CONNECT_STATE
        public int                    emHomeState;             // Home键状态， 参考  NET_HOME_STATE
        public byte[]              	  szICCIDExInfo = new byte[NET_COMMON_STRING_256];  // SIM卡号扩展信息，用于字段扩展使用
        public byte              	  by3GState;                // 3G/4G状态, 0-未连接，1-连接，2-模块未找到
        public byte              	  byWifiState;              // Wifi状态, 0-未连接，1-连接，2-模块未找到
        public byte             	  byGpsState;               // Gps状态, 0-未连接，1-连接，2-模块未找到
        public byte              	  byBlackBoxState;          // BlackBox状态, 0-未接，1-正常
        public int               	  nCpuUsage;                // CPU使用百分比, 单位%
        public int               	  nTemperature;             // 设备内部温度, 摄氏度
        public byte[]			  szVendor=new byte[32];				// 生产厂商
        public byte[]			  szFirmwareVersion=new byte[128];	// 设备程序版本，是一个字符数组
        public byte[]			  szSecurityBaseLineVersion=new byte[8];  // 安全基线版本
        public NET_GPS_STATUS_INFO	  stuGPSStatusInfo;			// GPS状态信息
        public byte[]			  szNetworkOperName=new byte[32];			// 4G运营商网络信息，需要向sim卡提供方获取
        public int		emEmergencyStatus;				// 紧急报警状态,EM_EMERGENCYSTATUS_TYPE
        public int	emTamperAletStatus;				// 设备锁状态,EM_TAMPERALTERSTATUS_TYPE
        public byte[]			  szImei=new byte[16];						// 国际移动设备辨识码15位数字标识
        public int			  nGSMsignalStrength;				// 3G信号强度0 - 31
        public int			  nMcc;							// 移动信号所属国家码
        public int			  nMnc;							// 移动网络号码，用于识别移动客户所属的移动网络，2~3位数字组成
        public int			  nLAC;							// 位置区码 （移动通信系统中）,是为寻呼而设置的一个区域，覆盖一片地理区域，初期一般按行政区域划分（一个县或一个区）,现在很灵活了，按寻呼量划分
        public int			  nCi;							// 小区识别码,三种主要的基于位置服务（LBS）技术之一。小区识别码通过识别网络中哪一个小区传输用户呼叫并将该信息翻译成纬度和经度来确定用户位置
        public int				  nAlarmInStatusNum;				// IO报警输入状态个数
        public int[]				  nAlarmInStatus=new int[32];				// IO报警输入状态列表一维数组，每个成员表示对应的通道报警输入状态（0=Off; 1 =On）
        public int				  nAlarmOutStatusNum;				// IO报警输出状态个数
        public int[]				  nAlarmOutStatus=new int[32];			// IO报警输出状态列表一维数组，每个成员表示对应的通道报警输出状态（0=Off; 1 =On）
        public byte[]			  szMasterSvrAddr=new byte[128];			// 主服务器地址，IPv4格式为点分十进制，IPv6格式为x:x:x:x:x:x:x:x，其中x是16位的十六进制值
        public byte[]			  szSlaveSvrAddr=new byte[128];			// 从服务器地址，IPv4格式为点分十进制，IPv6格式为x:x:x:x:x:x:x:x，其中x是16位的十六进制值
        public byte[]			  szSerialNo=new byte[48];					// 设备序列号

        public NET_SELFCHECK_INFO() {
            this.dwSize = this.size();

            for(int i = 0; i < NET_MAX_DISKNUM; i++) {
                stuHddStates[i] = new NET_HDD_STATE();
            }
        }
    }

    // 硬盘状态
    public static class NET_HDD_STATE extends SdkStructure
    {
        public int             		  dwSize;
        public int               	  nState;                   // 硬盘状态,0-正常,1-错误
        public double            	  dbTotalSize;              // 硬盘总容量,字节为单位
        public NET_PARTITION_STATE[]  stuPartitions = new NET_PARTITION_STATE[NET_MAX_STORAGE_PARTITION_NUM]; // 分区状态
        public int               	  nPartitionNum;            // 分区数

        public NET_HDD_STATE() {
            this.dwSize = this.size();

            for(int i = 0; i < NET_MAX_STORAGE_PARTITION_NUM; i++) {
                stuPartitions[i] = new NET_PARTITION_STATE();
            }
        }
    }

    // 分区状态
    public static class NET_PARTITION_STATE extends SdkStructure
    {
        public int             		 dwSize;
        public int               	 nStatus;                  // 分区状态,0-正常,1-错误
        public double            	 dbTotalSize;              // 分区总容量,字节为单位
        public double            	 dbRemainSize;             // 剩余容量,字节为单位

        public NET_PARTITION_STATE() {
            this.dwSize = this.size();
        }
    }

    // 录像状态详细信息
    public static class NET_RECORD_STATE_DETAIL extends SdkStructure
    {
        public int                    dwSize;
        public int                    bMainStream;            // 主码流, TRUE-正在录像, FALSE-没在录像
        public int                    bExtraStream1;          // 辅码流1, TRUE-正在录像, FALSE-没在录像
        public int                    bExtraStream2;          // 辅码流2, TRUE-正在录像, FALSE-没在录像
        public int                    bExtraStream3;          // 辅码流3, TRUE-正在录像, FALSE-没在录像

        public NET_RECORD_STATE_DETAIL() {
            this.dwSize = this.size();
        }
    }

    // 硬盘信息
    public static class NET_DEV_DISKSTATE extends SdkStructure
    {
        public int                dwVolume;                           // 硬盘的容量, 单位MB(B表示字节)
        public int                dwFreeSpace;                        // 硬盘的剩余空间, 单位MB(B表示字节)
        public byte               dwStatus;                           // 高四位的值表示硬盘类型,具体见枚举类型EM_DISK_TYPE；低四位的值表示硬盘的状态,0-休眠,1-活动,2-故障等；将DWORD拆成四个BYTE
        public byte               bDiskNum;                           // 硬盘号
        public byte               bSubareaNum;                        // 分区号
        public byte               bSignal;                            // 标识,0为本地 1为远程
    }

    // 设备硬盘信息
    public static class NET_DEV_HARDDISK_STATE extends SdkStructure
    {
        public int                		dwDiskNum;                         				  // 个数
        public NET_DEV_DISKSTATE[]      stDisks = new NET_DEV_DISKSTATE[NET_MAX_DISKNUM]; // 硬盘或分区信息

        public NET_DEV_HARDDISK_STATE() {
            for(int i = 0; i < NET_MAX_DISKNUM; i++) {
                stDisks[i] = new NET_DEV_DISKSTATE();
            }
        }
    }

    public static class EM_DISK_TYPE extends SdkStructure
    {
        public static final int SDK_DISK_READ_WRITE = 0;   // 读写驱动器
        public static final int SDK_DISK_READ_ONLY = 1;    // 只读驱动器
        public static final int SDK_DISK_BACKUP = 2;       // 备份驱动器或媒体驱动器
        public static final int SDK_DISK_REDUNDANT = 3;    // 冗余驱动器
        public static final int SDK_DISK_SNAPSHOT = 4;     // 快照驱动器
    }


    //表示硬盘的基本信息
    public static class NETDEV_DEVICE_INFO extends SdkStructure
    {
        public byte[]                byModle = new byte[32];                  // 型号
        public byte[]                bySerialNumber = new byte[32];           // 序列号
        public byte[]                byFirmWare = new byte[32];               // 固件号
        public int                   nAtaVersion;                  // ATA协议版本号
        public int                 	 nSmartNum ;                   // smart 信息数
        public long               	 Sectors;
        public int                 	 nStatus;                      // 磁盘状态 0-正常 1-异常
        public int[]                 nReserved = new int[33];                // 保留字节
    }

    //硬盘的smart信息,可能会有很多条,最多不超过30个　　
    public static class NETDEV_SMART_VALUE extends SdkStructure
    {
        public byte    byId;               // ID
        public byte    byCurrent;          // 属性值
        public byte    byWorst;            // 最大出错值
        public byte    byThreshold;        // 阈值
        public byte[]  szName = new byte[64];   // 属性名
        public byte[]  szRaw = new byte[8];     // 实际值
        public int     nPredict;           		// 状态
        public byte[]  reserved = new byte[128];
    }

    //硬盘smart信息查询
    public static class NETDEV_SMART_HARDDISK extends SdkStructure
    {
        public byte                	nDiskNum;                       // 硬盘号
        public byte                	byRaidNO;                       // Raid子盘,0表示单盘
        public byte[]               byReserved = new byte[2];       // 保留字节
        public NETDEV_DEVICE_INFO  	deviceInfo;
        public NETDEV_SMART_VALUE[] smartValue = new NETDEV_SMART_VALUE[MAX_SMART_VALUE_NUM];

        public NETDEV_SMART_HARDDISK() {
            for(int i = 0; i < MAX_SMART_VALUE_NUM; i++) {
                smartValue[i] = new NETDEV_SMART_VALUE();
            }
        }
    }

    // 扩展网络配置结构体
    public static class NETDEV_NET_CFG_EX extends SdkStructure
    {
        public int               	dwSize;
        public byte[]               sDevName = new byte[NET_MAX_NAME_LEN];  // 设备主机名
        public short                wTcpMaxConnectNum;                  	// TCP最大连接数
        public short                wTcpPort;                           	// TCP帧听端口
        public short                wUdpPort;                           	// UDP侦听端口
        public short                wHttpPort;                          	// HTTP端口号
        public short                wHttpsPort;                         	// HTTPS端口号
        public short                wSslPort;                           	// SSL端口号
        public int                  nEtherNetNum;                      	 	// 以太网口数
        public NET_ETHERNET_EX[]    stEtherNet = new NET_ETHERNET_EX[NET_MAX_ETHERNET_NUM_EX]; // 以太网口
        public NET_REMOTE_HOST      struAlarmHost;                      	// 报警服务器
        public NET_REMOTE_HOST      struLogHost;                        	// 日志服务器
        public NET_REMOTE_HOST      struSmtpHost;                       	// SMTP服务器
        public NET_REMOTE_HOST      struMultiCast;                      	// 多播组
        public NET_REMOTE_HOST      struNfs;                            	// NFS服务器
        public NET_REMOTE_HOST      struPppoe;                          	// PPPoE服务器
        public byte[]               sPppoeIP = new byte[NET_MAX_IPADDR_LEN]; // PPPoE注册返回的IP
        public NET_REMOTE_HOST      struDdns;                           	// DDNS服务器
        public byte[]               sDdnsHostName = new byte[NET_MAX_HOST_NAMELEN]; // DDNS主机名
        public NET_REMOTE_HOST      struDns;                            	// DNS服务器
        public NET_MAIL_CFG         struMail;                           	// 邮件配置
        public byte[]               bReserved = new byte[128];          	// 保留字节

        public NETDEV_NET_CFG_EX() {
            this.dwSize = this.size();

            for(int i = 0; i < NET_MAX_ETHERNET_NUM_EX; i++) {
                stEtherNet[i] = new NET_ETHERNET_EX();
            }
        }
    }

    // 以太网扩展配置
    public static class NET_ETHERNET_EX extends SdkStructure
    {
        public byte[]                sDevIPAddr = new byte[NET_MAX_IPADDR_LEN];      // DVR IP 地址
        public byte[]                sDevIPMask = new byte[NET_MAX_IPADDR_LEN];      // DVR IP 地址掩码
        public byte[]                sGatewayIP = new byte[NET_MAX_IPADDR_LEN];      // 网关地址

        /*
         * 1：10Mbps 全双工
         * 2：10Mbps 自适应
         * 3：10Mbps 半双工
         * 4：100Mbps 全双工
         * 5：100Mbps 自适应
         * 6：100Mbps 半双工
         * 7：自适应
         */
        // 为了扩展将DWORD拆成四个
        public byte                dwNetInterface;                     				// NSP
        public byte                bTranMedia;                         				// 0：有线,1：无线
        public byte                bValid;                             				// 按位表示,第一位：1：有效 0：无效；第二位：0：DHCP关闭 1：DHCP使能；第三位：0：不支持DHCP 1：支持DHCP
        public byte                bDefaultEth;                        				// 是否作为默认的网卡 1：默认 0：非默认
        public byte[]              byMACAddr = new byte[NET_MACADDR_LEN];           // MAC地址,只读
        public byte                bMode;                              				// 网卡所处模式, 0:绑定模式, 1:负载均衡模式, 2:多址模式, 3:容错模式
        public byte[]              bReserved1 = new byte[3];                        // 字节对齐
        public byte[]              szEthernetName = new byte[NET_MAX_NAME_LEN];     // 网卡名,只读
        public byte[]              bReserved = new byte[12];                        // 保留字节
    }


    // 远程主机配置
    public static class NET_REMOTE_HOST extends SdkStructure
    {
        public byte                byEnable;                           				// 连接使能
        public byte                byAssistant;                        				// 目前只对于PPPoE服务器有用,0：在有线网卡拨号；1：在无线网卡上拨号
        public short               wHostPort;                         				// 远程主机 端口
        public byte[]              sHostIPAddr = new byte[NET_MAX_IPADDR_LEN];      // 远程主机 IP 地址
        public byte[]              sHostUser = new byte[NET_MAX_HOST_NAMELEN];      // 远程主机 用户名
        public byte[]              sHostPassword = new byte[NET_MAX_HOST_PSWLEN];   // 远程主机 密码
    }

    // 邮件配置
    public static class NET_MAIL_CFG extends SdkStructure
    {
        public byte[]               sMailIPAddr = new byte[NET_MAX_IPADDR_LEN];     // 邮件服务器IP地址
        public short                wMailPort;                          			// 邮件服务器端口
        public short                wReserved;                         				// 保留
        public byte[]               sSenderAddr = new byte[NET_MAX_MAIL_ADDR_LEN];  // 发送地址
        public byte[]               sUserName = new byte[NET_MAX_NAME_LEN];         // 用户名
        public byte[]               sUserPsw = new byte[NET_MAX_NAME_LEN];          // 用户密码
        public byte[]               sDestAddr = new byte[NET_MAX_MAIL_ADDR_LEN];    // 目的地址
        public byte[]               sCcAddr = new byte[NET_MAX_MAIL_ADDR_LEN];      // 抄送地址
        public byte[]               sBccAddr = new byte[NET_MAX_MAIL_ADDR_LEN];     // 暗抄地址
        public byte[]               sSubject = new byte[NET_MAX_MAIL_SUBJECT_LEN];  // 标题
    }


    // 自动维护配置
    public static class NETDEV_AUTOMT_CFG extends SdkStructure
    {
        public int                 dwSize;
        public byte                byAutoRebootDay;            // 自动重启；0：从不, 1：每天,2：每星期日,3：每星期一,......
        public byte                byAutoRebootTime;           // 0：0:00,1：1:00,......23：23:00
        public byte                byAutoDeleteFilesTime;      // 自动删除文件；0：从不,1：24H,2：48H,3：72H,4：96H,......
        public byte[]              reserved = new byte[13];    // 保留位

        public NETDEV_AUTOMT_CFG() {
            this.dwSize = this.size();
        }
    }

    // 电子围栏类型枚举
    public static class ENCLOSURE_TYPE
    {
        public static final int ENCLOSURE_UNKNOWN = 0x00;                       // 未知
        public static final int ENCLOSURE_LIMITSPEED = 0x01;                    // 限速区
        public static final int ENCLOSURE_DRIVEALLOW = 0x02;                    // 驾驶区
        public static final int ENCLOSURE_FORBIDDRIVE = 0x04;                   // 禁止区
        public static final int ENCLOSURE_LOADGOODS = 0x08;                     // 装货区
        public static final int ENCLOSURE_UPLOADGOODS = 0x10;                   // 卸货区
        public static final int ENCLOSURE_FLYALLOW = 0x20;                      // 飞行区
        public static final int ENCLOSURE_MANUALFORBIDFLY = 0x40;               // 禁飞区(手动设置)
        public static final int ENCLOSURE_FIXEDFORBIDFLY = 0x80;                // 禁飞区(机场) - 不可配置
        public static final int ENCLOSURE_FiXEDLIMITFLY = 0x81;                 // 限制飞行 - 不可配置
    }

    // 电子围栏配置
    public static class NETDEV_ENCLOSURE_CFG extends SdkStructure
    {
        public int          unType;                              // 电子围栏类型掩码,见 ENCLOSURE_TYPE
        public byte[]       bRegion = new byte[8];               // 前四位分别代表国家、省、市或区、县(0-255),后4bytes保留
        public int          unId;                                // 一个区域以一个ID标识
        public int          unSpeedLimit;                        // 限速,单位km/h
        public int          unPointNum;                          // 电子围栏区域顶点数
        public GPS_POINT[]  stPoints = (GPS_POINT[]) new GPS_POINT().toArray(128);       // 电子围栏区域信息
        public byte[]       szStationName = new byte[32];        // 电子围栏包围的车站站点名称
        public byte         bDisenable;                          // 去使能。 0 启用 ;1 不启用
        public byte 	    bShape;                              // 围栏形状 0 多边形 1 圆形
        public byte         bLimitType;                          // 围栏限制类型 0 无; 1 限高; 2 限半径; 3 限高限半径
        public byte         bAction;                             // 触发围栏后，设备的动作；0 无,兼容以前; 1 只报告; 2 悬停; 3 返航;
        public int          nLimitAltitude;                      // 高度 单位：厘米。 0 无效
        public int          nAlarmAltitude;                      // 预警高度单位：厘米。 0 无效
        public int          unLimitRadius;                       // 半径单位：厘米。0 无效
        public int          unAlarmRadius;                       // 预警半径：厘米。0 无效
        public byte[]       reserved = new byte[12];             // 保留
    }

    // 电子围栏版本号配置
    public static class NETDEV_ENCLOSURE_VERSION_CFG extends SdkStructure
    {
        public int          unType;                              // 围栏类型掩码,如LIMITSPEED | DRIVEALLOW
        public int[]        unVersion = new int[32];             // 每个类型一个版本号,用于统一平台与设备上的围栏配置
        public int          nReserved;                           // 保留
    }

    // 向视频输出口投放视频和图片文件, CLIENT_ControlDevice接口的 CTRLTYPE_CTRL_DELIVERY_FILE 命令参数
    public static class NET_CTRL_DELIVERY_FILE extends SdkStructure
    {
        public int                  	 dwSize;                             // 结构体大小
        public int                    	 nPort;                              // 视频输出口
        public int 						 emPlayMode;                         // 播放类型, 参考  EM_VIDEO_PLAY_MODE_TYPE
        public NET_TIME                	 stuStartPlayTime;                   // 开始播放的时间
        public NET_TIME                	 stuStopPlayTime;                    // 结束播放的时间，emPlayMode为 EM_VIDEO_PLAY_MODE_TYPE_REPEAT 时，此值有效
        public int                     	 nFileCount;                         // 投放的文件个数
        public NET_DELIVERY_FILE_INFO[]  stuFileInfo = new NET_DELIVERY_FILE_INFO[MAX_DELIVERY_FILE_NUM]; // 投放的文件信息

        public NET_CTRL_DELIVERY_FILE() {
            this.dwSize = this.size();

            for(int i = 0; i < MAX_DELIVERY_FILE_NUM; i++) {
                stuFileInfo[i] = new NET_DELIVERY_FILE_INFO();
            }
        }
    }

    // 投放文件信息
    public static class NET_DELIVERY_FILE_INFO extends SdkStructure
    {
        public int   				emFileType;                                  // 文件类型, 参考 EM_DELIVERY_FILE_TYPE
        public byte[]               szFileURL = new byte[DELIVERY_FILE_URL_LEN]; // 文件的资源地址
        public int                  nImageSustain;                               // 每张图片停留多长时间，单位秒 (emFileType为 EM_DELIVERY_FILE_TYPE_IMAGE 时此字段有效)
        public int                  emPlayWithMode;                              // 文件所属的模式, 参考 EM_PLAY_WITH_MODE
        public byte[]               byReserved = new byte[1020];                 // 保留字节
    }

    // 视频播放模式
    public static class EM_VIDEO_PLAY_MODE_TYPE extends SdkStructure
    {
        public static final int EM_VIDEO_PLAY_MODE_TYPE_UNKNOWN = 0;              // 未知
        public static final int EM_VIDEO_PLAY_MODE_TYPE_ONCE = 1;                 // 播放一次
        public static final int EM_VIDEO_PLAY_MODE_TYPE_REPEAT = 2;               // 循环播放
    }

    // 投放的文件类型
    public static class EM_DELIVERY_FILE_TYPE extends SdkStructure
    {
        public static final int EM_DELIVERY_FILE_TYPE_UNKNOWN = 0;                	// 未知
        public static final int EM_DELIVERY_FILE_TYPE_VIDEO = 1;                  	// 视频
        public static final int EM_DELIVERY_FILE_TYPE_IMAGE = 2;                	// 图片
        public static final int EM_DELIVERY_FILE_TYPE_AUDIO = 3;					// 音频
    }

    // CLIENT_ControlDevice接口的 CTRLTYPE_CTRL_START_PLAYAUDIO 命令参数
    public static class NET_CTRL_START_PLAYAUDIO extends SdkStructure
    {
        public int               dwSize;
        public byte[]            szAudioPath = new byte[NET_MAX_AUDIO_PATH];

        public NET_CTRL_START_PLAYAUDIO() {
            this.dwSize = this.size();
        }
    }

    // 公告记录信息查询条件
    public static class FIND_RECORD_ANNOUNCEMENT_CONDITION extends SdkStructure
    {
        public int                  dwSize;
        public int                  bTimeEnable;                      // 启用时间段查询, BOOL类型
        public NET_TIME             stStartTime;                      // 起始时间
        public NET_TIME             stEndTime;                        // 结束时间

        public FIND_RECORD_ANNOUNCEMENT_CONDITION() {
            this.dwSize = this.size();
        }
    }

    //公告记录信息
    public static class NET_RECORD_ANNOUNCEMENT_INFO extends SdkStructure
    {
        public int					dwSize;
        public int					nRecNo;									   		    // 记录集编号,只读
        public NET_TIME             stuCreateTime;                          			// 创建时间
        public NET_TIME				stuIssueTime;										// 公告发布时间
        public byte[]				szAnnounceTitle = new byte[NET_COMMON_STRING_64];	// 公告标题
        public byte[]				szAnnounceContent = new byte[NET_COMMON_STRING_256];//公告内容
        public byte[]				szAnnounceDoor = new byte[NET_COMMON_STRING_16];	//公告要发送的房间号
        public NET_TIME				stuExpireTime;										//公告过期的时间
        public int			 		emAnnounceState;									//公告的状态 , 参考 NET_ANNOUNCE_STATE
        public int		 			emAnnounceReadFlag;									//公告是否已经浏览, 参考 NET_ANNOUNCE_READFLAG

        public NET_RECORD_ANNOUNCEMENT_INFO() {
            this.dwSize = this.size();
        }
    }

    //公告的状态
    public static class NET_ANNOUNCE_STATE extends SdkStructure
    {
        public static final int NET_ANNOUNCE_STATE_UNSENDED = 0;    //初始状态(未发送)
        public static final int NET_ANNOUNCE_STATE_SENDED = 1;		//已经发送
        public static final int NET_ANNOUNCE_STATE_EXPIRED = 2;		//已经过期
        public static final int NET_ANNOUNCE_STATE_UNKNOWN = 3;		//未知
    }

    //公告是否已经浏览
    public static class NET_ANNOUNCE_READFLAG extends SdkStructure
    {
        public static final int NET_ANNOUNCE_READFLAG_UNREADED = 0; //未读
        public static final int NET_ANNOUNCE_READFLAG_READED = 1;	//已读
        public static final int NET_ANNOUNCE_READFLAG_UNKNOWN = 2;  //未知
    }

    // 开始实时监视并指定回调数据格式入参
    public static class NET_IN_REALPLAY_BY_DATA_TYPE extends SdkStructure
    {
        public int               		dwSize;                 // 结构体大小
        public int                  	nChannelID;             // 通道编号
        public Pointer              	hWnd;                   // 窗口句柄, HWND类型
        public int     					rType;                  // 码流类型 ，参考  NET_RealPlayType
        public fRealDataCallBackEx  	cbRealData;             // 数据回调函数
        public int   					emDataType;             // 回调的数据类型，参考 EM_REAL_DATA_TYPE
        public Pointer           		dwUser;                 // 用户数据
        public String         			szSaveFileName;         // 转换后的文件名
        public fRealDataCallBackEx2	    cbRealDataEx;           // 数据回调函数-扩展
        public int		                emAudioType;			// 音频格式,对应枚举EM_AUDIO_DATA_TYPE
        public NET_IN_REALPLAY_BY_DATA_TYPE() {
            this.dwSize = this.size();
        }
    }

    // 开始实时监视并指定回调数据格式出参
    public static class NET_OUT_REALPLAY_BY_DATA_TYPE extends SdkStructure
    {
        public int               		dwSize;                 // 结构体大小

        public NET_OUT_REALPLAY_BY_DATA_TYPE() {
            this.dwSize = this.size();
        }
    }

    // 实时监视回调数据类型
    public static class EM_REAL_DATA_TYPE extends SdkStructure
    {
        public static final int EM_REAL_DATA_TYPE_PRIVATE = 0;       // 私有码流
        public static final int EM_REAL_DATA_TYPE_GBPS = 1;          // 国标PS码流
        public static final int EM_REAL_DATA_TYPE_TS = 2;            // TS码流
        public static final int EM_REAL_DATA_TYPE_MP4 = 3;           // MP4文件(从回调函数出来的是私有码流数据,参数dwDataType值为0)
        public static final int EM_REAL_DATA_TYPE_H264 = 4;          // 裸H264码流
        public static final int EM_REAL_DATA_TYPE_FLV_STREAM = 5;	 // 流式FLV
    }

    // 开始回放并指定回调数据格式 入参
    public static class NET_IN_PLAYBACK_BY_DATA_TYPE extends SdkStructure
    {
        public int               dwSize;                 // 结构体大小
        public int               nChannelID;             // 通道编号
        public NET_TIME          stStartTime;            // 开始时间
        public NET_TIME          stStopTime;             // 结束时间
        public Pointer           hWnd;                   // 播放窗格, 可为NULL
        public Callback   cbDownLoadPos;          // 进度回调
        public Pointer           dwPosUser;              // 进度回调用户信息
        public Callback   fDownLoadDataCallBack;  // 数据回调
        public int   			 emDataType;             // 回调的数据类型
        public Pointer           dwDataUser;             // 数据回调用户信息
        public int               nPlayDirection;         // 播放方向, 0:正放; 1:倒放;

        public NET_IN_PLAYBACK_BY_DATA_TYPE() {
            this.dwSize = this.size();
        }
    }

    // 开始回放并指定回调数据格式 出参
    public static class NET_OUT_PLAYBACK_BY_DATA_TYPE extends SdkStructure
    {
        public int               dwSize;                 // 结构体大小

        public NET_OUT_PLAYBACK_BY_DATA_TYPE() {
            this.dwSize = this.size();
        }
    }

    // 开始下载并指定回调数据格式 入参
    public static class NET_IN_DOWNLOAD_BY_DATA_TYPE extends SdkStructure
    {
        public int                      dwSize;                 // 结构体大小
        public int                      nChannelID;             // 通道编号
        public int        				emRecordType;           // 录像类型, 详见EM_QUERY_RECORD_TYPE
        public String                   szSavedFileName;        // 下载的文件路径
        public NET_TIME                 stStartTime;            // 开始时间
        public NET_TIME                 stStopTime;             // 结束时间
        public Callback    		        cbDownLoadPos;          // 进度回调
        public Pointer                  dwPosUser;              // 进度回调用户信息
        public Callback          fDownLoadDataCallBack;  // 数据回调
        public int           			emDataType;             // 回调的数据类型,详见 EM_REAL_DATA_TYPE
        public Pointer                  dwDataUser;             // 数据回调用户信息
        public int			            emAudioType;			// 音频类型,对应枚举EM_AUDIO_DATA_TYPE
        public NET_IN_DOWNLOAD_BY_DATA_TYPE() {
            this.dwSize = this.size();
        }
    }

    // 开始下载并指定回调数据格式 出参
    public static class NET_OUT_DOWNLOAD_BY_DATA_TYPE extends SdkStructure
    {
        public int               dwSize;                 // 结构体大小

        public NET_OUT_DOWNLOAD_BY_DATA_TYPE() {
            this.dwSize = this.size();
        }
    }

    // 事件类型 NET_ALARM_HIGH_SPEED (车辆超速报警事件)对应的数据块描述信息
    public static class ALARM_HIGH_SPEED_INFO extends SdkStructure
    {
        public int                        nAction;                   	// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
        public NET_TIME_EX			      stuTime;						// 事件发生的时间
        public double				      dbPTS;						// 时间戳(单位是毫秒)
        public NET_GPS_STATUS_INFO 		  stGPSStatusInfo;              // GPS信息
        public int						  nSpeedLimit;					// 车连限速值km/h
        public int						  nCurSpeed;					// 当前车辆速度km/h
        public int						  nMaxSpeed;					// 最高速度Km/h
        public byte[]                	  byReserved = new byte[508];   // 保留字节
    }

    // GPS状态信息
    public static class NET_GPS_STATUS_INFO extends SdkStructure
    {
        public NET_TIME                revTime;                        // 定位时间
        public byte[]                  DvrSerial = new byte[50];       // 设备序列号
        public byte[]                  byRserved1 = new byte[6];       // 对齐字节
        public double                  longitude;                      // 经度(单位是百万分之度,范围0-360度)
        public double                  latidude;                       // 纬度(单位是百万分之度,范围0-180度)
        public double                  height;                         // 高度(米)
        public double                  angle;                          // 方向角(正北方向为原点,顺时针为正)
        public double                  speed;                          // 速度(单位km/H)
        public short                   starCount;                      // 定位星数, emDateSource为 EM_DATE_SOURCE_GPS时有效
        public byte[]                  byRserved2 = new byte[2];       // 对齐字节
        public int   				   antennaState;                   // 天线状态, 参考  NET_THREE_STATUS_BOOL, emDateSource为 EM_DATE_SOURCE_GPS时有效
        public int   				   orientationState;               // 定位状态, 参考  NET_THREE_STATUS_BOOL
        public int                     workStae;                       // 工作状态(0=未定位,1=非差分定位,2=差分定位,3=无效PPS,6=正在估算
        // emDateSource为 EM_DATE_SOURCE_GPS时有效
        public int                     nAlarmCount;                    // 发生的报警位置个数
        public int[]                   nAlarmState = new int[128];     // 发生的报警位置,值可能多个, emDateSource为 EM_DATE_SOURCE_GPS时有效
        public byte                    bOffline;                       // 0-实时 1-补传
        public byte                    bSNR;                           // GPS信噪比,表示GPS信号强度,值越大,信号越强 范围：0~100,0表示不可用
        public byte[]                  byRserved3 = new byte[2];       // 对齐字节
        public int          		   emDateSource;                   // 数据来源, 参考 EM_DATE_SOURCE
        public int                     nSignalStrength;                // 在当前工作模式下（GPS或北斗等系统）的信号强度
        public float                   fHdop;                          // 水平精度因子惯性导航时无效
        public float                   fPdop;                          // 位置精度因子,惯性导航时无效
        public byte[]                  byRserved = new byte[100];      // 保留字节
    }

    //三态布尔类型
    public static class NET_THREE_STATUS_BOOL extends SdkStructure
    {
        public static final int BOOL_STATUS_FALSE  = 0;
        public static final int BOOL_STATUS_TRUE   = 1;
        public static final int BOOL_STATUS_UNKNOWN = 2;  //未知
    }

    // 数据来源
    public static class EM_DATE_SOURCE extends SdkStructure
    {
        public static final int EM_DATE_SOURCE_GPS = 0;                // GPS
        public static final int EM_DATE_SOURCE_INERTIALNAVIGATION = 1; // 惯性导航数据
    }

    // Gps定位信息
    public static class NET_GPS_LOCATION_INFO extends SdkStructure
    {
        public GPS_Info	        	stuGpsInfo;               		// GPS信息
        public ALARM_STATE_INFO     stuAlarmStateInfo;        		// 报警状态信息
        public int				    nTemperature;		      		// 温度(单位:0.1摄氏度)
        public int					nHumidity;				  		// 湿度(单位:0.1%)
        public int					nIdleTime;				 		// 怠速时长(单位:秒)
        public int        			nMileage;				  		// 里程(单位:0.1km)
        public int					nVoltage;				  		// 设置电压值(单位:0.1伏)
        public byte                 bOffline;                       // 0-实时 1-补传
        public byte[]			    byReserved = new byte[1023];
    }

    // 事件类型 NET_ALARM_VIDEO_LOSS (视频丢失事件)对应的数据块描述信息
    public static class ALARM_VIDEO_LOSS_INFO extends SdkStructure
    {
        public int                  nAction;                   		// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
        public int					nChannelID;						// 通道号
        public double				dbPTS;							// 时间戳(单位是毫秒)
        public byte[]				byReserved1 = new byte[4];		// 字节对齐
        public NET_TIME_EX			stuTime;						// 事件发生的时间
        public NET_TIME_EX						stuStartTime;					// 开始时间,nAction为2时上报此字段
        public NET_GPS_STATUS_INFO				stuGPS;							// GPS信息
        public byte[]               byReserved = new byte[1024];     // 保留字节
    }

    //报警事件类型 NET_ALARM_BUS_SHARP_ACCELERATE(车辆急加速事件)对应的数据描述信息
    public static class ALARM_BUS_SHARP_ACCELERATE_INFO extends SdkStructure
    {
        public int                  dwSize;
        public NET_GPS_STATUS_INFO  stuGPSStatusInfo;       // GPS信息
        public NET_TIME_EX			stuTime;				// 事件发生的时间

        public ALARM_BUS_SHARP_ACCELERATE_INFO() {
            this.dwSize = this.size();
        }
    }

    //报警事件类型 NET_ALARM_BUS_SHARP_DECELERATE(车辆急减速事件)对应的数据描述信息
    public static class ALARM_BUS_SHARP_DECELERATE_INFO extends SdkStructure
    {
        public int                  dwSize;
        public NET_GPS_STATUS_INFO  stuGPSStatusInfo;       // GPS信息
        public NET_TIME_EX			stuTime;				// 事件发生的时间

        public ALARM_BUS_SHARP_DECELERATE_INFO() {
            this.dwSize = this.size();
        }
    }

    // GPS未定位报警(NET_ALARM_GPS_NOT_ALIGNED)
    public static class ALARM_GPS_NOT_ALIGNED_INFO extends SdkStructure
    {
        public int                 nAction;                        // 事件动作,0表示脉冲事件,1表示报警开始,2表示报警结束;
        public NET_TIME_EX         stuTime;                        // 事件发生的时间
        public byte[]              byReserved = new byte[1024];    // 保留字节
    }

    // 前端断网报警信息, 对应  NET_ALARM_FRONTDISCONNECT
    public static class ALARM_FRONTDISCONNET_INFO extends SdkStructure
    {
        public int                dwSize;                           // 结构体大小
        public int                nChannelID;                       // 通道号
        public int                nAction;                          // 0:开始 1:停止
        public NET_TIME           stuTime;                          // 事件发生时间
        public byte[]             szIpAddress = new byte[MAX_PATH]; // 前端IPC的IP地址
        public NET_GPS_STATUS_INFO stGPSStatus;					 // GPS信息 定制功能，仅部分定制设备有效。报警类型为DH_ALARM_FRONTDISCONNECT时,此字段无效。
        public ALARM_FRONTDISCONNET_INFO() {
            this.dwSize = this.size();
        }
    }

    // 存储错误报警, 对应  NET_ALARM_STORAGE_FAILURE_EX
    public static class ALARM_STORAGE_FAILURE_EX extends SdkStructure
    {
        public int               dwSize;
        public int               nAction;                            		  // 0:开始 1:停止
        public byte[]            szName = new byte[NET_EVENT_NAME_LEN];       // 事件名称
        public byte[]            szDevice = new byte[NET_STORAGE_NAME_LEN];   // 存储设备名称
        public byte[]            szGroup = new byte[NET_STORAGE_NAME_LEN];    // 存储组名称
        public byte[]            szPath = new byte[MAX_PATH];                 // 路径
        public int    			 emError;                            		  // 错误类型, 参考   EM_STORAGE_ERROR
        public int               nPhysicNo;                          		  // 硬盘所在槽编码, 从1开始
        public NET_TIME_EX	     stuTime;									  // 事件发生的时间
        public NET_GPS_STATUS_INFO	stGPSStatus;						// GPS信息
        public ALARM_STORAGE_FAILURE_EX() {
            this.dwSize = this.size();
        }
    }

    // 存储组不存在事件信息, 对应  NET_ALARM_STORAGE_NOT_EXIST
    public static class ALARM_STORAGE_NOT_EXIST_INFO extends SdkStructure
    {
        public int              dwSize;
        public int              nAction;                            		  // 0:开始 1:停止
        public byte[]           szGroup = new byte[NET_STORAGE_NAME_LEN];     // 在录像或抓图存储点中设置但不存在的组
        public NET_TIME         stuTime;                           			  // 事件触发时间
        /**
         * gps信息
         */
        public NET_GPS_STATUS_INFO stGPSStatus;
        public ALARM_STORAGE_NOT_EXIST_INFO() {
            this.dwSize = this.size();
        }
    }

    // 车辆ACC报警事件, 对应事件类型  NET_ALARM_VEHICLE_ACC
    public static class ALARM_VEHICLE_ACC_INFO extends SdkStructure
    {
        public int                   dwSize;
        public int                   nACCStatus;                         // ACC状态, 0:无效, 1:开启, 2:关闭
        public int                   nAction;                            // 事件动作, 0:Start, 1:Stop
        public NET_GPS_STATUS_INFO   stuGPSStatusInfo;                   // GPS信息
        public int                   nConstantElectricStatus;            // 常电状态, 0:未知, 1:连接, 2:断开
        public NET_TIME_EX		     stuTime;							 // 事件发生的时间
        public int					 nTotalMileage;						// 总的里程数,单位:米,当nACCStatus为2时,将ntotalMileage进行上报
        public NET_TIME_EX			 stuStartTime;						// nACCStatus为1时刻的时间
        public NET_GPS_STATUS_INFO	 stuStartGPS;						// nACCStatus为1时刻的GPS信息

        public ALARM_VEHICLE_ACC_INFO() {
            this.dwSize = this.size();
        }
    }

    // 事件类型 NET_ALARM_VIDEOBLIND(视频遮挡事件)对应的数据块描述信息
    public static class ALARM_VIDEO_BLIND_INFO extends SdkStructure
    {
        public int                   nAction;                   		// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
        public int					 nChannelID;						// 通道号
        public double				 dbPTS;							    // 时间戳(单位是毫秒)
        public NET_TIME_EX			 stuTime;						    // 事件发生的时间
        public int					 nEventID;						    // 事件ID
        public NET_TIME_EX						stuStartTime;					// 开始时间,nAction为2时上报此字段
        public NET_GPS_STATUS_INFO				stuGPS;							// GPS信息
        public byte[]                byReserved = new byte[1024];       	// 保留字节
    }

    // 紧急事件(对应 NET_URGENCY_ALARM_EX2, 对原有的 NET_URGENCY_ALARM_EX 类型的升级, 指人为触发的紧急事件, 一般处理是联动外部通讯功能请求帮助)
    public static class ALARM_URGENCY_ALARM_EX2 extends SdkStructure
    {
        public int           	   dwSize;
        public NET_TIME            stuTime;                     		// 事件产生的时间
        public int           	   nID;                         		// 用于标识不同的紧急事件

        public ALARM_URGENCY_ALARM_EX2() {
            this.dwSize = this.size();
        }
    }

    // 事件类型 NET_ALARM_DRIVER_NOTCONFIRM (司机未按确认按钮报警事件)对应的数据块描述信息
    public static class ALARM_DRIVER_NOTCONFIRM_INFO extends SdkStructure
    {
        public int                  nAction;                   			// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
        public NET_TIME_EX			stuTime;							// 事件发生的时间
        public double				dbPTS;								// 时间戳(单位是毫秒)
        public byte[]               byReserved = new byte[512];			// 保留字节
    }

    // 交通拥塞报警
    public static class ALARM_TRAF_CONGESTION_INFO extends SdkStructure
    {
        public int                 nDriveWayID;            // 车道号
        public int                 nCongestionLevel;       // 交通拥塞等级:1,2,3,4,5,6;1级最严重
        public NET_TIME            stuTime;                // 报警发生时间
        public int                 nState;                 // 设备状态,0表示故障恢复,1表示发生故障
        public int                 dwChannel;              // 报警的通道号
        public byte[]              reserve = new byte[28];
    }

    // RAID异常信息
    public static class ALARM_RAID_INFO extends SdkStructure
    {
        public int              	nRaidNumber;                      					 // 上报的RAID个数
        public RAID_STATE_INFO[]  	stuRaidInfo = new RAID_STATE_INFO[NET_MAX_RAID_NUM]; // 异常的RAID信息
        public byte[]          		reserved = new byte[128];

        public ALARM_RAID_INFO() {
            for (int i = 0; i < stuRaidInfo.length; ++i) {
                stuRaidInfo[i] = new RAID_STATE_INFO();
            }
        }
    }

    public static class RAID_STATE_INFO extends SdkStructure
    {
        public byte[]        szName = new byte[16];                // Raid名称
        public byte          byType;                               // 类型 1:Jbod     2:Raid0      3:Raid1     4:Raid5
        public byte          byStatus;                             // 状态 0:Error ，1:Active，2:Degraded，3:Inactive，4:Resyncing
        public byte[]        byReserved = new byte[2];
        public int           nCntMem;                              // nMember数组的有效数据个数
        public int[]         nMember = new int[32];                // 1,2,3,... 组成磁盘通道,是个数组
        public int           nCapacity;                            // 容量,单位G
        public int           nRemainSpace;                         // 剩余容量,单位M
        public int           nTank;                                // 扩展柜 0:主机,1:扩展柜1,2:扩展柜2,……
        public byte[]        reserved = new byte[32];
    }


    // 流量统计报警通道信息
    public static class ALARM_TRAFFIC_FLUX_LANE_INFO extends SdkStructure
    {
        public NET_TIME            stuCurTime;            // 当前时间
        public int                 nLane;                 // 车道号
        public int                 nState;                // 状态值：1-表示拥堵, 2-表示拥堵恢复, 3-表示正常, 4-表示中断, 5-表示中断恢复
        public int                 nFlow;                 // 流量值,单位：辆/分
        public byte[]              byReserved = new byte[124];       // 保留
    }

    // CLIENT_AttachBusState, 订阅Bus状态输入参结构
    public static class NET_IN_BUS_ATTACH extends SdkStructure
    {
        public int                   dwSize;
        public fBusStateCallBack     cbBusState;                         // 状态回调函数
        public Pointer	             dwUser;                             // 用户数据

        public NET_IN_BUS_ATTACH() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_AttachBusState, 订阅Bus状态输出参结构
    public static class NET_OUT_BUS_ATTACH extends SdkStructure
    {
        public int                dwSize;

        public NET_OUT_BUS_ATTACH() {
            this.dwSize = this.size();
        }
    }

    // 事件类型 NET_ALARM_BUS_PASSENGER_CARD_CHECK (乘客刷卡事件)对应的数据描述信息
    public static class ALARM_PASSENGER_CARD_CHECK extends SdkStructure
    {
        public int                     bEventConfirm;                  			   // 是否需要回复, BOOL类型
        public byte[]                  szCardNum = new byte[NET_MAX_BUSCARD_NUM];  // 公交卡号
        public NET_GPS_STATUS_INFO     stuGPS;                        			   // GPS信息
        public NET_TIME_EX             UTC;                           			   // 刷卡时间
        public int                     nTime;                          			   // UTC整型
        public int    				   emType;                 					   // 刷卡类型, 参考  EM_PASSENGER_CARD_CHECK_TYPE
        public byte[]                  szMac = new byte[NET_MAX_POS_MAC_NUM];      // 刷卡机Mac码 (默认"0000",兼容老设备)
        public byte[]                  reserved = new byte[1012];                  // 预留
    }

    public static class EM_PASSENGER_CARD_CHECK_TYPE extends SdkStructure
    {
        public static final int EM_PASSENGER_CARD_CHECK_TYPE_UNKOWN = 0;            // 未知
        public static final int EM_PASSENGER_CARD_CHECK_TYPE_SIGNIN = 1;            // 签到/上车
        public static final int EM_PASSENGER_CARD_CHECK_TYPE_SIGNOUT = 2;           // 签出/下车
        public static final int EM_PASSENGER_CARD_CHECK_TYPE_NORMAL = 3;            // 正常刷卡，不区分上下车
    }

    // CLIENT_AttachEventRestore 接口输入参数
    public static class NET_IN_ATTACH_EVENT_RESTORE extends SdkStructure
    {
        public int                dwSize;											//结构体大小
        public byte[] 			  szUuid = new byte[MAX_EVENT_RESTORE_UUID];		//客户端惟一标识

        public NET_IN_ATTACH_EVENT_RESTORE() {
            this.dwSize = this.size();
        }
    }

    public static class GPS_TEMP_HUMIDITY_INFO extends SdkStructure
    {
        public double              dTemperature;               			// 温度值(摄氏度),实际值的1000倍,如30.0摄氏度表示为30000
        public double              dHumidity;                  			// 湿度值(%),实际值的1000倍,如30.0%表示为30000
        public byte[]              bReserved = new byte[128];           // 保留字节

        public static class ByValue extends GPS_Info implements SdkStructure.ByValue { }
    }


    // 事件类型 NET_ALARM_FACEINFO_COLLECT (人脸信息录入事件)对应的数据块描述信息
    public static class ALARM_FACEINFO_COLLECT_INFO extends SdkStructure
    {

        public int                nAction;                   				// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
        public NET_TIME_EX		  stuTime;									// 事件发生的时间
        public double			  dbPTS;									// 时间戳(单位是毫秒)
        public byte[]			  szUserID = new byte[NET_MAX_USERID_LEN];	// 用户ID
        public byte[]             byReserved = new byte[512];       		// 保留字节
    }

    // 人脸信息记录操作类型, 接口  CLIENT_FaceInfoOpreate
    public static class EM_FACEINFO_OPREATE_TYPE extends SdkStructure
    {
        public static final int EM_FACEINFO_OPREATE_ADD = 0;				// 添加, pInbuf = NET_IN_ADD_FACE_INFO , pOutBuf = NET_OUT_ADD_FACE_INFO
        public static final int EM_FACEINFO_OPREATE_GET = 1;				// 获取, pInBuf = NET_IN_GET_FACE_INFO , pOutBuf = NET_OUT_GET_FACE_INFO
        public static final int EM_FACEINFO_OPREATE_UPDATE = 2;				// 更新, pInbuf = NET_IN_UPDATE_FACE_INFO , pOutBuf = NET_OUT_UPDATE_FACE_INFO
        public static final int EM_FACEINFO_OPREATE_REMOVE = 3;				// 删除, pInbuf = NET_IN_REMOVE_FACE_INFO , pOutBuf = NET_OUT_REMOVE_FACE_INFO
        public static final int EM_FACEINFO_OPREATE_CLEAR = 4;				// 清除, pInbuf = NET_IN_CLEAR_FACE_INFO, pOutBuf = NET_OUT_CLEAR_FACE_INFO
        public static final int EM_FACEINFO_OPREATE_GETFACEEIGEN = 5;       // 获取人脸特征值, pInbuf = NET_IN_GETFACEEIGEN_INFO, pOutBuf = NET_OUT_GETFACEEIGEN_INFO
    }

    // 添加人脸记录信息输入参数
    public static class NET_IN_ADD_FACE_INFO extends SdkStructure
    {
        public int 					 dwSize;
        public byte[]				 szUserID = new byte[NET_MAX_USERID_LEN];	// 用户ID
        public NET_FACE_RECORD_INFO	 stuFaceInfo;								// 人脸数据

        public NET_IN_ADD_FACE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 人脸信息
    public static class NET_FACE_RECORD_INFO extends SdkStructure
    {
        public byte[]		 		szUserName = new byte[MAX_USER_NAME_LEN];						// 用户名
        public int			 		nRoom;														    // 房间个数
        public NET_FACE_ROOMNO[]	szRoomNoArr = (NET_FACE_ROOMNO[])new NET_FACE_ROOMNO().toArray(MAX_ROOMNUM_COUNT); // 房间号列表
        public int 			 		nFaceData;														// 人脸模板数据个数
        public NET_FACE_FACEDATA[]	szFaceDataArr = (NET_FACE_FACEDATA[])new NET_FACE_FACEDATA().toArray(MAX_FACE_COUTN);// 人脸模板数据
        public int[]         		nFaceDataLen = new int[MAX_FACE_COUTN];                         // 人脸模版数据大小
        public int         			nFacePhoto;                                         		    // 人脸照片个数
        public int[]         		nFacePhotoLen = new int[MAX_PHOTO_COUNT];                       // 每张图片的大小
        public FACE_PHOTO[]      	pszFacePhotoArr = (FACE_PHOTO[])new FACE_PHOTO().toArray(MAX_PHOTO_COUNT);   // 人脸照片数据,大小不超过120K
        public int                  bValidDate;                                                     //是否设置人脸有效时间
        public NET_TIME             stuValidDateStart;                                              //人脸有效开始时间
        public NET_TIME             stuValidDateEnd;                                                //人脸有效结束时间
        public int			        nValidCounts;										            // 刷脸有效次数：小于0表示不限次数， 等于0刷脸次数已用完
        public int		            bValidCountsEnable;									            // 次数字段使能
        public int                  bFaceDataExEnable;                                              // 人脸模板数据扩展使能
        public Pointer[]               pszFaceDataEx=new Pointer[MAX_FACE_COUTN];                         // 人脸模板数据扩展, 由用户申请释放, 每张照片最大为8K
        //public FACE_PHOTO_EX[]      pszFaceDataExArr = (FACE_PHOTO_EX[])new FACE_PHOTO_EX().toArray(MAX_FACE_COUTN);  // 人脸模板数据扩展, 由用户申请释放, 每张照片最大为8K
        public byte[]        		byReserved = new byte[240];                                     // 保留字节
    }

    public static class NET_FACE_ROOMNO extends SdkStructure {
        public byte[] szRoomNo = new byte[NET_COMMON_STRING_16];   // 房间号
    }

    public static class NET_FACE_FACEDATA extends SdkStructure {
        public byte[] szFaceData = new byte[MAX_FACE_DATA_LEN];    // 人脸数据
    }

    public static class FACE_PHOTO extends SdkStructure {
        public Pointer pszFacePhoto;
    }
	/*public static class FACE_PHOTO_EX extends SdkStructure {
		public Pointer pszFaceDataEx;
	}*/


    // 添加人脸记录信息输出参数
    public static class NET_OUT_ADD_FACE_INFO extends SdkStructure
    {
        public int 			dwSize;

        public NET_OUT_ADD_FACE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 获取人脸记录信息输入参数
    public static class NET_IN_GET_FACE_INFO extends SdkStructure
    {
        public int 			dwSize;
        public byte[]		szUserID = new byte[NET_MAX_USERID_LEN];	// 用户ID

        public NET_IN_GET_FACE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 获取人脸记录信息输出参数
    public static class NET_OUT_GET_FACE_INFO extends SdkStructure
    {
        public int 					dwSize;
        public int 					nFaceData;														// 人脸模板数据个数
        public NET_FACE_FACEDATA[]	szFaceDataArr = (NET_FACE_FACEDATA[])new NET_FACE_FACEDATA().toArray(MAX_FACE_COUTN);		// 人脸模板数据
        public int             		nPhotoData;                                         		  // 白光人脸照片数据个数, 最大个数：5
        public int[]             	nInPhotoDataLen = new int[MAX_PHOTO_COUNT];                   // 用户申请的每张白光人脸照片大小
        public int[]             	nOutPhotoDataLen = new int[MAX_PHOTO_COUNT];                  // 每张白光人脸照片实际的大小
        public Pointer[]			pPhotoData = new Pointer[MAX_PHOTO_COUNT];				  	  // 白光人脸照片数据, 由用户申请释放, 每张照片最大为200K

        public NET_OUT_GET_FACE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 更新人脸记录信息输入参数
    public static class NET_IN_UPDATE_FACE_INFO extends SdkStructure
    {
        public int 					  dwSize;
        public byte[]				  szUserID = new byte[NET_MAX_USERID_LEN];			  // 用户ID
        public NET_FACE_RECORD_INFO	  stuFaceInfo;							    		  // 人脸数据

        public NET_IN_UPDATE_FACE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 更新人脸记录信息输出参数
    public static class NET_OUT_UPDATE_FACE_INFO extends SdkStructure
    {
        public int 			dwSize;

        public NET_OUT_UPDATE_FACE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 删除人脸记录信息输入参数
    public static class NET_IN_REMOVE_FACE_INFO extends SdkStructure
    {
        public int 			dwSize;
        public byte[]		szUserID = new byte[NET_MAX_USERID_LEN];	// 用户ID

        public NET_IN_REMOVE_FACE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 删除人脸记录信息输出参数
    public static class NET_OUT_REMOVE_FACE_INFO extends SdkStructure
    {
        public int 			dwSize;

        public NET_OUT_REMOVE_FACE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 清除人脸记录信息输入参数
    public static class NET_IN_CLEAR_FACE_INFO extends SdkStructure
    {
        public int 			dwSize;

        public NET_IN_CLEAR_FACE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 清除人脸记录信息输出参数
    public static class NET_OUT_CLEAR_FACE_INFO extends SdkStructure
    {
        public int 			dwSize;

        public NET_OUT_CLEAR_FACE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 添加节目信息接口输入参数
    public static class NET_IN_ADD_ONE_PROGRAMME extends SdkStructure
    {
        public int           			dwSize;
        public NET_PROGRAMME_INFO		stuProgrammeInfo;	// 节目信息

        public NET_IN_ADD_ONE_PROGRAMME() {
            this.dwSize = this.size();
        }
    }

    // 添加节目信息接口输出参数
    public static class NET_OUT_ADD_ONE_PROGRAMME extends SdkStructure
    {
        public int           			 dwSize;
        public byte[]					 szProgrammeID = new byte[MAX_COMMON_STRING_64];	// 节目ID

        public NET_OUT_ADD_ONE_PROGRAMME() {
            this.dwSize = this.size();
        }
    }

    // 诱导屏节目配置信息
    public static class NET_PROGRAMME_INFO extends SdkStructure
    {
        public byte[]					szProgrammeName = new byte[MAX_COMMON_STRING_64];	// 节目名称
        public byte[]					szProgrammeID = new byte[MAX_COMMON_STRING_64];		// 节目ID，添加时无效，用于修改、删除
        public int						bEnable;											// 节目是否启用,BOOL类型
        public NET_ORDINARY_INFO		stuOrdinaryInfo = new NET_ORDINARY_INFO();			// 普通节目信息，此参数需要在库里new对象
        public byte[]        			byReserved = new byte[512];							// 保留字节
    }

    // 诱导屏普通节目信息
    public static class NET_ORDINARY_INFO extends SdkStructure
    {
        public int								bTempletState;										// 节目是否保存为模板, BOOL类型
        public byte[]							szDescription = new byte[MAX_COMMON_STRING_128];	// 节目描述信息
        public int								nWhnCount;											// 诱导屏窗口个数
        public NET_GUIDESCREEN_WINDOW_INFO[]	stuWindowsInfo = (NET_GUIDESCREEN_WINDOW_INFO[])new NET_GUIDESCREEN_WINDOW_INFO().toArray(MAX_WINDOWS_COUNT);		// 诱导屏窗口信息
        public byte[]        					byReserved = new byte[128];							// 保留字节
    }

    // 诱导屏窗口信息
    public static class NET_GUIDESCREEN_WINDOW_INFO extends SdkStructure
    {
        public byte[]			szWindowID = new byte[MAX_COMMON_STRING_64];	// 窗口ID
        public int				nVolume;									    // 窗口音量，相对整屏音量的百分比
        public NET_COLOR_RGBA	stuColor;										// 窗口背景颜色
        public int				nDiaphaneity;									// 窗口背景透明度0-100
        public int				emTourPeriodType;								// 窗口轮训类型, 对应  EM_TOURPERIOD_TYPE
        public int				nTourPeriodTime;								// 自定义轮训时间，单位秒, 轮训类型为自定义轮训时有效
        public int				bAutoPlay;										// 预览自动播放,Video元素有效, BOOL类型
        public int				bLoopPlay;										// 预览循环播放,Video元素有效, BOOL类型
        public int				nElementsCount;									// 诱导屏窗口元素个数
        public Pointer			pstElementsBuf;									// 诱导屏窗口元素信息缓存区, 根据类型对应不同的结构体
        // 填充多个元素信息, 每个元素信息内容为 NET_ELEMENT_COMMON_INFO + 元素类型对应的结构体
        public int				nBufLen;										// 诱导屏窗口元素信息缓存区大小
        public byte[]        	byReserved = new byte[128];						// 保留字节
    }

    // 窗口元素通有信息
    public static class NET_ELEMENT_COMMON_INFO extends SdkStructure
    {
        public int				emElementsType;								 	// 窗口元素类型,对应枚举  EM_ELEMENTS_TYPE
        public byte[]        	byReserved = new byte[128];						// 保留字节
    }

    //窗口轮训周期类型
    public static class EM_TOURPERIOD_TYPE extends SdkStructure
    {
        public static final int EM_TOURPERIOD_UNKNOWN = 0;				// 未知
        public static final int EM_TOURPERIOD_PROGRAMME = 1;			// 节目周期
        public static final int EM_TOURPERIOD_PLAN = 2;					// 计划周期
        public static final int EM_TOURPERIOD_CUSTOM = 3;				// 自定义周期
    }

    // 诱导屏窗口元素类型
    public static class EM_ELEMENTS_TYPE extends SdkStructure
    {
        public static final int EM_ELEMENTS_UNKNOWN = 0;			    // 未知
        public static final int EM_ELEMENTS_VIDEO = 1;					// 视频元素, 对应 NET_VIDEO_ELEMENT_INFO
        public static final int EM_ELEMENTS_PICTURE = 2;				// 图片元素, 对应 NET_PICTURE_ELEMENT_INFO
        public static final int EM_ELEMENTS_TEXT = 3;					// 文本元素, 对应 NET_TEXT_ELEMENT_INFO
        public static final int EM_ELEMENTS_PLACEHOLDER = 4;			// 占位符元素, 对应 NET_PLACEHOLDER_ELEMENT_INFO
        public static final int EM_ELEMENTS_CAPTURE = 5;				// 抓拍元素, 对应 NET_CAPTURE_ELEMENT_INFO
    }

    // 视频元素信息
    public static class NET_VIDEO_ELEMENT_INFO extends SdkStructure
    {
        public byte[] 						szName = new byte[MAX_COMMON_STRING_64];			// 素材自定义名称
        public int							bFillerState;										// 是否垫片, BOOL类型
        public byte[] 						szPath = new byte[MAX_COMMON_STRING_128];			// 文件地址
        public int							nPlayCount;											// 播放次数
        public int							nNote;												// 注释信息个数
        public NET_GUIDESCREEN_NOTE_INFO[]	stuNoteInfo = (NET_GUIDESCREEN_NOTE_INFO[])new NET_GUIDESCREEN_NOTE_INFO().toArray(MAX_NOTE_COUNT);			// 注释信息
        public byte[]        				byReserved = new byte[128];							// 保留字节
    }

    // 诱导屏窗口元素注释信息
    public static class NET_GUIDESCREEN_NOTE_INFO extends SdkStructure
    {
        public int							bEnable;					// 是否有效, BOOL类型
        public NET_GUIDESCREEN_TEXT_INFO	stuTextInfo;				// 文字注释信息
        public NET_RECT						stuRect;					// 文字注释的坐标
        public byte[]        				byReserved = new byte[128];	// 保留字节
    }

    // 文本信息
    public static class NET_GUIDESCREEN_TEXT_INFO extends SdkStructure
    {
        public byte[]					szContent = new byte[MAX_ELEMENTTEXT_LENGTH];		// 文本内容
        public int						nFontSize;											// 字体大小
        public NET_COLOR_RGBA			stuFontColor;										// 字体颜色
        public byte[]					szFontStyle = new byte[MAX_COMMON_STRING_32];		// 字体类型
        public double					dbLineHeight;										// 行高
        public int						emHoriAlign;										// 水平对齐方向, 对应 EM_HORI_ALIGN_TYPE
        public int						emVertAlign;										// 垂直对齐方向, 对应 EM_VERT_ALIGN_TYPE
        public int						nPlayTime;											// 播放时间, 单位秒
        public int						nPlayCount;											// 播放次数
        public int						nStayTime;											// 停留间隔（切入切出的间隔时间）单位：s
        public int						emEnterStyle;										// 切入风格, 对应  EM_PIC_STYLE_TYPE
        public int						emExitStyle;										// 切出风格, 对应  EM_PIC_STYLE_TYPE
        public byte[]        			byReserved = new byte[128];							// 保留字节
    }

    // 水平对齐类型
    public static class EM_HORI_ALIGN_TYPE extends SdkStructure
    {
        public static final int EM_HORI_ALIGN_UNKNOWN = 0;				// 未知
        public static final int EM_HORI_ALIGN_LEFT = 1;					// 左对齐
        public static final int EM_HORI_ALIGN_CENTER = 2;				// 居中
        public static final int EM_HORI_ALIGN_RIGHT = 3;				// 右对齐
    }

    // 垂直对齐类型
    public static class EM_VERT_ALIGN_TYPE extends SdkStructure
    {
        public static final int EM_VERT_ALIGN_UNKNOWN = 0;				// 未知
        public static final int EM_VERT_ALIGN_UP = 1;					// 上对齐
        public static final int EM_VERT_ALIGN_CENTER = 2;				// 居中
        public static final int EM_VERT_ALIGN_DOWN = 3;					// 下对齐
    }

    // 切入(切出) 风格
    public static class EM_PIC_STYLE_TYPE extends SdkStructure
    {
        public static final int EM_PIC_STYLE_UNKNOWN = 0;				// 未知
        public static final int EM_PIC_STYLE_DEFAULT = 1;				// 默认
        public static final int EM_PIC_STYLE_UP = 2;					// 上移
        public static final int EM_PIC_STYLE_DOWN = 3;					// 下移
        public static final int EM_PIC_STYLE_LEFT = 4;					// 左移
        public static final int EM_PIC_STYLE_RIGHT = 5;					// 右移
    }

    // 图片元素信息
    public static class NET_PICTURE_ELEMENT_INFO extends SdkStructure
    {
        public byte[] 						szName = new byte[MAX_COMMON_STRING_64];			// 素材自定义名称
        public int							bFillerState;										// 是否垫片, BOOL类型
        public byte[] 						szPath = new byte[MAX_COMMON_STRING_128];			// 图片文件地址
        public int							nPlayTime;											// 播放时间, 单位秒
        public int							nPlayCount;											// 播放次数
        public int							nDiaphaneity;										// 透明度, 0-100
        public int							nStayTime;											// 停留时间, 单位秒
        public int 							emEnterStyle;										// 切入风格, 对应  EM_PIC_STYLE_TYPE
        public int							emExitStyle;										// 切出风格, 对应  EM_PIC_STYLE_TYPE
        public int							nNote;												// 注释信息个数
        public NET_GUIDESCREEN_NOTE_INFO[]	stuNoteInfo = (NET_GUIDESCREEN_NOTE_INFO[])new NET_GUIDESCREEN_NOTE_INFO().toArray(MAX_NOTE_COUNT);			// 注释信息
        public byte[]        				byReserved = new byte[128];							// 保留字节
    }

    // 诱导屏窗口文本元素信息
    public static class NET_TEXT_ELEMENT_INFO extends SdkStructure
    {
        public byte[] 						szName = new byte[MAX_COMMON_STRING_64];			// 素材自定义名称
        public int							bFillerState;										// 是否垫片, 对应 BOOL类型
        public NET_GUIDESCREEN_TEXT_INFO	stuElementsText;									// 文本元素信息
        public int							nNote;												// 注释信息个数
        public NET_GUIDESCREEN_NOTE_INFO[]	stuNoteInfo = (NET_GUIDESCREEN_NOTE_INFO[])new NET_GUIDESCREEN_NOTE_INFO().toArray(MAX_NOTE_COUNT);			// 注释信息
        public byte[]        				byReserved = new byte[128];							// 保留字节
    }

    // 诱导屏窗口占位符元素信息
    public static class NET_PLACEHOLDER_ELEMENT_INFO extends SdkStructure
    {
        public byte[] 						szName = new byte[MAX_COMMON_STRING_64];			// 素材自定义名称
        public int							bFillerState;										// 是否垫片, BOOL类型
        public int							nNote;												// 注释信息个数
        public NET_GUIDESCREEN_NOTE_INFO[]	stuNoteInfo = (NET_GUIDESCREEN_NOTE_INFO[])new NET_GUIDESCREEN_NOTE_INFO().toArray(MAX_NOTE_COUNT);			// 注释信息
        public byte[]        				byReserved = new byte[128];							// 保留字节
    }

    public static class NET_CAPTURE_OSD_INFO extends SdkStructure
    {
        public  int                         bEnable;                                // 叠加使能
        public  NET_COLOR_RGBA		        stuFontColor;					        // 文字颜色
        public  NET_COLOR_RGBA		        stuBackGroundColor;					    // 背景颜色
        public  int                         nFontSize;                              // 字体大小
        public  byte[]                      szContent=new byte[MAX_COMMON_STRING_512];       // OSD内容
        public  byte[]          			byReserved=new byte[1024];						// 保留字节
    };

    // 抓拍元素信息
    public static class NET_CAPTURE_ELEMENT_INFO extends SdkStructure
    {

        public byte[] 						szName = new byte[MAX_COMMON_STRING_64];			// 素材自定义名称
        public int							bFillerState;										// 是否垫片, BOOL类型
        public byte[]						szUserName = new byte[NET_USER_NAME_LEN_EX];		// 用户名
        public byte[]						szPassWord = new byte[NET_USER_PSW_LEN_EX];			// 密码
        public byte[]						szIP = new byte[NET_MAX_IPADDR_LEN_EX];				// IP地址
        public int							nPort;												// 端口号
        public int							nChannel;											// 通道号
        public int 							emCaptureType;										// 抓拍类型, 对应  EM_CAPTURE_TYPE
        public int							nPlayTime;											// 播放时间, 单位秒
        public int							nNote;												// 注释信息个数
        public NET_GUIDESCREEN_NOTE_INFO[]	stuNoteInfo = (NET_GUIDESCREEN_NOTE_INFO[])new NET_GUIDESCREEN_NOTE_INFO().toArray(MAX_NOTE_COUNT);			// 注释信息
        public Pointer                      pstOsdInfo;                                         // OSD叠加信息, 由用户申请和释放内存，若为NULL，则不下发(获取)OSD信息,对应结构体NET_CAPTURE_OSD_INFO
        public byte[]        				byReserved = new byte[124];							// 保留字节
    }

    // 抓拍类型
    public static class EM_CAPTURE_TYPE extends SdkStructure
    {
        public static final int EM_CAPTURE_UNKNOWN = 0;			// 未知
        public static final int EM_CAPTURE_VIDEO = 1;			// 视频
        public static final int EM_CAPTURE_PICTURE = 2;			// 图片
    }

    // 设置诱导屏屏幕配置信息输入参数
    public static class NET_IN_SET_GUIDESCREEN_CFG extends SdkStructure
    {
        public int           					dwSize;
        public int								nScreenCount;		// 诱导屏属性配置信息个数, 值由用户指定

        // 诱导屏属性配置信息, 内存由用户维护, NET_GUIDESCREEN_ATTRIBUTE_INFO
        // 大小为nScreenCount 个 NET_GUIDESCREEN_ATTRIBUTE_INFO
        public Pointer							pstGuideScreenCfg;

        public NET_IN_SET_GUIDESCREEN_CFG() {
            this.dwSize = this.size();
        }
    }

    // 设置诱导屏屏幕配置信息输出参数
    public static class NET_OUT_SET_GUIDESCREEN_CFG extends SdkStructure
    {
        public int           		dwSize;

        public NET_OUT_SET_GUIDESCREEN_CFG() {
            this.dwSize = this.size();
        }
    }

    // 诱导屏属性配置信息
    public static class NET_GUIDESCREEN_ATTRIBUTE_INFO extends SdkStructure
    {
        public int           						dwSize;
        public byte[] 								szScreenID = new byte[MAX_COMMON_STRING_64];						// 屏幕ID
        public int									emStatus;															// 显示屏开关状态    对应 EM_SCREEN_STATUS_TYPE
        public int									bIsForeverOpen;														// 是否永久开屏, 0：开屏     1：关屏
        public int									nScreenTime;														// 开关屏时间个数
        public NET_SCREEN_TIME_INFO[]				stuScreenTime = (NET_SCREEN_TIME_INFO[])new NET_SCREEN_TIME_INFO().toArray(MAX_SCREENTIME_COUNT);	// 开关屏时间数组
        public int									nBright;															// 显示屏亮度, 1-100
        public int									nContrast;															// 显示屏对比度, 1-100
        public int									nSaturation;														// 显示屏饱和度, 1-100
        public int									nVolume;															// 屏幕整体音量
        public int									nWidth;																// 宽度
        public int									nHeight;															// 高度
        public int									nWindowsCount;														// 窗口个数
        public NET_GUIDESCREEN_WINDOW_RECT_INFO[] 	stuWindows = (NET_GUIDESCREEN_WINDOW_RECT_INFO[])new NET_GUIDESCREEN_WINDOW_RECT_INFO().toArray(MAX_WINDOWS_COUNT);	// 窗口信息
        public NET_GUIDESCREEN_AUTO_BRIGHT			stuAutoBright;														// 诱导屏自动调节屏幕亮度信息
        public byte[]         						byReserved = new byte[512];											// 保留字节

        public NET_GUIDESCREEN_ATTRIBUTE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 诱导屏自动调节屏幕亮度信息
    public static class NET_GUIDESCREEN_AUTO_BRIGHT extends SdkStructure
    {
        public int						bEnable;									// 是否使能自动亮度配置
        public int						nLightBright;								// 白天的亮度
        public int						nDarkBright;								// 夜间的亮度
        public NET_SUN_RISE_SET_TIME[]	stuSunTime = (NET_SUN_RISE_SET_TIME[])new NET_SUN_RISE_SET_TIME().toArray(MAX_SUNTIME_COUNT);		// 日出日落时间
        public byte[]        			byReserved = new byte[128];					// 保留字节
    }

    // 诱导屏配置日出日落时间
    public static class NET_SUN_RISE_SET_TIME extends SdkStructure
    {
        public int						nSunrise;									// 日出时间, 默认上午6 时
        public int						nSunset;									// 日落时间, 默认下午18 时
        public byte[]        			byReserved = new byte[32];					// 保留字节
    }

    //开关屏时间信息
    public static class NET_SCREEN_TIME_INFO extends SdkStructure
    {
        public int						bEnable;									// 是否启用, BOOL类型
        public int						emDateType;									// 开关屏日期类型  对应 EM_SCREEN_DATE_TYPE
        public int						nDateCount;									// 开关屏日期个数'
        public int[]					nPlayDates = new int[MAX_PLAYDATES_COUNT];	// 开关屏日期
        public NET_PROGRAMME_TIME_INFO	stuOpenTime;								// 开屏时间
        public NET_PROGRAMME_TIME_INFO	stuCloseTime;								// 关屏时间
        public byte[]         			byReserved = new byte[128];              	// 保留
    }

    // 诱导屏窗口坐标信息
    public static class NET_GUIDESCREEN_WINDOW_RECT_INFO extends SdkStructure
    {
        public byte[]				szWindowID = new byte[MAX_COMMON_STRING_64];	// 窗口ID
        public NET_RECT				stuRect;										// 窗口坐标
        public int					nWindowBright;									// 诱导屏窗口亮度，单独配置某个子屏的亮度，填0时以整屏亮度为准
        public byte[]				byReserved = new byte[132];						// 保留
    }

    // 节目时间信息
    public static class NET_PROGRAMME_TIME_INFO extends SdkStructure
    {
        public int                dwHour;                  // 时
        public int                dwMinute;                // 分
        public int                dwSecond;                // 秒

        public String toString() {
            return dwHour + ":" + dwMinute + "：" + dwSecond;
        }
    }

    // 显示屏开关状态（枚举转结构体）
    public static class EM_SCREEN_STATUS_TYPE extends SdkStructure
    {
        public static final int EM_SCREEN_STATUS_UNKNOWN = 0;		// 未知
        public static final int EM_SCREEN_STATUS_ON = 1;			// 开
        public static final int EM_SCREEN_STATUS_OFF = 2;			// 关
    }

    // 日期类型枚（枚举转结构体）
    public static class EM_SCREEN_DATE_TYPE extends SdkStructure
    {
        public static final int EM_SCREEN_DATE_UNKNOWN = 0;				// 未知
        public static final int EM_SCREEN_DATE_MONTH = 1;					// 每月
        public static final int EM_SCREEN_DATE_WEEK = 2;					// 每周
        public static final int EM_SCREEN_DATE_DAY = 3;					// 每日
    }

    // 增加即时节目计划输入参数
    public static class NET_IN_ADD_IMME_PROGRAMMEPLAN extends SdkStructure
    {
        public int           				dwSize;
        public NET_IMMEDIATELY_PLAN_INFO	stuImmePlan;		// 即时节目计划信息

        public NET_IN_ADD_IMME_PROGRAMMEPLAN() {
            this.dwSize = this.size();
        }
    }

    // 增加节目计划输出参数
    public static class NET_OUT_ADD_PROGRAMMEPLAN  extends SdkStructure
    {
        public int           			dwSize;
        public byte[]					szPlanID = new byte[MAX_COMMON_STRING_64];			// 节目计划ID char[]

        public NET_OUT_ADD_PROGRAMMEPLAN() {
            this.dwSize = this.size();
        }
    }

    // 即时节目计划配置信息
    public static class NET_IMMEDIATELY_PLAN_INFO extends SdkStructure
    {
        public byte[]				 szPlanName = new byte[MAX_COMMON_STRING_64];			// 节目计划名称
        public byte[]				 szPlanID = new byte[MAX_COMMON_STRING_64];				// 节目计划ID ，添加时无效，用于修改、删除
        public byte[]				 szSplitScreenID = new byte[MAX_COMMON_STRING_64];		// 分屏ID
        public int					 bEnable;												// 计划是否启用 , BOOL类型
        public int					 nPlayTime;												// 播放时长, 单位 : 分钟
        public byte[]				 szProgrammeName = new byte[MAX_COMMON_STRING_64];		// 即时发布的节目名称
        public byte[]				 szProgrammeID = new byte[MAX_COMMON_STRING_64];		// 即时发布的节目ID
        public byte[]        		 byReserved = new byte[512];							// 保留字节
    }

    // 修改节目信息接口输入参数
    public static class NET_IN_MODIFY_ONE_PROGRAMME extends SdkStructure
    {
        public int           			dwSize;
        public NET_PROGRAMME_INFO		stuProgrammeInfo;			// 节目信息

        public NET_IN_MODIFY_ONE_PROGRAMME() {
            this.dwSize = this.size();
        }
    }


    // 修改节目信息接口输出参数
    public static class NET_OUT_MODIFY_ONE_PROGRAMME extends SdkStructure
    {
        public int           			dwSize;

        public NET_OUT_MODIFY_ONE_PROGRAMME() {
            this.dwSize = this.size();
        }
    }

    // 批量删除节目信息接口输入参数
    public static class NET_IN_DEL_PROGRAMMES extends SdkStructure
    {
        public int           		   dwSize;
        public int				       nProgrammeID;															    				// 节目ID个数
        public PRO_GRAMME_ID[]		   szProGrammeIdListArr = (PRO_GRAMME_ID[])new PRO_GRAMME_ID().toArray(MAX_PROGRAMMES_COUNT);	// 需要删除的节目ID列表

        public NET_IN_DEL_PROGRAMMES() {
            this.dwSize = this.size();
        }
    }

    // 需要删除的节目ID
    public static class PRO_GRAMME_ID extends SdkStructure
    {
        public byte[]			       szProGrammeIdList = new byte[MAX_COMMON_STRING_64];	// 需要删除的节目ID
    }

    // 批量删除节目信息接口输出参数
    public static class NET_OUT_DEL_PROGRAMMES extends SdkStructure
    {
        public int           		 dwSize;

        public NET_OUT_DEL_PROGRAMMES() {
            this.dwSize = this.size();
        }
    }

    // 修改即时节目计划输入参数
    public static class NET_IN_MODIFY_IMME_PROGRAMMEPLAN extends SdkStructure
    {
        public int           				dwSize;
        public NET_IMMEDIATELY_PLAN_INFO	stuImmePlan;		// 即时节目计划信息

        public NET_IN_MODIFY_IMME_PROGRAMMEPLAN() {
            this.dwSize = this.size();
        }
    }

    // 修改即时节目计划输出参数
    public static class NET_OUT_MODIFY_IMME_PROGRAMMEPLAN extends SdkStructure
    {
        public int           			dwSize;

        public NET_OUT_MODIFY_IMME_PROGRAMMEPLAN() {
            this.dwSize = this.size();
        }
    }

    // 增加定时节目计划输入参数
    public static class NET_IN_ADD_TIMER_PROGRAMMEPLAN extends SdkStructure
    {
        public int           			dwSize;
        public NET_TIMER_PLAN_INFO		stuTimerPlan;		// 定时节目计划信息

        public NET_IN_ADD_TIMER_PROGRAMMEPLAN() {
            this.dwSize = this.size();
        }
    }

    // 定时节目计划配置信息
    public static class NET_TIMER_PLAN_INFO extends SdkStructure
    {
        public byte[]					szPlanName = new byte[MAX_COMMON_STRING_64];			// 节目计划名称
        public byte[]					szPlanID = new byte[MAX_COMMON_STRING_64];				// 节目计划ID，添加时无效，用于修改、删除
        public byte[]					szSplitScreenID = new byte[MAX_COMMON_STRING_64];		// 分屏ID
        public int						emDataType;											    // 节目计划日期类型, 对应 EM_TIMERPLAN_DATE_TYPE
        public int						nDataCount;												// 节目计划日期个数
        public int[]					nPlayDates = new int[MAX_PLAYDATES_COUNT];				// 节目播放日期列表
        public NET_PROGRAMME_DATA		stuSatrtDate = new NET_PROGRAMME_DATA();				// 节目开始日期
        public NET_PROGRAMME_DATA		stuEndDate = new NET_PROGRAMME_DATA();					// 节目结束日期
        public int						emReviewState;											// 审核状态, 对应  EM_REVIES_STATE
        public byte[]					szReviewOpinion = new byte[MAX_COMMON_STRING_64];		// 审核意见
        public int						bOverdue;												// 计划是否过期, BOOL类型
        public int						nProgrammes;											// 节目个数
        public NET_PROGRAMME_OF_PLAN[]	stuProgrammes = (NET_PROGRAMME_OF_PLAN[])new NET_PROGRAMME_OF_PLAN().toArray(MAX_PROGRAMMES_COUNT);		// 节目组信息
        public byte[]        			byReserved = new byte[512];								// 保留字节
    }

    // 定时计划日期类型
    public static class EM_TIMERPLAN_DATE_TYPE extends SdkStructure
    {
        public static final int EM_TIMERPLAN_DATE_UNKNOWN = 0;				// 未知
        public static final int EM_TIMERPLAN_DATE_MONTH = 1;				// 每月
        public static final int EM_TIMERPLAN_DATE_WEEK = 2;					// 每周
        public static final int EM_TIMERPLAN_DATE_DAY = 3;					// 每日
        public static final int EM_TIMERPLAN_DATE_CUSTOM = 4;				// 自定义
    }

    // 节目日期格式
    public static class NET_PROGRAMME_DATA extends SdkStructure
    {
        public int                		dwYear;                  // 年
        public int                		dwMonth;                 // 月
        public int                		dwDay;                	 // 日

        public String toString() {
            return dwYear + "-" + dwMonth + "-" + dwDay;
        }
    }

    // 节目计划中的节目信息
    public static class NET_PROGRAMME_OF_PLAN extends SdkStructure
    {
        public byte[]						szProgrammeName = new byte[MAX_COMMON_STRING_64];	// 节目名称
        public byte[]						szProgrammeID = new byte[MAX_COMMON_STRING_64];	    // 节目ID
        public int						    bIsBgProgramme;									    // 是否背景节目, BOOL类型
        public NET_PROGRAMME_TIME_INFO		stuSatrtTime;										// 节目开始时间
        public NET_PROGRAMME_TIME_INFO		stuEndTime;										    // 节目结束时间
        public byte[]        				byReserved = new byte[128];							// 保留字节
    }

    // 审核状态
    public static class EM_REVIES_STATE extends SdkStructure
    {
        public static final int EM_REVIES_UNKNOWN = 0;			// 未知
        public static final int EM_REVIES_PASS = 1;				// 通过
        public static final int EM_REVIES_NOTPASS = 2;			// 不通过
    }

    // 修改定时节目计划输入参数
    public static class NET_IN_MODIFY_TIMER_PROGRAMMEPLAN extends SdkStructure
    {
        public int           				dwSize;
        public NET_TIMER_PLAN_INFO			stuTimerPlan;		// 定时节目计划信息

        public NET_IN_MODIFY_TIMER_PROGRAMMEPLAN() {
            this.dwSize = this.size();
        }
    }

    // 修改定时节目计划输出参数
    public static class NET_OUT_MODIFY_TIMER_PROGRAMMEPLAN extends SdkStructure
    {
        public int           				dwSize;

        public NET_OUT_MODIFY_TIMER_PROGRAMMEPLAN() {
            this.dwSize = this.size();
        }
    }

    // 删除多个节目计划输入参数
    public static class NET_IN_DEL_PROGRAMMEPLANS extends SdkStructure
    {
        public int						dwSize;
        public int						nPlanID;															    // 节目计划ID个数
        public PLAN_ID[]				szPlanIDArr = (PLAN_ID[])new PLAN_ID().toArray(MAX_PROGRAMMES_COUNT);	// 节目计划ID

        public NET_IN_DEL_PROGRAMMEPLANS() {
            this.dwSize = this.size();
        }
    }

    // 节目计划ID
    public static class PLAN_ID extends SdkStructure
    {
        public byte[]					szPlanID = new byte[MAX_COMMON_STRING_64];	// 节目计划ID
    }

    // 删除多个节目计划输出参数
    public static class NET_OUT_DEL_PROGRAMMEPLANS extends SdkStructure
    {
        public int						dwSize;

        public NET_OUT_DEL_PROGRAMMEPLANS() {
            this.dwSize = this.size();
        }
    }

    // 通过诱导屏ID 获取诱导屏配置信息输入参数
    public static class NET_IN_GET_GUIDESCREEN_CFG_BYID extends SdkStructure
    {
        public int           			dwSize;
        public byte[]					szScreenID = new byte[MAX_COMMON_STRING_64];  // 屏ID

        public NET_IN_GET_GUIDESCREEN_CFG_BYID() {
            this.dwSize = this.size();
        }
    }

    // 通过诱导屏ID 获取诱导屏配置信息输出参数
    public static class NET_OUT_GET_GUIDESCREEN_CFG_BYID extends SdkStructure
    {
        public int           					dwSize;
        public NET_GUIDESCREEN_ATTRIBUTE_INFO	stuGuideScreenCfg;			// 诱导屏属性信息

        public NET_OUT_GET_GUIDESCREEN_CFG_BYID() {
            this.dwSize = this.size();
        }
    }

    // 获取所有诱导屏配置信息输入参数
    public static class NET_IN_GET_ALL_GUIDESCREEN_CFG extends SdkStructure
    {
        public int           				dwSize;

        public NET_IN_GET_ALL_GUIDESCREEN_CFG() {
            this.dwSize = this.size();
        }
    }

    // 获取所有诱导屏配置信息输出参数
    public static class NET_OUT_GET_ALL_GUIDESCREEN_CFG extends SdkStructure
    {
        public int           				dwSize;
        public int							nMaxScreen;					// 最大诱导屏个数, 值由用户指定
        public int							nRetScreen;					// 实际返回的诱导屏个数
        public Pointer						pstGuideScreenCfg;			// 用于存放获取到的诱导屏属性信息, 内存由用户维护
        // 大小为nMaxScreen 个 NET_GUIDESCREEN_ATTRIBUTE_INFO
        // 对应 NET_GUIDESCREEN_ATTRIBUTE_INFO[]
        public NET_OUT_GET_ALL_GUIDESCREEN_CFG() {
            this.dwSize = this.size();
        }
    }

    // 通过节目ID 获取节目信息输入参数
    public static class NET_IN_GET_PROGRAMME_BYID extends SdkStructure
    {
        public int           				dwSize;
        public byte[]						szProgrammeID = new byte[MAX_COMMON_STRING_64];	// 节目ID

        public NET_IN_GET_PROGRAMME_BYID() {
            this.dwSize = this.size();
        }
    }

    // 通过节目ID 获取节目信息输出参数
    public static class NET_OUT_GET_PROGRAMME_BYID extends SdkStructure
    {
        public int           				dwSize;
        public NET_PROGRAMME_INFO			stuProgrammeInfo;			// 节目配置信息

        public NET_OUT_GET_PROGRAMME_BYID() {
            this.dwSize = this.size();
        }
    }

    // 获取所有节目信息输入参数
    public static class NET_IN_GET_ALL_PROGRAMMES extends SdkStructure
    {
        public int           				dwSize;

        public NET_IN_GET_ALL_PROGRAMMES() {
            this.dwSize = this.size();
        }
    }

    // 获取所有节目信息输出参数
    public static class NET_OUT_GET_ALL_PROGRAMMES extends SdkStructure
    {
        public int           			    dwSize;
        public int						    nMaxCnt;					// pstProgrammeInfo最大NET_PROGRAMME_INFO 个数
        public int						    nRetCnt;					// pstProgrammeInfo实际返回的 NET_PROGRAMME_INFO 个数
        public Pointer					    pstProgrammeInfo;		    // 节目配置信息, 内存由用户维护,对应 NET_PROGRAMME_INFO[]
        // 大小为 nMaxCnt 个  NET_PROGRAMME_INFO

        public NET_OUT_GET_ALL_PROGRAMMES() {
            this.dwSize = this.size();
        }
    }

    // 获取所有节目的简要信息输入参数
    public static class NET_IN_GET_ALL_BRIEFLYPROGRAMMES extends SdkStructure
    {
        public int           			    dwSize;

        public NET_IN_GET_ALL_BRIEFLYPROGRAMMES() {
            this.dwSize = this.size();
        }
    }

    // 获取所有节目的简要信息输出参数
    public static class NET_OUT_GET_ALL_BRIEFLYPROGRAMMES extends SdkStructure
    {
        public int           				 dwSize;
        public int							 nRetCnt;									// 实际返回的个数
        public NET_BRIEFLY_PROGRAMME_INFO[]	 stuBriProgrammes = (NET_BRIEFLY_PROGRAMME_INFO[])new NET_BRIEFLY_PROGRAMME_INFO().toArray(MAX_PROGRAMMES_COUNT);	// 节目简要信息

        public NET_OUT_GET_ALL_BRIEFLYPROGRAMMES() {
            this.dwSize = this.size();
        }
    }

    // 节目简要信息
    public static class NET_BRIEFLY_PROGRAMME_INFO extends SdkStructure
    {
        public byte[]						szProgrammeName = new byte[MAX_COMMON_STRING_64];	// 节目名称
        public byte[]						szProgrammeID = new byte[MAX_COMMON_STRING_64];	    // 节目ID
        public int							emProgrammeType;									// 简要节目信息类型,对应枚举  EM_BRIEFLYPROGRAM_TYPE
        public int							bEnable;										    // 节目是否启用, BOOL类型
        public int							bTempletState;										// 节目是否保存为模板, BOOL类型
        public byte[]        				byReserved = new byte[512];							// 保留字节
    }

    // 简要节目信息类型
    public static class EM_BRIEFLYPROGRAM_TYPE extends SdkStructure
    {
        public static final int EM_BRIEFLYPROGRAM_UNKNOWN = 0;				// 未知
        public static final int EM_BRIEFLYPROGRAM_BAR = 1;					// 广告节目
        public static final int EM_BRIEFLYPROGRAM_ORDINARY = 2;				// 普通节目
    }

    // 获取所有节目计划输入参数
    public static class NET_IN_GET_ALL_PROGRAMMEPLANS extends SdkStructure
    {
        public int           				dwSize;

        public NET_IN_GET_ALL_PROGRAMMEPLANS() {
            this.dwSize = this.size();
        }
    }

    // 获取所有节目计划输出参数
    public static class NET_OUT_GET_ALL_PROGRAMMEPLANS extends SdkStructure
    {
        public int           				dwSize;
        public int							nMaxPlanCnt;			// 即时节目和定时节目计划最大个数, 由用户指定
        public int							nRetImmCnt;				// 实际返回的即时节目计划个数
        public Pointer						pstImmePlan;			// 即时节目计划信息, 对应  NET_IMMEDIATELY_PLAN_INFO[]，
        // 大小 nMaxPlanCnt 个 NET_IMMEDIATELY_PLAN_INFO
        public int							nRetTimerCnt;			// 实际返回的定时节目计划个数
        public Pointer						pstTimerPlan;			// 定时节目计划信息,对应  NET_TIMER_PLAN_INFO[]，
        // 大小 nMaxPlanCnt 个 NET_TIMER_PLAN_INFO

        public NET_OUT_GET_ALL_PROGRAMMEPLANS() {
            this.dwSize = this.size();
        }
    }

    // 即时计划与定时计划信息数组
    public static class NET_PROGRAMME_PLANS_INFO extends SdkStructure {
        public NET_IMMEDIATELY_PLAN_INFO[] szImmePlan;   			// 即时节目计划信息数组
        public NET_TIMER_PLAN_INFO[] szTimerPlan;					// 定时节目计划信息数组

        public NET_PROGRAMME_PLANS_INFO() {}

        public NET_PROGRAMME_PLANS_INFO(int maxPlanCount) {
            szImmePlan = new NET_IMMEDIATELY_PLAN_INFO[maxPlanCount];
            szTimerPlan = new NET_TIMER_PLAN_INFO[maxPlanCount];
            for(int i = 0; i < maxPlanCount; i++) {
                szImmePlan[i] = new NET_IMMEDIATELY_PLAN_INFO();
                szTimerPlan[i] = new NET_TIMER_PLAN_INFO();
            }
        }
    }

    // 通过节目计划ID 获取节目计划输入参数
    public static class NET_IN_GET_PROGRAMMEPLAN_BYID extends SdkStructure
    {
        public int           				dwSize;
        public byte[]						szPlanID = new byte[MAX_COMMON_STRING_64];		// 节目计划ID

        public NET_IN_GET_PROGRAMMEPLAN_BYID() {
            this.dwSize = this.size();
        }
    }

    // 通过节目计划ID 获取节目计划输出参数
    public static class NET_OUT_GET_PROGRAMMEPLAN_BYID extends SdkStructure
    {
        public int           				dwSize;
        public int							emPlanType;				// 节目计划类型, 对应  EM_PROGRAMMEPLAN_TYPE
        public NET_IMMEDIATELY_PLAN_INFO	stuImmePlan;			// 即时节目计划信息, emPlanType 为 EM_PROGRAMMEPLAN_IMME 时有效
        public NET_TIMER_PLAN_INFO			stuTimerPlan;			// 定时节目计划信息, emPlanType 为 EM_PROGRAMMEPLAN_TIMER 时有效

        public NET_OUT_GET_PROGRAMMEPLAN_BYID() {
            this.dwSize = this.size();
        }
    }

    // 节目计划类型
    public static class EM_PROGRAMMEPLAN_TYPE extends SdkStructure
    {
        public static final int EM_PROGRAMMEPLAN_UNKNOWN = 0;		// 未知
        public static final int EM_PROGRAMMEPLAN_IMME = 1;			// 即时计划
        public static final int EM_PROGRAMMEPLAN_TIMER = 2;			// 定时计划
    }

    //设置光带状态信息输入参数
    public static class NET_IN_SET_GD_STATUS extends SdkStructure
    {
        public int					dwSize;
        public byte[]				szScreenID = new byte[MAX_COMMON_STRING_64];		// 分屏ID, 即窗口ID
        public int					nGDNum;												// 光带总数
        public int[]				emStatus = new int[MAX_GD_COUNT];					// 光带信息, 对应  EM_GD_COLOR_TYPE

        public NET_IN_SET_GD_STATUS() {
            this.dwSize = this.size();
        }
    }

    //设置光带状态信息输出参数
    public static class NET_OUT_SET_GD_STATUS extends SdkStructure
    {
        public int					dwSize;

        public NET_OUT_SET_GD_STATUS() {
            this.dwSize = this.size();
        }
    }

    // 光带颜色类型
    public static class EM_GD_COLOR_TYPE extends SdkStructure
    {
        public static final int EM_GD_COLOR_RED = 0;		// 红色
        public static final int EM_GD_COLOR_GREEN = 1;		// 绿色
        public static final int EM_GD_COLOR_YELLOW = 2;		// 黄色
    }


    // 用户信息表
    public static class USER_MANAGE_INFO_EX extends SdkStructure
    {
        public int                	  dwRightNum;                    // 权限信息
        public OPR_RIGHT_EX[]         rightList = (OPR_RIGHT_EX[])new OPR_RIGHT_EX().toArray(NET_MAX_RIGHT_NUM);
        public int                	  dwGroupNum;                    // 用户组信息
        public USER_GROUP_INFO_EX[]   groupList = (USER_GROUP_INFO_EX[])new USER_GROUP_INFO_EX().toArray(NET_MAX_GROUP_NUM);
        public int                	  dwUserNum;                     // 用户信息
        public USER_INFO_EX[]         userList = (USER_INFO_EX[])new USER_INFO_EX().toArray(NET_MAX_USER_NUM);
        public int                	  dwFouctionMask;                // 掩码；0x00000001 - 支持用户复用,0x00000002 - 密码修改需要校验
        public byte                   byNameMaxLength;               // 支持的用户名最大长度
        public byte                   byPSWMaxLength;                // 支持的密码最大长度
        public byte[]                 byReserve = new byte[254];
    }

    // 权限信息
    public static class OPR_RIGHT_EX extends SdkStructure
    {
        public int                	  dwID;
        public byte[]                 name = new byte[NET_RIGHT_NAME_LENGTH];
        public byte[]                 memo = new byte[NET_MEMO_LENGTH];
    }

    // 用户组信息
    public static class USER_GROUP_INFO_EX extends SdkStructure
    {
        public int                	  dwID;
        public byte[]                 name = new byte[NET_USER_NAME_LENGTH_EX];
        public int                	  dwRightNum;
        public int[]                  rights = new int[NET_MAX_RIGHT_NUM];
        public byte[]                 memo = new byte[NET_MEMO_LENGTH];
    }

    // 用户信息
    public static class USER_INFO_EX extends SdkStructure
    {
        public int                	  dwID;
        public int                	  dwGroupID;
        public byte[]                 name = new byte[NET_USER_NAME_LENGTH_EX];
        public byte[]                 passWord = new byte[NET_USER_PSW_LENGTH_EX];
        public int                 	  dwRightNum;
        public int[]                  rights = new int[NET_MAX_RIGHT_NUM];
        public byte[]                 memo = new byte[NET_MEMO_LENGTH];
        public int                 	  dwFouctionMask;                // 掩码,0x00000001 - 支持用户复用
        public byte[]                 byReserve = new byte[32];
    }

    // CLIENT_DownloadRemoteFile 接口输入参数(文件下载)
    public static class NET_IN_DOWNLOAD_REMOTE_FILE extends SdkStructure
    {
        public int               	 dwSize;
        public Pointer           	 pszFileName;                    // 需要下载的文件名
        public Pointer         	 	 pszFileDst;                     // 存放文件路径

        public NET_IN_DOWNLOAD_REMOTE_FILE() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_DownloadRemoteFile 接口输出参数(文件下载)
    public static class NET_OUT_DOWNLOAD_REMOTE_FILE extends SdkStructure
    {
        public int               	dwSize;
        public int				dwMaxFileBufLen;				// 文件缓存区pstFileBuf的大小, 由用户指定
        public Pointer				pstFileBuf;					// 文件缓存区, 由用户申请和释放
        public int				dwRetFileBufLen;				// 缓存区中返回的实际文件数据大小
        public byte[]              	byReserved=new byte[4];            		// 字节对齐
        public NET_OUT_DOWNLOAD_REMOTE_FILE() {
            this.dwSize = this.size();
        }
    }

    // 车牌对比, 对应事件 EVENT_IVS_VEHICLE_RECOGNITION
    public static class DEV_EVENT_VEHICLE_RECOGNITION_INFO extends SdkStructure
    {
        public byte[]                	szName = new byte[128];                     // 事件名称
        public double              	 	PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         	 	UTC;                                        // 事件发生的时间
        public int                 	 	nEventID;                                   // 事件ID
        public int                 		nVehicleAction;                             // 车辆动作 0-未知,1-在检测区域内,2-离开检测区域

        public NET_MSG_OBJECT        	stuObject;                                  // 检测到的物体
        public NET_MSG_OBJECT        	stuVehicle;                                 // 车身信息

        public NET_SEAT_INFO       	 	stuMainSeatInfo; 							// 主驾驶位信息
        public NET_SEAT_INFO       	 	stuSlaveSeatInfo; 							// 副驾驶位信息
        public int                 	 	nVehicleAttachNum;							// 车上附件数量
        public NET_VEHICLE_ATTACH[] 	stuVehicleAttach = (NET_VEHICLE_ATTACH[])new NET_VEHICLE_ATTACH().toArray(8); // 车上附件数据
        public byte[]                	szCountry = new byte[32];  					// 国家,2字节,符合ISO3166规范

        public int                 		nCarCandidateNum; 							// 候选车辆数量
        public NET_CAR_CANDIDATE_INFO[] stuCarCandidate = (NET_CAR_CANDIDATE_INFO[])new NET_CAR_CANDIDATE_INFO().toArray(MAX_CAR_CANDIDATE_NUM);  // 候选车辆数据

        public EVENT_COMM_INFO     		stCommInfo;                                 // 公共信息
        public int                 		nChannel;                                   // 通道号
        public byte[]                	bReserved = new byte[1024];
    }

    // 事件类型EVENT_IVS_ELEVATOR_ABNORMAL(电动扶梯运行异常事件)对应的数据块描述信息
    public static class DEV_EVENT_ELEVATOR_ABNORMAL_INFO extends SdkStructure
    {
        public int                 nChannelID;							// 通道号
        public int                 nEventID;                    		// 事件ID
        public byte[]              szName  = new byte[SDK_EVENT_NAME_LEN];          // 事件名称
        public double              dbPTS;                              	// 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                	// 事件发生的时间
        public byte[]              byReserved1 = new byte[1020];		// 保留字节
    }

    public static class NET_CAR_CANDIDATE_INFO extends SdkStructure
    {
        public NET_VEHICLE_INFO    		stuVehicleInfo;							   // 车辆信息
        public int                 		nDifferentAttributresNum;				   // 和数据库不相符的属性数目
        public int[]                 	nDifferentAttributres = new int[16]; 	   // 和数据库不相符的属性集合,元素值取值意义:0-未知 1-车牌属地 2-车标 3-车型 4-车色 5-车牌颜色

        public byte[]                	bReserved = new byte[512];
    }

    public static class NET_VEHICLE_INFO extends SdkStructure
    {
        public int                		nUID;									   // 车辆唯一标识符,由服务端生成用于程序中表示惟一
        public byte[]                	szGroupID = new byte[64];				   // 车辆所属组ID
        public byte[]                	szGroupName = new byte[128]; 			   // 车辆所属组名
        public byte[]                	szPlateNumber = new byte[64]; 			   // 车牌号码
        public byte[]                	szPlateCountry = new byte[4]; 			   // 车辆所在国家,2字节，符合ISO3166规范

        public int                 		nPlateType;								   // 车牌类型
        // 01  大型汽车号牌 黄底黑字
        // 02  小型汽车号牌 蓝底白字
        // 03  使馆汽车号牌 黑底白字、红“使”字
        // 04  领馆汽车号牌 黑底白字、红“领”字
        // 05  境外汽车号牌 黑底白、红字
        // 06  外籍汽车号牌 黑底白字
        // 13  农用运输车号牌 黄底黑字黑框线
        // 15  挂车号牌 黄底黑字黑框线
        // 16  教练汽车号牌 黄底黑字黑框线
        // 18  试验汽车号牌
        // 20  临时入境汽车号牌 白底红字黑“临时入境”
        // 22  临时行驶车号牌 白底黑字黑线框
        // 23  公安警用汽车号牌

        public int                 		nVehicleType;							   // 车型(轿车、卡车等)
        // 001  巡逻车
        // 002  交警车辆
        // 003  消防车
        // 004  单兵
        // 005  其他警车
        // 006  其他设备
        // 020  政府车辆
        // 031  校车
        // 032  运钞车
        // 033  客运车辆
        // 034  公交车
        // 035  出租车
        // 036  危险品车辆

        public int                 		nBrand;									   // 车辆车标,需要通过映射表得到真正的车标.同卡口事件的CarLogoIndex
        public int                 		nCarSeries;								   // 车辆子品牌，需要通过映射表得到真正的子品牌,同卡口事件的SubBrand
        public int                 		nCarSeriesModelYearIndex; 				   // 车辆品牌年款，需要通过映射表得到真正的年款，同卡口事件的BrandYear 车头年款序号范围1~999；车尾年款序号范围1001~1999；0表示未知；1000预留。
        public NET_COLOR_RGBA      		stuVehicleColor;					 	   // 车色 第一个元素表示红色分量值； 第二个元素表示绿色分量值； 第三个元素表示蓝色分量值； 第四个元素表示透明度分量(无意义)
        public NET_COLOR_RGBA      		stuPlateColor;  						   // 车牌颜色,规则同车色
        public byte[]                	szOwnerName = new byte[64];				   // 车主名称
        public int                		nSex; 									   // 车主性别
        public int                 		nCertificateType; 						   // 车主证件类型 0-未知 1-身份证 2-护照 3-军官证
        public byte[]                	szPersonID = new byte[32];				   // 人员身份证号码,工号,或其他编号
        public byte[]                	szOwnerCountry = new byte[4]; 			   // 车主国籍,2字节,符合ISO3166规范
        public byte[]                	szProvince = new byte[64];				   // 省份
        public byte[]                	szCity = new byte[64];					   // 城市
        public byte[]                	szHomeAddress = new byte[128]; 			   // 注册人员家庭地址(IVSS需求)
        public byte[]                	szEmail = new byte[32];					   // 车主电子邮箱
        public byte[]                	szPhoneNo = new byte[128];				   // 注册车主电话号码
        public byte[]                	bReserved = new byte[512];
    }

    //获取播放盒上全部节目信息接口输入参数
    public static class NET_IN_GET_ALL_PLAYBOX_PROGRAM extends SdkStructure
    {
        public int           			dwSize;

        public NET_IN_GET_ALL_PLAYBOX_PROGRAM() {
            this.dwSize = this.size();
        }
    }

    //获取播放盒上全部节目信息接口输出参数
    public static class NET_OUT_GET_ALL_PLAYBOX_PROGRAM extends SdkStructure
    {
        public int           			dwSize;
        public int						nMaxProgramCount;			// 节目信息最大个数，由用户指定
        public int						nRetProgramCount;			// 实际返回的节目信息个数
        public Pointer				    pstProgramInfo;			    // 播放盒上的节目信息, 内存资源由用户维护,对应 NET_PROGRAM_ON_PLAYBOX[]

        public NET_OUT_GET_ALL_PLAYBOX_PROGRAM() {
            this.dwSize = this.size();
        }
    }

    // 播放盒节目信息
    public static class NET_PROGRAM_ON_PLAYBOX extends SdkStructure
    {
        public byte[]					  szProgrammeName = new byte[MAX_COMMON_STRING_64];	  // 节目名称
        public byte[]					  szProgrammeID = new byte[MAX_COMMON_STRING_64];	  // 节目ID, 添加节目时不需要指定
        public int						  bEnable;											  // 节目是否启用
        public int						  emProgramType;									  // 节目类型, 参考  EM_PLAYBOXPROGRAM_TYPE
        public NET_PROGRAM_LOGO_INFO	  stuLogoInfo;										  // LOGO节目信息, emProgramType为EM_PROGRAM_ON_PLAYBOX_LOGO时有效
        public NET_PROGRAM_BAR_INFO		  stuBarInfo;										  // 广告条节目信息, emProgramType为EM_PROGRAM_ON_PLAYBOX_BAR时有效
        public NET_PROGRAM_ORDINARY_INFO  stuOrdinaryInfo = new NET_PROGRAM_ORDINARY_INFO();  // 普通节目信息, emProgramType为EM_PROGRAM_ON_PLAYBOX_ORDINARY时有效, 此参数需要在库里new对象
        public byte[]        			  byReserved = new byte[512];						  // 保留字节
    }

    // 播放盒节目类型
    public static class EM_PLAYBOXPROGRAM_TYPE extends SdkStructure
    {
        public static final int EM_PROGRAM_ON_PLAYBOX_LOGO = 0;								// LOGO, 对应结构体 NET_PROGRAM_LOGO_INFO
        public static final int EM_PROGRAM_ON_PLAYBOX_BAR = 1;								// 广告条, 对应结构体 NET_PROGRAM_BAR_INFO
        public static final int EM_PROGRAM_ON_PLAYBOX_ORDINARY = 2;							// 普通节目, 对应结构体 NET_PROGRAM_ORDINARY_INFO
    }

    // LOGO节目信息
    public static class NET_PROGRAM_LOGO_INFO extends SdkStructure
    {
        public byte[]		 szLogoPath = new byte[MAX_COMMON_STRING_128];			// Logo路径
        public NET_RECT		 stuBackgroundRect;										// Logo位置
        public int			 nDiaphaneity;											// 透明度, 0-100
        public byte[]        byReserved = new byte[128];							// 保留字节
    }

    // 广告条节目信息
    public static class NET_PROGRAM_BAR_INFO extends SdkStructure
    {
        public byte[]			szContent = new byte[MAX_COMMON_STRING_512];		// 广告内容
        public NET_COLOR_RGBA	stuFontColor;										// 字体颜色
        public int				nFontSize;											// 字体大小
        public byte[]			szFontStyle = new byte[MAX_COMMON_STRING_32];		// 字体类型
        public int				nPlaySpeed;											// 播放速度
        public NET_RECT			stuBackgroundRect;									// 广告条位置
        public NET_COLOR_RGBA	stuBackColor;										// 广告条背景颜色
        public int				nDiaphaneity;										// 透明度, 0-100
        public byte[]        	byReserved = new byte[128];							// 保留字节
    }

    // 普通广告节目信息
    public static class NET_PROGRAM_ORDINARY_INFO extends SdkStructure
    {
        public int							bTempletState;							// 节目是否保存为模板
        public byte[]						szDescription = new byte[MAX_COMMON_STRING_128];	// 节目描述信息
        public int							nWidth;									// 画布宽度
        public int							nHeight;								// 画布高度
        public int							nWinCount;								// 窗口数量
        public NET_PLAYBOX_WINDOWS_INFO[]	stuWindowsInfo = (NET_PLAYBOX_WINDOWS_INFO[])new NET_PLAYBOX_WINDOWS_INFO().toArray(MAX_WINDOWS_COUNT);		// 窗口信息
        public byte[]        				byReserved = new byte[128];						// 保留字节
    }

    // 播放盒上窗口信息
    public static class NET_PLAYBOX_WINDOWS_INFO extends SdkStructure
    {
        public NET_RECT					stuRect;							// 窗口位置
        public int						nZorder;							// 窗口Z轴序
        public int						nVolume;							// 窗口音量，相对整屏音量的百分比
        public NET_COLOR_RGBA			stuBackColor;						// 窗口背景颜色
        public int						nDiaphaneity;						// 窗口背景透明度0-100
        public int 						emTourPeriodType;					// 窗口轮训类型 EM_TOURPERIOD_TYPE
        public int						nTourPeriodTime;					// 自定义轮训时间，单位秒, 轮训类型为自定义轮训时有效
        public int						bAutoPlay;							// 预览自动播放,Video元素有效
        public int						bLoopPlay;							// 预览循环播放,Video元素有效
        public int						nElementsCount;						// 诱导屏窗口元素个数
        public Pointer					pstElementsBuf;						// 播放盒窗口元素信息缓存区, 根据类型对应不同的结构体
        // 填充多个元素信息, 每个元素信息内容为 NET_ELEMENT_COMMON_INFO + 元素类型对应的结构体
        public int 						nBufLen;							// 诱导屏窗口元素信息缓存区大小
        public byte[]        			byReserved = new byte[128];			// 保留字节
    }

    // 通过programme ID 获取播放盒上对应的节目信息输入参数
    public static class NET_IN_GET_PLAYBOX_PROGRAM_BYID extends SdkStructure
    {
        public int           			dwSize;
        public byte[]					szProgrammeID = new byte[MAX_COMMON_STRING_64];	// 节目ID

        public NET_IN_GET_PLAYBOX_PROGRAM_BYID() {
            this.dwSize = this.size();
        }
    }

    // 通过programme ID 获取播放盒上对应的节目信息输出参数
    public static class NET_OUT_GET_PLAYBOX_PROGRAM_BYID extends SdkStructure
    {
        public int           			dwSize;
        public NET_PROGRAM_ON_PLAYBOX	stuPlayBoxProgram;					// 播放盒节目信息

        public NET_OUT_GET_PLAYBOX_PROGRAM_BYID() {
            this.dwSize = this.size();
        }
    }

    // 在播放盒上添加一个节目信息输入参数
    public static class NET_IN_ADD_ONE_PLAYBOX_PRAGROM extends SdkStructure
    {
        public int           			dwSize;
        public NET_PROGRAM_ON_PLAYBOX	stuPlayBoxProgram;			// 播放盒节目信息

        public NET_IN_ADD_ONE_PLAYBOX_PRAGROM() {
            this.dwSize = this.size();
        }
    }

    // 在播放盒上添加一个节目信息输出参数
    public static class NET_OUT_ADD_ONE_PLAYBOX_PRAGROM extends SdkStructure
    {
        public int           			dwSize;
        public byte[]					szProgrammeID = new byte[MAX_COMMON_STRING_64];	// 节目ID

        public NET_OUT_ADD_ONE_PLAYBOX_PRAGROM() {
            this.dwSize = this.size();
        }
    }

    // 在播放盒上修改指定ID的节目信息输入参数
    public static class NET_IN_MODIFY_PLAYBOX_PROGRAM_BYID extends SdkStructure
    {
        public int           			dwSize;
        public NET_PROGRAM_ON_PLAYBOX	stuPlayBoxProgram;			// 播放盒节目信息

        public NET_IN_MODIFY_PLAYBOX_PROGRAM_BYID() {
            this.dwSize = this.size();
        }
    }

    // 在播放盒上修改指定ID的节目信息输出参数
    public static class NET_OUT_MODIFY_PLAYBOX_PROGRAM_BYID extends SdkStructure
    {
        public int           			dwSize;

        public NET_OUT_MODIFY_PLAYBOX_PROGRAM_BYID() {
            this.dwSize = this.size();
        }
    }

    // 云台定位信息报警
    public static class NET_PTZ_LOCATION_INFO extends SdkStructure
    {
        public int     			nChannelID;                 		// 通道号
        public int     			nPTZPan;                    		// 云台水平运动位置,有效范围：[0,3600]
        public int     			nPTZTilt;                   		// 云台垂直运动位置,有效范围：[-1800,1800]
        public int    			nPTZZoom;                   		// 云台光圈变动位置,有效范围：[0,128]
        public byte    			bState;                     		// 云台运动状态, 0-未知 1-运动 2-空闲
        public byte   		 	bAction;                    		// 云台动作,
                                                                    // 255-未知,0-预置点,1-线扫,2-巡航,3-巡迹,4-水平旋转,5-普通移动,6-巡迹录制,
                                                                    // 7-全景云台扫描,8-热度图,9-精确定位,10-设备校正,11-智能配置，12-云台重启
        public byte    			bFocusState;                		// 云台聚焦状态, 0-未知, 1-运动状态, 2-空闲
        public byte    			bEffectiveInTimeSection;   			// 在时间段内预置点状态是否有效
                                                                    // 如果当前上报的预置点是时间段内的预置点,则为1,其他情况为0
        public int     			nPtzActionID;               		// 巡航ID号
        public int   			dwPresetID;                 		// 云台所在预置点编号
        public float   			fFocusPosition;             		// 聚焦位置
        public byte    			bZoomState;                 		// 云台ZOOM状态,0-未知,1-ZOOM,2-空闲
        public byte[]    		bReserved = new byte[3];            // 对齐
        public int   			dwSequence;                 		// 包序号,用于校验是否丢包
        public int   			dwUTC;                      		// 对应的UTC(1970-1-1 00:00:00)秒数。
        public int 				emPresetStatus; 					// 预置点位置,参考 EM_DH_PTZ_PRESET_STATUS
        public int	    		nZoomValue;				    		// 真实变倍值 当前倍率（扩大100倍表示）
        public NET_PTZSPACE_UNNORMALIZED stuAbsPosition;            // 云台方向与放大倍数（扩大100倍表示）
                                                                    // 第一个元素为水平角度，0-36000；
                                                                    // 第二个元素为垂直角度，（-18000）-（18000）；
                                                                    // 第三个元素为显示放大倍数，0-MaxZoom*100
        public int		nFocusMapValue;				                // 聚焦映射值
        public int		nZoomMapValue;				                // 变倍映射值
        public byte[]    reserved = new byte[700];                  // 保留字段
    }

    // 云台定位中非归一化坐标和变倍
    public static class NET_PTZSPACE_UNNORMALIZED extends SdkStructure
    {
        public int                    nPosX;           // x坐标
        public int                    nPosY;           // y坐标
        public int                    nZoom;           // 放大倍率
        public byte[]                 byReserved = new byte[52];   // 预留字节
    }

    // 预置点状态枚举
    public static class EM_DH_PTZ_PRESET_STATUS extends SdkStructure
    {
        public static final int EM_DH_PTZ_PRESET_STATUS_UNKNOWN = 0;        // 未知
        public static final int EM_DH_PTZ_PRESET_STATUS_REACH = 1;          // 预置点到达
        public static final int EM_DH_PTZ_PRESET_STATUS_UNREACH = 2;        // 预置点未到达
    }



    //通用曝光属性配置
    public static class NET_VIDEOIN_EXPOSURE_NORMAL_INFO extends SdkStructure
    {
        public int					dwSize;
        public int					emCfgType;								// 配置类型，获取和设置时都要指定,对应枚举  NET_EM_CONFIG_TYPE
        public int 					emExposureMode;							// 曝光模式, 对应枚举  NET_EM_EXPOSURE_MODE
        public int					nAntiFlicker;							// 防闪烁0-Outdoor  1-50Hz防闪烁 2-60Hz防闪烁
        public int					nCompensation;							// 曝光补偿0-100
        public int					nGain;									// 增益值
        public int					nGainMin;								// 增益下限0-100
        public int					nGainMax;								// 增益上限0-100
        public int					nExposureIris;							// 光圈值，模式为光圈优先时有效，0-100
        public double				dbExposureValue1;						// 自动曝光时间下限或者手动曝光自定义时间,毫秒为单位，取值0.1ms~80ms
        public double				dbExposureValue2;						// 自动曝光时间上限,毫秒为单位，取值0.1ms~80ms，且必须不小于"ExposureValue1"取值

        public Boolean              bIrisAuto;              // 自动光圈使能
        public int                  emDoubleExposure;       // 双快门的支持类型
        public NET_VIDEOIN_EXPOSURE_NORMAL_INFO() {
            this.dwSize = this.size();
        }
    }

    // 每个通道对应的配置类型
    public static class NET_EM_CONFIG_TYPE extends SdkStructure
    {
        public static final int NET_EM_CONFIG_DAYTIME = 0;				   // 白天
        public static final int NET_EM_CONFIG_NIGHT = 1;				   // 夜晚
        public static final int NET_EM_CONFIG_NORMAL = 2;				   // 普通
    }

    // 透雾模式
    public static class NET_EM_DEFOG_MODE extends SdkStructure {
        public static final int NET_EM_DEFOG_UNKNOW = 0;				   // 未知模式
        public static final int NET_EM_DEFOG_OFF = 1;				   // 关闭
        public static final int NET_EM_DEFOG_AUTO = 2;				   // 自动
        public static final int NET_EM_DEFOG_MANAUL = 3;				   // 手动
    }

    // 大气光模式枚举
    public static class NET_EM_INTENSITY_MODE extends SdkStructure {
        public static final int NET_EM_INTENSITY_MODE_UNKNOW = 0;				   // 未知方式
        public static final int NET_EM_INTENSITY_MODE_AUTO = 1;				   // 自动
        public static final int NET_EM_INTENSITY_MODE_MANUAL = 2;				   // 手动
    }

    // 曝光模式
    public static class NET_EM_EXPOSURE_MODE extends SdkStructure
    {
        public static final int NET_EM_EXPOSURE_AUTO = 0;					// 默认自动
        public static final int NET_EM_EXPOSURE_LOWNICE = 1;				// 低噪声
        public static final int NET_EM_EXPOSURE_ANTISHADOW = 2;				// 防拖影
        public static final int NET_EM_EXPOSURE_MANUALRANGE	= 4;			// 手动区间
        public static final int NET_EM_EXPOSURE_APERTUREFIRST = 5;			// 光圈优先
        public static final int NET_EM_EXPOSURE_MANUALFIXATION = 6;			// 手动固定
        public static final int NET_EM_EXPOSURE_GIANFIRST = 7;				// 增益优先
        public static final int NET_EM_EXPOSURE_SHUTTERFIRST = 8;			// 快门优先
        public static final int NET_EM_EXPOSURE_FLASHMATCH = 9;				// 闪光灯匹配模式
    }

    // 背光模式
    public static class NET_EM_BACK_MODE extends SdkStructure
    {
        public static final int NET_EM_BACKLIGHT_MODE_UNKNOW = 0;			// 未知模式
        public static final int NET_EM_BACKLIGHT_MODE_OFF = 1;				// 关闭
        public static final int NET_EM_BACKLIGHT_MODE_BACKLIGHT = 2;		// 背光补偿
        public static final int NET_EM_BACKLIGHT_MODE_WIDEDYNAMIC = 3;		// 宽动态
        public static final int NET_EM_BACKLIGHT_MODE_GLAREINHIBITION = 4;	// 强光抑制
        public static final int NET_EM_BACKLIGHT_MODE_SSA = 5;				// 场景自适应
    }

    // 背光补偿模式
    public static class NET_EM_BLACKLIGHT_MODE extends SdkStructure
    {
        public static final int NET_EM_BLACKLIGHT_UNKNOW = 0;				// 未知模式
        public static final int NET_EM_BLACKLIGHT_DEFAULT = 1;				// 默认模式
        public static final int NET_EM_BLACKLIGHT_REGION = 2;				// 自定义区域模式
    }

    // 背光配置
    public static class NET_VIDEOIN_BACKLIGHT_INFO extends SdkStructure
    {
        public int					dwSize;
        public int 					emCfgType;						// 配置类型，获取和设置时都要指定, 对应枚举  NET_EM_CONFIG_TYPE
        public int					emBlackMode;					// 背光模式, 对应枚举  NET_EM_BACK_MODE
        public int					emBlackLightMode;				// 背光补偿模式, 对应枚举  NET_EM_BLACKLIGHT_MODE
        public NET_RECT				stuBacklightRegion;     		// 背光补偿区域
        public int					nWideDynamicRange;				// 宽动态值，emBlackMode为NET_EM_BACKLIGHT_MODE_WIDEDYNAMIC时生效
        public int					nGlareInhibition;				// 强光抑制0-100，emBlackMode为NET_EM_BACKLIGHT_MODE_GLAREINHIBITION时生效

        public NET_VIDEOIN_BACKLIGHT_INFO() {
            this.dwSize = this.size();
        }
    }

    // 聚焦模式配置
    public static class NET_VIDEOIN_FOCUSMODE_INFO extends SdkStructure
    {
        public int					dwSize;
        public int					emCfgType;						// 配置类型，获取和设置时都要指定,对应枚举 NET_EM_CONFIG_TYPE
        public int				    emFocusMode;					// 聚焦模式, 对应枚举  NET_EM_FOCUS_MODE

        public NET_VIDEOIN_FOCUSMODE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 聚焦模式
    public static class NET_EM_FOCUS_MODE extends SdkStructure
    {
        public static final int NET_EM_FOCUS_OFF = 0;				// 关闭
        public static final int NET_EM_FOCUS_ASSIST = 1;			// 辅助聚焦
        public static final int NET_EM_FOCUS_AUTO = 2;				// 自动聚焦
        public static final int NET_EM_FOCUS_SEMI_AUTO = 3;			// 半自动聚焦
        public static final int NET_EM_FOCUS_MANUAL = 4;			// 手动聚焦
    }

    // 图像属性配置
    public static class NET_VIDEOIN_IMAGE_INFO extends SdkStructure
    {
        public int					dwSize;
        public int					emCfgType;						// 配置类型，获取和设置时都要制定,对应枚举 NET_EM_CONFIG_TYPE
        public int					bMirror;						// 是否开启画面镜像功能
        public int					bFlip;							// 是否开启画面翻转功能
        public int					nRotate90;						// 0-不旋转，1-顺时针90°，2-逆时针90°

        public NET_VIDEOIN_IMAGE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 网络协议配置
    public static class CFG_DVRIP_INFO extends SdkStructure
    {
        public int                 			nTcpPort;                           			// TCP服务端口,1025~65535
        public int                 			nSSLPort;                           			// SSL服务端口,1025~65535
        public int                 			nUDPPort;                          				// UDP服务端口,1025~65535
        public int                 			nMaxConnections;                    			// 最大连接数
        public int                			bMCASTEnable;                       			// 组播使能
        public int                 			nMCASTPort;                         			// 组播端口号
        public byte[]                		szMCASTAddress = new byte[MAX_ADDRESS_LEN];     // 组播地址
        public int                 			nRegistersNum;                      			// 主动注册配置个数
        public CFG_REGISTER_SERVER_INFO[]   stuRegisters = (CFG_REGISTER_SERVER_INFO[])new CFG_REGISTER_SERVER_INFO().toArray(MAX_REGISTER_NUM);// 主动注册配置
        public int    						emStreamPolicy;                     			// 带宽不足时码流策略,对应枚举  EM_STREAM_POLICY
        public CFG_REGISTERSERVER_VEHICLE	stuRegisterServerVehicle;						// 车载专用主动注册配置
    }

    // 带宽不足时码流策略
    public static class EM_STREAM_POLICY extends SdkStructure
    {
        public static final int STREAM_POLICY_UNKNOWN = 0;
        public static final int STREAM_POLICY_NONE = 1;										// 无策略,不开启使能"None"
        public static final int STREAM_POLICY_QUALITY = 2;                              	// 画质优先"Quality"
        public static final int STREAM_POLICY_FLUENCY = 3;                             		// 流畅度优先"Fluency"
        public static final int STREAM_POLICY_AUTOADAPT = 4;                           	 	// 自动"AutoAdapt"
    }

    // 主动注册配置
    public static class CFG_REGISTER_SERVER_INFO extends SdkStructure
    {
        public int                			bEnable;                            			// 主动注册使能
        public byte[]                		szDeviceID = new byte[MAX_ADDRESS_LEN];         // 设备ID
        public int                 			nServersNum;                        			// 服务器个数
        public CFG_SERVER_INFO[]     		stuServers = (CFG_SERVER_INFO[])new CFG_SERVER_INFO().toArray(MAX_SERVER_NUM);  // 服务器数组
    }

    // 服务器
    public static class CFG_SERVER_INFO extends SdkStructure
    {
        public int                 			nPort;                             				// 服务器端口号
        public byte[]                		szAddress = new byte[MAX_ADDRESS_LEN];          // IP地址或网络名
    }

    // 车载专用主动注册配置
    public static class CFG_REGISTERSERVER_VEHICLE extends SdkStructure
    {
        public int							bEnable;										// 主动注册使能
        public int							bRepeatEnable;									// 是否发送相同坐标数据
        public byte[]						szDeviceID = new byte[MAX_ADDRESS_LEN];			// 子设备ID
        public int							nSendInterval;									// 发送间隔, 单位：秒
        public byte[]						szAddress = new byte[MAX_ADDRESS_LEN];			// IP地址或网络名
        public int							nPort;											// 端口号
        public int							emSendPolicy;									// 上传策略,对应枚举  EM_CFG_SENDPOLICY
        public byte[]						szTestAddress = new byte[MAX_ADDRESS_LEN];		// 测试IP地址或网络名
        public int							nTestPort;										// 测试端口号
        public byte[]						byReserved = new byte[1024];					// 保留字节
    }

    // 上传策略
    public static class EM_CFG_SENDPOLICY extends SdkStructure
    {
        public static final int EM_SNEDPOLICY_UNKNOWN = -1;
        public static final int EM_SENDPOLICY_TIMING = 0;									// 定时上报
        public static final int EM_SENDPOLICY_EVENT = 1;									// 事件触发上报
    }

    // 网络接口配置
    public static class CFG_NETWORK_INFO extends SdkStructure
    {
        public byte[]						szHostName = new byte[MAX_NAME_LEN];			// 主机名称
        public byte[]						szDomain = new byte[MAX_NAME_LEN];				// 所属域
        public byte[]						szDefInterface = new byte[MAX_NAME_LEN];		// 默认使用的网卡
        public int							nInterfaceNum;									// 网卡数量
        public CFG_NETWORK_INTERFACE[]		stuInterfaces = (CFG_NETWORK_INTERFACE[])new CFG_NETWORK_INTERFACE().toArray(MAX_NETWORK_INTERFACE_NUM);	// 网卡列表
    }

    // 网络接口
    public static class CFG_NETWORK_INTERFACE extends SdkStructure
    {
        public byte[]							szName = new byte[MAX_NAME_LEN];			// 网络接口名称
        public byte[]							szIP = new byte[MAX_ADDRESS_LEN];			// ip地址
        public byte[]							szSubnetMask = new byte[MAX_ADDRESS_LEN];	// 子网掩码
        public byte[]							szDefGateway = new byte[MAX_ADDRESS_LEN];	// 默认网关
        public int								bDhcpEnable;								// 是否开启DHCP
        public int								bDnsAutoGet;								// DNS获取方式，dhcp使能时可以设置为true，支持通过dhcp获取
        public DNS_SERVERS[]					szDnsServersArr = (DNS_SERVERS[])new DNS_SERVERS().toArray(MAX_DNS_SERVER_NUM);	// DNS服务器地址
        public int								nMTU;										// 网络最大传输单元
        public byte[]							szMacAddress = new byte[MAX_ADDRESS_LEN];	// mac地址
        public int               			 	bInterfaceEnable;               			// 网络接口使能开关，表示该网口配置是否生效。不生效时，IP地址不设置到网卡上。
        public int                				bReservedIPEnable;              			// DHCP失败时是否使用保留IP，使用保留IP时还继续发DHCP请求
        public int 								emNetTranmissionMode;						// 网络传输模式，默认adapt自适应模式, 对应枚举  CFG_ENUM_NET_TRANSMISSION_MODE
        public int   	 						emInterfaceType;     						// 网口类型, 对应枚举  CFG_ENUM_NET_INTERFACE_TYPE
        public int          					bBond;               						// 是否绑定虚拟网口,对应枚举  CFG_THREE_STATUS_BOOL
    }

    public static class DNS_SERVERS extends SdkStructure
    {
        public byte[]				szDnsServers = new byte[MAX_ADDRESS_LEN];			// DNS服务器地址
    }

    // 网络传输模式
    public static class CFG_ENUM_NET_TRANSMISSION_MODE extends SdkStructure
    {
        public static final int CFG_ENUM_NET_MODE_ADAPT = 0;                            // 自适应
        public static final int CFG_ENUM_NET_MODE_HALF10M = 1;                          // 10M半双工
        public static final int CFG_ENUM_NET_MODE_FULL10M = 2;                          // 10M全双工
        public static final int CFG_ENUM_NET_MODE_HALF100M = 3;                         // 100M半双工
        public static final int CFG_ENUM_NET_MODE_FULL100M = 4;                         // 100M全双工
    }

    // 网口类型
    public static class CFG_ENUM_NET_INTERFACE_TYPE extends SdkStructure
    {
        public static final int CFG_ENUM_NET_INTERFACE_TYPE_UNKNOWN = 0;                // 未知
        public static final int CFG_ENUM_NET_INTERFACE_TYPE_STANDARD = 1;               // 标准网口
        public static final int CFG_ENUM_NET_INTERFACE_TYPE_MANAGER = 2;                // 管理网口
        public static final int CFG_ENUM_NET_INTERFACE_TYPE_EXTEND = 3;                 // 扩展网口
    }

    //三态布尔类型
    public static class CFG_THREE_STATUS_BOOL extends SdkStructure
    {
        public static final int CFG_BOOL_STATUS_UNKNOWN = -1;  							//未知
        public static final int CFG_BOOL_STATUS_FALSE  = 0;
        public static final int CFG_BOOL_STATUS_TRUE   = 1;
    }


    // RTMP配置
    public static class CFG_RTMP_INFO extends SdkStructure
    {
        public int						bEnable;											// RTMP配置是否开启
        public byte[]					szAddr = new byte[MAX_ADDRESS_LEN];					// RTMP服务器地址
        public int						nPort;												// RTMP服务器端口
        public int						nMainChnNum;										// 主码流通道个数
        public int[]					szMainChannel = new int[AV_CFG_Max_Channel_Num];	// 启用主码流通道号列表:每个成员表示对应的通道需要上传到RTMP服务器,通道号从0开始
        public int						nExtraChnNum;										// 辅码流通道个数
        public int[]					szExtraChannel = new int[AV_CFG_Max_Channel_Num];	// 启用辅码流通道号列表:每个成员表示对应的通道需要上传到RTMP服务器,通道号从0开始
        public byte[]					szCustomPath = new byte[MAX_ADDRESS_LEN];			// 定制路径名
        public byte[]					szStreamPath = new byte[MAX_ADDRESS_LEN];			// 码流路径前缀:不同通道以后缀数字区分
    }

    // 下载远程文件事件,对应  NET_ALARM_DOWNLOAD_REMOTE_FILE
    public static class ALARM_DOWNLOAD_REMOTE_FILE_INFO extends SdkStructure
    {
        public double				    dbPTS;											// 时间戳(单位是毫秒)
        public NET_TIME_EX			    stuTime;										// 事件发生的时间
        public int					    nEventID;										// 事件ID
        public byte[]					szURL = new byte[NET_COMMON_STRING_256];		// 下载文件对应的URL地址
        public int						nProgress;										// 下载进度[0,100]
        public byte[]                   byReserved = new byte[1020];					// 保留字节
    }

    // CLIENT_GetSplitWindowsInfo接口输入参数
    public static class NET_IN_SPLIT_GET_WINDOWS extends SdkStructure
    {
        public int                dwSize;
        public int                nChannel;                        // 通道号

        public NET_IN_SPLIT_GET_WINDOWS() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_GetSplitWindowsInfo接口输出参数
    public static class NET_OUT_SPLIT_GET_WINDOWS extends SdkStructure
    {
        public int                   	dwSize;
        public NET_BLOCK_COLLECTION     stuWindows;                 // 窗口信息

        public NET_OUT_SPLIT_GET_WINDOWS() {
            this.dwSize = this.size();
        }
    }

    // 融合屏通道信息
    public static class NET_COMPOSITE_CHANNEL extends SdkStructure
    {
        public int               	 dwSize;
        public byte[]                szMonitorWallName = new byte[NET_DEVICE_NAME_LEN];  // 电视墙名称
        public byte[]                szCompositeID = new byte[NET_DEV_ID_LEN_EX];        // 融合屏ID
        public int                   nVirtualChannel;                        			 // 虚拟通道号

        public NET_COMPOSITE_CHANNEL() {
            this.dwSize = this.size();
        }
    }

    // 电视墙
    public static class AV_CFG_MonitorWall extends SdkStructure
    {
        public int					nStructSize;
        public byte[]				szName = new byte[AV_CFG_Monitor_Name_Len];					// 名称
        public int					nLine;														// 网络行数
        public int					nColumn;													// 网格列数
        public int					nBlockCount;												// 区块数量
        public AV_CFG_MonitorWallBlock[] stuBlocks = new AV_CFG_MonitorWallBlock[AV_CFG_Max_Block_In_Wall];// 区块数组
        public int                	bDisable;                           						// 是否禁用, 0-该电视墙有效, 1-该电视墙无效
        public byte[]               szDesc = new byte[CFG_COMMON_STRING_256];      				// 电视墙描述信息

        public AV_CFG_MonitorWall() {
            this.nStructSize = this.size();
            for(int i = 0; i < stuBlocks.length; i++){
                stuBlocks[i] = new AV_CFG_MonitorWallBlock();
            }
        }

        public int fieldOffset(String name){
            return super.fieldOffset(name);
        }
    }

    // 电视墙区块
    public static class AV_CFG_MonitorWallBlock extends SdkStructure
    {
        public int							nStructSize;
        public int							nLine;													// 单个TV占的网格行数
        public int							nColumn;												// 单个TV占的网格列数
        public AV_CFG_Rect					stuRect;												// 区块的区域坐标
        public int							nTVCount;												// TV数量
        public AV_CFG_MonitorWallTVOut[]	stuTVs = new AV_CFG_MonitorWallTVOut[AV_CFG_Max_TV_In_Block];	      // TV数组
        public TIME_SECTION_WEEK_DAY_6[]	stuTimeSectionWeekDay = new TIME_SECTION_WEEK_DAY_6[WEEK_DAY_NUM];	  // 开关机时间
        public byte[]						szName = new byte[AV_CFG_Channel_Name_Len];				// 区块名称
        public byte[]						szCompositeID = new byte[AV_CFG_Device_ID_Len];			// 融合屏ID
        public byte[]                       szBlockType = new byte[NET_COMMON_STRING_32];   		// 显示单元组类型,为支持由接收卡组成单元的小间距LED区块而增加该字段,其他类型的区块填写为"LCD",如不存在该字段,默认采用LCD
        public int						    nOutputDelay;					// 输出延迟,单位：毫秒
        public AV_CFG_MonitorWallBlock() {
            this.nStructSize = this.size();
            for(int i = 0; i < stuTVs.length; i++){
                stuTVs[i] = new AV_CFG_MonitorWallTVOut();
            }
            for(int i = 0; i < stuTimeSectionWeekDay.length; i++){
                stuTimeSectionWeekDay[i] = new TIME_SECTION_WEEK_DAY_6();
            }
        }

        public int fieldOffset(String name){
            return super.fieldOffset(name);
        }
    }

    // 区域
    public static class AV_CFG_Rect extends SdkStructure
    {
        public int				nStructSize;
        public int				nLeft;
        public int				nTop;
        public int				nRight;
        public int				nBottom;

        public AV_CFG_Rect() {
            this.nStructSize = this.size();
        }
    };

    // 电视墙输出通道信息
    public static class AV_CFG_MonitorWallTVOut extends SdkStructure
    {
        public int				   nStructSize;
        public byte[]			   szDeviceID = new byte[AV_CFG_Device_ID_Len];			// 设备ID, 为空或"Local"表示本地设备
        public int				   nChannelID;											// 通道ID
        public byte[]			   szName = new byte[AV_CFG_Channel_Name_Len];			// 屏幕名称
        public boolean			bIsVirtual;							// 是否是虚拟屏（虚拟屏表示在本设备上不存在的屏）TRUE:虚拟屏 FALSE:非虚拟屏
        public byte[]			szAddress=new byte[40];						// 归属设备地址IP
        public AV_CFG_MONITOR_WALL_OUT_MODE_INFO	stuOutMode;		// 输出模式信息
        public AV_CFG_MonitorWallTVOut() {
            this.nStructSize = this.size();
        }
    }

    // CLIENT_OpenSplitWindow接口输入参数(开窗)
    public static class NET_IN_SPLIT_OPEN_WINDOW extends SdkStructure
    {
        public int               	dwSize;
        public int                  nChannel;                   		// 通道号(屏号)
        public DH_RECT              stuRect;                    		// 窗口位置, 0~8192
        public int                  bDirectable;                 		// 坐标是否满足直通条件, 直通是指拼接屏方式下,此窗口区域正好为物理屏区域

        public NET_IN_SPLIT_OPEN_WINDOW() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_OpenSplitWindow接口输出参数(开窗)
    public static class NET_OUT_SPLIT_OPEN_WINDOW extends SdkStructure
    {
        public int               	dwSize;
        public int        			nWindowID;                  		// 窗口序号
        public int        			nZOrder;                    		// 窗口次序

        public NET_OUT_SPLIT_OPEN_WINDOW() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_CloseSplitWindow接口输入参数(关窗)
    public static class NET_IN_SPLIT_CLOSE_WINDOW extends SdkStructure
    {
        public int               	dwSize;
        public int                  nChannel;                   		// 输出通道号或融合屏虚拟通道号, pszCompositeID为NULL时有效
        public int                  nWindowID;                  		// 窗口序号
        public String               pszCompositeID;             		// 融合屏ID

        public NET_IN_SPLIT_CLOSE_WINDOW() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_CloseSplitWindow接口输出参数(关窗)
    public static class NET_OUT_SPLIT_CLOSE_WINDOW extends SdkStructure
    {
        public int               	dwSize;

        public NET_OUT_SPLIT_CLOSE_WINDOW() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_GetGroupInfoForChannel接口输入参数
    public static class NET_IN_GET_GROUPINFO_FOR_CHANNEL extends SdkStructure
    {
        public int                dwSize;
        public int                nChannelID;                    // 通道号

        public NET_IN_GET_GROUPINFO_FOR_CHANNEL() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_GetGroupInfoForChannel接口输出参数
    public static class NET_OUT_GET_GROUPINFO_FOR_CHANNEL extends SdkStructure
    {
        public int                 dwSize;
        public int                 nGroupIdNum;                   									 // 人员组数
        public GROUP_ID[]          szGroupIdArr = (GROUP_ID[])new GROUP_ID().toArray(MAX_GOURP_NUM); // 人员组ID
        public int				   nSimilaryNum;													 // 相似度阈值个数, 与人员组数相同
        public int[]			   nSimilary = new int[MAX_GOURP_NUM];								 // 每个人脸组的相似度阈值, 0-100

        public NET_OUT_GET_GROUPINFO_FOR_CHANNEL() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_FaceRecognitionPutDisposition 接口输入参数
    public static class NET_IN_FACE_RECOGNITION_PUT_DISPOSITION_INFO extends SdkStructure
    {
        public int               				dwSize;
        public byte[]                			szGroupId = new byte[NET_COMMON_STRING_64]; 					// 人员组ID
        public int								nDispositionChnNum;											    // 布控视频通道个数
        public NET_DISPOSITION_CHANNEL_INFO[]	stuDispositionChnInfo = (NET_DISPOSITION_CHANNEL_INFO[])new NET_DISPOSITION_CHANNEL_INFO().toArray(NET_MAX_CAMERA_CHANNEL_NUM);	// 布控视频通道信息

        public NET_IN_FACE_RECOGNITION_PUT_DISPOSITION_INFO() {
            this.dwSize = this.size();
        }
    }

    // 布控的视频通道信息
    public static class NET_DISPOSITION_CHANNEL_INFO extends SdkStructure
    {
        public int					nChannelID;										// 视频通道号
        public int					nSimilary;										// 相似度阈值, 0-100
        public byte[]				bReserved = new byte[256];						// 保留
    }

    // CLIENT_FaceRecognitionPutDisposition 接口输出参数
    public static class NET_OUT_FACE_RECOGNITION_PUT_DISPOSITION_INFO extends SdkStructure
    {
        public int               	dwSize;
        public int					nReportCnt;										// 通道布控结果个数
        public int[]				bReport = new int[NET_MAX_CAMERA_CHANNEL_NUM];	// 通道布控结果, TRUE追加成功, FALSE追加失败

        public NET_OUT_FACE_RECOGNITION_PUT_DISPOSITION_INFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_FaceRecognitionDelDisposition 接口输入参数
    public static class NET_IN_FACE_RECOGNITION_DEL_DISPOSITION_INFO extends SdkStructure
    {
        public int               	dwSize;
        public byte[]               szGroupId = new byte[NET_COMMON_STRING_64]; 				// 人员组ID
        public int					nDispositionChnNum;											// 撤控视频通道个数
        public int[]				nDispositionChn = new int[NET_MAX_CAMERA_CHANNEL_NUM];		// 撤控视频通道列表

        public NET_IN_FACE_RECOGNITION_DEL_DISPOSITION_INFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_FaceRecognitionDelDisposition 接口输出参数
    public static class NET_OUT_FACE_RECOGNITION_DEL_DISPOSITION_INFO extends SdkStructure
    {
        public int                  dwSize;
        public int					nReportCnt;													// 通道布控结果个数
        public int[]				bReport = new int[NET_MAX_CAMERA_CHANNEL_NUM];				// 通道布控结果, TRUE删除成功, FALSE删除失败

        public NET_OUT_FACE_RECOGNITION_DEL_DISPOSITION_INFO() {
            this.dwSize = this.size();
        }
    }

    // 人证比对事件，用实时拍摄的人脸照片，和该人持有的身份证照片进行比对，并上报检测结果
    // 对应事件类型为 EVENT_IVS_CITIZEN_PICTURE_COMPARE
    public static class DEV_EVENT_CITIZEN_PICTURE_COMPARE_INFO extends SdkStructure
    {
        //公共字段
        public int                 nChannelID;                         				// 通道号,从0开始
        public int                 nEventAction;					    			// 事件动作, 0表示脉冲, -1表示未知
        public double              dbPTS;                              				// 时间戳(单位是毫秒)
        public byte[]              szName = new byte[NET_EVENT_NAME_LEN];   		// 事件名称
        public NET_TIME_EX         stuUTC;                             				// 事件发生的时间
        public int                 nEventID;                           				// 事件ID

        //事件对应字段
        public byte                bCompareResult;                     				// 人证比对结果,相似度大于等于阈值认为比对成功,1-表示成功,0-表示失败
        public byte                nSimilarity;                        				// 两张图片的相似度,单位百分比,范围[1,100]
        public byte                nThreshold;                         				// 检测阈值,范围[1,100]
        public int  			   emSex;                        					// 性别, 参考  EM_CITIZENIDCARD_SEX_TYPE

        public int                 nEthnicity;                         				// 民族
        // 0-无效数据; 1-汉族; 2-蒙古族; 3-回族; 4-藏族;; 5-维吾尔族
        // 6-苗族; 7-彝族; 8-壮族; 9-布依族; 10-朝鲜族; 11-满族; 12-侗族
        // 13-瑶族; 14-白族; 15-土家族; 16-哈尼族; 17-哈萨克族; 18-傣族
        // 19-黎族; 20-傈僳族; 21-佤族; 22-畲族; 23-高山族; 24-拉祜族
        // 25-水族; 26-东乡族; 27-纳西族; 28-景颇族; 29-柯尔克孜族
        // 30-土族; 31-达斡尔族; 32-仫佬族; 33-羌族; 34-布朗族; 35-撒拉族
        // 36-毛南族; 37-仡佬族; 38-锡伯族; 39-阿昌族; 40-普米族; 41-塔吉克族
        // 42-怒族; 43-乌孜别克族; 44-俄罗斯族; 45-鄂温克族; 46-德昂族
        // 47-保安族; 48-裕固族; 49-京族; 50-塔塔尔族; 51-独龙族; 52-鄂伦春族
        // 53-赫哲族; 54-门巴族; 55-珞巴族; 56-基诺族

        public byte[]              szCitizen = new byte[NET_COMMON_STRING_64];      // 居民姓名
        public byte[]              szAddress = new byte[NET_COMMON_STRING_256];     // 住址
        public byte[]              szNumber = new byte[NET_COMMON_STRING_64];       // 身份证号
        public byte[]              szAuthority = new byte[NET_COMMON_STRING_256];   // 签发机关
        public NET_TIME            stuBirth;                           				// 出生日期(年月日)
        public NET_TIME            stuValidityStart;                   				// 有效期限起始日期(年月日)
        public int                 bLongTimeValidFlag;                 				// 该值为 TRUE, 截止日期 表示长期有效,此时 stuValidityEnd 值无意义
        // 该值为 FALSE, 此时 截止日期 查看 stuValidityEnd 值
        public NET_TIME            stuValidityEnd;                     				// 有效期限结束日期(年月日)
        public CITIZEN_PICTURE_COMPARE_IMAGE_INFO[] stuImageInfo
                = (CITIZEN_PICTURE_COMPARE_IMAGE_INFO[])new CITIZEN_PICTURE_COMPARE_IMAGE_INFO().toArray(2);  // 图片信息，第一张为拍摄照片，第二张为身份证照片

        public byte[]              szCardNo = new byte[NET_COMMON_STRING_32];      // IC卡号
        public byte[]              szCellPhone = new byte[NET_COMMON_STRING_20];   // 手机号（比对时先输入手机号）
        public NET_EXTENSION_INFO  stuExtensionInfo;                   			   // 扩展信息

        public CITIZEN_PICTURE_COMPARE_IMAGE_INFO_EX[]	stuImageInfoEx
                = (CITIZEN_PICTURE_COMPARE_IMAGE_INFO_EX[])new CITIZEN_PICTURE_COMPARE_IMAGE_INFO_EX().toArray(6);	// 图片扩展信息

        public byte[]			      szCallNumber = new byte[20];					   // 呼叫号码
        public int	                  emDoorOpenMethod;			                       // 开门方式（人证照片或者人证指纹） 参考 NET_ACCESS_DOOROPEN_METHOD
        public int				      nEventGroupID;						           // 事件ID,用于不同事件进行关联
        public int				      nEventType;							           // 事件类型：0：人证比对结果	1：人证人脸采集 2：访客登记 3：人脸权限下发 4：人证人脸底库查询
        public byte[]		          szUserID = new byte[32];						   // 人证人脸采集时人员ID（定制）
        public byte[]	    		  szBuildingNo = new byte[16];					   // 楼号（定制）
        public byte[]				  szBuildingUnitNo = new byte[16];				   // 单元号（定制）
        public byte[]				  szBuildingRoomNo = new byte[16];				   // 房间号（定制）
        public int				      nFaceIndex;							// 人脸序号
        public int	                  emMask;								// 口罩状态 EM_MASK_STATE_TYPE
        public int					  bManTemperature;			            // 人员温度信息是否有效
        public NET_MAN_TEMPERATURE_INFO 	stuManTemperatureInfo;		    // 人员温度信息, bManTemperature 为TRUE 时有效
        public double						dbBulkOilQuantity;			    // 散装油量 (定制)
        public int					  nScore;								// 人脸质量评分
        public Pointer pstuCardNoArray;					// 卡号数组信息,对应NET_CARDNOARRAY_INFO
        public Pointer pstuFingerPrint;					// 指纹数组信息,对应NET_FINGERPRINT_INFO
        public byte[]				szIDPhysicalNumber=new byte[20];				// 物理身份证号（身份证序列号）
    }

    // 人证对比图片信息
    public static class CITIZEN_PICTURE_COMPARE_IMAGE_INFO extends SdkStructure
    {
        public int           		dwOffSet;                       				// 文件在二进制数据块中的偏移位置, 单位:字节
        public int           		dwFileLenth;                    				// 文件大小, 单位:字节
        public short            	wWidth;                         				// 图片宽度, 单位:像素
        public short            	wHeight;                        				// 图片高度, 单位:像素
        public byte[]            	byReserved = new byte[256];                		// 保留字节
    }

    // 人证对比扩展图片信息
    public static class CITIZEN_PICTURE_COMPARE_IMAGE_INFO_EX extends SdkStructure
    {
        public int					emType;											// 图片类型, 参考枚举  CITIZEN_PICTURE_COMPARE_TYPE
        public int					dwOffSet;               						// 文件在二进制数据块中的偏移位置, 单位:字节
        public int					dwFileLenth;            						// 文件大小, 单位:字节
        public short				wWidth;                 						// 图片宽度, 单位:像素
        public short				wHeight;                						// 图片高度, 单位:像素
        public byte[]				byReserved = new byte[64];        				// 保留字节
    }

    // 图片类型
    public static class CITIZEN_PICTURE_COMPARE_TYPE extends SdkStructure
    {
        public static final int CITIZEN_PICTURE_COMPARE_TYPE_UNKNOWN = -1;
        public static final int CITIZEN_PICTURE_COMPARE_TYPE_LOCAL = 0;				// 本地人脸库图
        public static final int CITIZEN_PICTURE_COMPARE_TYPE_FACEMAP = 1;			// 拍摄场景图
    }

    public static class EM_CITIZENIDCARD_SEX_TYPE extends SdkStructure
    {
        public static final int EM_CITIZENIDCARD_SEX_TYPE_UNKNOWN = 0;          	// 未知
        public static final int EM_CITIZENIDCARD_SEX_TYPE_MALE = 1;             	// 男
        public static final int EM_CITIZENIDCARD_SEX_TYPE_FEMALE = 2;           	// 女
        public static final int EM_CITIZENIDCARD_SEX_TYPE_UNTOLD = 3;           	// 未说明
    }

    // 事件类型 EVENT_IVS_HUMANTRAIT(人体特征事件)对应的数据块描述信息
    public static class DEV_EVENT_HUMANTRAIT_INFO extends SdkStructure
    {
        public int					nChannelID;									  // 通道号
        public byte[]				szName = new byte[NET_EVENT_NAME_LEN];		  // 事件名称
        public int                  nEventID;                                     // 事件ID
        public double              	PTS;                                          // 时间戳(单位是毫秒)
        public NET_TIME_EX          UTC;                                          // 事件发生的时间
        public int                  nAction;                                      // 1:开始 2:停止
        public int					emClassType;								  // 智能事件所属大类, 详见 EM_CLASS_TYPE
        public int					nGroupID;									  // 事件组ID，一次检测的多个人体特征nGroupID相同
        public int					nCountInGroup;								  // 一个事件组内的抓拍张数(人体个数),一次检测的多个人体特征nCountInGroup相同
        public int					nIndexInGroup;								  // 一个事件组内的抓拍序号，从1开始
        public HUMAN_IMAGE_INFO		stuHumanImage;								  // 人体图片信息
        public FACE_IMAGE_INFO		stuFaceImage;								  // 人脸图片信息
        public int					emDetectObject;								  // 检测到的人的信息, 详见 EM_DETECT_OBJECT
        public HUMAN_ATTRIBUTES_INFO stuHumanAttributes;						  // 人体属性
        public SCENE_IMAGE_INFO     stuSceneImage;                                // 全景大图信息
        public NET_FACE_ATTRIBUTE	stuFaceAttributes;							  // 人脸属性
        public FACE_SCENE_IMAGE		stuFaceSceneImage;							  // 人脸全景图
        public NET_EXTENSION_INFO  	stuExtensionInfo;                             // 扩展信息
        public NET_HUMANTRAIT_EXTENSION_INFO   stuHumanTrait;                     // 补充事件，表示当前人体特征是由该事件产生的
        public byte[]				byReserved = new byte[88];					  // 保留字节,留待扩展.
    }

    // 人体图片信息
    public static class HUMAN_IMAGE_INFO extends SdkStructure
    {
        public int       	nOffSet;					// 偏移
        public int	   		nLength;					// 图片大小,单位字节
        public int	   		nWidth;						// 图片宽度
        public int	   		nHeight;					// 图片高度
        public byte[]	 	byReserved = new byte[56];	// 预留字节
    }

    // 人脸图片信息
    public static class FACE_IMAGE_INFO extends SdkStructure
    {
        public int	   		nOffSet;					// 偏移
        public int	   		nLength;					// 图片大小,单位字节
        public int	   		nWidth;						// 图片宽度
        public int	   		nHeight;					// 图片高度
        public byte[]		byReserved = new byte[56];	// 预留字节
    }

    // 检测到的人的信息
    public static class EM_DETECT_OBJECT extends SdkStructure
    {
        public static final int EM_DETECT_OBJECT_UNKNOWN = 0;    			// 未知信息
        public static final int EM_DETECT_OBJECT_HUMAN_BODY_AND_FACE = 1;   // 人体和人脸都有
        public static final int EM_DETECT_OBJECT_HUMAN_BODY = 2;     		// 仅有人体
        public static final int EM_DETECT_OBJECT_HUMAN_FACE = 3;       		// 仅有人脸
    }

    // 角度
    public static class EM_ANGLE_TYPE extends SdkStructure
    {
        public static final int EM_ANGLE_UNKNOWN = 0;			// 未知
        public static final int EM_ANGLE_FRONT = 1;					// 正面
        public static final int EM_ANGLE_SIDE = 2;					// 侧面
        public static final int EM_ANGLE_BACK = 3;					// 背面
    }

    // 是否打伞
    public static class EM_HAS_UMBRELLA extends SdkStructure
    {
        public static final int EM_HAS_UMBRELLA_UNKNOWN = 0;		// 未知
        public static final int EM_HAS_UMBRELLA_NO = 1;				// 未打伞
        public static final int EM_HAS_UMBRELLA_YES = 2;			// 打伞
    }

    // 包类型
    public static class EM_BAG_TYPE extends SdkStructure
    {
        public static final int EM_BAG_UNKNOWN = 0;					// 未知
        public static final int EM_BAG_HANDBAG = 1;					// 手提包
        public static final int EM_BAG_SHOULDERBAG = 2;				// 肩包
        public static final int EM_BAG_KNAPSACK = 3;				// 背包
        public static final int EM_BAG_DRAWBARBOX = 4;				// 拉杆箱
    }

    // 上半身衣服图案
    public static class EM_CLOTHES_PATTERN extends SdkStructure
    {
        public static final int EM_CLOTHES_PATTERN_UNKNOWN = 0;		// 未知
        public static final int EM_CLOTHES_PATTERN_PURE = 1;		// 纯色
        public static final int EM_CLOTHES_PATTERN_STRIPE = 2;		// 条纹
        public static final int EM_CLOTHES_PATTERN_PATTERN = 3;		// 图案
        public static final int EM_CLOTHES_PATTERN_GAP = 4;			// 缝隙
        public static final int EM_CLOTHES_PATTERN_LATTICE = 5;		// 格子
    }

    // 头发样式
    public static class EM_HAIR_STYLE extends SdkStructure
    {
        public static final int EM_HAIR_UNKNOWN = 0;		// 未知
        public static final int EM_HAIR_LONG_HAIR = 1;		// 长发
        public static final int EM_HAIR_SHORT_HAIR = 2;		// 短发
        public static final int EM_HAIR_PONYTAIL = 3;		// 马尾
        public static final int EM_HAIR_UPDO = 4;			// 盘发
        public static final int EM_HAIR_HEAD_BLOCKED = 5;	// 头部被遮挡
    }

    // 帽类型
    public static class EM_CAP_TYPE extends SdkStructure
    {
        public static final int EM_CAP_UNKNOWN = 0;		// 未知
        public static final int EM_CAP_ORDINARY = 1;	// 普通帽子
        public static final int EM_CAP_HELMET   =2;		// 头盔
        public static final int EM_CAP_SAFE = 3;		// 安全帽
    }

    // 人体属性信息
    public static class HUMAN_ATTRIBUTES_INFO extends SdkStructure
    {
        public int    		emCoatColor;									// 上衣颜色, 详见 EM_CLOTHES_COLOR
        public int			emCoatType;										// 上衣类型, 详见 EM_COAT_TYPE
        public int			emTrousersColor;								// 裤子颜色, 详见 EM_CLOTHES_COLOR
        public int			emTrousersType;									// 裤子类型, 详见 EM_TROUSERS_TYPE
        public int			emHasHat;										// 是否戴帽子, 详见 EM_HAS_HAT
        public int			emHasBag;										// 是否带包, 详见 EM_HAS_BAG
        public NET_RECT     stuBoundingBox;						    		// 包围盒(8192坐标系)
        public int			nAge;											// 年龄
        public int 			emSex;											// 性别, 详见 EM_SEX_TYPE
        public int			emAngle;										// 角度, 详见 EM_ANGLE_TYPE
        public int			emHasUmbrella;									// 是否打伞, 详见 EM_HAS_UMBRELLA
        public int			emBag;											// 包类型 , 详见EM_BAG_TYPE
        public int			emUpperPattern;									// 上半身衣服图案, 详见EM_CLOTHES_PATTERN
        public int			emHairStyle;									// 头发样式, 详见EM_HAIR_STYLE
        public int			emCap;											// 帽类型, 详见EM_CAP_TYPE

        public byte[]		byReserved = new byte[80];						// 预留字节
    }

    // 衣服颜色
    public static class EM_CLOTHES_COLOR extends SdkStructure
    {
        public static final int EM_CLOTHES_COLOR_UNKNOWN = 0;    // 未知
        public static final int EM_CLOTHES_COLOR_WHITE = 1;      // 白色
        public static final int EM_CLOTHES_COLOR_ORANGE = 2;     // 橙色
        public static final int EM_CLOTHES_COLOR_PINK = 3;       // 粉色
        public static final int EM_CLOTHES_COLOR_BLACK = 4;      // 黑色
        public static final int EM_CLOTHES_COLOR_RED = 5;        // 红色
        public static final int EM_CLOTHES_COLOR_YELLOW = 6;     // 黄色
        public static final int EM_CLOTHES_COLOR_GRAY = 7;       // 灰色
        public static final int EM_CLOTHES_COLOR_BLUE = 8;       // 蓝色
        public static final int EM_CLOTHES_COLOR_GREEN = 9;      // 绿色
        public static final int EM_CLOTHES_COLOR_PURPLE = 10;    // 紫色
        public static final int EM_CLOTHES_COLOR_BROWN = 11;     // 棕色
        public static final int EM_CLOTHES_COLOR_OTHER = 12;     // 棕色
    }

    //上衣类型
    public static class EM_COAT_TYPE extends SdkStructure
    {
        public static final int EM_COAT_TYPE_UNKNOWN = 0;    	// 未知
        public static final int EM_COAT_TYPE_LONG_SLEEVE = 1;   // 长袖
        public static final int EM_COAT_TYPE_COTTA = 2;     	// 短袖
    }

    // 裤子类型
    public static class EM_TROUSERS_TYPE extends SdkStructure
    {
        public static final int EM_TROUSERS_TYPE_UNKNOWN = 0;    	// 未知
        public static final int EM_TROUSERS_TYPE_TROUSERS = 1;   	// 长裤
        public static final int EM_TROUSERS_TYPE_SHORTS = 2;     	// 短裤
        public static final int EM_TROUSERS_TYPE_SKIRT = 3;     	// 裙子
    }

    // 是否戴帽子
    public static class EM_HAS_HAT extends SdkStructure
    {
        public static final int EM_HAS_HAT_UNKNOWN = 0; // 未知
        public static final int EM_HAS_HAT_NO = 1;   	// 不戴帽子
        public static final int EM_HAS_HAT_YES = 2;     // 戴帽子
    }

    // 是否戴包(包括背包或拎包)
    public static class EM_HAS_BAG extends SdkStructure
    {
        public static final int EM_HAS_BAG_UNKNOWN = 0; // 未知
        public static final int EM_HAS_BAG_NO = 1;   	// 不带包
        public static final int EM_HAS_BAG_YES = 2;     // 带包
    }

    // 全景广角图
    public static class SCENE_IMAGE_INFO extends SdkStructure
    {
        public int	   		nOffSet;					// 在二进制数据块中的偏移
        public int	   		nLength;					// 图片大小,单位字节
        public int	   		nWidth;						// 图片宽度(像素)
        public int	   		nHeight;					// 图片高度(像素)
        public byte[]		byReserved = new byte[56];	// 预留字节
    }

    // 人脸属性
    public static class NET_FACE_ATTRIBUTE extends SdkStructure
    {
        public int 						emSex;						// 性别, 详见 EM_DEV_EVENT_FACEDETECT_SEX_TYPE
        public int        				nAge;						// 年龄,-1表示该字段数据无效
        public int        				nFeatureValidNum;           // 人脸特征数组有效个数,与 emFeature 结合使用
        public int[]    				emFeatures = new int[NET_MAX_FACEDETECT_FEATURE_NUM];   // 人脸特征数组,与 nFeatureValidNum 结合使用 , 详见 EM_DEV_EVENT_FACEDETECT_FEATURE_TYPE
        public int						emComplexion;				// 肤色, 详见 EM_COMPLEXION_TYPE
        public int						emEye;						// 眼睛状态, 详见 EM_EYE_STATE_TYPE
        public int						emMouth;					// 嘴巴状态, 详见 EM_MOUTH_STATE_TYPE
        public int 						emMask;						// 口罩状态, 详见 EM_MASK_STATE_TYPE
        public int						emBeard;					// 胡子状态, 详见 EM_BEARD_STATE_TYPE
        public int						nAttractive;				// 魅力值, 0未识别，识别时范围1-100,得分高魅力高
        public NET_RECT					stuBoundingBox;				// 包围盒(8192坐标系)
        public byte[]                	bReserved = new byte[112];  // 保留字节,留待扩展.
    }

    // 肤色
    public static class EM_COMPLEXION_TYPE extends SdkStructure
    {
        public static final int EM_COMPLEXION_NODISTI = 0;                       // 未识别
        public static final int EM_COMPLEXION_YELLOW = 1;                        // 黄
        public static final int EM_COMPLEXION_BLACK = 2;                         // 黑
        public static final int EM_COMPLEXION_WHITE = 3;                         // 白
    }

    // 人脸全景图
    public static class FACE_SCENE_IMAGE extends SdkStructure
    {
        public int	   		nOffSet;					// 在二进制数据块中的偏移
        public int	   		nLength;					// 图片大小,单位字节
        public int	   		nWidth;						// 图片宽度(像素)
        public int	   		nHeight;					// 图片高度(像素)
        public byte[]  		byReserved = new byte[56];  // 预留字节
    }

    // 事件扩展信息
    public static class NET_EXTENSION_INFO extends SdkStructure
    {
        public byte[]        szEventID = new byte[MAX_EVENT_ID_LEN];				// 国标事件ID
        public byte[]        byReserved = new byte[80];                             // 保留字节
    }

    // 当前人体特征是由什么事件产生的
    public static class NET_HUMANTRAIT_EXTENSION_INFO extends SdkStructure
    {
        public byte[]                szAdditionalCode = new byte[MAX_HUMANTRAIT_EVENT_LEN];     // 当前人体特征是由什么事件产生的,设备刚好返回32个字节数据，多加4个字节用于字节对齐和添加字符结束符
        public byte[]                byReserved = new byte[32];                                 // 保留字节
    }

    // 事件类型 NET_ALARM_WIFI_SEARCH (搜索WIFI设备)对应的数据描述信息
    public static class ALARM_WIFI_SEARCH_INFO extends SdkStructure
    {
        public int                      nWifiNum;                       			// WIFI设备数量, 指示stuWifi的有效数量
        public NET_WIFI_DEV_INFO[]      stuWifi = (NET_WIFI_DEV_INFO[])new NET_WIFI_DEV_INFO().toArray(1024);    // 周围Wifi设备的信息
        public int                      nChannel;                       			// 通道号
        public NET_WIFI_BASIC_INFO      stuWifiBasiInfo;				 			// Wifi事件上报基础信息
        public int					 	bGPSinfo;						 			// 是否包含GPS信息
        public NET_WIFI_GPS_INFO		stuWifiGPSInfo;				 				// GPS信息
        public byte[]                   reserved = new byte[376];                   // 预留
    }

    public static class ALARM_WIFI_SEARCH_INFO_EX extends SdkStructure
    {
        public Pointer                  pstuWifi;                                  // 周围Wifi设备的信息
        public int                      nWifiNum;                                  // Wifi设备数量，pstuWifi 的个数
        public int                      nChannel;                                  // 通道号
        public NET_WIFI_BASIC_INFO      stuWifiBasiInfo;                           // Wifi事件上报基础信息
        public int                      bGPSinfo;                                  // 是否包含GPS信息
        public NET_WIFI_GPS_INFO        stuWifiGPSInfo;                            // GPS信息
        public byte[]                   reserved=new byte[512];                    // 预留
    };

    // 搜索到的WIFI设备信息
    public static class NET_WIFI_DEV_INFO extends SdkStructure
    {
        public byte[]                   szMac = new byte[NET_MACADDR_LEN];         	 	// Wifi设备的Mac地址
        public int                      nLinkQuality;                   				// 链接质量百分比, 0~100
        public NET_TIME_EX              stuEnterTime;                   				// 第一被搜索到的时间
        public NET_TIME_EX              stuLeaveTime;                   				// 消失的时间
        public int                      nSearchedCount;                 				// 被搜索到的次数
        public byte[]                   szSSID = new byte[24];                      	// 网络名称
        public NET_TIME_EX              UTC;                            				// 事件发生时间
        public int      				emDevType;                      				// WIFI设备类型, 参考 EM_WIRELESS_DEV_TYPE
        public int                      nChannel;                       				// Wifi设备当前所在的信道
        public int  					emAuth;                      			 		// 认证方式, 参考 EM_WIRELESS_AUTHENTICATION
        public int  					emEncrypt;                      				// 数据加密方式, 参考 EM_WIRELESS_DATA_ENCRYPT
        public byte[]                   szAPMac = new byte[NET_MACADDR_LEN];        	// 接入热点Mac
        public int                      nAPChannel;                     				// 接入热点频道
        public byte[]                   szAPSSID = new byte[24];                    	// 接入热点SSID
        public int  					emAPEncrypt;                    				// 接入热点加密类型, 参考 EM_WIRELESS_DATA_ENCRYPT
        public int						nRssiQuality;                   				// 信号强度
        public byte[]					szManufacturer = new byte[MAX_MANUFACTURER_LEN];// Mac地址所属制造商
        public MACHISTORY_SSID[]		szMacHistorySSIDList = (MACHISTORY_SSID[])new MACHISTORY_SSID().toArray(MAX_MACHISTORY_SSID_NUM); // 此设备曾经连接过的历史SSID列表
        public int			 			nRetMacHistorySSIDNum;			 				// 此设备实际连接过的SSID个数
        public byte[]                   reserved = new byte[264];                  		// 预留
    }

    // 历史SSID
    public static class MACHISTORY_SSID extends SdkStructure
    {
        public byte[]    				szMacHistorySSID = new byte[MAX_MACHISTORY_SSID_LEN];	// 历史SSID
    }

    // 搜索到的WIFI基本信息
    public static class NET_WIFI_BASIC_INFO extends SdkStructure
    {
        public int 						nPeriodUTC;      			// 本周期上报的起始时间，为同一上报周期的标识；当同一上报周期内设备总数超过单次上报数量上限时需要多次上报事件，该值作为同一上报周期内多次上报事件的标识码；
        public int  					nDeviceSum;      			// 本周期上报的wifi总数，同一上报周期内的事件中的该值均应为本周期上报的wifi总数
        public int  					nCurDeviceCount; 			// 本次事件上报的Wifi设备数量，应与ALARM_WIFI_SEARCH_INFO结构体中的nWifiNum值一致；同一上报周期内该值的累积总数与nDeviceSum一致。
        public byte[]  					reserved = new byte[500];   // 预留字节
    }

    // 事件类型  NET_ALARM_WIFI_VIRTUALINFO_SEARCH (获取周围wifi设备虚拟信息事件)对应的数据描述信息
    public static class ALARM_WIFI_VIRTUALINFO_SEARCH_INFO extends SdkStructure
    {
        public int                      nVirtualInfoNum;								// WIFI设备虚拟身份数量, 指示stuVirtualInfo的有效数量
        public NET_WIFI_VIRTUALINFO[]   stuVirtualInfo = (NET_WIFI_VIRTUALINFO[])new NET_WIFI_VIRTUALINFO().toArray(MAX_VIRTUALINFO_NUM);    // 周围Wifi虚拟身份信息
        public int                      nChannel;										// 通道号
        public byte[]                   reserved = new byte[512];						// 预留
    }

    // 搜索到的WIFI设备虚拟身份信息
    public static class NET_WIFI_VIRTUALINFO extends SdkStructure
    {
        public NET_TIME_EX				stuAccessTime;											// 访问时间，时间不精确仅供参考
        public byte[]					szSrcMac = new byte[NET_MACADDR_LEN];					// 虚拟信息的来源MAC,字母大写，用"-"分隔
        public byte[]					szDstMac = new byte[NET_MACADDR_LEN];					// 虚拟信息的目标MAC,字母大写，用"-"分隔
        public int						nProtocal;												// 协议代号，上网应用对应的标识码
        public byte[]					szUrl = new byte[NET_MAX_URL_LEN];						// 上网url
        public byte[]					szDomain = new byte[MAX_VIRTUALINFO_DOMAIN_LEN];		// 上网域
        public byte[]					szTitle = new byte[MAX_VIRTUALINFO_TITLE_LEN];			// 上网标题
        public byte[]					szUsrName = new byte[MAX_VIRTUALINFO_USERNAME_LEN];		// 用户名
        public byte[]					szPassWord = new byte[MAX_VIRTUALINFO_PASSWORD_LEN];	// 密码
        public byte[]					szPhoneNum = new byte[MAX_VIRTUALINFO_PHONENUM_LEN];	// 手机号
        public byte[]					szImei = new byte[MAX_VIRTUALINFO_IMEI_LEN];			// 国际移动设备标识
        public byte[]					szImsi = new byte[MAX_VIRTUALINFO_IMSI_LEN];			// 国际移动用户识别码
        public byte[]					szLatitude = new byte[MAX_VIRTUALINFO_LATITUDE_LEN];	// 经度
        public byte[]					szLongitude = new byte[MAX_VIRTUALINFO_LONGITUDE_LEN];	// 纬度
        public byte[]					szSrcIP = new byte[NET_MAX_IPADDR_LEN_EX];				// 源IP
        public byte[]					szDstIP = new byte[NET_MAX_IPADDR_LEN_EX];				// 目的IP
        public int						nSrcPort;												// 源端口
        public int						nDstPort;												// 目的端口
        public byte[]                   szSiteNum = new byte[MAX_COMMON_STRING_16];             // 场所编号
        public byte[]                   szDevNum = new byte[MAX_COMMON_STRING_32];              // 采集设备编号
        public byte[]                   szUserID = new byte[MAX_COMMON_STRING_32];              // 虚拟用户ID
        public byte[]                   szIDFA = new byte[MAX_COMMON_STRING_64];                // 苹果手机的IDFA
        public byte[]                   reserved = new byte[368];								// 预留
    }

    // 事件类型 EVENT_IVS_ACCESS_CTL (门禁事件)对应数据块描述信息
    public static class DEV_EVENT_ACCESS_CTL_INFO extends SdkStructure
    {
        public int                      nChannelID;                         					// 门通道号
        public byte[]                   szName = new byte[NET_EVENT_NAME_LEN];          		// 事件名称
        public byte[]                	bReserved1 = new byte[4];                       		// 字节对齐
        public double              		PTS;                                					// 时间戳(单位是毫秒)
        public NET_TIME_EX         		UTC;                                					// 事件发生的时间
        public int                 		nEventID;                           					// 事件ID
        public NET_MSG_OBJECT           stuObject;                          					// 检测到的物体
        public NET_EVENT_FILE_INFO		stuFileInfo;	                    					// 事件对应文件信息
        public int   					emEventType;                        					// 门禁事件类型, 参考 NET_ACCESS_CTL_EVENT_TYPE
        public int                      bStatus;                            					// 刷卡结果, 1表示成功, 0表示失败
        public int      				emCardType;                         					// 卡类型, 参考 NET_ACCESSCTLCARD_TYPE
        public int  					emOpenMethod;                       					// 开门方式, 参考 NET_ACCESS_DOOROPEN_METHOD
        public byte[]                   szCardNo = new byte[NET_MAX_CARDNO_LEN];       		 	// 卡号
        public byte[]                   szPwd = new byte[NET_MAX_CARDPWD_LEN];          		// 密码
        public byte[]                   szReaderID = new byte[NET_COMMON_STRING_32];    		// 门读卡器ID
        public byte[]                   szUserID = new byte[NET_COMMON_STRING_64];      		// 开门用户
        public byte[]                   szSnapURL = new byte[NET_COMMON_STRING_128];    		// 抓拍照片存储地址

        public int                      nErrorCode;                         					// 开门失败的原因,仅在bStatus为FALSE时有效
        // 0x00 没有错误
        // 0x10 未授权
        // 0x11 卡挂失或注销
        // 0x12 没有该门权限
        // 0x13 开门模式错误
        // 0x14 有效期错误
        // 0x15 防反潜模式
        // 0x16 胁迫报警未打开
        // 0x17 门常闭状态
        // 0x18 AB互锁状态
        // 0x19 巡逻卡
        // 0x1A 设备处于闯入报警状态
        // 0x20 时间段错误
        // 0x21 假期内开门时间段错误
        // 0x30 需要先验证有首卡权限的卡片
        // 0x40 卡片正确,输入密码错误
        // 0x41 卡片正确,输入密码超时
        // 0x42 卡片正确,输入指纹错误
        // 0x43 卡片正确,输入指纹超时
        // 0x44 指纹正确,输入密码错误
        // 0x45 指纹正确,输入密码超时
        // 0x50 组合开门顺序错误
        // 0x51 组合开门需要继续验证
        // 0x60 验证通过,控制台未授权

        public int                      nPunchingRecNo;                     					// 刷卡记录集中的记录编号
        public int						nNumbers;												// 抓图张数
        public byte						byImageIndex;	                    					// 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public byte[]                   byReserved = new byte[3];                      		    // 字节对齐
        public int						dwSnapFlagMask;											// 抓图标志(按位),具体见 NET_RESERVED_COMMON
        public int         				emAttendanceState;                  					// 考勤状态, 参考 NET_ATTENDANCESTATE
        public byte[]					szClassNumber = new byte[MAX_CLASS_NUMBER_LEN];			// 班级（考勤肯尼亚定制）
        public byte[]					szPhoneNumber = new byte[MAX_PHONENUMBER_LEN];			// 电话（考勤肯尼亚定制）
        public byte[]					szCardName = new byte[NET_MAX_CARDNAME_LEN];			// 卡命名
        public int                      uSimilarity;                         					// 人脸识别相似度,范围为0~100
        public DEV_ACCESS_CTL_IMAGE_INFO[]	stuImageInfo
                = (DEV_ACCESS_CTL_IMAGE_INFO[])new DEV_ACCESS_CTL_IMAGE_INFO().toArray(6);	 // 图片信息
        public int						nImageInfoCount;										// 图片信息数量
        public byte[]					szCitizenIDNo = new byte[20];							// 身份证号
        public int						nGroupID;												// 事件组ID
        public int				        nCompanionCardCount;									// 陪同者卡号个数
        public COMPANION_CARD[]			szCompanionCards
                = (COMPANION_CARD[])new COMPANION_CARD().toArray(MAX_COMPANION_CARD_NUM);    // 陪同者卡号信息

        public DEV_ACCESS_CTL_CUSTOM_WORKER_INFO    stuCustomWorkerInfo;                        // 定制人员信息
        public int					emCardState;												// 当前事件是否为采集卡片,参考EM_CARD_STATE

        public byte[]				szSN = new byte[32];										// 设备序列号
        public int				    emHatStyle;							    // 帽子类型(参考EM_HAT_STYLE)
        public int		            emHatColor;							    // 帽子颜色(参考EM_UNIFIED_COLOR_TYPE)
        public int			        emLiftCallerType;					    // 梯控方式触发者(参考EM_LIFT_CALLER_TYPE)
        public int					bManTemperature;					    // 人员温度信息是否有效
        public NET_MAN_TEMPERATURE_INFO	stuManTemperatureInfo;				// 人员温度信息, bManTemperature 为TRUE时有效
        public byte[]				szCitizenName=new byte[256];			// 身份证姓名
        public int					nCompanionInfo;						                        // 陪同人员 stuCompanionInfo 个数
        public NET_COMPANION_INFO[]	stuCompanionInfo =(NET_COMPANION_INFO[])new NET_COMPANION_INFO().toArray(12);				                        // 陪同人员信息
        public int	                emMask;								                        // 口罩状态（EM_MASK_STATE_UNKNOWN、EM_MASK_STATE_NOMASK、EM_MASK_STATE_WEAR 有效）
        public int					nFaceIndex;							                        // 一人多脸的人脸序号
        public int					bClassNumberEx;						    // szClassNumberEx 是否有效，为TRUE时，szClassNumberEx 有效
        public byte[]				szClassNumberEx = new byte[512];		// 班级（定制）
        public byte[]				szDormitoryNo = new byte[64];			// 宿舍号（定制）
        public byte[]				szStudentNo = new byte[64];				// 学号（定制）
        public int                  emUserType;							    // 用户类型( EM_USER_TYPE_ORDINARY 至 EM_USER_TYPE_DISABLED 有效 ) EM_USER_TYPE
        public int					bRealUTC;							    // RealUTC 是否有效，bRealUTC 为 TRUE 时，用 RealUTC，否则用 UTC 字段
        public NET_TIME_EX         	RealUTC;                                // 事件发生的时间（标准UTC）
        public byte[]               szQRCode = new byte[512];               // 二维码信息
        public byte[]				szCompanyName = new byte[200];			// 公司名称
        public int					nScore;							        // 人脸质量评分
        public byte[]				bReserved = new byte[752];				// 保留字节,留待扩展.
    }

    //用户类型
    public static class EM_USER_TYPE
    {
        public static final int EM_USER_TYPE_UNKNOWN = -1;							// 未知
        public static final int EM_USER_TYPE_ORDINARY = 0;								// 普通用户
        public static final int EM_USER_TYPE_BLACKLIST = 1;								// 黑名单用户
        public static final int EM_USER_TYPE_VIP = 2;									// VIP用户
        public static final int EM_USER_TYPE_GUEST = 3;									// 来宾用户
        public static final int EM_USER_TYPE_PATROL = 4;								// 巡逻用户
        public static final int EM_USER_TYPE_DISABLED = 5;								// 残疾用户
        public static final int EM_USER_TYPE_FROZEN = 6;								// 冻结用户
        public static final int EM_USER_TYPE_LOGOUT = 7;								// 注销用户
        public static final int EM_USER_TYPE_LOSSCARD = 8;								// 挂失卡
    }

    // 人员温度信息
    public static class NET_MAN_TEMPERATURE_INFO extends SdkStructure
    {
        public float						fCurrentTemperature;			// 人员体温
        public int	                        emTemperatureUnit;				// 温度单位(参考EM_HUMAN_TEMPERATURE_UNIT)
        public int						    bIsOverTemperature;				// 是否超温
        public byte[]            			byReserved=new byte[260];       // 预留字节
    };

    // 陪同人员信息
    public static class NET_COMPANION_INFO extends SdkStructure
    {
        public byte[] 				        szCompanionCard=new byte[32];					// 陪同者卡号
        public byte[] 				        szCompanionUserID=new byte[32];					// 陪同者ID
        public byte[] 				        szCompanionName=new byte[120];					// 陪同者姓名
        public byte[] 						byReserved=new byte[256];						// 预留字段
    };

    // 定制人员信息
    public static class DEV_ACCESS_CTL_CUSTOM_WORKER_INFO extends SdkStructure
    {
        public int       			emSex;                                      	// 性别, 详见NET_ACCESSCTLCARD_SEX
        public byte[]               szRole = new byte[MAX_COMMON_STRING_32];        // 角色
        public byte[]               szProjectNo = new byte[MAX_COMMON_STRING_32];   // 项目ID
        public byte[]               szProjectName = new byte[MAX_COMMON_STRING_64]; // 项目名称
        public byte[]               szBuilderName = new byte[MAX_COMMON_STRING_64]; // 施工单位全称
        public byte[]               szBuilderID = new byte[MAX_COMMON_STRING_32];   // 施工单位ID
        public byte[]               szBuilderType = new byte[MAX_COMMON_STRING_32]; // 施工单位类型
        public byte[]               szBuilderTypeID = new byte[MAX_COMMON_STRING_8];// 施工单位类别ID
        public byte[]               szPictureID = new byte[MAX_COMMON_STRING_64];   // 人员照片ID
        public byte[]               szContractID = new byte[MAX_COMMON_STRING_16];  // 原合同系统合同编号
        public byte[]               szWorkerTypeID = new byte[MAX_COMMON_STRING_8]; // 工种ID
        public byte[]               szWorkerTypeName = new byte[MAX_COMMON_STRING_32];  // 工种名称
        public int                  bPersonStatus;                              	// 人员状态, TRUE:启用, FALSE:禁用
        public byte[]				bReserved = new byte[256];					    // 保留字节,留待扩展.
    }

    //图片信息
    public static class DEV_ACCESS_CTL_IMAGE_INFO extends SdkStructure
    {
        public int emType; // 图片类型, 参考 EM_ACCESS_CTL_IMAGE_TYPE
        public int						nOffSet;												// 二进制块偏移字节
        public int						nLength;												// 图片大小
        public int						nWidth;													// 图片宽度(单位:像素)
        public int						nHeight;												// 图片高度(单位:像素)
        public byte[]					byReserved = new byte[64];								// 保留字节
    }

    //图片类型
    public static class EM_ACCESS_CTL_IMAGE_TYPE extends SdkStructure
    {
        public static final int EM_ACCESS_CTL_IMAGE_UNKNOWN = -1;								// 未知
        public static final int EM_ACCESS_CTL_IMAGE_LOCAL = 0;									// 本地人脸图库
        public static final int EM_ACCESS_CTL_IMAGE_SCENE = 1;									// 拍摄场景抠图
        public static final int EM_ACCESS_CTL_IMAGE_FACE = 2;									// 人脸抠图
    }

    public static class COMPANION_CARD extends SdkStructure
    {
        public byte[]				    szCompanionCard = new byte[NET_MAX_CARDINFO_LEN];    	// 陪同者卡号信息
    }

    // 门禁事件类型
    public static class NET_ACCESS_CTL_EVENT_TYPE extends SdkStructure
    {
        public static final int NET_ACCESS_CTL_EVENT_UNKNOWN = 0;
        public static final int NET_ACCESS_CTL_EVENT_ENTRY = 1;                          // 进门
        public static final int NET_ACCESS_CTL_EVENT_EXIT = 2;                           // 出门
    }

    // 当前门采集状态
    public static class EM_CARD_STATE extends SdkStructure
    {
        public static final int EM_CARD_STATE_UNKNOWN = -1;				// 未知
        public static final int EM_CARD_STATE_SWIPE = 0;				// 门禁刷卡
        public static final int EM_CARD_STATE_COLLECTION = 1;			// 门禁采集卡
    }

    // 获取热度统计信息, 对应命令 NET_DEVSTATE_GET_HEAT_MAP
    public static class NET_QUERY_HEAT_MAP extends SdkStructure
    {
        public int                    	dwSize;                         // 该结构体大小
        public NET_IN_QUERY_HEAT_MAP    stuIn;                          // 热度统计信息查询条件
        public NET_OUT_QUERY_HEAT_MAP   stuOut;                         // 热度统计信息查询结果

        public NET_QUERY_HEAT_MAP() {
            this.dwSize = this.size();
        }
    }

    // 获取热度统计信息入参
    public static class NET_IN_QUERY_HEAT_MAP extends SdkStructure
    {
        public int                      nChannel;                       // 通道号
        public NET_TIME_EX              stuBegin;                       // 开始时间
        public NET_TIME_EX              stuEnd;                         // 结束时间
        public int                      nPlanID;                        // 计划ID,仅球机有效,从1开始
        public int	 					emDataType;					 	// 希望获取的数据类型, 参考  EM_HEAT_PIC_DATA_TYPE
        public byte[]                   reserved = new byte[1016];      // 预留
    }

    // 获取热度统计信息出参
    public static class NET_OUT_QUERY_HEAT_MAP extends SdkStructure
    {
        public int                      nWidth;                         // 图片宽度
        public int                      nHeight;                        // 图片高度
        public Pointer                  pBufData;                       // 热度数据灰阶位图, 用户申请内存,大小为nBufLen
        // 若emDataType为EM_HEAT_PIC_DATA_TYPE_GRAYDATA,则一个字节表示一个点
        // 若emDataType为EM_HEAT_PIC_DATA_TYPE_SOURCEDATA,则四个字节表示一个点
        public int                      nBufLen;                        // pBufData最大长度
        public int                      nBufRet;                        // 实际返回的长度
        public int                      nAverage;                       // 均值信息
        public int					 	nPlanID;						// 计划ID,与请求NET_IN_QUERY_HEAT_MAP的nPlanID对应
        public int    					emDataType;						// 获取到的数据类型, 参考 EM_HEAT_PIC_DATA_TYPE
        public int					 	nPixelMax;						// 实际像素点的最大值
        public int					 	nPixelMin;						// 实际像素点的最小值
        public byte[]                   reserved = new byte[1004];      // 预留
    }


    // 热度图数据类型
    public static class EM_HEAT_PIC_DATA_TYPE extends SdkStructure
    {
        public static final int EM_HEAT_PIC_DATA_TYPE_UNKNOWN = 0;		// 未知类型
        public static final int EM_HEAT_PIC_DATA_TYPE_GRAYDATA = 1;		// 灰度数据
        public static final int EM_HEAT_PIC_DATA_TYPE_SOURCEDATA = 2;	// 原始数据
    }


    // 通道名称配置
    public static class NET_ENCODE_CHANNELTITLE_INFO extends SdkStructure
    {
        public int					dwSize;
        public byte[]				szChannelName = new byte[MAX_CHANNEL_NAME_LEN];				// 通道名称

        public NET_ENCODE_CHANNELTITLE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 视频分析全局配置
    public static class CFG_ANALYSEGLOBAL_INFO extends SdkStructure
    {
        // 信息
        public byte[]				            szSceneType = new byte[MAX_NAME_LEN];	// 应用场景,详见"支持的场景列表", 参考  EM_SCENE_TYPE 里的场景

        //交通场景信息
        public double				            CameraHeight;							// 摄像头离地高度	单位：米
        public double				            CameraDistance;						    // 摄像头离地面检测区域中心的水平距离	单位：米
        public CFG_POLYGON                      stuNearDetectPoint;                     // 近景检测点
        public CFG_POLYGON                      stuFarDectectPoint;                     // 远景检测点
        public int                              nNearDistance;                          // NearDetectPoint,转换到实际场景中时,离摄像头垂直线的水平距离
        public int                              nFarDistance;                           // FarDectectPoint,转换到实际场景中时,离摄像头垂直线的水平距离
        public byte[]                           szSubType = new byte[MAX_NAME_LEN];     // 交通场景的子类型,"Gate",卡口类型,"Junction" 路口类型,"ParkingSpace" 车位检测类型
        public int                              nLaneNum;                               // 车道数
        public CFG_LANE[]                       stuLanes = (CFG_LANE[])new CFG_LANE().toArray(MAX_LANE_NUM);                 // 车道信息
        public int                              nPlateHintNum;                          // 车牌字符暗示个数
        public PLATE_HINT[]                     szPlateHintsArr = (PLATE_HINT[])new PLATE_HINT().toArray(MAX_PLATEHINT_NUM); // 车牌字符暗示数组，在拍摄图片质量较差车牌识别不确定时，根据此数组中的字符进行匹配，数组下标越小，匹配优先级越高
        public int                              nLightGroupNum;                         // 灯组数
        public CFG_LIGHTGROUPS[]                stLightGroups = (CFG_LIGHTGROUPS[])new CFG_LIGHTGROUPS().toArray(MAX_LIGHTGROUP_NUM);      // 灯组配置信息
        public boolean                          bHangingWordPlate;                      // 是否识别挂字车牌
        public boolean                          bNonStdPolicePlate;                     // 是否识别非标准警牌
        public boolean                          bYellowPlateLetter;                     // 是否识别黄牌字母
        public int                              nReportMode;                            // 上报模式，0：未定义，1：上报所有违章车辆，2：上报车牌识别成功的违章车辆
        public int                              nPlateMatch;                            // 车牌匹配率，0~100，多次识别车牌使用,表示重复识别车牌和前一次识别车牌的一致性要求
        public int                              nJudgment;                              // 违章判定依据，0：未定义，1：按车道，2：按行驶方向，3：按车道和行驶方向
        public int                              nLeftDivisionPtCount;                   // 左转弯分界线点数
        public CFG_POLYLINE[]                   stLeftDivisionLine = (CFG_POLYLINE[])new CFG_POLYLINE().toArray(MAX_POLYLINE_NUM);   // 左转弯分界线
        public int                              nRightDivisionPtCount;                  // 右转弯分界线点数
        public CFG_POLYLINE[]                   stRightDivisionLine = (CFG_POLYLINE[])new CFG_POLYLINE().toArray(MAX_POLYLINE_NUM);  // 右转弯分界线
        public CFG_ADJUST_LIGHT_COLOR           stAdjustLightColor;                     // 交通灯颜色校正配置
        public int                              nParkingSpaceNum;                       // 车位数
        public CFG_PARKING_SPACE[]              stParkingSpaces = (CFG_PARKING_SPACE[])new CFG_PARKING_SPACE().toArray(MAX_PARKING_SPACE_NUM);  // 车位配置信息,每个元素代表一个车位


        // 一般场景信息
        public int                              nStaffNum;                              // 标尺数
        public CFG_STAFF[]                      stuStaffs = (CFG_STAFF[])new CFG_STAFF().toArray(MAX_STAFF_NUM);               // 标尺

        public int                    			nCalibrateAreaNum;                      // 标定区域数
        public CFG_CALIBRATEAREA_INFO[]         stuCalibrateArea = (CFG_CALIBRATEAREA_INFO[])new CFG_CALIBRATEAREA_INFO().toArray(MAX_CALIBRATEBOX_NUM); // 标定区域(若该字段不存在，则以整幅场景为标定区域)

        public boolean                          bFaceRecognition;                       // 人脸识别场景是否有效
        public CFG_FACERECOGNITION_SCENCE_INFO  stuFaceRecognitionScene;                // 人脸识别场景

        public byte                          	abJitter;
        public byte                          	abDejitter;
        public byte[]                           bReserved = new byte[2];                // 保留字段

        public int					            nJitter;								// 摄像机抖动率 : 摄像机抖动率，取值0-100，反应静止摄像机抖动程度，抖动越厉害，值越大。
        public boolean                          bDejitter;                              // 是否开启去抖动模块 目前不实现

        public boolean                          abCompatibleMode;
        public int                              nCompatibleMode;                        // 0:"OldTrafficRule" : 交通老规则兼容模式;1:"NewTrafficRule" :  交通新规则兼容模式;-1:字符串错误

        public int                              nCustomDataLen;                         // 实际数据长度，不能大于1024
        public byte[]                           byCustomData = new byte[1024];          // 第三方自定义配置数据
        public double				            CameraAngle;							// 摄像头与垂方向的夹角
        public CFG_POLYGON			            stuLandLineStart;						// 地平线线段起始点(点的坐标坐标归一化到[0,8192)区间。)
        public CFG_POLYGON			            stuLandLineEnd;							// 地平线线段终止点(点的坐标坐标归一化到[0,8192)区间。)

        public boolean				            bFaceDetection;							// 人脸检测场景是否有效
        public CFG_FACEDETECTION_SCENCE_INFO    stuFaceDetectionScene;		            // 人脸检测场景
        public CFG_TIME_PERIOD		            stuDayTimePeriod;						// 标定白天的时间段.(8,20),表示从8点到晚上20点为白天
        public CFG_TIME_PERIOD		            stuNightTimePeriod;						// 标定黑夜的时间段.(20,7)，表示从晚8点到凌晨7点为黑夜
        public CFG_TIME_PERIOD_SCENE_INFO       stuTimePeriodSceneInfo;                 // 多场景标定白天和黑夜时间段
        public CFG_CALIBRATEAREA_SCENE_INFO     stuCalibrateAreaSceneInfo;              // 多场景标定区域配置信息
        public int       						emSwitchMode;                           // 昼夜算法切换模式,详见 CFG_TIMEPERIOD_SWITCH_MODE

        public int					            nSceneNum;								// 场景数, >0时表示支持多场景, stuMultiScene有效
        //public CFG_ANALYSEGLOBAL_SCENE[]	    stuMultiScene = (CFG_ANALYSEGLOBAL_SCENE[])new CFG_ANALYSEGLOBAL_SCENE().toArray(MAX_ANALYSE_SCENE_NUM);	// 多场景配置

        public byte[]	    stuMultiScene=new byte[189808 * MAX_ANALYSE_SCENE_NUM];
        public int								nSceneCount;							// 实际场景个数
        public SCENE_TYPE_LIST[]				szSceneTypeListArr = (SCENE_TYPE_LIST[])new SCENE_TYPE_LIST().toArray(MAX_SCENE_TYPE_LIST_SIZE);// 场景列别，同一视频通道下启用多个场景时，表示第2个之后的方案(可选)
        public int								emDepthType;							// 画面景深, 参考 EM_DEPTH_TYPE
        public int								nPtzPresetId;							// 云台预置点编号，0~255
        public int								unLongitude;							// 经度 单位百万分之一度
        public int								unLatitude;								// 纬度 单位百万分之一度

        public int							bSceneTypeListEx;						// szSceneTypeListEx 是否有效，当为TRUE时，使用 szSceneTypeListEx；否则使用 szSceneTypeList
        public int								nSceneCountEx;							// 实际场景个数扩展，szSceneTypeListEx 的有效个数
        public byte[]							szSceneTypeListEx=new byte[32*128];				// 场景列表扩展，szSceneTypeList 扩展字段

        public CFG_ANATOMYTEMP_SCENCE_INFO		stuAnatomyTempScene;					// 人体测温场景配置
        public Pointer			pstuDetectRegionsInfo;					// 规则相关检测区域信息,CFG_DETECT_REGIONS_INFO
        public int								nMaxDetectRegions;						// 最大规则相关检测区域个数,内存由客户申请
        public int								nDetectRegionsNum;						// 规则相关检测区域信息个数
        public CFG_DETAIL_DRIVEASSISTANT_INFO  stuDriveAssistant;                      // 驾驶辅助场景配置

        @Override
        public int fieldOffset(String name) {
            // TODO Auto-generated method stub
            return super.fieldOffset(name);
        }
        public CFG_ANALYSEGLOBAL_INFO(){
            this.setAutoSynch(false);
        }
    }

    // 人体测温场景配置
    public static class CFG_ANATOMYTEMP_SCENCE_INFO extends SdkStructure
    {
        public int			                emFaceDetectType;								// 人脸检测智能类型（参考CFG_EM_FACEDETECT_TYPE）
        public CFG_FACEDETECT_VISUAL_INFO	stuVisual;										// 可见光配置，emFaceDetectType为CFG_EM_FACEDETECT_TYPE_VISUAL或CFG_EM_FACEDETECT_TYPE_TIMESECTION时有效
        public CFG_TIME_SECTION				stuTimeSection;									// 可见光时间段，emFaceDetectType为CFG_EM_FACEDETECT_TYPE_TIMESECTION时有效
        public byte[]						byReserved=new byte[1024];						// 预留字段
    };

    // 可见光配置
    public static class CFG_FACEDETECT_VISUAL_INFO extends SdkStructure
    {
        public int						nFaceAngleUp;								// 需要检测的人脸向上(向下)最大偏角,超过此角度不上报,单位度,0-90。
        public int						nFaceAngleRight;							// 需要检测的人脸向右(向左)最大偏角,超过此角度不上报,单位度,0-90。
        public int						nFaceRollRight;								// 需要检测的人脸向右（向左）歪头最大偏角,超过此角度不上报,单位度,0-90。
        public byte[]					byReserved=new byte[1024];							// 预留字段
    };

    public static class PLATE_HINT extends SdkStructure
    {
        public byte[] 							szPlateHints = new byte[MAX_NAME_LEN];    // 车牌字符暗示数组，在拍摄图片质量较差车牌识别不确定时，根据此数组中的字符进行匹配，数组下标越小，匹配优先级越高
    }

    public static class SCENE_TYPE_LIST extends SdkStructure
    {
        public byte[]							szSceneTypeList = new byte[CFG_COMMON_STRING_16]; // 场景列别，同一视频通道下启用多个场景时，表示第2个之后的方案(可选)
    }

    // 车道信息
    public static class CFG_LANE extends SdkStructure
    {
        public int                				nLaneId;                           												// 车道编号
        public int                				nDirection;                        												// 车道方向(车开往的方向),0-北 1-东北 2-东 3-东南 4-南 5-西南 6-西 7-西北
        public CFG_POLYLINE[]       			stuLeftLine = (CFG_POLYLINE[])new CFG_POLYLINE().toArray(MAX_POLYLINE_NUM);     // 左车道线，车道线的方向表示车道方向，沿车道方向左边的称为左车道线
        public int                				nLeftLineNum;                      												// 左车道线顶点数
        public CFG_POLYLINE[]       			stuRightLine = (CFG_POLYLINE[])new CFG_POLYLINE().toArray(MAX_POLYLINE_NUM);    // 右车道线，车道线的方向表示车道方向，沿车道方向右边的称为右车道线
        public int                				nRightLineNum;                     												// 右车道线顶点数
        public int                				nLeftLineType;                     												// 左车道线属性，1-表示白实线，2- 白虚线，3- 黄线
        public int               				nRightLineType;                    												// 右车道线属性，1-表示白实线，2- 白虚线，3- 黄线
        public int               				bDriveDirectionEnable;             												// 车道行驶方向使能, 1-true  0-false
        public int                				nDriveDirectionNum;                     										// 车道行驶方向数
        public DRIVE_DIRECTION[]               	szDriveDirectionArr = (DRIVE_DIRECTION[])new DRIVE_DIRECTION().toArray(MAX_LIGHT_DIRECTION);  // 车道行驶方向，"Straight" 直行，"TurnLeft" 左转，"TurnRight" 右转,"U-Turn":掉头
        public int                				nStopLineNum;                      												// 车道对应停止线顶点数
        public CFG_POLYLINE[]       			stuStopLine = (CFG_POLYLINE[])new CFG_POLYLINE().toArray(MAX_POLYLINE_NUM);     // 车道对应停止线
        public int                				nTrafficLightNumber;               												// 车道对应的红绿灯组编号

        public byte               				abDetectLine;                      												// 对应能力集
        public byte               				abPreLine;
        public byte              				abPostLine;
        public byte[]              				byReserved = new byte[1];

        public int                				nDetectLine;
        public CFG_POLYLINE[]       			stuDetectLine = (CFG_POLYLINE[])new CFG_POLYLINE().toArray(MAX_POLYLINE_NUM);   // 车道对应的检测线
        public int                				nPreLine;
        public CFG_POLYLINE[]       			stuPreLine = (CFG_POLYLINE[])new CFG_POLYLINE().toArray(MAX_POLYLINE_NUM);      // 车道对应的前置线
        public int                				nPostLine;
        public CFG_POLYLINE[]      				stuPostLine = (CFG_POLYLINE[])new CFG_POLYLINE().toArray(MAX_POLYLINE_NUM); 	// 车道对应的后置线
        public CFG_TRAFFIC_FLOWSTAT_DIR_INFO 	stuTrafficFlowDir;	  															// 车道流量信息
        public int  							emRankType;						  												// 道路等级，用于车流量统计上报交通状态, 参考 EM_LANE_RANK_TYPE
    }

    public static class DRIVE_DIRECTION extends SdkStructure
    {
        public byte[]               			szDriveDirection = new byte[MAX_NAME_LEN];  // 车道行驶方向，"Straight" 直行，"TurnLeft" 左转，"TurnRight" 右转,"U-Turn":掉头
    }

    // 折线的端点信息
    public static class CFG_POLYLINE extends SdkStructure
    {
        public int							nX; //0~8191
        public int							nY;
    }

    // 车辆流量统计车道方向信息
    public static class CFG_TRAFFIC_FLOWSTAT_DIR_INFO extends SdkStructure
    {
        public int							emDrivingDir;									//行驶方向, 参考 CFG_FLOWSTAT_DIRECTION
        public byte[]						szUpGoing = new byte[CFG_FLOWSTAT_ADDR_NAME];	//上行地点
        public byte[]						szDownGoing = new byte[CFG_FLOWSTAT_ADDR_NAME];	//下行地点
    }

    // 交通灯组配置信息
    public static class CFG_LIGHTGROUPS extends SdkStructure
    {
        public int                  		nLightGroupId;                     						// 灯组编号
        public CFG_RECT             		stuLightLocation;                  						// 灯组坐标
        public int                 		    nDirection;                        						// 灯组的方向,1- 灯组水平向,2- 灯组垂直向
        public int               			bExternalDetection;                						// 是否为外接红绿灯信号,当外接红绿灯时，以外界信号为判断依据。外界信号每次跳变时通知
        public int               			bSwingDetection;                   						// 是否支持自适应灯组摇摆检测,在风吹或者容易震动的场景下，位置会进行一定的浮动偏差。如果由算法自行检测，会增加检测时间
        public int                  		nLightNum;                         						// 灯组中交通灯的数量
        public CFG_LIGHTATTRIBUTE[] 		stuLightAtrributes = (CFG_LIGHTATTRIBUTE[])new CFG_LIGHTATTRIBUTE().toArray(MAX_LIGHT_NUM); // 灯组中各交通灯的属性

    }

    // 交通灯属性
    public static class CFG_LIGHTATTRIBUTE extends SdkStructure
    {
        public int              			bEnable;                           											// 当前交通灯是否有效，与车辆通行无关的交通需要设置无效
        public int              			nTypeNum;
        public LIGHT_TYPE[]					szLightTypeArr = (LIGHT_TYPE[])new LIGHT_TYPE().toArray(MAX_LIGHT_TYPE);    // 当前交通灯显现内容（包括:红-Red,黄-Yellow,绿-Green,倒计时-Countdown），如某交通灯可以显示红黄绿三种颜色，某交通灯只显示倒计时
        public int              			nDirectionNum;
        public DIRECTION[]       		    szDirectionArr = (DIRECTION[])new DIRECTION().toArray(MAX_LIGHT_DIRECTION); // 交通灯指示的行车方向,"Straight": 直行，"TurnLeft":左转，"TurnRight":右转，"U-Turn": 掉头
        public int              			nYellowTime;                       									    	// 黄灯亮时间
    }

    public static class LIGHT_TYPE extends SdkStructure
    {
        public byte[]		     			szLightType = new byte[MAX_NAME_LEN];      // 当前交通灯显现内容（包括:红-Red,黄-Yellow,绿-Green,倒计时-Countdown），如某交通灯可以显示红黄绿三种颜色，某交通灯只显示倒计时
    }

    public static class DIRECTION extends SdkStructure
    {
        public byte[]             		szDirection = new byte[MAX_NAME_LEN];         // 交通灯指示的行车方向,"Straight": 直行，"TurnLeft":左转，"TurnRight":右转，"U-Turn": 掉头
    }

    // 交通灯颜色校正配置
    public static class CFG_ADJUST_LIGHT_COLOR extends SdkStructure
    {
        public int                  nMode;                                  								// 红灯颜色校正模式 0:未定义 1:红绿灯才校正 2:一直校正
        public int                  bEnable;                                								// 是否允许图片红绿灯颜色校正
        public int                  nLevel;                                 								// 校正等级 范围0~100，数值越大矫正越明显
        public int                  bVideoEnable;                           								// 是否启用视频涂红功能，存在此项时，Level值使用LevelSeparate下的Level值
        public ADJUST_LEVEL_SEP[]   stLevelSep = (ADJUST_LEVEL_SEP[])new ADJUST_LEVEL_SEP().toArray(4);     // 分立等级，目前为4个
    }

    // 交通灯颜色校正配置，分立项
    public static class ADJUST_LEVEL_SEP extends SdkStructure
    {
        public int                  nType;                                  // 0：未定义，1：视频，2：图片
        public int                  nTime;                                  // 0：未定义，1：白天，2：夜晚
        public int                  nLevel;                                 // 范围0~100，数值越大矫正越明显
    }

    public static class CFG_PARKING_SPACE extends SdkStructure
    {
        public int             	    nNumber;                									 //车位编号
        public CFG_REGION      	    stArea;                										 //检测区域
        public int                  nShieldAreaNum;                              				 //有效屏蔽区个数
        public CFG_REGION[]         stShieldArea =
                (CFG_REGION[])new CFG_REGION().toArray(MAX_SHIELD_AREA_NUM); //屏蔽区域
        public byte[]            szCustomParkNo=new byte[CFG_COMMON_STRING_32];        // 自定义车位名称
        //public int             nPtzPresetId;							     // 云台预置点编号，0~255
    }

    public static class CFG_STAFF extends SdkStructure
    {
        public CFG_POLYLINE         stuStartLocation;      					// 起始坐标点
        public CFG_POLYLINE         stuEndLocation;        					// 终止坐标点
        public float                nLenth;               					// 实际长度,单位米
        public int	   		        emType;                					// 标尺类型, 参考 EM_STAFF_TYPE
    }

    // 标定区域,普通场景使用
    public static class CFG_CALIBRATEAREA_INFO extends SdkStructure
    {
        public int					nLinePoint;								// 水平方向标尺线顶点数
        public CFG_POLYGON[]		stuLine =
                (CFG_POLYGON[])new CFG_POLYGON().toArray(MAX_POLYLINE_NUM);// 水平方向标尺线
        public float				fLenth;                 				// 实际长度
        public CFG_REGION			stuArea;                  				// 区域
        public int                 	nStaffNum;                 				// 垂直标尺数
        public CFG_STAFF[]          stuStaffs =
                (CFG_STAFF[])new CFG_STAFF().toArray(MAX_STAFF_NUM); // 垂直标尺
        public int 					emType;									// 区域类型, 参考 EM_CALIBRATEAREA_TYPE
        public int				    emMethodType;							// 标定方式, 参考  EM_METHOD_TYPE
    }

    // 人脸识别场景
    public static class CFG_FACERECOGNITION_SCENCE_INFO extends SdkStructure
    {
        public double				dbCameraHeight;							// 摄像头离地高度 单位：米
        public double				dbCameraDistance;						// 摄像头离地面检测区域中心的水平距离 单位：米
        public int                  nMainDirection;                         // 人流主要方向顶点数
        public CFG_POLYGON[]        stuMainDirection =
                (CFG_POLYGON[])new CFG_POLYGON().toArray(MAX_POLYLINE_NUM); // 人流主要方向，第一个点是起始点，第二个点是终止点
        public byte                 byFaceAngleDown;                        // 需要检测的人脸向下最大偏角, 单位度，-45~45，负数表示人脸向画面上边，正数表示人脸向画面下边，0表示人脸垂直方向上正对着摄像头。
        public byte                 byFaceAngleUp;                          // 需要检测的人脸向上最大偏角,单位度，-45~45，负数表示人脸向画面上边，正数表示人脸向画面下边，0表示人脸垂直方向上正对着摄像头。
        public byte                 byFaceAngleLeft;                        // 需要检测的人脸向左最大偏角,单位度，-45~45，负数表示人脸向画面左边，正数表示人脸向画面右边，0表示人脸水平方向上正对着摄像头
        public byte                 byFaceAngleRight;                       // 需要检测的人脸向右最大偏角,单位度，-45~45，负数表示人脸向画面左边，正数表示人脸向画面右边，0表示人脸水平方向上正对着摄像头
        public int					emDetectType;							// 人脸检测类型, 参考 EM_FACEDETECTION_TYPE
    }

    // 人脸检测场景
    public static class CFG_FACEDETECTION_SCENCE_INFO extends SdkStructure
    {
        public double				dbCameraHeight;							// 摄像头离地高度 单位：米
        public double				dbCameraDistance;						// 摄像头离地面检测区域中心的水平距离 单位：米
        public int                  nMainDirection;                         // 人流主要方向顶点数
        public CFG_POLYGON[]        stuMainDirection = (CFG_POLYGON[])new CFG_POLYGON().toArray(MAX_POLYLINE_NUM);     // 人流主要方向，第一个点是起始点，第二个点是终止点
        public byte                 byFaceAngleDown;                        // 需要检测的人脸向下最大偏角, 单位度，-45~45，负数表示人脸向画面上边，正数表示人脸向画面下边，0表示人脸垂直方向上正对着摄像头。
        public byte                 byFaceAngleUp;                          // 需要检测的人脸向上最大偏角,单位度，-45~45，负数表示人脸向画面上边，正数表示人脸向画面下边，0表示人脸垂直方向上正对着摄像头。
        public byte                 byFaceAngleLeft;                        // 需要检测的人脸向左最大偏角,单位度，-45~45，负数表示人脸向画面左边，正数表示人脸向画面右边，0表示人脸水平方向上正对着摄像头
        public byte                 byFaceAngleRight;                       // 需要检测的人脸向右最大偏角,单位度，-45~45，负数表示人脸向画面左边，正数表示人脸向画面右边，0表示人脸水平方向上正对着摄像头
        public int					emDetectType;							// 人脸检测类型, 参考 EM_FACEDETECTION_TYPE
    }

    public static class CFG_TIME_PERIOD extends SdkStructure
    {
        public CFG_TIME				stuStartTime;
        public CFG_TIME				stuEndTime;
    }

    public static class CFG_TIME extends SdkStructure
    {
        public int					dwHour;									// 时
        public int					dwMinute;								// 分
        public int					dwSecond;								// 秒
    }

    // 多场景标定白天和黑夜配置
    public static class CFG_TIME_PERIOD_SCENE_INFO extends SdkStructure
    {
        public int                  dwMaxTimePeriodSceneNum;                // 多场景标定白天和黑夜配置最大个数(需要申请此大小内存)
        public int                  dwRetTimePeriodSceneNum;                // 实际包含多场景标定白天和黑夜配置个数
        public Pointer   			pstuTimePeriodScene;                    // 多场景标白天和黑夜配置域单元,由用户申请内存，大小为sizeof(CFG_TIME_PERIOD_SCENE_UNIT)*dwMaxTimePeriodSceneNum
        // 指向  CFG_TIME_PERIOD_SCENE_UNIT[]
    }

    // 多场景标定区域配置
    public static class CFG_CALIBRATEAREA_SCENE_INFO extends SdkStructure
    {
        public int                  dwMaxSceneCalibrateAreaNum;             // 多场景标定区域最大个数(需要申请此大小内存)
        public int                  dwRetSceneCalibrateAreaNum;             // 实际包含多场景标定区域个数
        public Pointer 				pstuCalibrateArea;                      // 多场景标定区域单元, 由用户申请内存, 指向 CFG_CALIBRATEAREA_SCENE_UNIT[]。
        // 大小为  sizeof(CFG_CALIBRATEAREA_SCENE_UNIT)*dwMaxSceneCalibrateAreaNum
    }

    // 昼夜算法切换模式
    public static class CFG_TIMEPERIOD_SWITCH_MODE extends SdkStructure
    {
        public static final int CFG_TIMEPERIOD_SWITCH_MODE_UNKNOWN = 0;        // 未知
        public static final int CFG_TIMEPERIOD_SWITCH_MODE_BYCOLOR = 1;        // 通过色彩切换
        public static final int CFG_TIMEPERIOD_SWITCH_MODE_BYBRIGHTNESS = 2;   // 通过亮度切换
        public static final int CFG_TIMEPERIOD_SWITCH_MODE_BYPOS = 3;		   // 通过经纬度计算日出日落时间切换
    }

    // 视频分析全局配置场景
    public static class CFG_ANALYSEGLOBAL_SCENE extends SdkStructure
    {
        public byte[]							szSceneType = new byte[MAX_NAME_LEN];	// 应用场景,详见"支持的场景列表"

        public union 			   				union = new union();
        // 以下为场景具体信息, 根据szSceneType决定哪个场景有效
        public static class union extends Union {
            public CFG_FACEDETECTION_SCENCE_INFO	stuFaceDetectionScene;				// 人脸检测场景/人脸识别检查
            public CFG_TRAFFIC_SCENE_INFO			stuTrafficScene;					// 交通场景
            public CFG_NORMAL_SCENE_INFO			stuNormalScene;						// 普通场景/远景场景/中景场景/近景场景/室内场景/人数统计场景
            public CFG_TRAFFIC_TOUR_SCENE_INFO		stuTrafficTourScene;				// 交通巡视场景
        }

        public int								emDepthType;							// 画面景深, 参考 EM_DEPTH_TYPE
        public int								nPtzPresetId;							// 云台预置点编号，0~255
        // 以下是有多个大类业务的情况
        public int								nSceneListCount;						// 实际场景个数
        public SCENE_TYPE_LIST[]				szSceneTypeListArr = (SCENE_TYPE_LIST[])new SCENE_TYPE_LIST().toArray(MAX_SCENE_TYPE_LIST_SIZE);// 场景列别，同一视频通道下启用多个场景时，表示第2个之后的方案
        // 多个大类业务时有效
        public CFG_INTELLI_UNIFORM_SCENE 		stuUniformScene; 						// 统一场景配置
        public int						    bSceneTypeListEx;						// szSceneTypeListEx 是否有效，当为TRUE时，使用szSceneTypeListEx
        public int							nSceneListCountEx;						// 实际场景个数扩展，szSceneTypeListEx 的有效个数
        public byte[]						szSceneTypeListEx=new byte[32*128];				// 场景列表扩展，szSceneTypeList 的扩展字段
        public Pointer		                pstuDetectRegionsInfo;					// 规则相关检测区域信息,CFG_DETECT_REGIONS_INFO
        public int							nMaxDetectRegions;						// 最大规则相关检测区域个数,内存由客户申请
        public int							nDetectRegionsNum;						// 规则相关检测区域信息个数
    }

    // 交通场景
    public static class CFG_TRAFFIC_SCENE_INFO extends SdkStructure
    {
        public int                		abCompatibleMode;
        public int                 		nCompatibleMode;                        	// 0:"OldTrafficRule" : 交通老规则兼容模式;1:"NewTrafficRule" :  交通新规则兼容模式;-1:字符串错误
        public float					fCameraHeight;								// 摄像头离地高度	单位：米
        public float					fCameraDistance;							// 摄像头离地面检测区域中心的水平距离	单位：米
        public byte[]                	szSubType = new byte[MAX_NAME_LEN];     	// 交通场景的子类型,"Gate" 卡口类型,"Junction" 路口类型
        // "Tunnel"隧道类型 , "ParkingSpace"车位检测类型
        // "Bridge"桥梁类型
        // "Freeway"高速公路类型
        public CFG_POLYGON         		stuNearDetectPoint;                     	// 近景检测点
        public CFG_POLYGON         		stuFarDectectPoint;                     	// 远景检测点
        public int                 		nNearDistance;                          	// NearDetectPoint,转换到实际场景中时,离摄像头垂直线的水平距离
        public int                 		nFarDistance;                           	// FarDectectPoint,转换到实际场景中时,离摄像头垂直线的水平距离
        public int                 		nPlateHintNum;                          	// 车牌字符暗示个数
        public PLATE_HINT[]         	szPlateHintsArr = (PLATE_HINT[])new PLATE_HINT().toArray(MAX_PLATEHINT_NUM); 		   // 车牌字符暗示数组，在拍摄图片质量较差车牌识别不确定时，根据此数组中的字符进行匹配，数组下标越小，匹配优先级越高
        public int                 		nLaneNum;                               	// 车道数
        public CFG_LANE[]            	stuLanes = (CFG_LANE[])new CFG_LANE().toArray(MAX_LANE_NUM);                 		   // 车道信息
        public int                 		nLightGroupNum;                         	// 灯组数
        public CFG_LIGHTGROUPS[]     	stLightGroups = (CFG_LIGHTGROUPS[])new CFG_LIGHTGROUPS().toArray(MAX_LIGHTGROUP_NUM);  // 灯组配置信息
        public int                		bHangingWordPlate;                      	// 是否识别挂字车牌
        public int                		bNonStdPolicePlate;                     	// 是否识别非标准警牌
        public int                		bYellowPlateLetter;                     	// 是否识别黄牌字母
        public int                 		nReportMode;                            	// 上报模式，0：未定义，1：上报所有违章车辆，2：上报车牌识别成功的违章车辆
        public int                 		nPlateMatch;                            	// 车牌匹配率，0~100，多次识别车牌使用,表示重复识别车牌和前一次识别车牌的一致性要求
        public int                 		nJudgment;                              	// 违章判定依据，0：未定义，1：按车道，2：按行驶方向，3：按车道和行驶方向
        public int                 		nLeftDivisionPtCount;                   	// 左转弯分界线点数
        public CFG_POLYLINE[]        	stLeftDivisionLine = (CFG_POLYLINE[])new CFG_POLYLINE().toArray(MAX_POLYLINE_NUM);     // 左转弯分界线
        public int                 		nRightDivisionPtCount;                  	// 右转弯分界线点数
        public CFG_POLYLINE[]        	stRightDivisionLine = (CFG_POLYLINE[])new CFG_POLYLINE().toArray(MAX_POLYLINE_NUM);    // 右转弯分界线
        public CFG_ADJUST_LIGHT_COLOR   stAdjustLightColor;                 		// 交通灯颜色校正配置
        public int                  	nParkingSpaceNum;                       	// 车位数
        public CFG_PARKING_SPACE[]    	stParkingSpaces = (CFG_PARKING_SPACE[])new CFG_PARKING_SPACE().toArray(MAX_PARKING_SPACE_NUM);// 车位配置信息,每个元素代表一个车位

    }

    // 普遍场景
    public static class CFG_NORMAL_SCENE_INFO extends SdkStructure
    {
        public float					fCameraHeight;							// 摄像头离地高度	单位：米
        public float					fCameraAngle;							// 摄像头与垂方向的夹角	单位度，0~90，
        public float					fCameraDistance;						// 摄像头离地面检测区域中心的水平距离	单位：米
        public CFG_POLYGON				stuLandLineStart;						// 地平线线段起始点(点的坐标坐标归一化到[0,8192)区间。)
        public CFG_POLYGON				stuLandLineEnd;							// 地平线线段终止点(点的坐标坐标归一化到[0,8192)区间。)
    }

    // 交通巡视场景
    public static class CFG_TRAFFIC_TOUR_SCENE_INFO extends SdkStructure
    {
        public int                 		nPlateHintNum;                          // 车牌字符暗示个数
        public PLATE_HINT[]             szPlateHintsArr = (PLATE_HINT[])new PLATE_HINT().toArray(MAX_PLATEHINT_NUM); // 车牌字符暗示数组，在拍摄图片质量较差车牌识别不确定时，根据此数组中的字符进行匹配，数组下标越小，匹配优先级越高
    }

    // 统一场景配置,TypeList存在时配置此场景
    public static class CFG_INTELLI_UNIFORM_SCENE extends SdkStructure
    {
        public byte[]                	szSubType = new byte[MAX_NAME_LEN];                			  // 交通场景的子类型,"Gate" 卡口类型,"Junction" 路口类型
        // "Tunnel"隧道类型 , "ParkingSpace"车位检测类型
        // "Bridge"桥梁类型
        // "Freeway"高速公路类型
        public int                 		nPlateHintNum;                          					  // 车牌字符暗示个数
        public PLATE_HINT[]             szPlateHints = (PLATE_HINT[])new PLATE_HINT[MAX_PLATEHINT_NUM]; // 车牌字符暗示数组，在拍摄图片质量较差车牌识别不确定时，根据此数组中的字符进行匹配，数组下标越小，匹配优先级越高
        public int                 		nLaneNum;                               					  // 车道数
        public CFG_LANE[]            	stuLanes = (CFG_LANE[])new CFG_LANE().toArray(MAX_LANE_NUM);  // 车道信息
    }

    // CLIENT_MatrixAddCamerasByDevice 接口输入参数
    public static class NET_IN_ADD_LOGIC_BYDEVICE_CAMERA extends SdkStructure
    {
        public int                   	dwSize;
        public byte[]                   pszDeviceID = new byte[NET_DEV_ID_LEN]; 	// 设备ID
        public NET_REMOTE_DEVICE        stuRemoteDevice;            				// 远程设备信息
        public int                      nCameraCount;               				// 视频源信息数量
        public Pointer 					pCameras;      								// 视频源信息数组,用户分配内存,大小为sizeof(NET_LOGIC_BYDEVICE_ADD_CAMERA_PARAM)*nCameraCount
        // 对应 NET_LOGIC_BYDEVICE_ADD_CAMERA_PARAM[]

        public NET_IN_ADD_LOGIC_BYDEVICE_CAMERA() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_MatrixAddCamerasByDevice 接口输出参数
    public static class NET_OUT_ADD_LOGIC_BYDEVICE_CAMERA extends SdkStructure
    {
        public int                   	dwSize;
        public byte[]                   szDeviceID = new byte[NET_DEV_ID_LEN];     // 设备ID
        public int                      nMaxResultCount;              			   // 结果数组大小, 用户填写
        public int                      nRetResultCount;              			   // 实际结果数量
        public Pointer 					pResults;        						   // 添加视频源结果数组,用户分配内存,大小为sizeof(NET_LOGIC_BYDEVICE_ADD_CAMERA_RESULT)*nMaxResultCount
        // 对应  NET_LOGIC_BYDEVICE_ADD_CAMERA_RESULT[]

        public NET_OUT_ADD_LOGIC_BYDEVICE_CAMERA() {
            this.dwSize = this.size();
        }
    }

    // 视频源信息
    public static class NET_LOGIC_BYDEVICE_ADD_CAMERA_PARAM extends SdkStructure
    {
        public int                   	dwSize;
        public int                      nUniqueChannel;             			  // 统一编号
        public int                      nChannel;                   			  // 通道号

        public NET_LOGIC_BYDEVICE_ADD_CAMERA_PARAM() {
            this.dwSize = this.size();
        }
    }

    // 添加视频源结果信息
    public static class NET_LOGIC_BYDEVICE_ADD_CAMERA_RESULT extends SdkStructure
    {
        public int                   	dwSize;
        public int                      nUniqueChannel;             		      // 统一编号
        public int                      nFailedCode;               			      // 失败码, 0-成功,1-通道不支持设置

        public NET_LOGIC_BYDEVICE_ADD_CAMERA_RESULT() {
            this.dwSize = this.size();
        }
    }

    // 事件类型 EVENT_IVS_FACEDETECT (人脸检测事件)对应的规则配置
    public static class CFG_FACEDETECT_INFO extends SdkStructure
    {
        public byte[]							szRuleName = new byte[MAX_NAME_LEN];								// 规则名称,不同规则不能重名
        public byte								bRuleEnable;														// 规则使能, 1-true  0-false
        public byte[]                			bReserved = new byte[3];                                            // 保留字段
        public int								nObjectTypeNum;														// 相应物体类型个数
        public byte[]				            szObjectTypes = new byte[MAX_OBJECT_LIST_SIZE*MAX_NAME_LEN];			    // 相应物体类型列表
        public int								nDetectRegionPoint;													// 检测区顶点数
        public CFG_POLYGON[]					stuDetectRegion = (CFG_POLYGON[])new CFG_POLYGON().toArray(MAX_POLYGON_NUM);						    // 检测区
        public int                 				nHumanFaceTypeCount;                                    			// 触发事件的人脸类型个数
        public byte[]     		                szHumanFaceType = new byte[MAX_HUMANFACE_LIST_SIZE*MAX_NAME_LEN];   // 触发事件的人脸类型
        public CFG_ALARM_MSG_HANDLE 			stuEventHandler;													// 报警联动
        public CFG_TIME_SECTION[]	            stuTimeSection =
                (CFG_TIME_SECTION[])new CFG_TIME_SECTION().toArray(WEEK_DAY_NUM*MAX_REC_TSECT_EX);	// 事件响应时间段
        public int                 				nPtzPresetId;														// 云台预置点编号	0~65535
        public int                 				nMinDuration;                                           			// 最短触发时间,单位：秒
        public int                 				nSensitivity;                                           			// 灵敏度,范围[1,10],灵敏度越高越容易检测
        public int                 				nReportInterval;                                        			// 重复报警间隔,单位:秒,[0,600](等于0表示不重复报警)
        public int               		 		bSizeFileter;                                           			// 规则特定的尺寸过滤器是否有效
        public CFG_SIZEFILTER_INFO 				stuSizeFileter;                                         			// 规则特定的尺寸过滤器, 1-true  0-false
        public int								bFeatureEnable;														// 是否开启人脸属性识别, IPC增加, 1-true 0-false
        // (通过FaceDetection能力中的FeatureSupport来确定该配置是否可以设置)
        public int								nFaceFeatureNum;													// 需要检测的人脸属性个数
        public int[]  							emFaceFeatureType = new int[MAX_FEATURE_LIST_SIZE];				 	// 需检测的人脸属性, 通过FaceDetection能力来获取支持哪些人脸属性, 参考  EM_FACEFEATURE_TYPE
    }

    public static class MAX_OBJECT_LIST extends SdkStructure
    {
        public byte[]				 			szObjectTypes = new byte[MAX_NAME_LEN];   	// 相应物体类型列表
    }

    public static class MAX_HUMANFACE_LIST extends SdkStructure
    {
        public byte[]                			szHumanFaceType = new byte[MAX_NAME_LEN];  // 触发事件的人脸类型
    }

    public static class TIME_SECTION_WEEK_DAY_10 extends SdkStructure
    {
        public CFG_TIME_SECTION[]	 			stuTimeSection = (CFG_TIME_SECTION[])new CFG_TIME_SECTION().toArray(MAX_REC_TSECT_EX);	 // 事件响应时间段
    }

    public static class TIME_SECTION_WEEK_DAY_6 extends SdkStructure
    {
        public CFG_TIME_SECTION[]	 			stuTimeSection = (CFG_TIME_SECTION[])new CFG_TIME_SECTION().toArray(MAX_REC_TSECT);	     // 事件响应时间段, 每天最多6个时间段
    }

    public static class TIME_SECTION_WEEK_DAY_4 extends SdkStructure
    {
        public CFG_TIME_SECTION[]	 			stuTimeSection = (CFG_TIME_SECTION[])new CFG_TIME_SECTION().toArray(MAX_DOOR_TIME_SECTION);	 // 事件响应时间段, 每天最多4个时间段
    }

    public static class TIME_SECTION_WEEK_DAY_2 extends SdkStructure
    {
        public CFG_TIME_SECTION[]	 			stuTimeSection = (CFG_TIME_SECTION[])new CFG_TIME_SECTION().toArray(MAX_NAS_TIME_SECTION);	 // 事件响应时间段, 每天最多4个时间段
    }

    // 设备ID
    public static class DEVICE_ID extends SdkStructure
    {
        public byte[]	szDeviceID = new byte[NET_DEV_ID_LEN_EX]; 	// 设备ID
    }

    // 设备通知类型
    public static class EM_DEVICE_NOTIFY_TYPE extends SdkStructure
    {
        public static final int EM_DEVICE_NOTIFY_TYPE_UNKNOWN = 0;			// 未知
        public static final int EM_DEVICE_NOTIFY_TYPE_NEW = 1;			    // 新设备添加
        public static final int EM_DEVICE_NOTIFY_TYPE_UPDATE = 2;			// 设备信息更新
        public static final int EM_DEVICE_NOTIFY_TYPE_REMOVE = 3;			// 设备删除
        public static final int EM_DEVICE_NOTIFY_TYPE_CONNECT = 4;			// 设备有通道上下线
    }

    // 向设备注册的回调返回信息
    public static class NET_CB_ATTACH_DEVICE_STATE extends SdkStructure
    {
        public int   		    emNotifyType;    	                // 通知类型, 详见 EM_DEVICE_NOTIFY_TYPE
        public int 				nRetCount;				            // 设备个数
        public DEVICE_ID[]		szDeviceIDsArr = (DEVICE_ID[])new DEVICE_ID().toArray(MAX_LINK_DEVICE_NUM); // 设备列表
        public byte[] 			byReserved = new byte[512];         // 保留字节
    }

    // CLIENT_AttachDeviceState 注册设备状态回调入参结构
    public static class NET_IN_ATTACH_DEVICE_STATE extends SdkStructure
    {
        public int                           	dwSize;
        public Callback         			cbDeviceState; 		//回调函数
        public Pointer                          dwUser;             //用户数据

        public NET_IN_ATTACH_DEVICE_STATE() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_AttachDeviceState 注册设备状态回调出参结构
    public static class NET_OUT_ATTACH_DEVICE_STATE extends SdkStructure
    {
        public int           dwSize;

        public NET_OUT_ATTACH_DEVICE_STATE() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_AsyncAddDevice 添加设备入参结构
    public static class NET_IN_ASYNC_ADD_DEVICE extends SdkStructure
    {
        public int                           dwSize;
        public int							 nCount;																	// URL个数
        public DEVICE_URL[]		 			 szUrlsArr = (DEVICE_URL[])new DEVICE_URL().toArray(MAX_ADD_DEVICE_NUM);	// URL组

        public NET_IN_ASYNC_ADD_DEVICE() {
            this.dwSize = this.size();
        }
    }

    // 设备URL
    public static class DEVICE_URL extends SdkStructure {
        public byte[] szUrl = new byte[MAX_COMMON_STRING_512];    // URL
    }

    // CLIENT_AsyncAddDevice 添加设备出参结构
    public static class NET_OUT_ASYNC_ADD_DEVICE extends SdkStructure
    {
        public int           				dwSize;
        public int							nTaskID;		//任务ID

        public NET_OUT_ASYNC_ADD_DEVICE() {
            this.dwSize = this.size();
        }
    }

    // 设备的添加状态
    public static class EM_DEVICE_ADD_STATE extends SdkStructure
    {
        public static final int EM_DEVICE_ADD_STATE_UNKNOWN = 0;			// 未知
        public static final int EM_DEVICE_ADD_STATE_WAIT = 1;			    // 等待添加
        public static final int EM_DEVICE_ADD_STATE_CONNECT = 2;			// 连接中
        public static final int EM_DEVICE_ADD_STATE_FAILURE = 3;			// 添加失败
        public static final int EM_DEVICE_ADD_STATE_SUCCESS = 4;			// 添加成功
        public static final int EM_DEVICE_ADD_STATE_STOP = 5;				// 停止添加
    }

    // 注册添加设备的回调返回信息
    public static class NET_CB_ATTACH_ADD_DEVICE extends SdkStructure
    {
        public int                	nTaskID;       						// 任务ID
        public int					emAddState;							// 添加设备结果
        public int					nIndex;								// 任务中设备序号
        public byte[] 				byReserved = new byte[512];         // 保留字节
    }

    // CLIENT_AttachAddDevice 注册添加设备回调入参结构
    public static class NET_IN_ATTACH_ADD_DEVICE extends SdkStructure
    {
        public int                           	dwSize;
        public Callback         			cbAddDevice; 		//回调函数
        public Pointer                          dwUser;             //用户数据

        public NET_IN_ATTACH_ADD_DEVICE() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_AttachAddDevice 注册添加设备回调出参结构
    public static class NET_OUT_ATTACH_ADD_DEVICE extends SdkStructure
    {
        public int               	dwSize;

        public NET_OUT_ATTACH_ADD_DEVICE() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_GetAddDeviceInfo 获取添加中的设备状态入参结构
    public static class NET_IN_GET_ADD_DEVICE_LIST_INFO extends SdkStructure
    {
        public int               	dwSize;
        public int					nTaskID;										// 任务ID
        public int					nCount;											// 设备个数
        public int[]              	nIndex = new int[MAX_ADD_DEVICE_NUM];       	// 设备序号列表(NET_IN_ADD_DEVICE中szUrls的序号，从0开始)

        public NET_IN_GET_ADD_DEVICE_LIST_INFO() {
            this.dwSize = this.size();
        }
    }

    // 添加中设备的结果信息
    public static class NET_GET_ADD_DEVICE_INFO extends SdkStructure
    {
        public byte[]                	szDeviceID = new byte[NET_DEV_ID_LEN_EX];       // 设备ID
        public byte[]                	szUrl = new byte[NET_COMMON_STRING_512];        // url
        public int						emAddState;										// 当前添加状态，详见 EM_DEVICE_ADD_STATE
        public int						nErrorCode;										// 错误码
        public byte[] 					byReserved = new byte[512];                     // 保留字节
    }

    // CLIENT_GetAddDeviceInfo 获取添加中的设备状态出参结构
    public static class NET_OUT_GET_ADD_DEVICE_LIST_INFO extends SdkStructure
    {
        public int               			dwSize;
        public int							nRetCount;															// 设备个数
        public NET_GET_ADD_DEVICE_INFO[]  	stuDeviceInfo =
                (NET_GET_ADD_DEVICE_INFO[])new NET_GET_ADD_DEVICE_INFO().toArray(MAX_ADD_DEVICE_NUM);  	// 设备信息列表

        public NET_OUT_GET_ADD_DEVICE_LIST_INFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_GetDeviceInfo 获取已添加的设备状态入参结构
    public static class NET_IN_GET_DEVICE_LIST_INFO extends SdkStructure
    {
        public int               	dwSize;
        public int					nCount;															// 设备个数
        public DEVICE_ID[]			szDeviceIDsArr = (DEVICE_ID[])new DEVICE_ID().toArray(MAX_LINK_DEVICE_NUM); // 设备列表

        public NET_IN_GET_DEVICE_LIST_INFO() {
            this.dwSize = this.size();
        }
    }

    // 已添加设备的结果信息
    public static class NET_GET_DEVICE_INFO extends SdkStructure
    {
        public byte[]                szDeviceID = new byte[NET_DEV_ID_LEN_EX];           						// 设备ID
        public byte[]                szUrl = new byte[NET_COMMON_STRING_512];           						// url
        public byte[]                szSerialNo = new byte[NET_COMMON_STRING_32];           					// 设备序列号
        public byte[]                szDeviceType = new byte[NET_COMMON_STRING_64];      						// 设备类型
        public byte[]                szDeviceClass = new byte[NET_DEV_CLASS_LEN];        						// 设备大类
        public int					 nMacCount;																	// 设备mac个数
        public DEVICE_MAC[]	 		 szMacsArr = (DEVICE_MAC[])new DEVICE_MAC().toArray(MAX_MACADDR_NUM);		// 设备mac地址组
        public byte[]                szDevSoftVersion = new byte[NET_COMMON_STRING_128];       					// 设备软件版本号
        public byte[]                szDeviceName = new byte[NET_DEV_NAME_LEN];          						// 设备名称
        public byte[]                szDetail = new byte[NET_COMMON_STRING_512];          						// 设备详细信息
        public int                	 nVideoInputCh;                          									// 视频输入通道数
        public int               	 nVideoOutputCh;                         									// 视频输出通道数
        public int               	 nAudioInputCh;                          									// 音频输入通道数
        public int               	 nAudioOutputCh;                         									// 音频输出通道数
        public int               	 nAlarmInputCh;                          									// 报警输入通道数
        public int                	 nAlarmOutputCh;                         									// 报警输出通道数
        public int					 nErrorCode;																// 设备离线错误码
        public int					 nVtoDoors;																	// 门禁设备可控制的门的总数
        public byte					 byOnline;																	// 设备是否在线 0:离线 1：在线
        public byte[] 				 byReserved = new byte[511];                    							// 保留字节
    }

    // 设备mac地址
    public static class DEVICE_MAC extends SdkStructure {
        public byte[] szMac = new byte[NET_MACADDR_LEN];    // 设备mac地址
    }

    // CLIENT_GetDeviceInfo 获取已添加的设备状态出参结构
    public static class NET_OUT_GET_DEVICE_LIST_INFO extends SdkStructure
    {
        public int               		dwSize;
        public int						nMaxCount;			// 用户申请的设备个数
        public int						nRetCount;			// 实际返回的设备个数
        public Pointer  				pstuDeviceInfo; 	// 设备信息列表 用户分配内存,大小为sizeof(NET_GET_DEVICE_INFO)*nMaxCount, 对应 NET_GET_DEVICE_INFO[]

        public NET_OUT_GET_DEVICE_LIST_INFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_SetConnectChannel 设置连接通道入参结构
    public static class NET_IN_SET_CONNECT_CHANNEL extends SdkStructure
    {
        public int               	dwSize;
        public byte[]               szDeviceID = new byte[NET_DEV_ID_LEN_EX];    	// 设备ID
        public int					nCount;											// 通道个数
        public int[]            	nChannels = new int[MAX_DEVICE_CHANNEL_NUM];    // 通道列表

        public NET_IN_SET_CONNECT_CHANNEL() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_SetConnectChannel 设置连接通道出参结构
    public static class NET_OUT_SET_CONNECT_CHANNEL extends SdkStructure
    {
        public int					dwSize;

        public NET_OUT_SET_CONNECT_CHANNEL() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_GetChannelInfo 获取设备通道信息入参结构
    public static class NET_IN_GET_CHANNEL_INFO extends SdkStructure
    {
        public int					dwSize;
        public byte[]		        szDeviceID = new byte[NET_DEV_ID_LEN_EX]; // 设备ID

        public NET_IN_GET_CHANNEL_INFO() {
            this.dwSize = this.size();
        }
    }

    // 获取设备通道信息结果信息
    public static class NET_GET_CHANNEL_INFO extends SdkStructure
    {
        public int                	nRemoteChannel;           								// 远程通道号
        public int                 	nLogicChannel;           								// 分配的逻辑通道
        public byte[]       		szName = new byte[NET_DEV_NAME_LEN];      				// 通道名称
        public byte[]       		szDetail = new byte[NET_COMMON_STRING_512];     		// 设备详细信息
        public byte[]               szDeviceType = new byte[NET_COMMON_STRING_64];      	// 设备类型
        public byte[]               szDeviceClass = new byte[NET_DEV_CLASS_LEN];        	// 设备大类
        public byte[]               szIP = new byte[NET_MAX_IPADDR_LEN];          			// ip地址
        public byte[]               szMac = new byte[NET_MACADDR_LEN];     					// 设备mac地址
        public byte[]               szSerialNo = new byte[NET_DEV_SERIALNO_LEN];           	// 设备序列号
        public byte[]               szDevSoftVersion = new byte[NET_COMMON_STRING_128];     // 设备软件版本号
        public int                	nVideoInputCh;                          				// 视频输入通道数
        public int               	nVideoOutputCh;                         				// 视频输出通道数
        public int               	nAudioInputCh;                          				// 音频输入通道数
        public int               	nAudioOutputCh;                         				// 音频输出通道数
        public int               	nAlarmInputCh;                          				// 报警输入通道数
        public int                	nAlarmOutputCh;                         				// 报警输出通道数
        public byte					byOnline;												// 通道是否在线0:离线 1：在线
        public byte					byUsed;													// 该通道是否被本地设备使用 0：未使用 1：使用
        public byte[] 				byReserved = new byte[510];                    			// 保留字节
    }

    // CLIENT_GetChannelInfo 获取设备通道信息出参结构
    public static class NET_OUT_GET_CHANNEL_INFO extends SdkStructure
    {
        public int						dwSize;
        public int						nMaxCount;			// 用户申请的通道个数
        public int						nRetCount;			// 实际返回的通道个数
        public Pointer					pstuChannelInfo;	// 通道信息列表 用户分配内存,大小为sizeof(NET_GET_CHANNEL_INFO)*nMaxCount, 对应 NET_GET_CHANNEL_INFO[]

        public NET_OUT_GET_CHANNEL_INFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_RemoveDevice 删除设备入参结构
    public static class NET_IN_REMOVE_DEVICE extends SdkStructure
    {
        public int					dwSize;
        public int					nCount;				// 设备个数
        public DEVICE_ID[]			szDeviceIDsArr = (DEVICE_ID[])new DEVICE_ID().toArray(MAX_LINK_DEVICE_NUM); // 设备列表

        public NET_IN_REMOVE_DEVICE() {
            this.dwSize = this.size();
        }
    }
    // CLIENT_RemoveDevice 删除设备出参结构
    public static class NET_OUT_REMOVE_DEVICE extends SdkStructure
    {
        public int	dwSize;

        public NET_OUT_REMOVE_DEVICE() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_CancelAddDeviceTask 接口输入参数
    public static class NET_IN_CANCEL_ADD_TASK extends SdkStructure
    {
        public int                          dwSize;
        public int 							nTaskID;		 // 任务ID

        public NET_IN_CANCEL_ADD_TASK() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_CancelAddDeviceTask 接口输出参数
    public static class NET_OUT_CANCEL_ADD_TASK extends SdkStructure
    {
        public int                          dwSize;

        public NET_OUT_CANCEL_ADD_TASK() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_ConfirmAddDeviceTask 接口输入参数
    public static class NET_IN_CONFIRM_ADD_TASK extends SdkStructure
    {
        public int                          dwSize;
        public int 							nTaskID;		 // 任务ID

        public NET_IN_CONFIRM_ADD_TASK() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_ConfirmAddDeviceTask 接口输出参数
    public static class NET_OUT_CONFIRM_ADD_TASK extends SdkStructure
    {
        public int                          dwSize;

        public NET_OUT_CONFIRM_ADD_TASK() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_SCADAAlarmAttachInfo()接口输入参数
    public static class NET_IN_SCADA_ALARM_ATTACH_INFO extends SdkStructure
    {
        public int                           	dwSize;
        public Callback    				cbCallBack;                 // 数据回调函数,对应回调 fSCADAAlarmAttachInfoCallBack
        public Pointer                          dwUser;	                    // 用户定义参数

        public NET_IN_SCADA_ALARM_ATTACH_INFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_SCADAAlarmAttachInfo()接口输出参数
    public static class NET_OUT_SCADA_ALARM_ATTACH_INFO extends SdkStructure
    {
        public int                       		dwSize;

        public NET_OUT_SCADA_ALARM_ATTACH_INFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_SyncParkingInfo 接口输入参数
    public static class NET_IN_SYNC_PARKING_INFO extends SdkStructure
    {
        public int                      dwSize;
        public int						nChannel;								// 通道号
        public byte[]					szParkingNum = new byte[32];			// 车位编号
        public int						dwPresetNum;							// 预置点编号
        public int						bHaveCar;								// 车位是否有车
        public int						bParkingFault;							// 车位是否有故障
        public int						nSnapTimes;								// 补拍次数（取值范围：0-5）
        public int						nSnapIntervel;							// 补拍间隔（取值范围：3-10）

        public NET_IN_SYNC_PARKING_INFO() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_SyncParkingInfo 接口输出参数
    public static class NET_OUT_SYNC_PARKING_INFO extends SdkStructure
    {
        public int                       		dwSize;

        public NET_OUT_SYNC_PARKING_INFO() {
            this.dwSize = this.size();
        }
    }

    // 监测点位报警信息列表
    public static class NET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST extends SdkStructure
    {
        public int                               	dwSize;
        public int	                                nList;                                          // 监测点位报警信息个数
        public NET_SCADA_NOTIFY_POINT_ALARM_INFO[]  stuList = (NET_SCADA_NOTIFY_POINT_ALARM_INFO[])new NET_SCADA_NOTIFY_POINT_ALARM_INFO().toArray(MAX_SCADA_POINT_LIST_ALARM_INFO_NUM);   // 监测点位报警信息

        public NET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST() {
            this.dwSize = this.size();
        }
    }

    // 监测点位报警信息
    public static class NET_SCADA_NOTIFY_POINT_ALARM_INFO extends SdkStructure
    {
        public int           		dwSize;
        public byte[]            	szDevID = new byte[NET_COMMON_STRING_16];               // 设备ID
        public byte[]            	szPointID = new byte[NET_COMMON_STRING_128];            // 点位ID
        public int            		bAlarmFlag;                                 			// 报警标志, 1-true  0-false
        public NET_TIME        		stuAlarmTime;                               			// 报警时间
        public int	           		nAlarmLevel;                                			// 报警级别（0~6）
        public int             		nSerialNo;                                  			// 报警编号,同一个告警的开始和结束的编号是相同的。
        public byte[]           	szAlarmDesc = new byte[NET_COMMON_STRING_128];          // 报警描述

        public NET_SCADA_NOTIFY_POINT_ALARM_INFO() {
            this.dwSize = this.size();
        }
    }

    // 指纹采集(对应 CTRLTYPE_CTRL_CAPTURE_FINGER_PRINT 命令)
    public static class NET_CTRL_CAPTURE_FINGER_PRINT extends SdkStructure
    {
        public int           		dwSize;
        public int            		nChannelID;                             				// 门禁序号(从开始)
        public byte[]            	szReaderID = new byte[NET_COMMON_STRING_32];        	// 读卡器ID

        public NET_CTRL_CAPTURE_FINGER_PRINT() {
            this.dwSize = this.size();
        }
    }

    // 门禁状态事件
    public static class ALARM_ACCESS_CTL_STATUS_INFO extends SdkStructure
    {
        public int                  dwSize;
        public int                  nDoor;                  		 // 门通道号
        public NET_TIME             stuTime;               			 // 事件发生的时间
        public int  				emStatus;              			 // 门禁状态, 对应   NET_ACCESS_CTL_STATUS_TYPE
        public byte[]               szSerialNumber = new byte[256];  //无线设备序列号(智能锁)
        public boolean				bRealUTC;				// RealUTC 是否有效，bRealUTC 为 TRUE 时，用 RealUTC，否则用
        // stuTime 字段
        public NET_TIME_EX         	RealUTC;                // 事件发生的时间（标准UTC）
        public ALARM_ACCESS_CTL_STATUS_INFO() {
            this.dwSize = this.size();
        }
    }

    //事件类型 EVENT_IVS_SNAPMANUAL(SnapManual事件)对应数据块描述信息
    public static class DEV_EVENT_SNAPMANUAL extends SdkStructure
    {
        public int                 	 nChannelID;                                   		// 通道号
        public byte[]                szName = new byte[NET_EVENT_NAME_LEN];             // 事件名称
        public byte[]                bReserved1 = new byte[4];                          // 字节对齐
        public double              	 PTS;                                          		// 时间戳(单位是毫秒)
        public NET_TIME_EX         	 UTC;                                          		// 事件发生的时间
        public int                 	 nEventID;                                     		// 事件ID

        public NET_EVENT_FILE_INFO	 stuFileInfo;								  		// 事件对应文件信息
        public byte				     byImageIndex;								  		// 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int				     dwSnapFlagMask;								  	// 抓图标志(按位),具体见 NET_RESERVED_COMMON
        public byte[]				 bReserved = new byte[1024];						// 保留字节,留待扩展.
    }

    // 即时抓图(又名手动抓图)入参, 对应命令 CTRLTYPE_CTRL_SNAP_MNG_SNAP_SHOT
    public static class NET_IN_SNAP_MNG_SHOT extends SdkStructure
    {
        public int                    dwSize;                 // 该结构体大小
        public int                    nChannel;               // 通道号
        public int                    nTime;                  // 连拍次数, 0表示停止抓拍,正数表示连续抓拍的张数

        public NET_IN_SNAP_MNG_SHOT() {
            this.dwSize = this.size();
        }
    }

    // 即时抓图(又名手动抓图)出参, 对应命令 CTRLTYPE_CTRL_SNAP_MNG_SNAP_SHOT
    public static class NET_OUT_SNAP_MNG_SHOT extends SdkStructure
    {
        public int                    dwSize;                 // 该结构体大小

        public NET_OUT_SNAP_MNG_SHOT() {
            this.dwSize = this.size();
        }
    }

    // 获取摄像机状态, CLIENT_QueryDevInfo 接口 NET_QUERY_GET_CAMERA_STATE 命令入参
    public static class NET_IN_GET_CAMERA_STATEINFO extends SdkStructure
    {
        public int               	dwSize;
        public int               	bGetAllFlag;                                		 // 是否查询所有摄像机状态,若该成员为 TRUE,则 nChannels 成员无需设置, 1-true; 0-false
        public int                  nValidNum;                                 			 // 该成员,bGetAllFlag 为 FALSE时有效,表示 nChannels 成员有效个数
        public int[]                nChannels = new int[NET_MAX_CAMERA_CHANNEL_NUM];     // 该成员,bGetAllFlag 为 FALSE时有效,将需要查询的通道号依次填入

        public NET_IN_GET_CAMERA_STATEINFO() {
            this.dwSize = this.size();
        }
    }

    // 获取摄像机状态, CLIENT_QueryDevInfo 接口 NET_QUERY_GET_CAMERA_STATE 命令出参
    public static class NET_OUT_GET_CAMERA_STATEINFO extends SdkStructure
    {
        public int                  dwSize;
        public int                  nValidNum;              	// 查询到的摄像机通道状态有效个数,由sdk返回
        public int                  nMaxNum;                	// pCameraStateInfo 数组最大个数,由用户填写
        public Pointer      		pCameraStateInfo;           // 摄像机通道信息数组,由用户分配, 对应  NET_CAMERA_STATE_INFO[]

        public NET_OUT_GET_CAMERA_STATEINFO() {
            this.dwSize = this.size();
        }
    }

    public static class NET_CAMERA_STATE_INFO extends SdkStructure
    {
        public int                  nChannel;           			// 摄像机通道号, -1表示通道号无效
        public int 				    emConnectionState;  			// 连接状态, 参考  EM_CAMERA_STATE_TYPE
        public byte[]               szReserved = new byte[1024];    // 保留字节
    }

    public static class EM_CAMERA_STATE_TYPE extends SdkStructure
    {
        public static final int EM_CAMERA_STATE_TYPE_UNKNOWN = 0;       // 未知
        public static final int EM_CAMERA_STATE_TYPE_CONNECTING = 1;    // 正在连接
        public static final int EM_CAMERA_STATE_TYPE_CONNECTED = 2;     // 已连接
        public static final int EM_CAMERA_STATE_TYPE_UNCONNECT = 3;     // 未连接
        public static final int EM_CAMERA_STATE_TYPE_EMPTY = 4;         // 通道未配置,无信息
        public static final int EM_CAMERA_STATE_TYPE_DISABLE = 5;       // 通道有配置,但被禁用
    }

    // CLIENT_StartFindFaceInfo 输入参数
    public static class NET_IN_FACEINFO_START_FIND extends SdkStructure
    {
        public int 				dwSize;
        public byte[]			szUserID = new byte[NET_MAX_USERID_LEN];	// 用户ID

        public NET_IN_FACEINFO_START_FIND() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_StartFindFaceInfo 输出参数
    public static class NET_OUT_FACEINFO_START_FIND extends SdkStructure
    {
        public int 				dwSize;
        public int              nTotalCount;                   // 符合查询条件的总数

        public NET_OUT_FACEINFO_START_FIND() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_DoFindFaceInfo 输入参数
    public static class NET_IN_FACEINFO_DO_FIND extends SdkStructure
    {
        public int 			   dwSize;
        public int             nStartNo;                       // 起始序号
        public int             nCount;                         // 本次查询的条数

        public NET_IN_FACEINFO_DO_FIND() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_DoFindFaceInfo 输出参数
    public static class NET_OUT_FACEINFO_DO_FIND extends SdkStructure
    {
        public int 				dwSize;
        public int              nRetNum;                        // 本次查询到的个数
        public Pointer   		pstuInfo;                       // 查询结果, 用户分配内存,大小为sizeof(NET_FACEINFO)*nMaxNum, 对应 NET_FACEINFO[]
        public int	            nMaxNum;                        // 用户分配内存的个数
        public byte[]           byReserved = new byte[4];

        public NET_OUT_FACEINFO_DO_FIND() {
            this.dwSize = this.size();
        }
    }

    // 人脸信息
    public static class NET_FACEINFO extends SdkStructure
    {
        public byte[]			szUserID = new byte[NET_MAX_USERID_LEN];	// 用户ID
        public int              nMD5;                           			// 有效的MD5编码数量
        public MD5[]            szMD5Arr = (MD5[])new MD5().toArray(5);  	// 图片对应的32字节MD5编码加密
        public byte[]           byReserved = new byte[512];
    }

    // 图片对应的32字节MD5编码加密
    public static class MD5 extends SdkStructure
    {
        public byte[]   		szMD5 = new byte[NET_COMMON_STRING_64];
    }

    // 初始化设备账户输入结构体
    public static class NET_IN_INIT_DEVICE_ACCOUNT extends SdkStructure
    {
        public int				dwSize;													// 结构体大小:初始化结构体时赋值
        public byte[]			szMac = new byte[NET_MACADDR_LEN];						// 设备mac地址
        public byte[]			szUserName = new byte[MAX_USER_NAME_LEN];				// 用户名
        public byte[]			szPwd = new byte[MAX_PWD_LEN];							// 设备密码
        public byte[]			szCellPhone = new byte[MAX_CELL_PHONE_NUMBER_LEN];		// 预留手机号
        public byte[]			szMail = new byte[MAX_MAIL_LEN];						// 预留邮箱
        public byte				byInitStatus;										    // 此字段已经废弃
        public byte				byPwdResetWay;											// 设备支持的密码重置方式：搜索设备接口(CLIENT_SearchDevices、CLIENT_StartSearchDevices的回调函数、CLIENT_SearchDevicesByIPs)返回字段byPwdResetWay的值
        // 该值的具体含义见 DEVICE_NET_INFO_EX 结构体，需要与设备搜索接口返回的 byPwdResetWay 值保持一致
        // bit0 : 1-支持预留手机号，此时需要在szCellPhone数组中填入预留手机号(如果需要设置预留手机) ;
        // bit1 : 1-支持预留邮箱，此时需要在szMail数组中填入预留邮箱(如果需要设置预留邮箱)
        public byte[]			byReserved = new byte[2];								// 保留字段

        public NET_IN_INIT_DEVICE_ACCOUNT() {
            this.dwSize = this.size();
        }
    }

    // 初始化设备账户输出结构体
    public static class NET_OUT_INIT_DEVICE_ACCOUNT extends SdkStructure
    {
        public int				dwSize;						// 结构体大小:初始化结构体时赋值

        public NET_OUT_INIT_DEVICE_ACCOUNT() {
            this.dwSize = this.size();
        }
    }

    //用户权限
    public static class NET_ATTENDANCE_AUTHORITY extends SdkStructure
    {
        public static final int NET_ATTENDANCE_AUTHORITY_UNKNOWN = -1;
        public static final int NET_ATTENDANCE_AUTHORITY_CUSTOMER = 0;           //普通用户
        public static final int NET_ATTENDANCE_AUTHORITY_ADMINISTRATORS = 1;     //管理员
    }

    //考勤用户信息
    public static class NET_ATTENDANCE_USERINFO extends SdkStructure
    {
        public byte[]                    szUserID = new byte[MAX_COMMON_STRING_32];   			//用户编号ID
        public byte[]                    szUserName = new byte[MAX_ATTENDANCE_USERNAME_LEN]; 	//人员姓名
        public byte[]                    szCardNo = new byte[MAX_COMMON_STRING_32];   			// 卡号
        public int  					 emAuthority;      										// 用户权限
        public byte[]                    szPassword = new byte[MAX_COMMON_STRING_32]; 			// 密码
        public int                       nPhotoLength;                     						// 照片数据长度
        public byte[]					 szClassNumber = new byte[MAX_CLASS_NUMBER_LEN];  		// 班级（肯尼亚定制）
        public byte[]					 szPhoneNumber = new byte[MAX_PHONENUMBER_LEN];   		// 电话（肯尼亚定制）
        public byte[]					 byReserved = new byte[208];				   			// 保留字节
    }

    // CLIENT_Attendance_AddUser 入参
    public static class NET_IN_ATTENDANCE_ADDUSER extends SdkStructure
    {
        public int						  dwSize;
        public NET_ATTENDANCE_USERINFO    stuUserInfo = new NET_ATTENDANCE_USERINFO();           // 用户信息
        public Pointer                    pbyPhotoData;        			 						 // 照片数据

        public NET_IN_ATTENDANCE_ADDUSER() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_Attendance_AddUser 出参
    public static class NET_OUT_ATTENDANCE_ADDUSER extends SdkStructure
    {
        public int						  dwSize;

        public NET_OUT_ATTENDANCE_ADDUSER() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_Attendance_DelUser 入参
    public static class NET_IN_ATTENDANCE_DELUSER extends SdkStructure
    {
        public int						  dwSize;
        public byte[]    				  szUserID = new byte[MAX_COMMON_STRING_32];  // 用户ID

        public NET_IN_ATTENDANCE_DELUSER() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_Attendance_DelUser 出参
    public static class NET_OUT_ATTENDANCE_DELUSER extends SdkStructure
    {
        public int						  dwSize;

        public NET_OUT_ATTENDANCE_DELUSER() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_Attendance_ModifyUser 入参
    public static class NET_IN_ATTENDANCE_ModifyUSER extends SdkStructure
    {
        public int						  dwSize;
        public NET_ATTENDANCE_USERINFO    stuUserInfo = new NET_ATTENDANCE_USERINFO();           // 用户信息
        public Pointer                    pbyPhotoData;        			 						 // 照片数据

        public NET_IN_ATTENDANCE_ModifyUSER() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_Attendance_ModifyUser 出参
    public static class NET_OUT_ATTENDANCE_ModifyUSER extends SdkStructure
    {
        public int						  dwSize;

        public NET_OUT_ATTENDANCE_ModifyUSER() {
            this.dwSize = this.size();
        }
    }


    // CLIENT_Attendance_GetUser 入参
    public static class NET_IN_ATTENDANCE_GetUSER extends SdkStructure
    {
        public int						  dwSize;
        public byte[]    				  szUserID = new byte[MAX_COMMON_STRING_32];  // 用户ID

        public NET_IN_ATTENDANCE_GetUSER() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_Attendance_GetUser 出参
    public static class NET_OUT_ATTENDANCE_GetUSER extends SdkStructure
    {
        public int						  dwSize;
        public NET_ATTENDANCE_USERINFO    stuUserInfo = new NET_ATTENDANCE_USERINFO();      // 用户信息
        public int                        nMaxLength;             							// 最大存放照片数据的长度
        public Pointer                    pbyPhotoData;        			 					// 照片数据

        public NET_OUT_ATTENDANCE_GetUSER() {
            this.dwSize = this.size();
        }
    }

    //CLIENT_Attendance_InsertFingerByUserID 入参
    public static class NET_IN_FINGERPRINT_INSERT_BY_USERID extends SdkStructure
    {
        public int						  dwSize;
        public byte[]    				  szUserID = new byte[NET_COMMON_STRING_32];  	// 用户ID
        public int 						  nSinglePacketLen;								// 单个指纹数据包长度
        public int 						  nPacketCount;									// 指纹数据包的个数
        public Pointer					  szFingerPrintInfo;							// 指纹数据(数据总长度即nSinglePacketLen*nPacketCount)

        public NET_IN_FINGERPRINT_INSERT_BY_USERID() {
            this.dwSize = this.size();
        }
    }

    //CLIENT_Attendance_InsertFingerByUserID 出参
    public static class NET_OUT_FINGERPRINT_INSERT_BY_USERID extends SdkStructure
    {
        public int						dwSize;
        public int[]					nFingerPrintID = new int[NET_MAX_FINGER_PRINT];	//指纹ID数组
        public int 						nReturnedCount;									//数组中实际返回的个数
        public int						nFailedCode;									//错误码  0：成功;   1：其他错误;  2：超过本用户下指纹能力的限制.

        public NET_OUT_FINGERPRINT_INSERT_BY_USERID() {
            this.dwSize = this.size();
        }
    }

    //CLIENT_Attendance_RemoveFingerByUserID 入参(removeByUserID)
    public static class NET_CTRL_IN_FINGERPRINT_REMOVE_BY_USERID extends SdkStructure
    {
        public int						  dwSize;
        public byte[]    				  szUserID = new byte[NET_COMMON_STRING_32];  // 用户ID

        public NET_CTRL_IN_FINGERPRINT_REMOVE_BY_USERID() {
            this.dwSize = this.size();
        }
    }

    //CLIENT_Attendance_RemoveFingerByUserID 出参
    public static class NET_CTRL_OUT_FINGERPRINT_REMOVE_BY_USERID extends SdkStructure
    {
        public int						  dwSize;

        public NET_CTRL_OUT_FINGERPRINT_REMOVE_BY_USERID() {
            this.dwSize = this.size();
        }
    }

    //CLIENT_Attendance_RemoveFingerRecord 入参(remove)
    public static class NET_CTRL_IN_FINGERPRINT_REMOVE extends SdkStructure
    {
        public int						  dwSize;
        public int    				  	  nFingerPrintID;  // 指纹编号

        public NET_CTRL_IN_FINGERPRINT_REMOVE() {
            this.dwSize = this.size();
        }
    }

    //CLIENT_Attendance_RemoveFingerRecord 出参
    public static class NET_CTRL_OUT_FINGERPRINT_REMOVE extends SdkStructure
    {
        public int						  dwSize;

        public NET_CTRL_OUT_FINGERPRINT_REMOVE() {
            this.dwSize = this.size();
        }
    }

    //CLIENT_Attendance_GetFingerRecord 入参
    public static class NET_CTRL_IN_FINGERPRINT_GET extends SdkStructure
    {
        public int						  dwSize;
        public int    				  	  nFingerPrintID;  // 指纹编号

        public NET_CTRL_IN_FINGERPRINT_GET() {
            this.dwSize = this.size();
        }
    }

    //CLIENT_Attendance_GetFingerRecord 出参
    public static class NET_CTRL_OUT_FINGERPRINT_GET extends SdkStructure
    {
        public int							dwSize;
        public byte[] 						szUserID = new byte[NET_COMMON_STRING_32];			// 所属用户的用户ID
        public byte[] 						szFingerPrintName = new byte[NET_COMMON_STRING_32]; // 指纹名称
        public int							nFingerPrintID;										// 指纹ID
        public int							nRetLength;											// 实际返回的二进制指纹数据长度
        public int							nMaxFingerDataLength;								// 二进制指纹数据的最大长度
        public Pointer						szFingerPrintInfo;									// 指纹数据

        public NET_CTRL_OUT_FINGERPRINT_GET() {
            this.dwSize = this.size();
        }
    }

    //CLIENT_Attendance_FindUser 入参
    public static class NET_IN_ATTENDANCE_FINDUSER extends SdkStructure
    {
        public int				dwSize;
        public int				nOffset;						// 查询偏移
        public int				nPagedQueryCount;				// 查询个数，分页查询，最多不超过100

        public NET_IN_ATTENDANCE_FINDUSER() {
            this.dwSize = this.size();
        }
    };

    //CLIENT_Attendance_FindUser 出参
    public static class NET_OUT_ATTENDANCE_FINDUSER extends SdkStructure
    {
        public int 								dwSize;
        public int								nTotalUser;					// 总的用户数
        public int								nMaxUserCount;				// 用户信息最大缓存数
        public Pointer       					stuUserInfo;            	// 用户信息，内存由用户申请，大小为(sizeof(NET_ATTENDANCE_USERINFO)*nMaxUserCount)
        public int								nRetUserCount;				// 实际返回的用户个数
        public int                           	nMaxPhotoDataLength;        // 照片数据最大长度
        public int								nRetPhoteLength;			// 实际返回的照片数据长度
        public Pointer                        	pbyPhotoData;           	// 照片数据

        public NET_OUT_ATTENDANCE_FINDUSER() {
            this.dwSize = this.size();
        }
    }

    //CLIENT_Attendance_GetFingerByUserID 入参
    public static class NET_IN_FINGERPRINT_GETBYUSER extends SdkStructure
    {
        public int						  dwSize;
        public byte[]    				  szUserID = new byte[NET_COMMON_STRING_32];  // 用户ID

        public NET_IN_FINGERPRINT_GETBYUSER() {
            this.dwSize = this.size();
        }
    }

    //CLIENT_Attendance_GetFingerByUserID 出参
    public static class NET_OUT_FINGERPRINT_GETBYUSER extends SdkStructure
    {
        public int							dwSize;
        public int[]						nFingerPrintIDs = new int[NET_MAX_FINGER_PRINT];// 指纹ID数组
        public int							nRetFingerPrintCount;							// 实际返回的指纹ID个数，即nFingerPrintIDs数组中实际有效个数
        public int							nSinglePacketLength;							// 单个指纹数据包长度
        public int							nMaxFingerDataLength;							// 接受指纹数据的缓存的最大长度
        public int							nRetFingerDataLength;							// 实际返回的总的指纹数据包的长度
        public Pointer                      pbyFingerData;                       			// 指纹数据

        public NET_OUT_FINGERPRINT_GETBYUSER() {
            this.dwSize = this.size();
        }
    }

    // 获取考勤机在线状态入参
    public static class NET_IN_ATTENDANCE_GETDEVSTATE extends SdkStructure
    {
        public int						  dwSize;

        public NET_IN_ATTENDANCE_GETDEVSTATE() {
            this.dwSize = this.size();
        }
    }

    // 获取考勤机在线状态出参
    public static class NET_OUT_ATTENDANCE_GETDEVSTATE extends SdkStructure
    {
        public int 			           		dwSize;
        public int                          nState;     // 0:离线;1:在线;其他:未知;考勤机状态

        public NET_OUT_ATTENDANCE_GETDEVSTATE() {
            this.dwSize = this.size();
        }
    }

    // 输入通道基本配置
    public static class CFG_VIDEO_IN_INFO extends SdkStructure
    {
        public byte[]				szDevType = new byte[MAX_NAME_LEN];			// 通道类型（指通道连接的设备类型）
        public byte[]				szDevID = new byte[MAX_NAME_LEN];			// 摄像头唯一编号
        public byte[]				szChnName = new byte[MAX_NAME_LEN];			// 通道名称
        public byte[]				szManufacturer = new byte[MAX_NAME_LEN];	// 厂商
        public byte[]				szModel = new byte[MAX_NAME_LEN];			// 设备型号
        public byte[]				szAddress = new byte[MAX_ADDRESS_LEN];		// 安装地址
        public byte[]				szCivilCode = new byte[MAX_NAME_LEN];		// 行政区域
        public byte[]				szOwner = new byte[MAX_NAME_LEN];			// 设备归属
        public int					bParental;						// 是否有子设备
        public int					bEnable;						// 通道使能
        public int					nRegisterWay;					// 注册方式
        // 0-符合sip3261标准的认证注册模式
        // 1-基于口令的双向认证注册模式
        // 2-基于数字证书的双向认证注册模式
        public int					bSecrecy;						// 保密属性, FALSE不涉密, TRUE涉密
        public byte[]				szUpperDevID = new byte[MAX_NAME_LEN];		// 上级连接设备设备ID
        public int					nUpperDevOutChn;				// 上级连接设备输出通道号
        public byte[]				szRemoteName = new byte[MAX_NAME_LEN];		// 远程通道名称
        public int 					emSignalType;              	// 输入信号类型 , 详见EM_CFG_VIDEO_SIGNAL_TYPE
        public int  				emLineType;                 // 通道接入线缆的类型, 详见EM_CFG_VIDEO_LINE_TYPE
    }

    // 输入信号类型
    public static class EM_CFG_VIDEO_SIGNAL_TYPE extends SdkStructure
    {
        public static final int EM_CFG_VIDEO_SIGNAL_UNKNOWN = 0;
        public static final int EM_CFG_VIDEO_SIGNAL_CVBS = 1;
        public static final int EM_CFG_VIDEO_SIGNAL_SDI = 2;
        public static final int EM_CFG_VIDEO_SIGNAL_VGA = 3;
        public static final int EM_CFG_VIDEO_SIGNAL_DVI = 4;
        public static final int EM_CFG_VIDEO_SIGNAL_HDMI = 5;
        public static final int EM_CFG_VIDEO_SIGNAL_YPBPR = 6;
        public static final int EM_CFG_VIDEO_SIGNAL_SFP = 7;
        public static final int EM_CFG_VIDEO_SIGNAL_HDCVI = 8;
        public static final int EM_CFG_VIDEO_SIGNAL_DUALLINK = 9;
        public static final int EM_CFG_VIDEO_SIGNAL_AHD = 10;
        public static final int EM_CFG_VIDEO_SIGNAL_AUTO = 11;
        public static final int EM_CFG_VIDEO_SIGNAL_TVI = 12;
    }

    // 通道接入线缆的类型
    public static class EM_CFG_VIDEO_LINE_TYPE extends SdkStructure
    {
        public static final int EM_CFG_VIDEO_LINE_TYPE_UNKNOWN = 0;     // 未知
        public static final int EM_CFG_VIDEO_LINE_TYPE_COAXIAL = 1;    	// 同轴线
        public static final int EM_CFG_VIDEO_LINE_TYPE_TP10 = 2;     	// 10欧姆阻抗双绞线
        public static final int EM_CFG_VIDEO_LINE_TYPE_TP17 = 3;     	// 17欧姆阻抗双绞线
        public static final int EM_CFG_VIDEO_LINE_TYPE_TP25 = 4;        // 25欧姆阻抗双绞线
        public static final int EM_CFG_VIDEO_LINE_TYPE_TP35 = 5;        // 35欧姆阻抗双绞线
    }

    // 通道名称配置
    public static class AV_CFG_ChannelName extends SdkStructure
    {
        public int			nStructSize;
        public int			nSerial;						// 摄像头唯一编号
        public byte[]		szName = new byte[CFG_MAX_CHANNEL_NAME_LEN];// 通道名

        public AV_CFG_ChannelName() {
            this.nStructSize = this.size();
        }
    }

    // 设备通过Wifi模块扫描周围无线设备配置
    public static class CFG_WIFI_SEARCH_INFO extends SdkStructure
    {
        public int 		bEnable;					// 是否生效, boolean类型,为1或者0
        public int		nPeriod;            		// 事件上报周期,单位秒,该值需要大于等于6
        public int		bOptimizNotification;  		// boolean类型,为1或者0,默认值是0，置0时，搜索到的设备状态每次均全部上报,置1时，搜索到的设备状态在未超过PD中OptimizationPeriod取值周期时，只上报新增/离开的设备状态；超过PD中OptimizationPeriod取值周期时，当次需上报搜索到的全部设备状态
    }

    public static class EM_CFG_CARD_STATE extends SdkStructure
    {

        public static final int EM_CFG_CARD_STATE_UNKNOWN = -1;					// 未知
        public static final int EM_CFG_CARD_STATE_SWIPE = 0;					// 门禁刷卡
        public static final int EM_CFG_CARD_STATE_COLLECTION = 1;				// 门禁采集卡
    }

    // 门禁事件配置
    public static class CFG_ACCESS_EVENT_INFO extends SdkStructure
    {
        public byte[]               szChannelName = new byte[MAX_NAME_LEN];		// 门禁通道名称
        public int   			 	emState;									// 门禁状态, 参考 CFG_ACCESS_STATE
        public int     				emMode;										// 门禁模式, 参考  CFG_ACCESS_MODE
        public int					nEnableMode;								// 门禁使能电平值, 0:低电平有效(断电启动); 1:高电平有效(通电启动);
        public int                	bSnapshotEnable;							// 事件联动抓图使能, 1-true, 0-false

        // 能力
        public byte                 abDoorOpenMethod;
        public byte                 abUnlockHoldInterval;
        public byte                 abCloseTimeout;
        public byte                 abOpenAlwaysTimeIndex;
        public byte                 abCloseAlwaysTimeIndex;
        public byte                 abHolidayTimeIndex;
        public byte                 abBreakInAlarmEnable;
        public byte				    abRepeatEnterAlarmEnable;
        public byte                 abDoorNotClosedAlarmEnable;
        public byte				    abDuressAlarmEnable;
        public byte                 abDoorTimeSection;
        public byte				    abSensorEnable;
        public byte				    abFirstEnterEnable;
        public byte                 abRemoteCheck;
        public byte                 abRemoteDetail;
        public byte                 abHandicapTimeOut;
        public byte                 abCheckCloseSensor;
        public byte                 abAutoRemoteCheck;
        public byte[]               reverse = new byte[2];

        public int					emDoorOpenMethod;							// 开门方式, 参考  CFG_DOOR_OPEN_METHOD
        public int					nUnlockHoldInterval;						// 门锁保持时间(自动关门时间),单位毫秒,[250, 20000]
        public int					nCloseTimeout;								// 关门超时时间, 超过阈值未关会触发报警，单位秒,[0,9999];0表示不检测超时
        public int					nOpenAlwaysTimeIndex;						// 常开时间段, 值为CFG_ACCESS_TIMESCHEDULE_INFO配置的数组下标
        public int                  nCloseAlwaysTimeIndex;          			// 常关时间段, 值为CFG_ACCESS_TIMESCHEDULE_INFO配置的数组下标
        public int					nHolidayTimeRecoNo;							// 假期内时间段, 值为假日记录集的记录编号，对应NET_RECORDSET_HOLIDAY的nRecNo
        public int					bBreakInAlarmEnable;						// 闯入报警使能, 1-true, 0-false
        public int					bRepeatEnterAlarm;							// 反潜报警使能, 1-true, 0-false
        public int 					bDoorNotClosedAlarmEnable;					// 门未关报警使能, 1-true, 0-false
        public int					bDuressAlarmEnable;							// 胁迫报警使能, 1-true, 0-false
        public CFG_DOOROPEN_TIMESECTION_WEEK_DAY[]	stuDoorTimeSectionArr =
                (CFG_DOOROPEN_TIMESECTION_WEEK_DAY[])new CFG_DOOROPEN_TIMESECTION_WEEK_DAY().toArray(WEEK_DAY_NUM);// 分时段开门信息
        public int 					bSensorEnable;								// 门磁使能, 1-true, 0-false
        public CFG_ACCESS_FIRSTENTER_INFO stuFirstEnterInfo;					// 首卡开门信息
        public int                  bRemoteCheck;                   			// 1-true, 0-false, 是否需要平台验证, TRUE表示权限通过后必须要平台验证后才能开门, FALSE表示权限验证通过后可立即开门
        public CFG_REMOTE_DETAIL_INFO  stuRemoteDetail;            				// 与bRemoteCheck配合使用, 如果远端验证未应答, 设定的设备超时时间到后, 是正常开门还是不开门
        public CFG_HANDICAP_TIMEOUT_INFO   stuHandicapTimeOut;     				// 针对残疾人的开门参数
        public int                  bCloseCheckSensor;              			// 闭锁前是否检测门磁, 1-true, 0-false
        // true:则当开锁保持时间计时结束后，只有监测到有效门磁信号时，才可以恢复关闭锁的动作。
        // 反之，如果开锁保持时间已到，但未检测到有效门磁信号，则一直保持开锁状态；
        // false(默认):则直接按照设定的开锁保持时间进行开锁保持和恢复关闭的动作。
        public CFG_AUTO_REMOTE_CHECK_INFO  stuAutoRemoteCheck;     				// 开门远程验证, 如果开启, 在该时间段内, 设备通过多人组合开门事件通知到平台确认是否可以开门
        public int                	bLocalControlEnable;            			// 本地控制启用, 1-TRUE 启用,   0-false 停用
        public int                	bRemoteControlEnable;           			// 远程控制启用, 1-true  启用,   0-false 停用
        public int                  nSensorDelay;                   			// 传感器输出延时，超过此时间判断有人, 单位：秒。 0~10
        public int                  nHumanStatusSensitivity;        			// 人状态变化检测灵敏度,在此时间内，判断有人 单位： 秒。 0~300
        public int                  nDetectSensitivity;             			// 传感器本身的检测灵敏度  单位：%， 0~100
        public int					bLockTongueEnable;							// 锁舌使能, 1-true, 0-false
        public int                  nABLockRoute;                   			// AB互锁路线与AB互锁的index对应；-1代表无效
        public int                  nDoorNotClosedReaderAlarmTime; 	 			// 门未关超时读卡器报警, 单位：秒
        public int					bEnable;									// 使能项,此通道配置是否启用, 1-true为使能, 0-false为关闭
        public byte[]				szSN = new byte[CFG_MAX_SN_LEN];			// 无线设备序列号,只获取，不能设置
        public int					nCloseDuration;								// 门闭合时间,单位：秒
        public int					nUnlockReloadInterval;						// 开锁命令响应间隔时间,单位:毫秒
        public int		 		 	emAccessProtocol;							// 门禁协议, 参考  CFG_EM_ACCESS_PROTOCOL
        public int	  				emProtocolType;								// 参考 CFG_EM_SERIAL_PROTOCOL_TYPE, 串口协议下的具体协议功能,当emAccessProtocol为CFG_EM_ACCESS_PROTOCOL_SERIAL时有效
        public CFG_ACCESS_CONTROL_UDP_INFO	  stuAccessControlUdpInfo;  		// 门禁udp开锁信息,当emAccessProtocol为CFG_EM_ACCESS_PROTOCOL_REMOTE时有效
        public int				    nEntranceLockChannel;						// 门禁控制器下的子通道,当emAccessProtocol为CFG_EM_ACCESS_PROTOCOL_REMOTE时有效
        public int					bSnapshotUpload;							// 使能项,抓图是否上传, 1-true为抓图上传, 0-false为抓图不上传
        public int				    nSnapUploadPos;								// 抓图上传地址,对应的是NAS配置项的下标，NAS配置为CFG_CMD_NASEX
        public int                  bCustomPasswordEnable;              		// 是否启用个性化密码, 1-true, 0-false
        public int                  nRepeatEnterTime;                   		// 重复进入时间,0~180秒，0表示不启用
        public int                  nCardNoConvert;                     		// 卡号转换，0:不需要转换,1:字节取反,2:按HIDpro转换
        public int                	bUnAuthorizedMaliciousSwipEnable;   		// 未授权恶意刷卡事件使能, 1-true, 0-false
        public int                	bFakeLockedAlarmEnable;             		// 假锁报警使能, 1-true, 0-false
        public int					emReadCardState;							// 当前门采集状态,参考EM_CFG_CARD_STATE
        public Boolean				bHelmetEnable;						        // 是否检测安全帽
    }

    // 分时段开门信息
    public static class CFG_DOOROPEN_TIMESECTION_WEEK_DAY extends SdkStructure
    {

        public CFG_DOOROPEN_TIMESECTION_INFO[]	stuDoorTimeSection =
                (CFG_DOOROPEN_TIMESECTION_INFO[])new CFG_DOOROPEN_TIMESECTION_INFO().toArray(MAX_DOOR_TIME_SECTION);
    }

    // 分时段开门
    public static class CFG_DOOROPEN_TIMESECTION_INFO extends SdkStructure
    {
        public CFG_TIME_PERIOD			stuTime;						// 时间段
        public int						emDoorOpenMethod;				// 开门模式, 参考 CFG_DOOR_OPEN_METHOD
    }

    // 首卡开门信息
    public static class CFG_ACCESS_FIRSTENTER_INFO extends SdkStructure
    {
        public int						bEnable;						// 在指定的时间,只有拥有首卡权限的用户验证通过后，其他的用户才能刷卡(指纹等)进入，1-true 使能, 0-false 关闭
        public int						emStatus;						// 首卡权限验证通过后的门禁状态, 参考 CFG_ACCESS_FIRSTENTER_STATUS
        public int						nTimeIndex;						// 需要首卡验证的时间段, 值为  配置 "AccessTimeSchedule"的门禁刷卡时间段的下标
    }

    // 远程开门验证
    public static class CFG_REMOTE_DETAIL_INFO extends SdkStructure
    {
        public int                 		nTimeOut;                       // 超时时间, 0表示永久等待, 其他值表示超时时间(单位为秒)
        public int                		bTimeOutDoorStatus;             // 超时后的门状态, 1-true:打开, 0-false:关闭
    }

    // 针对残疾人的开门信息
    public static class CFG_HANDICAP_TIMEOUT_INFO extends SdkStructure
    {
        public int                	    nUnlockHoldInterval;            // 门锁保持时间(自动关门时间),单位毫秒,[250, 60000]
        public int                 		nCloseTimeout;                  // 关门超时时间, 超过阈值未关会触发报警，单位秒,[0,9999];0表示不检测超时
    }

    // 开门远程验证
    public static class CFG_AUTO_REMOTE_CHECK_INFO extends SdkStructure
    {
        public int                		bEnable;                        // 使能项, 1-true: 开启, 0-false: 关闭
        public int                	 	nTimeSechdule;                  // 对应CFG_CMD_ACCESSTIMESCHEDULE配置的索引
    }

    // 大华门禁udp开锁信息
    public static class CFG_ACCESS_CONTROL_UDP_INFO extends SdkStructure
    {
        public byte[]					szAddress = new byte[CFG_MAX_ACCESS_CONTROL_ADDRESS_LEN];// 地址
        public int						nPort;													 // 端口
    }

    // 门禁状态
    public static class CFG_ACCESS_STATE extends SdkStructure
    {
        public static final int ACCESS_STATE_NORMAL = 0;                                        // 普通
        public static final int ACCESS_STATE_CLOSEALWAYS = 1;                                   // 常关
        public static final int ACCESS_STATE_OPENALWAYS = 2;                                    // 常开
        // 常开常闭状态下,Opendoor开门无效.
        public static final int ACCESS_STATE_NOPERSONNC = 3;                                    // 无人状态常闭
        public static final int ACCESS_STATE_NOPERSONNO = 4;                                    // 无人状态常开
    }

    // 门禁模式
    public static class CFG_ACCESS_MODE extends SdkStructure
    {
        public static final int ACCESS_MODE_HANDPROTECTED = 0;                                  // 防夹模式
        public static final int ACCESS_MODE_SAFEROOM = 1;                                       // 防护房间模式
        public static final int ACCESS_MODE_OTHER = 2;                                          // 其它
    }

    // 自定义开门方式
    public static class CFG_DOOR_OPEN_METHOD extends SdkStructure
    {
        public static final int CFG_DOOR_OPEN_METHOD_UNKNOWN                        = 0;
        public static final int CFG_DOOR_OPEN_METHOD_PWD_ONLY						= 1;    	 // 只允许密码开锁
        public static final int CFG_DOOR_OPEN_METHOD_CARD							= 2;    	 // 只允许刷卡开锁
        public static final int CFG_DOOR_OPEN_METHOD_PWD_OR_CARD					= 3;    	 // 密码或刷卡开锁
        public static final int CFG_DOOR_OPEN_METHOD_CARD_FIRST						= 4;    	 // 先刷卡后密码开锁
        public static final int CFG_DOOR_OPEN_METHOD_PWD_FIRST						= 5;    	 // 先密码后刷卡开锁
        public static final int CFG_DOOR_OPEN_METHOD_SECTION						= 6;    	 // 分时段开门
        public static final int CFG_DOOR_OPEN_METHOD_FINGERPRINTONLY                = 7;    	 // 仅指纹开锁
        public static final int CFG_DOOR_OPEN_METHOD_PWD_OR_CARD_OR_FINGERPRINT     = 8;    	 // 密码或刷卡或指纹开锁
        public static final int CFG_DOOR_OPEN_METHOD_PWD_AND_CARD_AND_FINGERPINT    = 9;   		 // 密码+刷卡+指纹组合开锁
        public static final int CFG_DOOR_OPEN_METHOD_PWD_AND_FINGERPRINT            = 10;   	 // 密码+指纹组合开锁
        public static final int CFG_DOOR_OPEN_METHOD_CARD_AND_FINGERPRINT           = 11;   	 // 刷卡+指纹开锁
        public static final int CFG_DOOR_OPEN_METHOD_MULTI_PERSON                   = 12;  		 // 多人开锁
        public static final int CFG_DOOR_OPEN_METHOD_FACEIDCARD						= 13;   	 // 人证对比
        public static final int CFG_DOOR_OPEN_METHOD_FACEIDCARD_AND_IDCARD			= 14;		 // 身份证+ 人证比对
        public static final int CFG_DOOR_OPEN_METHOD_FACEIDCARD_OR_CARD_OR_FINGER	= 15;		 // 人证比对或刷卡或指纹
        public static final int CFG_DOOR_OPEN_METHOD_FACEIPCARDANDIDCARD_OR_CARD_OR_FINGER	= 16;// (身份证+认证比对)或刷卡或指纹
        public static final int CFG_DOOR_OPEN_METHOD_USERID_AND_PWD                 = 17;   	 // UserID+密码
        public static final int CFG_DOOR_OPEN_METHOD_FACE_ONLY                      = 18; 		 // 只允许人脸开锁
        public static final int CFG_DOOR_OPEN_METHOD_FACE_AND_PWD                   = 19;   	 // 人脸+密码开锁
        public static final int CFG_DOOR_OPEN_METHOD_FINGERPRINT_AND_PWD            = 20;  		 // 指纹+密码开锁
        public static final int CFG_DOOR_OPEN_METHOD_FINGERPRINT_AND_FACE           = 21;  		 // 指纹+人脸开锁
        public static final int CFG_DOOR_OPEN_METHOD_CARD_AND_FACE                  = 22;  		 // 刷卡+人脸开锁
        public static final int CFG_DOOR_OPEN_METHOD_FACE_OR_PWD                    = 23;  		 // 人脸或密码开锁
        public static final int CFG_DOOR_OPEN_METHOD_FINGERPRINT_OR_PWD             = 24;  		 // 指纹或密码开锁
        public static final int CFG_DOOR_OPEN_METHOD_FINGERPRINT_OR_FACE            = 25;   	 // 指纹或人脸开锁
        public static final int CFG_DOOR_OPEN_METHOD_CARD_OR_FACE                   = 26;   	 // 刷卡或人脸开锁
        public static final int CFG_DOOR_OPEN_METHOD_CARD_OR_FINGERPRINT            = 27;   	 // 刷卡或指纹开锁
        public static final int CFG_DOOR_OPEN_METHOD_FINGERPRINT_AND_FACE_AND_PWD   = 28;   	 // 指纹+人脸+密码开锁
        public static final int CFG_DOOR_OPEN_METHOD_CARD_AND_FACE_AND_PWD          = 29;  		 // 刷卡+人脸+密码开锁
        public static final int CFG_DOOR_OPEN_METHOD_CARD_AND_FINGERPRINT_AND_PWD   = 30;   	 // 刷卡+指纹+密码开锁
        public static final int CFG_DOOR_OPEN_METHOD_CARD_AND_PWD_AND_FACE          = 31;  		 // 卡+指纹+人脸组合开锁
        public static final int CFG_DOOR_OPEN_METHOD_FINGERPRINT_OR_FACE_OR_PWD     = 32;   	 // 指纹或人脸或密码
        public static final int CFG_DOOR_OPEN_METHOD_CARD_OR_FACE_OR_PWD               = 33;	 // 卡或人脸或密码开锁
        public static final int CFG_DOOR_OPEN_METHOD_CARD_OR_FINGERPRINT_OR_FACE    = 34;   	 // 卡或指纹或人脸开锁
        public static final int CFG_DOOR_OPEN_METHOD_CARD_AND_FINGERPRINT_AND_FACE_AND_PWD  = 35;// 卡+指纹+人脸+密码组合开锁
        public static final int CFG_DOOR_OPEN_METHOD_CARD_OR_FINGERPRINT_OR_FACE_OR_PWD     = 36;// 卡或指纹或人脸或密码开锁
        public static final int CFG_DOOR_OPEN_METHOD_FACEIPCARDANDIDCARD_OR_CARD_OR_FACE    = 37;//(身份证+人证比对)或 刷卡 或 人脸
        public static final int CFG_DOOR_OPEN_METHOD_FACEIDCARD_OR_CARD_OR_FACE        = 38;     // 人证比对 或 刷卡(二维码) 或 人脸
    }

    // 首卡权限验证通过后的门禁状态
    public static class CFG_ACCESS_FIRSTENTER_STATUS extends SdkStructure
    {
        public static final int ACCESS_FIRSTENTER_STATUS_UNKNOWN = 0;									// 未知状态
        public static final int ACCESS_FIRSTENTER_STATUS_KEEPOPEN = 1;									// KeepOpen-首卡权限验证通过后，门保持常开
        public static final int ACCESS_FIRSTENTER_STATUS_NORMAL = 2;									// Normal-首卡权限验证通过后，其他用户才能刷卡(指纹等)验证通过
    }

    // 门禁协议
    public static class CFG_EM_ACCESS_PROTOCOL extends SdkStructure
    {
        public static final int CFG_EM_ACCESS_PROTOCOL_UNKNOWN = 0;										// 未知
        public static final int CFG_EM_ACCESS_PROTOCOL_LOCAL = 1;										// 本机开关量控制
        public static final int CFG_EM_ACCESS_PROTOCOL_SERIAL = 2;										// 串口协议
        public static final int CFG_EM_ACCESS_PROTOCOL_REMOTE = 3;										// 门禁udp开锁
    }

    // 串口协议下的具体协议功能
    public static class CFG_EM_SERIAL_PROTOCOL_TYPE extends SdkStructure
    {
        public static final int CFG_EM_SERIAL_PROTOCOL_TYPE_UNKNOWN = -1;								// 未知
        public static final int CFG_EM_SERIAL_PROTOCOL_TYPE_UNUSED = 0;									// 未使用
        public static final int CFG_EM_SERIAL_PROTOCOL_TYPE_DAHUA_ACCESS_485 = 1;						// 门禁485
        public static final int CFG_EM_SERIAL_PROTOCOL_TYPE_LADDER_CONTROL = 2;							// 梯控
        public static final int CFG_EM_SERIAL_PROTOCOL_TYPE_REMOTE_READ_HEAD = 3;						// 远距离读头
    }

    // CLIENT_MatrixSetCameras接口的输入参数
    public static class NET_IN_MATRIX_SET_CAMERAS extends SdkStructure
    {
        public int                   dwSize;
        public Pointer  			 pstuCameras;                    // 显示源信息 NET_MATRIX_CAMERA_INFO 数组, 用户分配内存，大小为sizeof(NET_MATRIX_CAMERA_INFO)*nCameraCount
        public int                   nCameraCount;                   // 显示源数组大小

        public NET_IN_MATRIX_SET_CAMERAS() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_MatrixSetCameras接口的输出参数
    public static class NET_OUT_MATRIX_SET_CAMERAS extends SdkStructure
    {
        public int                   dwSize;

        public NET_OUT_MATRIX_SET_CAMERAS() {
            this.dwSize = this.size();
        }
    }

    // 各种违章事件联动报警输出事件 (NET_ALARM_TRAFFIC_LINKAGEALARM)
    public static class ALARM_TRAFFIC_LINKAGEALARM_INFO extends SdkStructure
    {
        public NET_TIME_EX			stuTime;									// 事件发生的时间
        public byte[]				szCode = new byte[NET_COMMON_STRING_32];	// 违章联动报警事件
        public byte[]               byReserved = new byte[1024];       			// 保留字节
    }

    // IPC新增(2017.4),RFID标签信息采集事件
    public static class ALARM_LABELINFO extends SdkStructure
    {
        public int					nChannelID;										// 通道号
        public byte[]				szIndexIs = new byte[NET_COMMON_STRING_8];		// 事件Index代表的含义，如无该字段，无法级联
        public int					nVideoIndex;									// 视频通道号
        public int					nACK;											// 确认ID
        public byte[]				szReceiverID = new byte[NET_COMMON_STRING_16];	// 接收器ID
        public byte[]				szLabelID = new byte[NET_COMMON_STRING_16];		// RFID标签
        public NET_TIME_EX			stuDateTime;									// 采集时间UTC
        public int					emLabelDataState;								// 标签的数据状态（进入0、离开1）
        public byte[]				byReserve = new byte[1024];						// 保留字节
    }

    // 事件数据类型
    public static class NET_EM_EVENT_DATA_TYPE extends SdkStructure
    {
        public static final int NET_EN_EVENT_DATA_TYPE_UNKNOWN = 0;									// 未知
        public static final int NET_EN_EVENT_DATA_TYPE_REAL = 1;									// 实时数据
        public static final int NET_EN_EVENT_DATA_TYPE_ALARM = 2;									// 报警数据
    }

    // 事件类型 NET_ALARM_FLOATINGOBJECT_DETECTION (漂浮物检测事件)
    public static class ALARM_FLOATINGOBJECT_DETECTION_INFO extends SdkStructure
    {
        public int                 	nAction;                        // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              	reserved1 = new byte[4];		// 预留字段
        public byte[]              	szName = new byte[128];         // 事件名称
        public double              	PTS;                            // 时间戳(单位是毫秒)
        public NET_TIME_EX         	UTC;							// 事件发生的时间
        public int				    nChannel;						// 通道号
        public int					nEventID;						// 事件ID

        public int				    nPresetID;						// 事件触发的预置点ID
        public byte[]			    szPresetName = new byte[64];	// 事件触发的预置名称
        public int				    bExistFloatingObject;			// 是否存在漂浮物
        public int					emEventType;					// 事件数据类型,详见NET_EM_EVENT_DATA_TYPE
        public float				fCurrentRatio;					// 漂浮物当前占比（相对于检测区域）单位:%, 取值范围[0, 100]
        public float				fAlarmThreshold;				// 报警阈值。漂浮物相对于检测区域的占比, 取值范围[0, 100]

        public NET_POINT[]          stuDetectRegion = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM); // 规则检测区域
        public int                 	nDetectRegionNum;               // 规则检测区域顶点数

        public byte[]               byReserved = new byte[1020];    // 预留字段
    }

    // 水位状态
    public static class NET_EM_WATER_LEVEL_STATUS extends SdkStructure
    {
        public static final int NET_EM_WATER_LEVEL_STATUS_UNKNOWN = 0;		// 未知
        public static final int NET_EM_WATER_LEVEL_STATUS_NORMAL = 1;		// 水位正常
        public static final int NET_EM_WATER_LEVEL_STATUS_HIGH = 2;			// 水位高于上限阈值
        public static final int NET_EM_WATER_LEVEL_STATUS_LOW = 3;			// 水位低于上限阈值
    }

    // 水位尺颜色
    public static class NET_EM_WATER_RULER_COLOR extends SdkStructure
    {
        public static final int NET_EM_WATER_LEVEL_STATUS_UNKNOWN = 0;		// 未知
        public static final int NET_EM_WATER_RULER_COLOR_BLUE = 1;			// 蓝色
        public static final int NET_EM_WATER_RULER_COLOR_RED = 2;			// 红色
    }

    // 水位尺
    public static class NET_WATER_RULER extends SdkStructure
    {
        public int					emRulerColor;							// 水位尺颜色, 详见 NET_EM_WATER_RULER_COLOR
        public byte[]				szRulerNum = new byte[128];				// 水位尺编号
        public float				fWaterLevel;							// 水位值（对于有拼接的情况，该值为标定的基准值加上当前刻度值，单位：米）
        public byte[]				byReserved = new byte[512];				// 保留字节
    }

    // 事件类型 NET_ALARM_WATER_LEVEL_DETECTION (水位检测事件)
    public static class ALARM_WATER_LEVEL_DETECTION_INFO extends SdkStructure
    {
        public int                 	nAction;                        // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              	reserved1 = new byte[4];		// 预留字段
        public byte[]              	szName = new byte[128];         // 事件名称
        public double              	PTS;                            // 时间戳(单位是毫秒)
        public NET_TIME_EX         	UTC;							// 事件发生的时间
        public int				    nChannel;						// 通道号
        public int					nEventID;						// 事件ID
        public int					nPresetID;						// 预置点ID
        public byte[]				szPresetName = new byte[64];	// 预置点名称
        public byte[]				szObjectUUID = new byte[48];	// 智能物体全局唯一物体标识
        public int					emEventType;					// 事件数据类型, 详见 NET_EM_EVENT_DATA_TYPE
        public int					emStatus;						// 水位状态, 详见 NET_EM_WATER_LEVEL_STATUS
        public NET_WATER_RULER		stuWaterRuler;					// 水位尺
        public byte[]				byReserved = new byte[1024];    // 预留字段
    }

    // 事件类型 EVENT_IVS_FLOATINGOBJECT_DETECTION (漂浮物检测)对应的规则配置
    public static class CFG_FLOATINGOBJECT_DETECTION_INFO extends SdkStructure
    {
        // 信息
        public byte[]				szRuleName=new byte[MAX_NAME_LEN];						// 规则名称,不同规则不能重名
        public int				    bRuleEnable;											// 规则使能
        public int					nObjectTypeNum;											// 相应物体类型个数
        public byte[]				szObjectTypes=new byte[MAX_OBJECT_LIST_SIZE*MAX_NAME_LEN];		// 相应物体类型列表
        public int                  nPtzPresetId;											// 云台预置点编号	0~65535
        public CFG_ALARM_MSG_HANDLE stuEventHandler;										// 报警联动
        public CFG_TIME_SECTION[]	stuTimeSection=(CFG_TIME_SECTION[])new CFG_TIME_SECTION().toArray(WEEK_DAY_NUM*MAX_REC_TSECT_EX);			// 事件响应时间段
        public int					nDetectRegionPoint;										// 检测区顶点数
        public CFG_POLYGON[]		stuDetectRegion=(CFG_POLYGON[])new CFG_POLYGON().toArray(MAX_POLYGON_NUM);						// 检测区
        public float				fAlarmThreshold;										// 报警阈值。当检测区域内的漂浮物占比超过阈值时则产生报警;单位:%，取值范围(0, 100]
        public int				    nAlarmInterval;											// 报警时间间隔。（单位：秒）。取值范围[60, 86400]
        public int				    bDataUpload;											// 是否上报实时数据。
        public int				    nUpdateInterval;										// 实时数据上报间隔。(单位：秒)。取值范围[60, 86400]
        public byte[]				byReserved=new byte[4096]; 								// 保留字节
    };

    // 事件类型 EVENT_IVS_WATER_LEVEL_DETECTION (水位检测事件)对应的规则配置
    public static class CFG_WATER_LEVEL_DETECTION_INFO extends SdkStructure
    {
        // 信息
        public byte[]				szRuleName=new byte[MAX_NAME_LEN];						// 规则名称,不同规则不能重名
        public int				    bRuleEnable;											// 规则使能
        public int					nObjectTypeNum;											// 相应物体类型个数
        public byte[]				szObjectTypes=new byte[MAX_OBJECT_LIST_SIZE*MAX_NAME_LEN];		// 相应物体类型列表
        public int                 nPtzPresetId;											// 云台预置点编号	0~65535
        public CFG_ALARM_MSG_HANDLE stuEventHandler;										// 报警联动
        public CFG_TIME_SECTION[]	stuTimeSection=(CFG_TIME_SECTION[])new CFG_TIME_SECTION().toArray(WEEK_DAY_NUM*MAX_REC_TSECT_EX);			// 事件响应时间段
        public int					nBaseLinePointNum;										// 拼接的水位尺坐标点数
        public CFG_POLYGON[]		stuBaseLine=(CFG_POLYGON[])new CFG_POLYGON().toArray(16);										// 对于拼接的水位尺，需页面上标定出拼接处，若无拼接无需填充																					// 一般4个点，最大不超过16个点,每个点坐标归一化到[0,8192]区间
        public float				fBaseLevel;												// 对应BaseLine标定的实际水位值。（单位：米）
        public float				fHighLevel;												// 水位上限报警阈值(单位：米)
        public float				fLowLevel;												// 水位下限报警阈值(单位：米)
        public int				    nAlarmInterval;											// 报警时间间隔。（单位：秒）。取值范围[60, 86400]
        public int				    bDataUpload;											// 是否上报实时数据。
        public int				    nUpdateInterval;										// 实时数据上报间隔。(单位：秒)。取值范围[60, 86400]
        public byte[]				byReserved=new byte[4096]; 								// 保留字节
    };

    // 事件类型NET_ALARM_TRAFFIC_JUNCTION
    public static class ALARM_TAFFIC_JUNCTION_INFO extends SdkStructure
    {
        public int				   nAction;									// 事件动作
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName = new byte[NET_EVENT_NAME_LEN];      // 事件名称
        public byte                byMainSeatBelt;                             // 主驾驶座,系安全带状态,1-系安全带,2-未系安全带
        public byte                bySlaveSeatBelt;                            // 副驾驶座,系安全带状态,1-系安全带,2-未系安全带
        public byte                byVehicleDirection;                         // 当前被抓拍到的车辆是车头还是车尾,具体请见 EM_VEHICLE_DIRECTION
        public byte                byOpenStrobeState;                          // 开闸状态,具体请见 EM_OPEN_STROBE_STATE
        public byte[]			   byReserved1=new byte[4];					   // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体
        public int                 nLane;                                      // 对应车道号
        public int                 dwBreakingRule;                             // 违反规则掩码,第一位:闯红灯;
        // 第二位:不按规定车道行驶;
        // 第三位:逆行; 第四位：违章掉头;
        // 第五位:交通堵塞; 第六位:交通异常空闲
        // 第七位:压线行驶; 否则默认为:交通路口事件
        public NET_TIME_EX         RedLightUTC;                                // 红灯开始UTC时间
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public int                 nSequence;                                  // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public int                 nSpeed;                                     // 车辆实际速度Km/h
        /*public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;*/
        public byte                byDirection;                                // 路口方向,1-表示正向,2-表示反向
        public byte                byLightState;                               // LightState表示红绿灯状态:0 未知,1 绿灯,2 红灯,3 黄灯
        public byte                byReserved2;                                 // 保留字节
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public NET_MSG_OBJECT      stuVehicle;                                 // 车身信息
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见 NET_RESERVED_COMMON, 0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public NET_RESOLUTION_INFO stuResolution;                              // 对应图片的分辨率
        public byte[]              szRecordFile = new byte[NET_COMMON_STRING_128];// 报警对应的原始录像文件信息
        public EVENT_JUNCTION_CUSTOM_INFO   stuCustomInfo;                     // 自定义信息
        public byte                byPlateTextSource;                          // 车牌识别来源, 0:本地算法识别,1:后端服务器算法识别
        public byte[]              byReserved3 = new byte[3];                   // 保留字节,留待扩展.
        public NET_GPS_INFO        stuGPSInfo;                                 // GPS信息 车载定制

        public byte                byNoneMotorInfo;                            // 0-无非机动车人员信息信息,1-有非机动车人员信息信息  此字段为1时下面11个字段生效
        public byte                byBag;                                      // 是否背包, 0-未知 1-不背包   2-背包
        public byte                byUmbrella;                                 // 是否打伞, 0-未知 1-不打伞   2-打伞
        public byte                byCarrierBag;                               // 手提包状态,0-未知 1-没有 2-有
        public byte                byHat;                                      // 是否戴帽子, 0-未知 1-不戴帽子 2-戴帽子
        public byte                byHelmet;                                   // 头盔状态,0-未知 1-没有 2-有
        public byte                bySex;                                      // 性别,0-未知 1-男性 2-女性
        public byte                byAge;                                      // 年龄
        public NET_COLOR_RGBA      stuUpperBodyColor;                          // 上身颜色
        public NET_COLOR_RGBA      stuLowerBodyColor;                          // 下身颜色
        public byte                byUpClothes;                                // 上身衣服类型 0:未知 1:长袖 2:短袖 3:长裤 4:短裤 5:裙子 6:背心 7:超短裤 8:超短裙
        public byte                byDownClothes;                              // 下身衣服类型 0:未知 1:长袖 2:短袖 3:长裤 4:短裤 5:裙子 6:背心 7:超短裤 8:超短裙

        public NET_EXTENSION_INFO  stuExtensionInfo;                           // 扩展信息
        public byte[]              byReserved4 = new byte[22];                   // 保留字节,留待扩展.
        public int                 nTriggerType;                               // TriggerType:触发类型,0车检器,1雷达,2视频
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stTrafficCar;                 // 交通车辆信息
        public int                 dwRetCardNumber;                            // 卡片个数
        public EVENT_CARD_INFO[]   stuCardInfo = (EVENT_CARD_INFO[])new EVENT_CARD_INFO().toArray(NET_EVENT_MAX_CARD_NUM);// 卡片信息
        public EVENT_COMM_INFO     stCommInfo;                                 // 公共信息

        public int				   bNonMotorInfoEx;							   // 是否有非机动车信息, 1-true; 0-false
        public VA_OBJECT_NONMOTOR  stuNonMotor;								   // 非机动车信息
        public byte[]			   byReserved = new byte[2048];			   // 保留字节,留待扩展
    }

    // 门禁控制器操作类型
    public static class NET_EM_ACCESS_CTL_MANAGER extends SdkStructure
    {
        public static final int NET_EM_ACCESS_CTL_MANAGER_ADDDEVICE = 0;            // 添加单个分控器, 对应结构体 pstInParam = NET_IN_ACCESS_CTL_MANAGER_ADDDEVICE, pstOutParam = NET_OUT_ACCESS_CTL_MANAGER_ADDDEVICE
        public static final int NET_EM_ACCESS_CTL_MANAGER_MODIFYDEVICE = 1;         // 修改分控器名称, 对应结构体 pstInParam = NET_IN_ACCESS_CTL_MANAGER_MODIFYDEVICE, pstOutParam = NET_OUT_ACCESS_CTL_MANAGER_MODIFYDEVICE
        public static final int NET_EM_ACCESS_CTL_MANAGER_REMOVEDEVICE = 2;         // 删除分控器, 对应结构体 pstInParam = NET_IN_ACCESS_CTL_MANAGER_REMOVEDEVICE, pstOutParam = NET_OUT_ACCESS_CTL_MANAGER_REMOVEDEVICE
        public static final int NET_EM_ACCESS_CTL_GETSUBCONTROLLER_INFO = 3;        // 获取分控器信息, 对应结构体 pstInParam = NET_IN_GET_SUB_CONTROLLER_INFO, pstOutParam = NET_OUT_GET_SUB_CONTROLLER_INFO
        public static final int NET_EM_ACCESS_CTL_GETSUBCONTROLLER_STATE = 4;       // 获取分控器状态, 对应结构体 pstInParam = NET_IN_GET_SUB_CONTROLLER_STATE, pstOutParam = NET_OUT_GET_SUB_CONTROLLER_STATE
        public static final int NET_EM_ACCESS_CTL_SET_REPEAT_ENTERROUTE = 5;        // 设置反潜路径信息, 对应结构体 pstInparam = NET_IN_SET_REPEAT_ENTERROUTE, pstOutParam = NET_OUT_SET_REPEAT_ENTERROUTE
        public static final int NET_EM_ACCESS_CTL_GET_REPEAT_ENTERROUTE = 6;        // 获取反潜路径信息, 对应结构体 pstInparam = NET_IN_GET_REPEAT_ENTERROUTE, pstOutParam = NET_OUT_GET_REPEAT_ENTERROUTE
        public static final int NET_EM_ACCESS_CTL_SET_ABLOCK_ROUTE = 7;             // 设置AB互锁路径信息, 对应结构体 pstInparam = NET_IN_SET_ABLOCK_ROUTE, pstOutParam = NET_OUT_SET_ABLOCK_ROUTE
        public static final int NET_EM_ACCESS_CTL_GET_ABLOCK_ROUTE = 8;             // 获取AB互锁路径信息, 对应结构体 pstInparam = NET_IN_GET_ABLOCK_ROUTE, pstOutParam = NET_OUT_GET_ABLOCK_ROUTE
        public static final int NET_EM_ACCESS_CTL_GET_LOGSTATUS = 9;                // 获取日志同步状态,对应结构体 pstInparam = NET_IN_GET_LOGSTATUS, pstOutParam = NET_OUT_GET_LOGSTATUS
        public static final int NET_EM_ACCESS_CTL_SYNCHRO_OFFLINE_LOG = 10;         // 同步离线日志, 对应结构体 pstInparam = NET_IN_SYNCHRO_OFFLINE_LOG, pstOutParam = NET_OUT_SYNCHRO_OFFLINE_LOG
        public static final int NET_EM_ACCESS_CTL_SYNCHRO_TIME = 11;                // 同步分控器时间,对应结构体 pstInparam = NET_IN_SYNCHRO_CONTROLLER_TIME, pstOutParam = NET_OUT_SYNCHRO_CONTROLLER_TIME
        public static final int NET_EM_ACCESS_CTL_SET_QRCODEDECODE_INFO = 12;       // 设置二维码的解码信息, 对应结构体 pstInparam = NET_IN_SET_QRCODE_DECODE_INFO, pstOutParam = NET_OUT_SET_QRCODE_DECODE_INFO
    }

    // 获取分控器信息入参
    public static class NET_IN_GET_SUB_CONTROLLER_INFO extends SdkStructure
    {
        public int                 dwSize;
        public int[]               nSubControllerID = new int[MAX_ACCESSSUBCONTROLLER_NUM];  // 分控器ID, 取值范围 -1~255, -1:获取所有,0:获取本地,1~255:外置分控
        public int                 nSubControllerNum;                              			 // 需要查询的分控器数量

        public NET_IN_GET_SUB_CONTROLLER_INFO() {
            this.dwSize = this.size();
        }
    }

    // 获取分控器信息出参
    public static class NET_OUT_GET_SUB_CONTROLLER_INFO extends SdkStructure
    {
        public int                           dwSize;
        public NET_SUB_CONTROLLER_INFO[]     stuSubControllerInfo =
                (NET_SUB_CONTROLLER_INFO[])new NET_SUB_CONTROLLER_INFO().toArray(MAX_ACCESSSUBCONTROLLER_NUM);  // 分控器信息
        public int                           nRetNum;                                            									         // 查询到的分控器数量

        public NET_OUT_GET_SUB_CONTROLLER_INFO() {
            this.dwSize = this.size();
        }
    }

    // 分控器信息
    public static class NET_SUB_CONTROLLER_INFO extends SdkStructure
    {
        public int                       nSubControllerID;                               		 // 分控器ID，取值范围 0~255,0为本地
        public byte[]                    szSubControllerName = new byte[MAX_COMMON_STRING_128];  // 分控器名称
        public int         	 			 emProperty;                                     		 // 门禁单双向, 对应枚举 NET_ACCESS_PROPERTY
        public byte[]                    szDeviceType = new byte[MAX_COMMON_STRING_128];         // 分控器型号
        public byte[]                    szVesion = new byte[MAX_COMMON_STRING_128];             // 分控器版本号
        public int                       nDoorNum;                                               // 门数量
        public NET_CARDREAD_INFO[]       stuReaderInfo =
                (NET_CARDREAD_INFO[])new NET_CARDREAD_INFO().toArray(MAX_ACCESSDOOR_NUM);   // 门对应的读卡器号
        public byte[]                    byReserved = new byte[128];
    }

    // 读卡器信息
    public static class NET_CARDREAD_INFO extends SdkStructure
    {
        public int                       nDoor;                                          	     // 门序号
        public int                       nReadNum;                                       		 // 读卡器数量
        public READ_ID[]                 szReadIDArr =
                (READ_ID[])new READ_ID().toArray(MAX_ACCESS_READER_NUM);// 读卡器ID
        public byte[]                    byReserved = new byte[64];
    }

    // 读卡器ID
    public static class READ_ID extends SdkStructure
    {
        public byte[]                    szReadID = new byte[NET_COMMON_STRING_32];  			// 读卡器ID
    }

    // 单双向
    public static class NET_ACCESS_PROPERTY extends SdkStructure
    {
        public static final int NET_EM_ACCESS_PROPERTY_UNKNOWN = 0;                             // 未知
        public static final int NET_EM_ACCESS_PROPERTY_BIDIRECT = 1;                            // 双向门禁
        public static final int NET_EM_ACCESS_PROPERTY_UNIDIRECT = 2;                           // 单向门径
    }


    // 门禁刷卡时间段，对此配置，通道号实际表示配置索引, 对应命令  CFG_CMD_ACCESSTIMESCHEDULE
    public static class CFG_ACCESS_TIMESCHEDULE_INFO extends SdkStructure
    {
        public TIME_SECTION_WEEK_DAY_4[]	stuTimeWeekDay =
                (TIME_SECTION_WEEK_DAY_4[])new TIME_SECTION_WEEK_DAY_4().toArray(WEEK_DAY_NUM); // 刷卡时间段
        public int					        bEnable;																	 	// 时间段使能开关， 1-true; 0-false
        public byte[]                    	szName = new byte[CFG_COMMON_STRING_128];                  				 	    // 自定义名称
    }

    // 普通配置 (CFG_CMD_DEV_GENERRAL) General
    public static class CFG_DEV_DISPOSITION_INFO extends SdkStructure
    {
        public int                      	nLocalNo;              				// 本机编号，主要用于遥控器区分不同设备	0~998
        public byte[]                     	szMachineName = new byte[256];    	// 机器名称或编号
        public byte[]                     	szMachineAddress = new byte[256]; 	// 机器部署地点即道路编码
        public byte[]                     	szMachineGroup = new byte[256];   	// 机器分组或叫设备所属单位	默认为空，用户可以将不同的设备编为一组，便于管理，可重复。
        public byte[]					 	szMachineID = new byte[64];			// 机器编号, 联网平台内唯一
        public int						 	nLockLoginTimes;					// 登陆失败可尝试次数
        public int						 	nLoginFailLockTime;    				// 登陆失败锁定时间
        public int					 		bLockLoginEnable;					// 登陆失败可尝试次数使能, 1-true; 0-false
        public byte[]		             	bReserved = new byte[948];        	// 保留字节
    }

    // 接口 CLIENT_StartVideoDiagnosis 的输入参数
    public static class NET_IN_VIDEODIAGNOSIS extends SdkStructure
    {
        public int                			dwSize;                         	// 此结构体大小
        public int                  		nDiagnosisID;                   	// 视频诊断ID,从0开始
        public int                			dwWaitTime;                     	// 接口超时等待时间
        public Callback  			cbVideoDiagnosis;               	// 视频诊断结果回调函数, 对应回调函数  fRealVideoDiagnosis
        public Pointer               		dwUser;                         	// 用户自定义参数

        public NET_IN_VIDEODIAGNOSIS() {
            this.dwSize = this.size();
        }
    }

    // 接口 CLIENT_StartVideoDiagnosis 的输出参数
    public static class NET_OUT_VIDEODIAGNOSIS extends SdkStructure
    {
        public int                			dwSize;                         	// 此结构体大小
        public LLong                		lDiagnosisHandle;               	// 订阅句柄

        public NET_OUT_VIDEODIAGNOSIS() {
            this.dwSize = this.size();
        }
    }

    // cbVideoDiagnosis 回调参数类型
    public static class NET_REAL_DIAGNOSIS_RESULT extends SdkStructure
    {
        public int                			dwSize;                         	// 此结构体大小
        public Pointer					    pstDiagnosisCommonInfo;  			// 视频诊断通用信息, 对应 NET_VIDEODIAGNOSIS_COMMON_INFO
        public int                  		nTypeCount;                     	// 诊断结果数据诊断类型个数
        public Pointer                		pDiagnosisResult;               	// 一次诊断结果数据, 大小为 dwBufSize, 格式如 NET_DIAGNOSIS_RESULT_HEADER+诊断类型1+NET_DIAGNOSIS_RESULT_HEADER+诊断类型2+...
        public int                			dwBufSize;                      	// 缓冲长度

        public NET_REAL_DIAGNOSIS_RESULT() {
            this.dwSize = this.size();
        }
    }

    public static class NET_DIAGNOSIS_RESULT_HEADER extends SdkStructure
    {
        public int                			dwSize;                         	  // 此结构体大小
        public byte[]                 		szDiagnosisType = new byte[MAX_PATH]; // 诊断类型,详见"视频诊断上报结果检测类型定义" 如 NET_DIAGNOSIS_DITHER
        public int                  		nDiagnosisTypeLen;              	  // 该诊断类型结构体大小

        public NET_DIAGNOSIS_RESULT_HEADER() {
            this.dwSize = this.size();
        }
    }

    // 视频诊断结果上报通用数据
    public static class NET_VIDEODIAGNOSIS_COMMON_INFO extends SdkStructure
    {
        public int                           dwSize;                                 // 此结构体大小
        public int                           nDiagnosisID;                           // 检测通道
        public NET_ARRAY                     stProject;                              // 计划名称
        public NET_ARRAY                     stTask;                                 // 任务名称
        public NET_ARRAY                     stProfile;                              // 参数表名称
        public NET_ARRAY                     stDeviceID;                             // 设备唯一标志
        public NET_TIME                      stStartTime;                            // 开始时间
        public NET_TIME                      stEndTime;                              // 结束时间
        public int                           nVideoChannelID;                        // 视频通道号 前端设备比如DVR,IPC的通道
        public int                 			 emVideoStream;                          // 视频码流, 参考  NET_STREAM_TYPE
        public int  						 emResultType;                           // 诊断结果类型, 参考 NET_VIDEODIAGNOSIS_RESULT_TYPE
        public int                           bCollectivityState;                     // 诊断结果, 1-true, 0-false
        public int    						 emFailedCause;                          // 失败原因, 参考 NET_VIDEODIAGNOSIS_FAIL_TYPE
        public byte[]                        szFailedCode = new byte[NET_COMMON_STRING_64];      // 失败原因描述
        public byte[]                        szResultAddress = new byte[NET_COMMON_STRING_128];  // 诊断结果存放地址
        public int                           nFrameRate;                             // 码率	单位 kb/s, 每天上报一次
        public int                           nFrameWidth;                            // 宽	每天上报一次
        public int                           nFrameHeight;                           // 高	每天上报一次
        public int						     nBackPic;								 // 背景图片个数
        public BACK_PICTURE_ADDRESS[]		 szBackPicAddressArr = (BACK_PICTURE_ADDRESS[])new BACK_PICTURE_ADDRESS().toArray(MAX_BACKPIC_COUNT);	// 背景图片路径列表
        public byte[]                        szResultAddressEx=new byte[NET_COMMON_STRING_256];  // 诊断结果存放地址扩展
        public NET_VIDEODIAGNOSIS_COMMON_INFO() {
            this.dwSize = this.size();
        }
    }

    // 背景图片路径
    public static class BACK_PICTURE_ADDRESS extends SdkStructure
    {
        public byte[]						 szBackPicAddress = new byte[NET_COMMON_STRING_128];	// 背景图片路径
    }

    // 通用变长字符串以‘\0’结束
    public static class NET_ARRAY extends SdkStructure
    {
        public int          				dwSize;                  	     // 此结构体大小
        public Pointer          			pArray;                 		 // 缓冲区 目前最小260字节,调用者申请内存 填充数据保证是'\0'结束
        public int         				    dwArrayLen;             		 // 缓冲空间长度

        public NET_ARRAY() {
            this.dwSize = this.size();
        }
    }

    // 视频码流类型
    public static class NET_STREAM_TYPE extends SdkStructure
    {
        public static final int NET_EM_STREAM_ERR = 0;                      // 其它
        public static final int NET_EM_STREAM_MAIN = 1;                     // "Main"-主码流
        public static final int NET_EM_STREAM_EXTRA_1 = 2;                  // "Extra1"-辅码流1
        public static final int NET_EM_STREAM_EXTRA_2 = 3;                  // "Extra2"-辅码流2
        public static final int NET_EM_STREAM_EXTRA_3 = 4;                  // "Extra3"-辅码流3
        public static final int NET_EM_STREAM_SNAPSHOT = 5;                 // "Snapshot"-抓图码流
        public static final int NET_EM_STREAM_OBJECT = 6;                   // "Object"-物体流
        public static final int NET_EM_STREAM_AUTO = 7;                     // "Auto"-自动选择合适码流
        public static final int NET_EM_STREAM_PREVIEW = 8;                  // "Preview"-预览裸数据码流
        public static final int NET_EM_STREAM_NONE = 9;                     // 无视频码流(纯音频)
    }

    // 视频诊断结果类型
    public static class NET_VIDEODIAGNOSIS_RESULT_TYPE extends SdkStructure
    {
        public static final int NET_EM_ROTATION = 0;                        // "Rotation" -视频轮巡分析结果
        public static final int NET_EM_REAL = 1;                            // "Real" -实时视频分析结果
        public static final int NET_EM_NR_UNKNOW = 2;                       // 未定义
    }

    //视频诊断错误原因
    public static class NET_VIDEODIAGNOSIS_FAIL_TYPE extends SdkStructure
    {
        public static final int NET_EM_NO_ERROR = 0;                        // 诊断成功
        public static final int NET_EM_DISCONNECT = 1;                      // "Disconnect" - 末能连接设备
        public static final int NET_EM_CH_NOT_EXIST = 2;                    // "ChannelNotExist" - 通道不存在
        public static final int NET_EM_LOGIN_OVER_TIME = 3;                 // "LoginOverTime" - 登录超时
        public static final int NET_EM_NO_VIDEO = 4;                        // "NoVideo" - 登录成功无视频
        public static final int NET_EM_NO_RIGHT = 5;                        // "NoRight" - 无操作权限
        public static final int NET_EM_PLATFROM_LOGIN_FAILED = 6;           // "PlatformLoginFailed" - 平台登入失败
        public static final int NET_EM_PLATFROM_DISCONNECT = 7;             // "PlatformDisconnect" - 平台断开连接
        public static final int NET_EM_GET_STREAM_OVER_TIME = 8;            // "GetStreamOverTime" - 获取码流超时
        public static final int NET_EM_GET_NO_ENOUGH_STREAM = 9;            // "NoEnoughStream" - 码流不足
        public static final int NET_EM_DECODE_STREAM_FAILED = 10;           // "DecodeStreamFailed" - 解码失败
        public static final int NET_EM_GET_OFF_LINE = 11;                   // "OffLine" - 前端设备离线
        public static final int NET_EM_NF_UNKNOW = 12;                      // 其他原因,详见结构体里的失败原因描述
        public static final int NET_EM_NOT_SD = 13;                         // "NotSD" - 设备非球机，云台类检测无效
    }

    // 接口 CLIENT_StartFindDiagnosisResult 的输入参数
    public static class NET_IN_FIND_DIAGNOSIS extends SdkStructure
    {
        public int                	dwSize;                         		// 此结构体大小
        public int                  nDiagnosisID;                   		// 视频诊断ID,从0开始
        public int                	dwWaitTime;                     		// 接口超时等待时间
        public NET_ARRAY            stuDeviceID;                    		// 设备唯一标志,pArray : null表示不使用设备ID查询
        public NET_TIME             stuStartTime;                   		// 开始时间
        public NET_TIME             stuEndTime;                     		// 结束时间
        public int                  nVideoChannel;                  		// 视频通道号,-1:所有通道号
        public int                  nTypeCount;                     		// 诊断类型个数,0:不使用诊断类型查询
        public Pointer          	pstDiagnosisTypes;              		// 诊断类型数组,表示需要查询的诊断类型, 对应 NET_ARRAY[]
        // 由用户申请内存，大小为sizeof(NET_ARRAY)*nTypeCount
        public byte[]               szProjectName = new byte[MAX_PATH];     // 计划名称
        public int                  nCollectivityStateNum;                  // 需要查询的诊断结果状态个数, 为0时表示需要查询的诊断结果类型为成功
        public int[]                emCollectivityState=new int[2];         // 需要查询的诊断结果状态数组, 表示需要查询的诊断结果类型,对应枚举EM_COLLECTIVITY_STATE
        public NET_IN_FIND_DIAGNOSIS() {
            this.dwSize = this.size();
        }
    }

    // 接口 CLIENT_StartFindDiagnosisResult 的输出参数
    public static class NET_OUT_FIND_DIAGNOSIS extends SdkStructure
    {
        public int                	dwSize;                         		// 此结构体大小
        public LLong                lFindHandle;                    		// 查询句柄
        public int                	dwTotalCount;                   		// 符合条件的总个数

        public NET_OUT_FIND_DIAGNOSIS() {
            this.dwSize = this.size();
        }
    }

    // 接口 CLIENT_DoFindDiagnosisResult 的输入参数
    public static class NET_IN_DIAGNOSIS_INFO extends SdkStructure
    {
        public int                	dwSize;                         		// 此结构体大小
        public int                  nDiagnosisID;                   		// 视频诊断ID,从0开始
        public int                	dwWaitTime;                     		// 接口超时等待时间
        public int                  nFindCount;                     		// 每次查询的视频诊断结果条数
        public int                  nBeginNumber;                   		// 查询起始序号 0<=beginNumber<= totalCount-1

        public NET_IN_DIAGNOSIS_INFO() {
            this.dwSize = this.size();
        }
    }

    // 接口 CLIENT_DoFindDiagnosisResult 的输出参数
    public static class NET_OUT_DIAGNOSIS_INFO extends SdkStructure
    {
        public int                  dwSize;                         		// 此结构体大小
        public int                  nInputNum;                      		// 用户分配的 NET_VIDEODIAGNOSIS_RESULT_INFO 个数
        public int                  nReturnNum;                    			// 返回结果个数
        public Pointer  			pstDiagnosisResult; 					// 结果数据  结构体指针需要调用者分配, 对应 NET_VIDEODIAGNOSIS_RESULT_INFO[]
        // 申请内存大小为sizeof(NET_VIDEODIAGNOSIS_RESULT_INFO)*nInputNum

        public NET_OUT_DIAGNOSIS_INFO() {
            this.dwSize = this.size();
        }
    }

    public static class NET_VIDEODIAGNOSIS_RESULT_INFO extends SdkStructure
    {
        public int                  dwSize;                                	// 此结构体大小

        public Pointer       	    pstDiagnosisCommonInfo;					// 视频诊断通用信息  以下结构体指针需要调用者分配, 对应 NET_VIDEODIAGNOSIS_COMMON_INFO

        public int                  abDither;                              	// 用于表示此次结果中这个诊断项是否有效, 1-true, 0-false
        public Pointer     			pstDither;             					// 视频抖动检测, 对应  NET_VIDEO_DITHER_DETECTIONRESULT

        public int                  abStration;							    // 用于表示此次结果中这个诊断项是否有效, 1-true, 0-false
        public Pointer  			pstStration;           					// 视频条纹检测, 对应  NET_VIDEO_STRIATION_DETECTIONRESULT

        public int                  abLoss;								    // 用于表示此次结果中这个诊断项是否有效, 1-true, 0-false
        public Pointer       		pstLoss;              				    // 视频丢失检测, 对应  NET_VIDEO_LOSS_DETECTIONRESULT

        public int                  abCover;								// 用于表示此次结果中这个诊断项是否有效, 1-true, 0-false
        public Pointer      		pstCover;              					// 视频遮挡检测, 对应 NET_VIDEO_COVER_DETECTIONRESULT

        public int                  abFrozen;								// 用于表示此次结果中这个诊断项是否有效, 1-true, 0-false
        public Pointer     			pstFrozen;             					// 视频冻结检测, 对应 NET_VIDEO_FROZEN_DETECTIONRESULT

        public int                  abBrightness;							// 用于表示此次结果中这个诊断项是否有效, 1-true, 0-false
        public Pointer 				pstBrightness;         					// 视频亮度异常检测, 对应  NET_VIDEO_BRIGHTNESS_DETECTIONRESULT

        public int                  abContrast;								// 用于表示此次结果中这个诊断项是否有效, 1-true, 0-false
        public Pointer   			pstContrast;           					// 视频对比度异常检测, 对应  NET_VIDEO_CONTRAST_DETECTIONRESULT

        public int                  abUnbalance;							// 用于表示此次结果中这个诊断项是否有效, 1-true, 0-false
        public Pointer  			pstUnbalance;          					// 视频偏色检测, 对应 NET_VIDEO_UNBALANCE_DETECTIONRESULT

        public int                  abNoise;								// 用于表示此次结果中这个诊断项是否有效, 1-true, 0-false
        public Pointer      		pstNoise;              					// 视频噪声检测, 对应 NET_VIDEO_NOISE_DETECTIONRESULT

        public int                  abBlur;									// 用于表示此次结果中这个诊断项是否有效, 1-true, 0-false
        public Pointer       		pstBlur;               					// 视频模糊检测, 对应  NET_VIDEO_BLUR_DETECTIONRESULT

        public int                  abSceneChange;							// 用于表示此次结果中这个诊断项是否有效, 1-true, 0-false
        public Pointer 				pstSceneChange;       					// 视频场景变化检测, 对应 NET_VIDEO_SCENECHANGE_DETECTIONRESULT

        public int                  abVideoDelay;							// 用于表示此次结果中这个诊断项是否有效, 1-true, 0-false
        public Pointer       		pstVideoDelay;         					// 视频延迟检测, 对应 NET_VIDEO_DELAY_DETECTIONRESUL

        public int                  abPTZMoving;							// 用于表示此次结果中这个诊断项是否有效, 1-true, 0-false
        public Pointer       		pstPTZMoving;          					// 云台操作检测, 对应 NET_PTZ_MOVING_DETECTIONRESULT

        public int					abBlackAndWhite;						// 用于表示此次结果中这个诊断项是否有效, 1-true, 0-false
        public Pointer	  			pstBlackAndWhite;		    			// 黑白图像检测, 对应  NET_BLACK_WHITE_DETECTIONRESULT

        public int					abDramaticChange;						// 用于表示此次结果中这个诊断项是否有效, 1-true, 0-false
        public Pointer 				pstDramaticChange;						// 场景剧变检测, 对应  NET_DIAGNOSIS_DRAMATIC_DETECTIONRESULT
        public boolean				abVideoAvailability;                    // 是否支持视频完好率监测
        public Pointer              pstVideoAvailability;	                // 视频完好率监测结果,对应NET_VIDEO_AVAILABILITY_DETECTIONRESULT

        public boolean              abSnowflake;                            // 是否支持雪花屏检测
        public Pointer              pstSnowflake;                           // 雪花屏检测,对应NET_VIDEO_SNOWFLAKE_DETECTIONRESULT
        public NET_VIDEODIAGNOSIS_RESULT_INFO() {
            this.dwSize = this.size();
        }
    }

    // 对应检测类型(NET_DIAGNOSIS_DITHER) 视频抖动检测结果 -- 画面变化 风吹,晃动,转动包括云台转动
    public static class NET_VIDEO_DITHER_DETECTIONRESULT extends SdkStructure
    {
        public int                	dwSize;                         		// 此结构体大小
        public int                  nValue;                         		// 检测结果量化值
        public int       			emState;                        		// 检测结果状态  一般小于是正常,大于是异常,中间是警告, 参考  NET_STATE_TYPE
        public int                  nDuration;                      		// 状态持续时间  检测项持续检测时间 暂时无用

        public NET_VIDEO_DITHER_DETECTIONRESULT() {
            this.dwSize = this.size();
        }
    }

    public static class NET_STATE_TYPE extends SdkStructure
    {
        public static final int NET_EM_STATE_ERR = 0;        				// 其它
        public static final int NET_EM_STATE_NORMAL = 1;     				// "Normal" 正常
        public static final int NET_EM_STATE_WARNING = 2;    				// "Warning" 警告
        public static final int NET_EM_STATE_ABNORMAL = 3;   				// "Abnormal" 异常
    }

    // 对应检测类型(NET_DIAGNOSIS_STRIATION)视频条纹检测结果 -- 相机受到干扰出现异常条纹
    public static class NET_VIDEO_STRIATION_DETECTIONRESULT extends SdkStructure
    {
        public int                	dwSize;                         		// 此结构体大小
        public int                  nValue;                         		// 检测结果量化值
        public int       			emState;                        		// 检测结果状态, 参考  NET_STATE_TYPE
        public int                  nDuration;                      		// 状态持续时间

        public NET_VIDEO_STRIATION_DETECTIONRESULT() {
            this.dwSize = this.size();
        }
    }

    // 对应检测类型(NET_DIAGNOSIS_LOSS)视频丢失检测结果 -- 断电 断线等造成的
    public static class NET_VIDEO_LOSS_DETECTIONRESULT extends SdkStructure
    {
        public int                	dwSize;                         		// 此结构体大小
        public int       			emState;                        		// 检测结果状态, 参考 NET_STATE_TYPE
        public int                  nDuration;                     		 	// 状态持续时间

        public NET_VIDEO_LOSS_DETECTIONRESULT() {
            this.dwSize = this.size();
        }
    }

    // 对应检测类型(NET_DIAGNOSIS_COVER)视频遮挡检测结果 -- 相机被遮挡了
    public static class NET_VIDEO_COVER_DETECTIONRESULT extends SdkStructure
    {
        public int                	dwSize;                         		// 此结构体大小
        public int                  nValue;                         		// 检测结果量化值
        public int       			emState;                        		// 检测结果状态, 参考 NET_STATE_TYPE
        public int                  nDuration;                      		// 状态持续时间

        public NET_VIDEO_COVER_DETECTIONRESULT() {
            this.dwSize = this.size();
        }
    }

    // 对应检测类型(NET_DIAGNOSIS_FROZEN)视频冻结检测结果 -- 画面不动多久为冻结
    public static class NET_VIDEO_FROZEN_DETECTIONRESULT extends SdkStructure
    {
        public int                	dwSize;                         		// 此结构体大小
        public int       			emState;                        		// 检测结果状态, 参考 NET_STATE_TYPE
        public int                  nDuration;                      		// 状态持续时间

        public NET_VIDEO_FROZEN_DETECTIONRESULT() {
            this.dwSize = this.size();
        }
    }

    // 对应检测类型(NET_DIAGNOSIS_BRIGHTNESS)视频亮度异常检测结果 --以下是相机配置不正确的一些现象检测
    public static class NET_VIDEO_BRIGHTNESS_DETECTIONRESULT extends SdkStructure
    {
        public int                	dwSize;                         		// 此结构体大小
        public int                  nValue;                         		// 检测结果量化值
        public int       			emState;                        		// 检测结果状态, 参考 NET_STATE_TYPE
        public int                  nDuration;                      		// 状态持续时间

        public NET_VIDEO_BRIGHTNESS_DETECTIONRESULT() {
            this.dwSize = this.size();
        }
    }

    // 对应检测类型(NET_DIAGNOSIS_CONTRAST)视频对比度异常检测结果
    public static class NET_VIDEO_CONTRAST_DETECTIONRESULT extends SdkStructure
    {
        public int                	dwSize;                         		// 此结构体大小
        public int                  nValue;                         		// 检测结果量化值
        public int       			emState;                        		// 检测结果状态, 参考 NET_STATE_TYPE
        public int                  nDuration;                      		// 状态持续时间

        public NET_VIDEO_CONTRAST_DETECTIONRESULT() {
            this.dwSize = this.size();
        }
    }

    // 对应检测类型(NET_DIAGNOSIS_UNBALANCE)视频偏色异常检测结果
    public static class NET_VIDEO_UNBALANCE_DETECTIONRESULT extends SdkStructure
    {
        public int                	dwSize;                         		// 此结构体大小
        public int                  nValue;                         		// 检测结果量化值
        public int       			emState;                        		// 检测结果状态, 参考 NET_STATE_TYPE
        public int                  nDuration;                      		// 状态持续时间

        public NET_VIDEO_UNBALANCE_DETECTIONRESULT() {
            this.dwSize = this.size();
        }
    }

    // 对应检测类型(NET_DIAGNOSIS_NOISE)视频噪声异常检测结果
    public static class NET_VIDEO_NOISE_DETECTIONRESULT extends SdkStructure
    {
        public int                	dwSize;                         		// 此结构体大小
        public int                  nValue;                         		// 检测结果量化值
        public int       			emState;                        		// 检测结果状态, 参考 NET_STATE_TYPE
        public int                  nDuration;                      		// 状态持续时间

        public NET_VIDEO_NOISE_DETECTIONRESULT() {
            this.dwSize = this.size();
        }
    }

    // 对应检测类型(NET_DIAGNOSIS_BLUR)视频模糊异常检测结果
    public static class NET_VIDEO_BLUR_DETECTIONRESULT extends SdkStructure
    {
        public int                	dwSize;                         		// 此结构体大小
        public int                  nValue;                         		// 检测结果量化值
        public int       			emState;                        		// 检测结果状态, 参考 NET_STATE_TYPE
        public int                  nDuration;                      		// 状态持续时间

        public NET_VIDEO_BLUR_DETECTIONRESULT() {
            this.dwSize = this.size();
        }
    }

    // 对应检测类型(NET_DIAGNOSIS_SCENECHANGE)视频场景变化检测结果
    public static class NET_VIDEO_SCENECHANGE_DETECTIONRESULT extends SdkStructure
    {
        public int                	dwSize;                         		// 此结构体大小
        public int                  nValue;                         		// 检测结果量化值
        public int       			emState;                        		// 检测结果状态, 参考 NET_STATE_TYPE
        public int                  nDuration;                     	 		// 状态持续时间

        public NET_VIDEO_SCENECHANGE_DETECTIONRESULT() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_DeleteDevConfig 输入参数
    public static class NET_IN_DELETECFG extends SdkStructure
    {
        public int         			dwSize;                       			// 结构体大小
        public String        		szCommand;                    			// 配置命令

        public NET_IN_DELETECFG() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_DeleteDevConfig 输出参数
    public static class NET_OUT_DELETECFG extends SdkStructure
    {
        public int         			dwSize;                       			// 结构体大小
        public int           		nError;                       			// 设备返回的错误码
        public int           		nRestart;                     			// 设备是否重启
        public int         			dwOptionMask;                 			// 选项 具体见枚举 NET_EM_CONFIGOPTION

        public NET_OUT_DELETECFG() {
            this.dwSize = this.size();
        }
    }

    public static class NET_EM_CONFIGOPTION extends SdkStructure
    {
        public static final int NET_EM_CONFIGOPTION_OK = 0;
        public static final int NET_EM_CONFIGOPTION_NEEDRESTART = 1;       // 需要重启应用程序
        public static final int NET_EM_CONFIGOPTION_NEEDREBOOT = 2;		   // 需要重启系统
        public static final int NET_EM_CONFIGOPTION_WRITEFILEERROR = 4;    // 写文件出错
        public static final int NET_EM_CONFIGOPTION_CAPSNOTSUPPORT = 8;    // 设备特性不支持
        public static final int NET_EM_CONFIGOPTION_VALIDATEFAILED = 16;   // 配置校验失败
    }

    // CLIENT_GetMemberNames 输入参数
    public static class NET_IN_MEMBERNAME extends SdkStructure
    {
        public int         		    dwSize;                       		   // 结构体大小
        public String         		szCommand;                    		   // 配置命令

        public NET_IN_MEMBERNAME() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_GetMemberNames 输出参数
    public static class NET_OUT_MEMBERNAME extends SdkStructure
    {
        public int         			dwSize;                       		  // 结构体大小
        public int           		nError;                       		  // 设备返回的错误码
        public int           		nRestart;                     		  // 设备是否重启
        public int           		nTotalNameCount;              		  // 名称个数 通过能力集得到,调用者填写
        public int           		nRetNameCount;                		  // 返回的实际名称个数
        public Pointer     			pstNames;                     		  // 名称数组 调用者申请内存,个数是 nTotalNameCount 个 NET_ARRAY
        // 由用户申请内存，大小为sizeof(NET_ARRAY)*nTotalNameCount

        public NET_OUT_MEMBERNAME() {
            this.dwSize = this.size();
        }
    }

    // 视频诊断参数表(CFG_CMD_VIDEODIAGNOSIS_PROFILE)，支持多种参数表，用表名称来索引   调用者申请内存并初始化
    public static class CFG_VIDEODIAGNOSIS_PROFILE extends SdkStructure
    {
        public int						nTotalProfileNum;					// 调用者分配参数表数 根据能力集获取
        public int						nReturnProfileNum;					// 返回的实际参数表数
        public Pointer					pstProfiles;						// 调用者分配 nTotalProfileNum 个 CFG_VIDEO_DIAGNOSIS_PROFILE
    }

    public static class CFG_VIDEO_DIAGNOSIS_PROFILE extends SdkStructure
    {
        public byte[]					szName = new byte[MAX_PATH];		// 名称Ansi编码

        public Pointer					pstDither;							// 视频抖动检测, 对应 CFG_VIDEO_DITHER_DETECTION
        public Pointer 					pstStriation;						// 视频条纹检测, 对应  CFG_VIDEO_STRIATION_DETECTION
        public Pointer 					pstLoss;							// 视频丢失检测, 对应  CFG_VIDEO_LOSS_DETECTION
        public Pointer 					pstCover;							// 视频遮挡检测, 对应  CFG_VIDEO_COVER_DETECTION
        public Pointer 					pstFrozen;							// 视频冻结检测, 对应  CFG_VIDEO_FROZEN_DETECTION
        public Pointer 					pstBrightness;						// 视频亮度异常检测, 对应  CFG_VIDEO_BRIGHTNESS_DETECTION
        public Pointer 					pstContrast;						// 对比度异常检测, 对应  CFG_VIDEO_CONTRAST_DETECTION
        public Pointer 					pstUnbalance;						// 偏色异常检测, 对应  CFG_VIDEO_UNBALANCE_DETECTION
        public Pointer 					pstNoise;							// 噪声检测, 对应  CFG_VIDEO_NOISE_DETECTION
        public Pointer 					pstBlur;							// 模糊检测, 对应  CFG_VIDEO_BLUR_DETECTION
        public Pointer 					pstSceneChange;						// 场景变化检测, 对应  CFG_VIDEO_SCENECHANGE_DETECTION
        public Pointer        			pstVideoDelay;                      // 视频延时检测, 对应  CFG_VIDEO_DELAY_DETECTION
        public Pointer         			pstPTZMoving;                       // 云台移动检测, 对应  CFG_PTZ_MOVING_DETECTION
        public Pointer 	 				pstBlackAndWhite;					// 黑白图像检测, 对应  CFG_VIDEO_BLACKWHITE_DETECTION
        public Pointer 					pstDramaticChange;				    // 场景剧变检测, 对应  CFG_VIDEO_DRAMATICCHANGE_DETECTION
        public Pointer	                pstVideoAvailability;			    // 视频完好率监测,对应 CFG_VIDEO_AVAILABILITY_DETECTION
        public Pointer                  pstSnowflake;                       // 雪花屏检测,对应 CFG_VIDEO_SNOWFLAKE_DETECTION
    }

    ///////////////////////////////////视频诊断参数配置///////////////////////////////////////
    // 视频抖动检测
    public static class CFG_VIDEO_DITHER_DETECTION extends SdkStructure
    {
        public int						bEnable;							// 使能配置, 1-true, 0-false
        public int						nMinDuration;						// 最短持续时间 单位：秒 0~65535
        public byte						byThrehold1;						// 预警阀值 取值1-100
        public byte						byThrehold2;						// 报警阀值 取值1-100
    }

    // 条纹检测
    public static class CFG_VIDEO_STRIATION_DETECTION extends SdkStructure
    {
        public int						bEnable;							// 使能配置, 1-true, 0-false
        public int						nMinDuration;						// 最短持续时间 单位：秒 0~65535
        public byte						byThrehold1;						// 预警阀值 取值1-100
        public byte						byThrehold2;						// 报警阀值 取值1-100
        public byte[]					byReserved1 = new byte[2];			// 字节对齐
        public int						bUVDetection;						// UV分量是否检测, 1-true, 0-false
    }

    // 视频丢失检测
    public static class CFG_VIDEO_LOSS_DETECTION extends SdkStructure
    {
        public int						bEnable;							// 使能配置, 1-true, 0-false
        public int						nMinDuration;						// 最短持续时间 单位：秒 0~65535
    }

    // 视频遮挡检测
    public static class CFG_VIDEO_COVER_DETECTION extends SdkStructure
    {
        public int						bEnable;							// 使能配置, 1-true, 0-false
        public int						nMinDuration;						// 最短持续时间 单位：秒 0~65535
        public byte						byThrehold1;						// 预警阀值 取值1-100
        public byte						byThrehold2;						// 报警阀值 取值1-100
    }

    // 画面冻结检测
    public static class CFG_VIDEO_FROZEN_DETECTION extends SdkStructure
    {
        public int						bEnable;							// 使能配置, 1-true, 0-false
        public int						nMinDuration;						// 最短持续时间 单位：秒 0~65535
    }

    // 亮度异常检测
    public static class CFG_VIDEO_BRIGHTNESS_DETECTION extends SdkStructure
    {
        public int						bEnable;							// 使能配置, 1-true, 0-false
        public int						nMinDuration;						// 最短持续时间 单位：秒 0~65535
        public byte						bylowerThrehold1;					// 预警阀值 取值1-100
        public byte						bylowerThrehold2;					// 报警阀值 取值1-100
        public byte						byUpperThrehold1;					// 预警阀值 取值1-100
        public byte						byUpperThrehold2;					// 报警阀值 取值1-100
    }

    // 对比度异常检测
    public static class CFG_VIDEO_CONTRAST_DETECTION extends SdkStructure
    {
        public int						bEnable;							// 使能配置, 1-true, 0-false
        public int						nMinDuration;						// 最短持续时间 单位：秒 0~65535
        public byte						bylowerThrehold1;					// 预警阀值 取值1-100
        public byte						bylowerThrehold2;					// 报警阀值 取值1-100
        public byte						byUpperThrehold1;					// 预警阀值 取值1-100
        public byte						byUpperThrehold2;					// 报警阀值 取值1-100
    }

    // 偏色检测
    public static class CFG_VIDEO_UNBALANCE_DETECTION extends SdkStructure
    {
        public int						bEnable;							// 使能配置, 1-true, 0-false
        public int						nMinDuration;						// 最短持续时间 单位：秒 0~65535
        public byte						byThrehold1;						// 预警阀值 取值1-100
        public byte						byThrehold2;						// 报警阀值 取值1-100
    }

    // 噪声检测
    public static class CFG_VIDEO_NOISE_DETECTION extends SdkStructure
    {
        public int						bEnable;							// 使能配置, 1-true, 0-false
        public int						nMinDuration;						// 最短持续时间 单位：秒 0~65535
        public byte					    byThrehold1;						// 预警阀值 取值1-100
        public byte						byThrehold2;						// 报警阀值 取值1-100
    }

    // 模糊检测
    public static class CFG_VIDEO_BLUR_DETECTION extends SdkStructure
    {
        public int						bEnable;							// 使能配置, 1-true, 0-false
        public int						nMinDuration;						// 最短持续时间 单位：秒 0~65535
        public byte						byThrehold1;						// 预警阀值 取值1-100
        public byte						byThrehold2;						// 报警阀值 取值1-100
    }

    // 场景变化检测
    public static class CFG_VIDEO_SCENECHANGE_DETECTION extends SdkStructure
    {
        public int						bEnable;							// 使能配置, 1-true, 0-false
        public int						nMinDuration;						// 最短持续时间 单位：秒 0~65535
        public byte					    byThrehold1;						// 预警阀值 取值1-100
        public byte						byThrehold2;						// 报警阀值 取值1-100
    }

    // 视频延时检测
    public static class CFG_VIDEO_DELAY_DETECTION extends SdkStructure
    {
        public int    					bEnable;                			// 使能配置, 1-true, 0-false
    }

    // 云台移动检测
    public static class CFG_PTZ_MOVING_DETECTION extends SdkStructure
    {
        public int    					bEnable;                			// 使能配置, 1-true, 0-false
    }

    // 黑白图像检测
    public static class CFG_VIDEO_BLACKWHITE_DETECTION extends SdkStructure
    {
        public int						bEnable;							// 使能配置, 1-true, 0-false
        public int						nEarlyWarning;						// 预警阈值
        public int						nAlarm;								// 报警阈值
        public int						nMinDuration;						// 最短持续时间
    }

    // 场景剧变检测
    public static class CFG_VIDEO_DRAMATICCHANGE_DETECTION extends SdkStructure
    {
        public int						bEnable;							// 使能配置, 1-true, 0-false
        public int						nEarlyWarning;						// 预警阈值
        public int						nAlarm;								// 报警阈值
        public int						nMinDuration;						// 最短持续时间
    }

    // 视频诊断任务表(CFG_CMD_VIDEODIAGNOSIS_TASK),不同的任务通过名子索引  调用者申请内存并初始化
    public static class CFG_VIDEODIAGNOSIS_TASK extends SdkStructure
    {
        public int						nTotalTaskNum; 						// 调用者分配任务个数  根据能力集获取
        public int						nReturnTaskNum; 					// 返回实际任务个数
        public Pointer					pstTasks;							// 任务配置 调用者分配内存 nTotalTaskNum 个 CFG_DIAGNOSIS_TASK
    }

    public static class CFG_DIAGNOSIS_TASK extends SdkStructure
    {
        public byte[]					szTaskName = new byte[MAX_PATH];	// 任务名称Ansi编码
        public byte[]					szProfileName = new byte[MAX_PATH]; // 本任务使用的诊断参数表名Ansi编码
        public int						nTotalSourceNum;					// 调用者分配任务数据源的个数  根据能力集获取
        public int						nReturnSourceNum;					// 返回实际任务数据源的个数
        public Pointer					pstSources;							// 任务数据源 调用者分配内存 nTotalSourceNum 个 CFG_TAST_SOURCES
    }

    public static class CFG_TAST_SOURCES extends SdkStructure
    {
        // 能力
        public byte						abDeviceID;                         // abDeviceID(使用szDeviceID) 和 abRemoteDevice(使用stRemoteDevice) 必须有一个为true，否则Sources是null
        public byte						abRemoteDevice;

        public byte[]					szDeviceID = new byte[MAX_PATH];	// 设备ID
        public CFG_TASK_REMOTEDEVICE    stRemoteDevice = new CFG_TASK_REMOTEDEVICE();   // 设备详细信息
        public int						nVideoChannel;						// 视频通道号
        public int						emVideoStream;						// 视频码流类型, 参考 CFG_EM_STREAM_TYPE
        public int						nDuration;							// 持续诊断时间
        public int                      abStartTime;                        // 0 表示源为实时码流, stuStartTime字段无效; 1表示源为录像文件, stuStartTime字段有效
        public CFG_NET_TIME             stuStartTime;                       // 当abStartTime为TRUE时有效，表示源不是实时监视码流, 而是录像文件，该时间表示要分析的录像的开始时间
        // stuStartTime字段作废，后续都使用stuDiagnosisRecordInfo，保留此字段只为兼容老设备
        public boolean                  abDiagnosisRecordInfo;                      // 表示stuDiagnosisRecordInfo字段是否有效; 若源为录像文件则设置为TRUE, 否则设置成FALSE.
        public NET_VIDEO_DIAGNOSIS_RECORD_INFO stuDiagnosisRecordInfo;                     // 视频诊断录像信息, 当 abDiagnosisRecordInfo 为TRUE有效
        public int                      emSourceInputType;                       // 视频源输入方式,EM_VIDEO_CHANNEL_SOURCE_INPUT_TYPE
    }

    // 设备详细信息
    public static class CFG_TASK_REMOTEDEVICE extends SdkStructure
    {
        public byte[]                   szAddress = new byte[MAX_PATH];     // 设备地址或域名
        public int                    	dwPort;                             // 端口号
        public byte[]                   szUserName = new byte[MAX_PATH];    // 用户名
        public byte[]                   szPassword = new byte[MAX_PATH];    // 密码明文
        public byte[]                   szProtocolType = new byte[MAX_PATH];// 连接设备的协议类型
        public Pointer      			pVideoInput;                		// 视频输入通道，用户申请nMaxVideoInputs 个 CFG_RemoteDeviceVideoInput
        public int				        nMaxVideoInputs;					// 视频输入通道最大数
        public int				        nRetVideoInputs;					// 返回的视频输入通道数
    }

    public static class CFG_EM_STREAM_TYPE extends SdkStructure
    {
        public static final int CFG_EM_STREAM_ERR = 0;                  	// 其它
        public static final int CFG_EM_STREAM_MAIN = 1;						// "Main"-主码流
        public static final int CFG_EM_STREAM_EXTRA_1 = 2;					// "Extra1"-辅码流1
        public static final int CFG_EM_STREAM_EXTRA_2 = 3;					// "Extra2"-辅码流2
        public static final int CFG_EM_STREAM_EXTRA_3 = 4;					// "Extra3"-辅码流3
        public static final int CFG_EM_STREAM_SNAPSHOT = 5;					// "Snapshot"-抓图码流
        public static final int CFG_EM_STREAM_OBJECT = 6;					// "Object"-物体流
    }

    // 频诊断计划表(CFG_CMD_VIDEODIAGNOSIS_PROJECT),不同的计划通过名字索引 调用者申请内存并初始化
    public static class CFG_VIDEODIAGNOSIS_PROJECT extends SdkStructure
    {
        public int						nTotalProjectNum;					// 调用者分配计划个数  根据能力集获取
        public int						nReturnProjectNum;					// 返回实际计划个数
        public Pointer					pstProjects;						// 计划配置 调用者分配内存 nTotalProjectNum 个 CFG_DIAGNOSIS_PROJECT
    }

    public static class CFG_DIAGNOSIS_PROJECT extends SdkStructure
    {
        public byte[]					szProjectName = new byte[MAX_PATH]; // 计划名称Ansi编码
        public int						nTotalTaskNum;						// 调用者分配任务列表个数  根据能力集获取
        public int						nReturnTaskNum;					    // 返回实际任务列表个数
        public Pointer					pstProjectTasks;					// 任务列表 调用者分配内存 nTotalTaskNum 个 CFG_PROJECT_TASK
    }

    // 视频诊断计划
    public static class CFG_PROJECT_TASK extends SdkStructure
    {
        public int						 bEnable;							// 任务是否使能, 1-true, 0-false
        public byte[]					 szTaskName = new byte[MAX_PATH];	// 任务名称Ansi编码
        public TIME_SECTION_WEEK_DAY_6[] stTimeSectionWeekDay =
                (TIME_SECTION_WEEK_DAY_6[])new TIME_SECTION_WEEK_DAY_6().toArray(WEEK_DAY_NUM);	// 任务时间段
        public int                       bIsCycle;                          // 任务是否循环, 1表示循环, 0表示不循环
    }

    // 获取视频诊断进行状态( CFG_CMD_VIDEODIAGNOSIS_GETSTATE )对应结构体
    public static class CFG_VIDEODIAGNOSIS_STATE_INFO extends SdkStructure
    {
        public int                      bEnable;                               // 是否使能, 1-true, 0-false
        public int                      bRunning;                              // 是否正在运行, 1-true, 0-false, 使能开启，并且当前有工作任务正在进行，没有错误发生。
        public byte[]                   szCurrentProject = new byte[MAX_PATH]; // 当前计划名称
        public byte[]                   szCurrentTask = new byte[MAX_PATH];    // 当前任务名称
        public byte[]                   szCurrentProfile = new byte[MAX_PATH]; // 当前任务配置参数表名称
        public int                      nCurrentSourceCount;                   // 当前任务轮训视频源个数
        public int                      nCurrentSourceIndex;                   // 当前任务当前视频源序号	从0开始
        public CFG_TIME_SECTION         stCurrentTimeSection;                  // 当前计划时间段
        public int                      nTaskCountOfProject;                   // 当前计划总任务数
        public int                      nIndexOfCurrentTask;                   // 当前任务序号 从0开始
        public int                      emTaskState;                           // 任务运行状态,对应枚举EM_VIDEODIAGNOSIS_TASK_STATE
    }


    // 云台支持能力信息( CFG_CAP_CMD_PTZ_ENABLE )对应结构体
    public static class CFG_CAP_PTZ_ENABLEINFO extends SdkStructure
    {
        public int bEnable;												//该通道是否支持云台
    }

    // CLIENT_GetVideoDiagnosisState 入参
    public static class NET_IN_GET_VIDEODIAGNOSIS_STATE extends SdkStructure
    {
        public int				        dwSize;                                //  结构体大小
        public byte[]                  szProject = new byte[128];             //  计划名，为空表示所有执行的计划

        public NET_IN_GET_VIDEODIAGNOSIS_STATE() {
            this.dwSize = this.size();
        }
    }

    // 诊断状态
    public static class VIDEODIAGNOSIS_STATE extends SdkStructure
    {
        public int                      bEnable;                               // 是否使能
        public int                      bRunning;                              // 是否正在运行	使能开启，并且当前有工作任务正在进行，没有错误发生。
        public byte[]                   szCurrentProject = new byte[MAX_PATH]; // 当前计划名称
        public byte[]                   szCurrentTask = new byte[MAX_PATH];    // 当前任务名称
        public byte[]                   szCurrentProfile = new byte[MAX_PATH]; // 当前任务配置参数表名称
        public int                      nCurrentSourceCount;                   // 当前任务轮训视频源个数
        public int                      nCurrentSourceIndex;                   // 当前任务当前视频源序号	从0开始
        public NET_TSECT                stCurrentTimeSection;                  // 当前计划时间段
        public int                      nTaskCountOfProject;                   // 当前计划总任务数
        public int                      nIndexOfCurrentTask;                   // 当前任务序号 从0开始
        public byte[]				    byReserved = new byte[512];			   // 保留字节
    }
    // CLIENT_GetVideoDiagnosisState 出参
    public static class NET_OUT_GET_VIDEODIAGNOSIS_STATE extends SdkStructure
    {
        public int				        dwSize;                                      //  结构体大小
        public VIDEODIAGNOSIS_STATE[]   stuState = (VIDEODIAGNOSIS_STATE[])new VIDEODIAGNOSIS_STATE().toArray(2);//  工作状态,数组下标0:Tour,1:RealTime

        public NET_OUT_GET_VIDEODIAGNOSIS_STATE() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_RadiometryAttach 入参
    public static class NET_IN_RADIOMETRY_ATTACH extends SdkStructure
    {
        public int              	    dwSize;
        public int                 		nChannel;                              // 视频通道号	-1 表示全部
        public Callback 	   		cbNotify;                              // 状态回调函数指针, 对应回调函数  fRadiometryAttachCB
        public Pointer             		dwUser;                                // 用户数据

        public NET_IN_RADIOMETRY_ATTACH() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_RadiometryAttach 出参
    public static class NET_OUT_RADIOMETRY_ATTACH extends SdkStructure
    {
        public int               		 dwSize;

        public NET_OUT_RADIOMETRY_ATTACH() {
            this.dwSize = this.size();
        }
    }

    // 热图数据
    public static class NET_RADIOMETRY_DATA extends SdkStructure
    {
        public NET_RADIOMETRY_METADATA   stMetaData;                 		// 元数据
        public Pointer                   pbDataBuf;                  		// 热图数据缓冲区（压缩过的数据,里面是每个像素点的温度数据,可以使用元数据信息解压）
        public int                       dwBufSize;                  		// 热图数据缓冲区大小
        public byte[]                    reserved = new byte[512];
    }

    // 热图元数据信息
    public static class NET_RADIOMETRY_METADATA extends SdkStructure
    {
        public int                 		 nHeight;                            // 高
        public int                 		 nWidth;                             // 宽
        public int                 		 nChannel;                           // 通道
        public NET_TIME           		 stTime;                             // 获取数据时间
        public int                		 nLength;                            // 数据大小
        public byte[]                	 szSensorType = new byte[64];        // 机芯类型
        public int                 		 nUnzipParamR;                       // 解压缩参数R
        public int                		 nUnzipParamB;                       // 解压缩参数B
        public int                		 nUnzipParamF;                       // 解压缩参数F
        public int                		 nUnzipParamO;                       // 解压缩参数O
        public byte[]             	     Reserved = new byte[256];
    }

    // CLIENT_RadiometryFetch 入参
    public static class NET_IN_RADIOMETRY_FETCH extends SdkStructure
    {
        public int               		 dwSize;
        public int                	     nChannel;                           // 通道号, 通道号要与订阅时一致, -1除外

        public NET_IN_RADIOMETRY_FETCH() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_RadiometryFetch 出参
    public static class NET_OUT_RADIOMETRY_FETCH extends SdkStructure
    {
        public int               		 dwSize;
        public int                 		 nStatus;                            // 0: 未知, 1: 空闲, 2: 获取热图中

        public NET_OUT_RADIOMETRY_FETCH() {
            this.dwSize = this.size();
        }
    }

    // 设备信息类型,对应 CLIENT_StartFind CLIENT_DoFind CLIENT_StopFind 接口
    public static class NET_FIND extends SdkStructure
    {
        public static final int NET_FIND_RADIOMETRY = 0;      // 热成像温度查询, pInBuf= NET_IN_RADIOMETRY_*FIND*, pOutBuf= NET_OUT_RADIOMETRY_*FIND*
        public static final int NET_FIND_POS_EXCHANGE = 1;	  // POS交易信息查询,pInBuf = NET_IN_POSEXCHANGE_*FIND*,pOutBuf= NET_OUT_POSEXCHANGE_*FIND*
    }

    //热成像查询保存周期
    public static class EM_RADIOMETRY_PERIOD extends SdkStructure
    {
        public static final int EM_RADIOMETRY_PERIOD_UNKNOWN = 0;		  // 未知
        public static final int EM_RADIOMETRY_PERIOD_5  = 5;			  // 5分钟记录表，默认
        public static final int EM_RADIOMETRY_PERIOD_10 = 10;           // 10分钟记录表
        public static final int EM_RADIOMETRY_PERIOD_15 = 15;           // 15分钟记录表
        public static final int EM_RADIOMETRY_PERIOD_30 = 30;           // 30分钟记录表
    }

    // CLIENT_StartFind 接口 NET_FIND_RADIOMETRY 命令入参
    public static class NET_IN_RADIOMETRY_STARTFIND extends SdkStructure
    {
        public int                    dwSize;
        public NET_TIME               stStartTime;                       // 查询开始时间
        public NET_TIME               stEndTime;                         // 查询结束时间
        public int                    nMeterType;                        // 查询类别,见NET_RADIOMETRY_METERTYPE
        public int                    nChannel;                          // 通道号
        public int   				  emPeriod;                          // 所查询表的保存周期,详见EM_RADIOMETRY_PERIOD

        public NET_IN_RADIOMETRY_STARTFIND() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_StartFind 接口 NET_FIND_RADIOMETRY 命令出参
    public static class NET_OUT_RADIOMETRY_STARTFIND extends SdkStructure
    {
        public int               dwSize;
        public int               nFinderHanle;                      // 取到的查询句柄
        public int               nTotalCount;                       // 符合此次查询条件的结果总条数

        public NET_OUT_RADIOMETRY_STARTFIND() {
            this.dwSize = this.size();
        }
    }


    // CLIENT_DoFind 接口 NET_FIND_RADIOMETRY 命令入参
    public static class NET_IN_RADIOMETRY_DOFIND extends SdkStructure
    {
        public int                 dwSize;
        public int                 nFinderHanle;                      // 查询句柄
        public int                 nBeginNumber;                      // 本次查询开始的索引号
        public int                 nCount;                            // 本次查询条数,最大为NET_IN_RADIOMETRY_DOFIND_MAX

        public NET_IN_RADIOMETRY_DOFIND() {
            this.dwSize = this.size();
        }
    }

	// 热成像查询返回的查询结果
	public static class NET_RADIOMETRY_QUERY extends SdkStructure
	{
		public NET_TIME            stTime;                            // 记录时间
		public int                 nPresetId;                         // 预置点编号
		public int                 nRuleId;                           // 规则编号
		public byte[]              szName = new byte[64];             // 查询项名称
		public NET_POINT           stCoordinate;                      // 查询测温点坐标
		public int                 nChannel;                          // 通道号
		public NET_RADIOMETRYINFO  stTemperInfo;                      // 测温信息,目前nTemperMid, nTemperStd 成员无效
		//public NET_POINT            stCoordinates[8];				   // 查询测温点坐标
		public NET_POINT[]         stCoordinates = (NET_POINT[])new NET_POINT().toArray(8);
		public int				   nCoordinateNum;					   // 查询温度点坐标返回的个数
		public byte[]              reserved = new byte[220];
	}

    // CLIENT_DoFind 接口 NET_FIND_RADIOMETRY 命令出参
    public static class NET_OUT_RADIOMETRY_DOFIND extends SdkStructure
    {
        public int                       dwSize;
        public int                       nFound;                             // 实际查询到的点数
        public NET_RADIOMETRY_QUERY[]    stInfo = (NET_RADIOMETRY_QUERY[])new NET_RADIOMETRY_QUERY().toArray(NET_RADIOMETRY_DOFIND_MAX); // 温度统计信息

        public NET_OUT_RADIOMETRY_DOFIND() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_StopFind 接口 NET_FIND_RADIOMETRY 命令入参
    public static class NET_IN_RADIOMETRY_STOPFIND extends SdkStructure
    {
        public int                 dwSize;
        public int                 nFinderHanle;                       // 查询句柄

        public NET_IN_RADIOMETRY_STOPFIND() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_StopFind 接口 NET_FIND_RADIOMETRY 命令出参
    public static class NET_OUT_RADIOMETRY_STOPFIND extends SdkStructure
    {
        public int               dwSize;

        public NET_OUT_RADIOMETRY_STOPFIND() {
            this.dwSize = this.size();
        }
    }

    // IPC报警,IPC通过DVR或NVR上报的本地报警(对应事件 NET_ALARM_IPC)
    public static class ALARM_IPC_INFO extends SdkStructure
    {
        public int               		dwSize;
        public int						nChannelID;										// 通道号
        public int                 		nEventAction;                   				// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public NET_TIME_EX				UTC;											// 事件发生的时间
        public byte[]					szName = new byte[MAX_ALARM_CHANNEL_NAME_LEN];	// 报警通道名称

        public ALARM_IPC_INFO() {
            this.dwSize = this.size();
        }
    }

    // 蓝牙开门记录集信息查询条件
    public static class FIND_RECORD_ACCESS_BLUETOOTH_INFO_CONDITION extends SdkStructure
    {
        public int						dwSize;
        public byte[]					szUserName = new byte[NET_COMMON_STRING_128];  // 用户名

        public FIND_RECORD_ACCESS_BLUETOOTH_INFO_CONDITION() {
            this.dwSize = this.size();
        }
    }

    // 蓝牙开门记录集信息
    public static class NET_RECORD_ACCESS_BLUETOOTH_INFO extends SdkStructure
    {
        public int                      dwSize;                                 	  // 结构体大小
        public int                      nRecNo;                                 	  // 记录集编号,只读
        public byte[]				    szUserName = new byte[NET_COMMON_STRING_128]; // 用户名
        public byte[]					szPassword = new byte[NET_COMMON_STRING_128]; // 密码
        public byte[]        			szMac = new byte[NET_COMMON_STRING_32];       // mac地址
        public byte[]        			szNote = new byte[NET_COMMON_STRING_128];     // 用户备注信息

        public NET_RECORD_ACCESS_BLUETOOTH_INFO() {
            this.dwSize = this.size();
        }
    }

    // 智能锁添加更新用户信息接口 CLIENT_UpdateSmartLockUser 入参
    public static class NET_IN_SMARTLOCK_UPDATE_USER_INFO extends SdkStructure
    {
        public int							dwSize;						                						// 结构体大小
        public byte[]                       szSerialNumber = new byte[32];                         				// 设备序列号
        public byte[]                       szCredentialHolder = new byte[16];                    				// 身份拥有者(与AccessControlCard记录集中的UserID概念一致)
        public byte[]                       szUserName = new byte[32];                             				// 用户名称
        public NET_TIME                     stuStartTime;                               						// 起始时间
        public NET_TIME                     stuEndTime;                                 						// 结束时间
        public byte[]						szReserve = new byte[512];					            			// 保留字段
        public int                          nCardInfoNum;                               						// 卡信息数量
        public NET_SMARTLOCK_CARDINFO[]     stuCardInfo =
                (NET_SMARTLOCK_CARDINFO[])new NET_SMARTLOCK_CARDINFO().toArray(4);  // 卡的信息
        public int                          nPwdInfoNum;                                						// 密码信息数量
        public NET_SMARTLOCK_PWDINFO[]      stuPwdInfo =
                (NET_SMARTLOCK_PWDINFO[])new NET_SMARTLOCK_PWDINFO().toArray(4);    // 密码信息
        public int                          nFingerPrintInfoNum;                        						// 密码信息数量
        public NET_SMARTLOCK_FPINFO[]       stuFingerPrintInfo =
                (NET_SMARTLOCK_FPINFO[])new NET_SMARTLOCK_FPINFO().toArray(4);      // 指纹信息
        public int							nTaskID;															// 任务ID

        public NET_IN_SMARTLOCK_UPDATE_USER_INFO() {
            this.dwSize = this.size();
        }
    }

    // 智能锁添加更新用户信息接口 CLIENT_UpdateSmartLockUser 出参
    public static class NET_OUT_SMARTLOCK_UPDATE_USER_INFO extends SdkStructure
    {
        public int							dwSize;							// 结构体大小

        public NET_OUT_SMARTLOCK_UPDATE_USER_INFO() {
            this.dwSize = this.size();
        }
    }

    // 卡片信息
    public static class NET_SMARTLOCK_CARDINFO extends SdkStructure
    {
        public int			   				 emType;                       // 开门类型, 参考 NET_ACCESS_METHOD
        public int                           nIndex;                       // 用户信息序号
        public byte[]                        szCardNo = new byte[32];      // 卡号
        public int          				 emCardType;                   // 卡类型, 参考 NET_ACCESSCTLCARD_TYPE
        public byte[]						 szReserve = new byte[512];	   // 保留字段
    }

    // 密码信息
    public static class NET_SMARTLOCK_PWDINFO extends SdkStructure
    {
        public int			    			emType;                        // 开门类型, 参考 NET_ACCESS_METHOD
        public int                          nIndex;                        // 用户信息序号
        public byte[]                       szPassword = new byte[32];     // 密码
        public int                          dwUseTime;                     // 使用次数
        public byte[]						szReserve = new byte[512];	   // 保留字段
    }

    // 指纹信息
    public static class NET_SMARTLOCK_FPINFO extends SdkStructure
    {
        public int			    			emType;                        // 开门类型, 参考 NET_ACCESS_METHOD
        public int                          nIndex;                        // 用户信息序号
        public int                          nFingerprintLen;               // 指纹数据长度,不超过1.5K
        public Pointer                      pFingerprintData;              // 指纹数据
        public byte[]						szReserve = new byte[512];	   // 保留字段
    }

    // 控制方式
    public static class NET_ACCESS_METHOD extends SdkStructure
    {
        public static final int NET_ACCESS_METHOD_UNKNOWN = 0;             // 未知
        public static final int NET_ACCESS_METHOD_CARD = 1;                // 卡
        public static final int NET_ACCESS_METHOD_PASSWORD = 2;            // 密码
        public static final int NET_ACCESS_METHOD_FINGERPRINT = 3;         // 指纹
    }

    // 获取当前智能锁的注册用户信息 CLIENT_GetSmartLockRegisterInfo 入参 (每次获取最多获取32条信息)
    public static class NET_IN_GET_SMART_LOCK_REGISTER_INFO extends SdkStructure
    {
        public int				 			dwSize;												// 结构体大小
        public byte[]            			szSerialNumber = new byte[MAX_COMMON_STRING_32];    // 设备序列号
        public int				 			nOffset;											// 用户列表的偏移量

        public NET_IN_GET_SMART_LOCK_REGISTER_INFO() {
            this.dwSize = this.size();
        }
    }

    // 注册用户的信息
    public static class NET_SMART_LOCK_REGISTER_INFO extends SdkStructure
    {
        public int							emType;												// 开锁方式类型, 参考 NET_ACCESS_METHOD
        public byte[]						szUserID = new byte[MAX_COMMON_STRING_16];			// 用户ID(非AccessControlCard记录集中的UserID概念)
        public byte[]						szName = new byte[MAX_COMMON_STRING_32];			// 用户名称
        public byte[]						byReserved = new byte[512];							// 保留字段
    }

    // 获取当前智能锁的注册用户信息 CLIENT_GetSmartLockRegisterInfo 出参
    public static class NET_OUT_GET_SMART_LOCK_REGISTER_INFO extends SdkStructure
    {
        public int								dwSize;											// 结构体大小
        public int								nTotalCount;									// 总的用户数量
        public int								nReturnCount;									// 实际返回的用户数量
        public NET_SMART_LOCK_REGISTER_INFO[]	stuRegisterInfo =
                (NET_SMART_LOCK_REGISTER_INFO[])new NET_SMART_LOCK_REGISTER_INFO().toArray(MAX_NUMBER_REGISTER_INFO);	// 注册用户的信息

        public NET_OUT_GET_SMART_LOCK_REGISTER_INFO() {
            this.dwSize = this.size();
        }
    }

    // 智能锁修改用户信息 CLIENT_SetSmartLockUserName 入参
    public static class NET_IN_SET_SMART_LOCK_USERNAME extends SdkStructure
    {
        public int							dwSize;												// 结构体大小
        public int							emType;												// 开锁方式类型, 参考 NET_ACCESS_METHOD
        public byte[]						szSerialNumber = new byte[MAX_COMMON_STRING_32];    // 智能锁序列号
        public byte[]						szUserID = new byte[MAX_COMMON_STRING_16];			// 用户ID(非AccessControlCard记录集中的UserID概念)
        public byte[]						szName = new byte[MAX_COMMON_STRING_32];			// 需要修改成的名称

        public NET_IN_SET_SMART_LOCK_USERNAME() {
            this.dwSize = this.size();
        }
    }

    // 智能锁修改用户信息 CLIENT_SetSmartLockUserName 出参
    public static class NET_OUT_SET_SMART_LOCK_USERNAME extends SdkStructure
    {
        public int							dwSize;												// 结构体大小

        public NET_OUT_SET_SMART_LOCK_USERNAME() {
            this.dwSize = this.size();
        }
    }

    // 智能锁删除用户接口 CLIENT_RemoveSmartLockUser 入参
    public static class NET_IN_SMARTLOCK_REMOVE_USER_INFO extends SdkStructure
    {
        public int							dwSize;						                		// 结构体大小
        public byte[]                       szSerialNumber = new byte[32];                      // 设备序列号
        public byte[]                       szCredentialHolder = new byte[16];                  // 身份拥有者(与AccessControlCard记录集中的UserID概念一致)
        public int			    			emType;                                     		// 开门类型,unknown 表示全部, 参考 NET_ACCESS_METHOD
        public int                          nIndex;                                     		// 某种开门方式的索引号，-1表示全部
        public int							nTaskID;											// 任务ID

        public NET_IN_SMARTLOCK_REMOVE_USER_INFO() {
            this.dwSize = this.size();
        }
    }

    // 智能锁删除用户接口 CLIENT_RemoveSmartLockUser 出参
    public static class NET_OUT_SMARTLOCK_REMOVE_USER_INFO extends SdkStructure
    {
        public int							dwSize;						                		// 结构体大小

        public NET_OUT_SMARTLOCK_REMOVE_USER_INFO() {
            this.dwSize = this.size();
        }
    }

    // 获取对码信息, 对应命令  NET_DEVSTATE_GET_CODEID_LIST
    public static class NET_GET_CODEID_LIST extends SdkStructure
    {
        public int                 			dwSize;
        public int                			nStartIndex;            // 开始的索引号,开始第一次查询可设为0
        public int                 			nQueryNum;              // 本次获取的对码条数,此值小于等于能力集中nMaxPageSize字段的值
        public int                			nRetCodeIDNum;          // 实际返回的对码条数
        public Pointer    		   			pstuCodeIDInfo;         // 获取对码的内容, 对应 NET_CODEID_INFO[],内存由用户分配,不能小于nQueryNum*sizeof(NET_CODEID_INFO)

        public NET_GET_CODEID_LIST() {
            this.dwSize = this.size();
        }
    }

    // 对码信息
    public static class NET_CODEID_INFO extends SdkStructure
    {
        public int                       	dwSize;
        public long                     	nWirelessId;                        		    // 无线ID号
        public int    					 	emType;                             			// 无线设备类型, 对应枚举 NET_WIRELESS_DEVICE_TYPE
        public byte[]                       szName = new byte[NET_USER_NAME_LENGTH];        // 用户名
        public int                        	bEnable;                            			// 是否启用了此设备, 1-true; 0-false
        public byte[]                       szCustomName = new byte[NET_COMMON_STRING_64];  // 自定义名称
        public int                          nChannel;                           			// 无线防区的alarm通道号,Alarm配置的下标,只有Type为Defence时此字段才有效。
        public int     						emMode;                             			// 无线设备工作模式, 对应枚举  EM_WIRELESS_DEVICE_MODE
        public int 							emSenseMethod;                     				// 传感器方式, 对应枚举  EM_CODEID_SENSE_METHOD_TYPE
        public byte[]                       szSerialNumber = new byte[NET_WIRELESS_DEVICE_SERIAL_NUMBER_MAX_LEN]; // 无线设备序列号
        public int                          nTaskID;                            // 任务ID
        public byte[]                       szRoomNo=new byte[64];                       // 智能锁房间号
        public int                          nMaxFingerprints;                   // 指纹数量:为0时表示不支持指纹
        public int                          nMaxCards;                          // 卡片数量:为0时表示不支持卡片
        public int                          nMaxPwd;                            // 密码数量:为0时表示不支持密码
        public NET_CODEID_INFO() {
            this.dwSize = this.size();
        }
    }

    // 无线设备类型
    public static class NET_WIRELESS_DEVICE_TYPE extends SdkStructure
    {
        public static final int NET_WIRELESS_DEVICE_TYPE_UNKNOWN = 0;
        public static final int NET_WIRELESS_DEVICE_TYPE_KEYBOARD = 1;          	// 无线键盘
        public static final int NET_WIRELESS_DEVICE_TYPE_DEFENCE = 2;           	// 无线防区
        public static final int NET_WIRELESS_DEVICE_TYPE_REMOTECONTROL = 3;     	// 无线遥控
        public static final int NET_WIRELESS_DEVICE_TYPE_MAGNETOMER = 4;        	// 无线门磁
        public static final int NET_WIRELESS_DEVICE_TYPE_ALARMBELL = 5;				// 无线警号
        public static final int NET_WIRELESS_DEVICE_TYPE_SWITCHER = 6;          	// 无线插座
        public static final int NET_WIRELESS_DEVICE_TYPE_SMARTLOCK = 7;        	    // 无线智能锁
        public static final int NET_WIRELESS_DEVICE_TYPE_REPEATER = 8;         	    // 无线中继器
    }

    // 无线设备工作模式
    public static class EM_WIRELESS_DEVICE_MODE extends SdkStructure
    {
        public static final int EM_WIRELESS_DEVICE_MODE_UNKNOWN = 0;            	// 模式未识别
        public static final int EM_WIRELESS_DEVICE_MODE_NORMAL = 1;             	// Normal 普通模式
        public static final int EM_WIRELESS_DEVICE_MODE_POLLING = 2;            	// Polling 巡检模式 只有Type为RemoteControl时才能处于巡检模式
    }

    // 传感器方式
    public static class EM_CODEID_SENSE_METHOD_TYPE extends SdkStructure
    {
        public static final int EM_CODEID_SENSE_METHOD_TYPE_UNKOWN = 0;         	// 未知的
        public static final int EM_CODEID_SENSE_METHOD_TYPE_DOOR_MAGNETISM = 1; 	// 门磁
        public static final int EM_CODEID_SENSE_METHOD_TYPE_GAS_SENSOR = 2;     	// 燃气传感
        public static final int EM_CODEID_SENSE_METHOD_TYPE_CURTAIN_SENSOR = 3; 	// 幕帘传感器
        public static final int EM_CODEID_SENSE_METHOD_TYPE_MOBILE_SENSOR = 4;  	// 移动传感器
        public static final int EM_CODEID_SENSE_METHOD_TYPE_PASSIVEINFRA = 5;   	// 被动红外传感器
        public static final int EM_CODEID_SENSE_METHOD_TYPE_URGENCY_BUTTON = 6; 	// 紧急按钮
        public static final int EM_CODEID_SENSE_METHOD_TYPE_SMOKING_SENSOR = 7; 	// 烟雾传感器
        public static final int EM_CODEID_SENSE_METHOD_TYPE_DOUBLEMETHOD = 8;   	// 双鉴传感器(红外+微波)
        public static final int EM_CODEID_SENSE_METHOD_TYPE_WATER_SENSOR = 9;   	// 水浸传感器
        public static final int EM_CODEID_SENSE_METHOD_TYPE_THREEMETHOD = 10;   	// 三技术
    }

    // CLIENT_EncryptString 接口入参
    public static class NET_IN_ENCRYPT_STRING extends SdkStructure
    {
        public int							 dwSize;								// 结构体大小
        public byte[]						 szCard = new byte[33];					// 需要加密的字符串
        public byte[]                        byReserved1 = new byte[3];             // 字节对齐
        public byte[]                        szKey = new byte[33];                  // 秘钥
        public byte[]                        byReserved2 = new byte[3];             // 字节对齐

        public NET_IN_ENCRYPT_STRING() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_EncryptString 接口出参
    public static class NET_OUT_ENCRYPT_STRING extends SdkStructure
    {
        public int							dwSize;									// 结构体大小
        public byte[]						szEncryptString = new byte[1024];		// 加密后字符串

        public NET_OUT_ENCRYPT_STRING() {
            this.dwSize = this.size();
        }
    }

    // 设置二维码的解码信息入参
    public static class NET_IN_SET_QRCODE_DECODE_INFO extends SdkStructure
    {
        public int                       	dwSize;
        public int      					emCipher;                                // 加密方式, 参考枚举 NET_ENUM_QRCODE_CIPHER
        public byte[]                       szKey = new byte[33];                    // 秘钥
        public byte[]                       byReserved = new byte[3];                // 字节对齐

        public NET_IN_SET_QRCODE_DECODE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 设置二维码的解码信息出参
    public static class NET_OUT_SET_QRCODE_DECODE_INFO extends SdkStructure
    {
        public int                       dwSize;

        public NET_OUT_SET_QRCODE_DECODE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 使用的加密算法
    public static class NET_ENUM_QRCODE_CIPHER extends SdkStructure
    {
        public static final int NET_ENUM_QRCODE_CIPHER_UNKNOWN = 0;
        public static final int NET_ENUM_QRCODE_CIPHER_AES256 = 1;                  // AES-256
    }

    //门禁卡数据操作事件
    public static class ALARM_ACCESS_CARD_OPERATE_INFO extends SdkStructure
    {
        public int                   	dwSize;
        public int   				    emActionType;                    			 // 门禁卡数据操作类型, 参考  NET_ACCESS_ACTION_TYPE
        public byte[]                   szCardNo = new byte[NET_MAX_CARDINFO_LEN];   // 门禁卡卡号
        public int    					emResult;                        			 // 操作结果,-1为未知,0为失败,1为成功,参考 NET_THREE_STATUS_BOOL
        public int                      nChannelID;                      			 // 门通道号(或者门锁,门和门锁一一对应), 从0开始
        public byte[]                   szCredentialHolder = new byte[16];           // 身份拥有者
        public int						emType;                          			 // 用户类型， 参考 NET_ACCESS_METHOD
        public byte[]                   szSerialNum = new byte[32];                  // 序列号
        public int                      nIndex;                          		     // 某开门方式下的索引号
        public int						nTaskID;						 			 // 任务ID
        public int 	                    emErrorde;						 // 操作错误码 (只有当操作结果emResult=0时才有效)
        public ALARM_ACCESS_CARD_OPERATE_INFO() {
            this.dwSize = this.size();
        }
    }


    //门禁卡数据操作类型
    public static class NET_ACCESS_ACTION_TYPE extends SdkStructure
    {
        public static final int NET_ACCESS_ACTION_TYPE_UNKNOWN  = 0;    			// 未知
        public static final int NET_ACCESS_ACTION_TYPE_INSERT   = 1;   			 	// 插入
        public static final int NET_ACCESS_ACTION_TYPE_UPDATE   = 2;    			// 更新
        public static final int NET_ACCESS_ACTION_TYPE_REMOVE   = 3;    			// 删除
    }

    // 门禁未关事件详细信息
    public static class ALARM_ACCESS_CTL_NOT_CLOSE_INFO extends SdkStructure
    {
        public int           	 	dwSize;
        public int             	 	nDoor;                                  		// 门通道号
        public byte[]            	szDoorName = new byte[NET_MAX_DOORNAME_LEN];    // 门禁名称
        public NET_TIME        	 	stuTime;                                		// 报警事件发生的时间
        public int             	 	nAction;                                		// 0:开始 1:停止
        public int 		    	 	nEventID;				                		// 事件ID
        public boolean			    bRealUTC;	// RealUTC 是否有效，bRealUTC 为 TRUE 时，用RealUTC，否则用 stuTime 字段
        public NET_TIME_EX          RealUTC;								// 事件发生的时间（标准UTC）
        public ALARM_ACCESS_CTL_NOT_CLOSE_INFO() {
            this.dwSize = this.size();
        }
    }

    // 闯入事件详细信息
    public static class ALARM_ACCESS_CTL_BREAK_IN_INFO extends SdkStructure
    {
        public int           		dwSize;
        public int             		nDoor;                                  		// 门通道号
        public byte[]            	szDoorName = new byte[NET_MAX_DOORNAME_LEN];    // 门禁名称
        public NET_TIME        		stuTime;                                		// 报警事件发生的时间
        public int 					nEventID;				                		//事件ID
        public int                  emMethod;                                       // 闯入方式
        public boolean				bRealUTC;	// RealUTC 是否有效，bRealUTC 为 TRUE 时，用RealUTC，否则用 stuTime 字段
        public NET_TIME_EX         	RealUTC;								// 事件发生的时间（标准UTC）
        public byte[]               reserved=new byte[4];                           // 字节对齐

        public ALARM_ACCESS_CTL_BREAK_IN_INFO() {
            this.dwSize = this.size();
        }
    }

    // 门禁控制-重置密码(对应CLIENT_ControlDevice接口的 CTRLTYPE_CTRL_ACCESS_RESET_PASSWORD 命令)
    public static class NET_CTRL_ACCESS_RESET_PASSWORD extends SdkStructure
    {
        public int                  dwSize;                                 		   // 结构体大小
        public int                  nChannelID;                            			   // 门禁序号(从0开始)
        public int         			emType;                                 		   // 密码类型, 参考 EM_ACCESS_PASSWORD_TYPE
        public byte[]               szUserID = new byte[MAX_COMMON_STRING_32];         // 用户ID
        public byte[]               szNewPassword = new byte[MAX_COMMON_STRING_32];    // 新密码

        public NET_CTRL_ACCESS_RESET_PASSWORD() {
            this.dwSize = this.size();
        }
    }

    // 门禁控制密码类型
    public static class EM_ACCESS_PASSWORD_TYPE extends SdkStructure
    {
        public static final int EM_ACCESS_PASSWORD_OPENDOOR = 1;                 	  // 开门密码
        public static final int EM_ACCESS_PASSWORD_ALARM = 2;                         // 防劫持报警密码
    }

    //设置对讲状态
    public static class EM_CALL_STATUS extends SdkStructure
    {
        public static final int EM_CALL_STATUS_UNKNOWN = -1;
        public static final int EM_CALL_STATUS_TRYING = 0;					// 通话请求正在处理事件
        public static final int EM_CALL_STATUS_RINGING = 1;					// 主叫时，被叫回铃事件
        public static final int EM_CALL_STATUS_PREPARECONNECTED = 2;		// 收到对端通话接通
        public static final int EM_CALL_STATUS_CONNECTED = 3;				// 双方通话已经正式建立
        public static final int EM_CALL_STATUS_CALLED = 4;					// 被叫来电事件
        public static final int EM_CALL_STATUS_PREPARELEAVINGMESSAGE = 5;	// 收到留言请求事件
        public static final int EM_CALL_STATUS_LEAVINGMESSAGECONNECTED = 6;	// 留言通话接通事件
        public static final int EM_CALL_STATUS_CALLEND = 7;					// 呼叫结束事件
        public static final int EM_CALL_STATUS_CALLTRANSFER = 8;			// 转移呼叫到其他设备
        public static final int EM_CALL_STATUS_CALLTRANSFERCONNECTED = 9;	// 呼叫转移接通
        public static final int EM_CALL_STATUS_HELD = 10;					// 呼叫保持
        public static final int EM_CALL_STATUS_RESUME = 11;					// 呼叫召回
        public static final int EM_CALL_STATUS_DND = 12;						// 免打扰
        public static final int EM_CALL_STATUS_REMOTESDPCHANGE = 13;			// 远端SDP改变
        public static final int EM_CALL_STATUS_REFUSE = 14;					// 拒接
    }

    // CLIENT_ControlDeviceEx接口的  DH_CTRL_SET_THIRD_CALLSTATUS 命令参数入参
    public static class NET_IN_VTP_THIRDCALL_STATUS extends SdkStructure
    {
        public int                      dwSize;
        public int						emCallStatus;           // 门禁对讲状态,参考EM_CALL_STATUS
        public NET_IN_VTP_THIRDCALL_STATUS() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_ControlDeviceEx接口的  DH_CTRL_SET_THIRD_CALLSTATUS 命令参数出参
    public static class NET_OUT_VTP_THIRDCALL_STATUS extends SdkStructure
    {
        public int              dwSize;
        public byte[]			szCallID= new byte[64];           // 对讲id
        public NET_OUT_VTP_THIRDCALL_STATUS() {
            this.dwSize = this.size();
        }
    }

    // 录像回放入参信息
    public static class NET_IN_PLAY_BACK_BY_TIME_INFO extends SdkStructure
    {
        public NET_TIME            	  stStartTime;                       			// 开始时间
        public NET_TIME            	  stStopTime;                        			// 结束时间
        public Pointer                hWnd;                             		 	// 播放窗格, 可为NULL
        public fDownLoadPosCallBack   cbDownLoadPos;                    			// 进度回调
        public Pointer                dwPosUser;                        		 	// 进度回调用户信息
        public fDataCallBack          fDownLoadDataCallBack;             			// 数据回调
        public Pointer                dwDataUser;                        			// 数据回调用户信息
        public int                    nPlayDirection;                    			// 播放方向, 0:正放; 1:倒放;
        public int                    nWaittime;                         			// 接口超时时间, 目前倒放使用
        public byte[]                 bReserved = new byte[1024];                   // 预留字节
    }

    // 录像回放出参信息
    public static class NET_OUT_PLAY_BACK_BY_TIME_INFO extends SdkStructure
    {
        public byte[]                 bReserved = new byte[1024];                   // 预留字节
    }

    // 扩展模块掉线事件 对应事件类型 NET_ALARM_MODULE_LOST
    public static class ALARM_MODULE_LOST_INFO extends SdkStructure
    {
        public int                    dwSize;
        public NET_TIME               stuTime;                        				// 事件上报时间
        public int                    nSequence;                      				// 扩展模块接的总线的序号(从0开始)
        public int            		  emBusType;                      				// 总线类型, 参考枚举  NET_BUS_TYPE
        public int                    nAddr;                          				// 掉线的扩展模块数目
        public int[]                  anAddr = new int[MAX_ALARMEXT_MODULE_NUM];	// 掉线的扩展模块的序号(从0开始)
        public byte[]				  szDevType = new byte[NET_COMMON_STRING_64];	// 设备类型 "SmartLock",是级联设备,当设备类型"AlarmDefence"接口序号为报警序号
        public int					  bOnline;										// 在线情况   默认0。   0-不在线;  1-在线
        public byte[]                 szSN = new byte[32];                       	// 无线配件序列号

        public ALARM_MODULE_LOST_INFO() {
            this.dwSize = this.size();
        }
    }

    // 总线类型
    public static class NET_BUS_TYPE extends SdkStructure
    {
        public static final int NET_BUS_TYPE_UNKNOWN = 0;
        public static final int NET_BUS_TYPE_MBUS = 1;                              // M-BUS总线
        public static final int NET_BUS_TYPE_RS485 = 2;                             // RS-485总线
        public static final int  NET_BUS_TYPE_CAN = 3;                              // CAN总线
    }

    //节假日记录信息
    public static class NET_RECORDSET_HOLIDAY extends SdkStructure {
        public int             dwSize;
        public int             nRecNo;                                 // 记录集编号,只读
        public int             nDoorNum;                               // 有效的的门数目
        public int[]           sznDoors  = new int[NET_MAX_DOOR_NUM];              // 有权限的门序号,即CFG_CMD_ACCESS_EVENT配置CFG_ACCESS_EVENT_INFO的数组下标
        public NET_TIME        stuStartTime;                           // 开始时间
        public NET_TIME        stuEndTime;                             // 结束时间
        public int             bEnable;                                // 假期使能
        public byte[]          szHolidayNo = new byte[NET_COMMON_STRING_32];       // 假期编号
        public byte[]    	   szHolidayName   =     new byte [NET_COMMON_STRING_128];    // 假期名称

        public NET_RECORDSET_HOLIDAY() {
            this.dwSize = this.size();
        }
    }

    // 事件类型 EVENT_IVS_FLOATINGOBJECT_DETECTION (漂浮物检测)对应的规则配置
    public static class NET_FLOATINGOBJECT_DETECTION_RULE_INFO extends SdkStructure
    {
        public int					nDetectRegionPoint;										// 检测区顶点数
        public POINTCOORDINATE[]	stuDetectRegion=(POINTCOORDINATE[]) new POINTCOORDINATE().toArray(20);									// 检测区
        public float				fAlarmThreshold;										// 报警阈值。当检测区域内的漂浮物占比超过阈值时则产生报警;单位:%，取值范围(0, 100]
        public int				    nAlarmInterval;											// 报警时间间隔。（单位：秒）。取值范围[60, 86400]
        public int				    bDataUpload;											// 是否上报实时数据。
        public int 				    nUpdateInterval;										// 实时数据上报间隔。(单位：秒)。取值范围[60, 86400]
        public byte[]				byReserved=new byte[4096]; 										// 保留字节
    };

    // 堆积物点阵图信息
    public static class NET_FLOATINGOBJECT_MASK_INFO extends SdkStructure
    {
        public int            nColNum;                     // 点阵列数
        public int            nOffset;                     // 偏移
        public int            nLength;                     // 长度
        public byte[]		  byReserved=new byte[508];    // 预留字段
    };

    // 事件类型 EVENT_IVS_FLOATINGOBJECT_DETECTION (漂浮物检测事件) 对应的数据块描述信息
    public static class DEV_EVENT_FLOATINGOBJECT_DETECTION_INFO extends SdkStructure
    {
        public int                 	nChannelID;                         // 通道号
        public int                 	nAction;                       		// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              	szName = new byte[128];             // 事件名称
        public double              	PTS;                            	// 时间戳(单位是毫秒)
        public NET_TIME_EX         	UTC;								// 事件发生的时间
        public int					nEventID;							// 事件ID
        public NET_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
        public NET_POINT[]          stuDetectRegion = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM); // 规则检测区域
        public int                 	nDetectRegionNum;                   // 规则检测区域顶点数
        public int                 	nImageIndex;                        // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int               	dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public int                 	nSourceIndex;                       // 事件源设备上的index,-1表示数据无效
        public byte[]               szSourceDevice = new byte[MAX_PATH];           // 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int					nOccurrenceCount;                   // 事件触发累计次数
        public int                 	nObjectNum;                         // 检测到的物体个数
        public NET_MSG_OBJECT[]    	stuObjects = (NET_MSG_OBJECT[]) new NET_MSG_OBJECT().toArray(HDBJ_MAX_OBJECTS_NUM);   // 检测到的物体
        public EVENT_INTELLI_COMM_INFO   stuIntelliCommInfo;         	// 智能事件公共信息
        public byte[]				szPresetName = new byte[64];		// 事件触发的预置名称
        public int					bExistFloatingObject;				// 是否存在漂浮物
        public int					emEventType;						// 事件数据类型,详见NET_EM_EVENT_DATA_TYPE
        public float				fCurrentRatio;						// 漂浮物当前占比（相对于检测区域）单位:%, 取值范围[0, 100]
        public float				fAlarmThreshold;					// 报警阈值。漂浮物相对于检测区域的占比, 取值范围[0, 100]
        public NET_INTELLIGENCE_IMAGE_INFO	stuOriginalImage;			// 原始图
        public NET_INTELLIGENCE_IMAGE_INFO	stuSceneImage;				// 球机变到最小倍下的抓图
        public NET_FLOATINGOBJECT_MASK_INFO stuObjectMaskInfo;         // 堆积物点阵图信息
        public byte[]               byReserved = new byte[3436];        // 保留字节,留待扩展.
    }

    // 事件类型 EVENT_IVS_WATER_LEVEL_DETECTION(水位检测事件)对应的数据块描述信息
    public static class DEV_EVENT_WATER_LEVEL_DETECTION_INFO extends SdkStructure
    {
        public int					nChannelID;							// 通道号
        public int					nAction;							// 0:脉冲 1:开始 2:停止
        public byte[]              	szName = new byte[MAX_EVENT_NAME];  // 事件名称
        public double              	PTS;                            	// 时间戳(单位是毫秒)
        public NET_TIME_EX         	UTC;								// 事件发生的时间
        public int					nEventID;							// 事件ID
        public NET_EVENT_FILE_INFO  stuFileInfo;                        // 事件对应文件信息
        public EVENT_INTELLI_COMM_INFO    stuIntelliCommInfo;			// 智能事件公共信息
        public byte[]				szPresetName = new byte[64];		// 预置点名称
        public byte[]				szObjectUUID = new byte[48];		// 智能物体全局唯一物体标识
        public int					emEventType;						// 事件数据类型,详见NET_EM_EVENT_DATA_TYPE
        public int					emStatus;							// 水位状态,详见NET_EM_WATER_LEVEL_STATUS
        public NET_WATER_RULER		stuWaterRuler;						// 水位尺
        public NET_INTELLIGENCE_IMAGE_INFO	stuOriginalImage;			// 原始图
        public NET_INTELLIGENCE_IMAGE_INFO	stuSceneImage;				// 球机变到最小倍下的抓图
        public byte[]				byReserved = new byte[1024];        // 保留字节
    }

    // 全景广角图
    public static class SCENE_IMAGE_INFO_EX extends SdkStructure
    {
        public int	   nOffSet;					// 在二进制数据块中的偏移
        public int	   nLength;					// 图片大小,单位字节
        public int	   nWidth;					// 图片宽度(像素)
        public int	   nHeight;					// 图片高度(像素)
        public byte[]  szFilePath = new byte[260];	// 全景图片路径
        public byte[]  byReserved = new byte[512];	// 预留字节
    }


    // 水果类型
    public static class EM_FRUIT_TYPE extends SdkStructure
    {
        public static final int EM_FRUIT_TYPE_UNKNOWN = 0;					// 未知
        public static final int EM_FRUIT_TYPE_GREEN_TANGERINE = 1;			// 青橘
        public static final int EM_FRUIT_TYPE_YELLOW_TANGERINE_ORANGE = 2;	// 黄橘，橙类
        public static final int EM_FRUIT_TYPE_GRAPEFRUIT = 3;				// 柚子
        public static final int EM_FRUIT_TYPE_LEMON = 4;					// 柠檬
        public static final int EM_FRUIT_TYPE_WATERMELON = 5;				// 西瓜
        public static final int EM_FRUIT_TYPE_BANANA = 6;					// 香蕉
        public static final int EM_FRUIT_TYPE_RED_APPLE = 7;				// 红苹果
        public static final int EM_FRUIT_TYPE_GREEN_APPLE = 8;				// 青苹果
        public static final int EM_FRUIT_TYPE_MUSKMELON = 9;				// 香瓜
        public static final int EM_FRUIT_TYPE_HAMIMELON = 10;				// 哈密瓜
        public static final int EM_FRUIT_TYPE_PEAR = 11;					// 梨
        public static final int EM_FRUIT_TYPE_KIWI = 12;					// 奇异果
        public static final int EM_FRUIT_TYPE_PAPAYA = 13;					// 木瓜
        public static final int EM_FRUIT_TYPE_PINEAPPLE = 14;				// 菠萝
        public static final int EM_FRUIT_TYPE_MANGO = 15;					// 芒果
        public static final int EM_FRUIT_TYPE_LONGAN = 16;					// 龙眼
        public static final int EM_FRUIT_TYPE_GINSENG_FRUIT = 17;			// 人参果
        public static final int EM_FRUIT_TYPE_POMEGRABATE = 18;				// 石榴
        public static final int EM_FRUIT_TYPE_COCONUT = 19;					// 椰子
        public static final int EM_FRUIT_TYPE_CREAM_JUJUBE = 20;			// 奶油枣
        public static final int EM_FRUIT_TYPE_WINTER_JUJUBE = 21;			// 冬枣
        public static final int EM_FRUIT_TYPE_AVOCADO = 22;					// 牛油果
        public static final int EM_FRUIT_TYPE_RED_PLUM = 23;				// 红布林
        public static final int EM_FRUIT_TYPE_PITAYA = 24;					// 火龙果
        public static final int EM_FRUIT_TYPE_GUAVA = 25;					// 芭乐
        public static final int EM_FRUIT_TYPE_PERSIMMON = 26;				// 柿子
        public static final int EM_FRUIT_TYPE_YACON = 27;					// 雪莲果
    }


    // 检测到的水果信息
    public static class NET_CANDIDATE_FRUIT_INFO extends SdkStructure
    {
        public int				nSimilarity;				// 相似度
        public int				emFruitType;				// 检测到的水果类型,参考EM_FRUIT_TYPE
        public byte[]  byReserved = new byte[1024];	// 预留字节
    }

    // 事件类型 EVENT_IVS_WEIGHING_PLATFORM_DETECTION(称重平台检测事件) 对应的数据块描述信息
    public static class DEV_EVENT_WEIGHING_PLATFORM_DETECTION_INFO extends SdkStructure
    {
        public int                 	nChannelID;							// 通道号
        public int                	nAction;							// 0:脉冲 1:开始 2:停止
        public byte[]               szName = new byte[MAX_EVENT_NAME];	// 事件名称
        public double              	PTS;								// 时间戳(单位是毫秒)
        public NET_TIME_EX         	UTC;								// 事件发生的时间
        public int                 	nEventID;							// 事件ID

        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;          // 智能事件公共信息
        public int					nCandidateFruitNum;					// 检测到的水果信息个数
        public NET_CANDIDATE_FRUIT_INFO[]	stuFruitInfos = (NET_CANDIDATE_FRUIT_INFO[])new NET_CANDIDATE_FRUIT_INFO().toArray(100);// 检测到的水果信息
        public SCENE_IMAGE_INFO_EX			stuSceneImage;				// 全景图
        public SCENE_IMAGE_INFO_EX			stuFruitImage;				// 水果抠图
        public byte[]          		byReserved = new byte[1024];		// 保留字节
    }

    // 安全帽佩戴状态
    public static class EM_WORK_HELMET_STATE extends SdkStructure
    {
        public static final int EM_HELMET_STATE_UNKNOWN = 0;		// 未知
        public static final int EM_HELMET_STATE_NOTWEAR = 1;		// 不带安全帽
        public static final int EM_HELMET_STATE_WEAR = 2;			// 有带安全帽
    }

    // 安全帽属性
    public static class NET_HELMET_ATTRIBUTE extends SdkStructure
    {
        public int 					emHelmetState;								// 安全帽佩戴状态，参考EM_WORK_HELMET_STATE
        public int 					emHelmetColor;								// 安全帽颜色，参考EM_CLOTHES_COLOR
        public byte[]          		byReserved = new byte[1024];		// 保留字节
    }

    // 工作服穿戴状态
    public static class EM_WORKCLOTHES_STATE extends SdkStructure
    {
        public static final int EM_WORKCLOTHES_STATE_UNKNOWN = 0;		// 未知
        public static final int EM_WORKCLOTHES_STATE_NOTWEAR = 1;		// 无工作服
        public static final int EM_WORKCLOTHES_STATE_WEAR = 2;			// 有工作服
    }
    
    //工作服合法状态
    public static class EM_CLOTHES_LEGAL_STATE extends SdkStructure{
    	public static final int EM_CLOTHES_LEGAL_STATE_UNKNOWN = 0;		    // 未知
        public static final int EM_CLOTHES_LEGAL_STATE_WRONGFUL = 1;		// 不合法
        public static final int EM_CLOTHES_LEGAL_STATE_LEGAL = 2;			// 合法   	
    }

    // 工作服属性
    public static class NET_WORKCLOTHES_ATTRIBUTE extends SdkStructure
    {
        public int					emWorkClothesState;							// 工作服穿戴状态，参考EM_WORKCLOTHES_STATE
        public int					emWorkClothColor;							// 工作服颜色,参考EM_CLOTHES_COLOR
        public int                  emWorkClothesLegalState;                    // 工作服合法状态,参考EM_CLOTHES_LEGAL_STATE
        public byte[]         		byReserved = new byte[1020];		// 保留字节
    }
    
   // 工作裤穿戴状态
    public static class EM_WORKPANTS_STATE extends SdkStructure{
    	 public static final int EM_WORKPANTS_STATE_UNKNOWN = 0;		// 未知
         public static final int EM_WORKPANTS_STATE_NOTWEAR = 1;		// 没有
         public static final int EM_WORKPANTS_STATE_WEAR = 2;			// 有    	
    }
    
    //工作裤属性
    public static class NET_WORKPANTS_ATTRIBUTE extends SdkStructure{
    	public int				   emWorkPantsState;							// 工作裤穿戴状态,参考EM_WORKPANTS_STATE
    	public int				   emWorkPantsColor;							// 工作裤颜色,参考EM_CLOTHES_COLOR	
    	public byte[]			   byReserved = new byte[1024];			// 预留字节
    }

    // 事件类型 EVENT_IVS_WORKCLOTHES_DETECT(工装(安全帽/工作服等)) 对应的数据块描述信息
    public static class DEV_EVENT_WORKCLOTHES_DETECT_INFO extends SdkStructure
    {

        public int                 			nChannelID;                         		// 通道号
        public int							nAction;									// 0:脉冲 1:开始 2:停止
        public byte[]                 		szName = new byte[MAX_EVENT_NAME];			// 事件名称
        public double              			PTS;                                		// 时间戳(单位是毫秒)
        public NET_TIME_EX         			UTC;                                		// 事件发生的时间
        public int                 			nEventID;                           		// 事件ID

        public int							emClassType;								// 智能事件所属大类,详见EM_SCENE_CLASS_TYPE
        public int							nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
        public int							nObjectID;									// 物体ID
        public int							nGroupID;									// 事件组ID，一次检测的多个nGroupID相同
        public int							nCountInGroup;								// 一个事件组内的抓拍张数,一次检测的多个nCountInGroup相同
        public int							nIndexInGroup;								// 一个事件组内的抓拍序号，从1开始
        public SCENE_IMAGE_INFO				stuSceneImage;           					// 全景大图信息
        public HUMAN_IMAGE_INFO    			stuHumanImage;         						// 人体小图信息
        public NET_HELMET_ATTRIBUTE			stuHelmetAttribute;							// 安全帽属性
        public NET_WORKCLOTHES_ATTRIBUTE	stuWorkClothesAttribute;					// 工作服属性
        public NET_WORKPANTS_ATTRIBUTE      stuWorkPantsAttribute;                      // 工作裤属性
        public int                          nAlarmType;                                 // 不规范报警类型 0-未知 1-防护服不规范 2: 工作服不规范3:安全帽不规范4:安全帽和工作服不规范
        public byte[]          				byReserved = new byte[1020];				// 保留字节

    }
    // 智能事件抓图信息
    public static class NET_INTELLIGENCE_IMAGE_INFO extends SdkStructure
    {
        public int				nOffSet;					// 在二进制数据块中的偏移
        public int				nLength;					// 图片大小,单位字节
        public int				nWidth;						// 图片宽度(像素)
        public int				nHeight;					// 图片高度(像素)
        public byte[]			byReserved = new byte[48];	// 预留字节
    }

    // 事件类型 EVENT_IVS_RADAR_SPEED_LIMIT_ALARM(雷达限速报警事件)对应的数据块描述信息
    public static class DEV_EVENT_RADAR_SPEED_LIMIT_ALARM_INFO extends SdkStructure
    {
        public int                 		nChannelID;                                     // 通道号
        public int                 		nAction;                                        // 0:脉冲 1:开始 2:停止
        public byte[]              		szAddress = new byte[32];                       // 设备IP地址
        public int                 		nSpeed;                                         // 时速, 单位km/h
        public NET_TIME_EX         		UTC;                                            // 事件发生时间

        public int                 		nGroupID;                                       // 事件组ID
        public int                 		nCountInGroup;                                  // 一个事件组内的抓拍张数
        public int                 		nIndexInGroup;                                  // 一个事件组内的抓拍序号，测速过程第n张图片,从1开始
        public EVENT_INTELLI_COMM_INFO  stuIntelliCommInfo;                      	    // 智能事件公共信息
        public byte[]                	byReserved = new byte[1024];                    // 保留字节
    }

    /*************************************************************************************************
     * 							门禁用户信息操作：增、删、改、查、清空
     ************************************************************************************************/
    // 人员信息操作类型
    public static class NET_EM_ACCESS_CTL_USER_SERVICE extends SdkStructure
    {
        public static final int NET_EM_ACCESS_CTL_USER_SERVICE_INSERT = 0;              // 添加/更新人员信息, pstInParam = NET_IN_ACCESS_USER_SERVICE_INSERT , pstOutParam = NET_OUT_ACCESS_USER_SERVICE_INSERT
        public static final int NET_EM_ACCESS_CTL_USER_SERVICE_GET = 1;                 // 获取人员信息, pstInParam = NET_IN_ACCESS_USER_SERVICE_GET , pstOutParam = NET_OUT_ACCESS_USER_SERVICE_GET
        public static final int NET_EM_ACCESS_CTL_USER_SERVICE_REMOVE = 2;              // 删除人员信息,包含所有授权信息 pstInParam = NET_IN_ACCESS_USER_SERVICE_REMOVE , pstOutParam = NET_OUT_ACCESS_USER_SERVICE_REMOVE
        public static final int NET_EM_ACCESS_CTL_USER_SERVICE_CLEAR = 3;               // 清空所有人员信息, pstInParam = NET_IN_ACCESS_USER_SERVICE_CLEAR , pstOutParam = NET_OUT_ACCESS_USER_SERVICE_CLEAR
    }

    // 新增或更新用户信息入参
    public static class NET_IN_ACCESS_USER_SERVICE_INSERT extends SdkStructure
    {
        public int                   dwSize;	                                		// 结构体大小
        public int                   nInfoNum;                                   		// 用户信息数量
        public Pointer       		 pUserInfo;                                  		// 用户信息,对应数组 NET_ACCESS_USER_INFO,内存由用户申请释放，申请大小不小于nInfoNum*sizeof(NET_ACCESS_USER_INFO);

        public NET_IN_ACCESS_USER_SERVICE_INSERT() {
            this.dwSize = this.size();
        }
    }

    // 新增或更新用户信息出参
    public static class NET_OUT_ACCESS_USER_SERVICE_INSERT extends SdkStructure
    {
        public int                   dwSize;	                                    	// 结构体大小
        public int                   nMaxRetNum;                                 		// 申请的最大返回的错误信息数量,不小于NET_IN_ACCESS_USER_SERVICE_INSERT中nInfoNum
        public Pointer        		 pFailCode;                                 		// 对应 FAIL_CODE, 用户分配释放内存,插入失败时，对应插入的每一项的结果,返回个数同NET_IN_ACCESS_USER_SERVICE_INSERT中nInfoNum

        public NET_OUT_ACCESS_USER_SERVICE_INSERT() {
            this.dwSize = this.size();
        }
    }

    // 插入失败时，对应插入的每一项的结果
    public static class FAIL_CODE extends SdkStructure
    {
        public int        			 nFailCode;                                 		// 对应 NET_EM_FAILCODE
    }

    // 获取用户信息入参
    public static class NET_IN_ACCESS_USER_SERVICE_GET extends SdkStructure
    {
        public int                   dwSize;	                                    	// 结构体大小
        public int                   nUserNum;                                   		// 查询的数量
        public USERID[]			     szUserIDs = (USERID[])new USERID().toArray(100);	// 用户ID列表

        public NET_IN_ACCESS_USER_SERVICE_GET() {
            this.dwSize = this.size();
        }
    }

    public static class USERID extends SdkStructure
    {
        public byte[]				szUserID = new byte[32];				            // 用户ID
    }

    // 获取用户信息出参
    public static class NET_OUT_ACCESS_USER_SERVICE_GET extends SdkStructure
    {
        public int                  dwSize;	                                    		// 结构体大小
        public int                  nMaxRetNum;                                 		// 查询返回的最大数量
        public Pointer       		pUserInfo;                                 		    // 用户信息，对应数组 NET_ACCESS_USER_INFO,内存由用户申请释放，申请大小不小于 nUserNum*sizeof(NET_ACCESS_USER_INFO)                                                                           // 返回个数同NET_IN_ACCESS_USER_SERVICE_GET中nUserNum
        public Pointer            	pFailCode;                                  		// 对应FAIL_CODE, 查询失败时，内存由用户申请释放,对应查询的每一项的结果，返回个数同NET_IN_ACCESS_USER_SERVICE_GET中nUserNum

        public NET_OUT_ACCESS_USER_SERVICE_GET() {
            this.dwSize = this.size();
        }
    }

    // 删除指定ID人员信息入参
    public static class NET_IN_ACCESS_USER_SERVICE_REMOVE extends SdkStructure
    {
        public int                  dwSize;	                                    		// 结构体大小
        public int                  nUserNum;                                   		// 删除的数量
        public USERID[]			    szUserIDs = (USERID[])new USERID().toArray(100);    // 用户ID列表

        public NET_IN_ACCESS_USER_SERVICE_REMOVE() {
            this.dwSize = this.size();
        }
    }

    // 删除指定ID人员信息出参
    public static class NET_OUT_ACCESS_USER_SERVICE_REMOVE extends SdkStructure
    {
        public int                  dwSize;	                                    	   // 结构体大小
        public int                  nMaxRetNum;                                        // 返回的最大数量,不小于 NET_IN_ACCESS_USER_SERVICE_REMOVE中nUserNum
        public Pointer            	pFailCode;                          			   // 对应FAIL_CODE, 插入失败时，内存由用户申请释放,对应插入的每一项的结果,返回个数同NET_IN_ACCESS_USER_SERVICE_REMOVE中nUserNum

        public NET_OUT_ACCESS_USER_SERVICE_REMOVE() {
            this.dwSize = this.size();
        }
    }

    // 删除所有人员信息入参
    public static class NET_IN_ACCESS_USER_SERVICE_CLEAR extends SdkStructure
    {
        public int                  dwSize;	                                    	  // 结构体大小

        public NET_IN_ACCESS_USER_SERVICE_CLEAR() {
            this.dwSize = this.size();
        }
    }

    // 删除所有人员信息出参
    public static class NET_OUT_ACCESS_USER_SERVICE_CLEAR extends SdkStructure
    {
        public int                 dwSize;	                                    	// 结构体大小

        public NET_OUT_ACCESS_USER_SERVICE_CLEAR() {
            this.dwSize = this.size();
        }
    }

    // 用户类型
    public static class NET_ENUM_USER_TYPE extends SdkStructure
    {
        public static final int NET_ENUM_USER_TYPE_UNKNOWN = -1;            			// 未知用户
        public static final int NET_ENUM_USER_TYPE_NORMAL = 0;                  		// 普通用户
        public static final int NET_ENUM_USER_TYPE_BLACKLIST = 1;               		// 黑名单用户
        public static final int NET_ENUM_USER_TYPE_GUEST = 2;                   		// 来宾账户
        public static final int NET_ENUM_USER_TYPE_PATROL = 3;                  		// 巡逻用户
        public static final int NET_ENUM_USER_TYPE_VIP = 4;                     		// VIP用户
        public static final int NET_ENUM_USER_TYPE_HANDICAP = 5;               			// 残疾用户
    }

    // 用户信息
    public static class NET_ACCESS_USER_INFO extends SdkStructure
    {
        public byte[]				szUserID = new byte[NET_MAX_USERID_LEN];				// 用户ID
        public byte[]				szName = new byte[MAX_COMMON_STRING_32];				// 人员名称
        public int          		emUserType;                                 			// 用户类型, 对应枚举  NET_ENUM_USER_TYPE
        public int                  nUserStatus;                                			// 用户状态, 0 正常, 1 冻结
        public int                  nUserTime;                                  			// 来宾卡的通行次数
        public byte[]			    szCitizenIDNo = new byte[MAX_COMMON_STRING_32];			// 身份证号码
        public byte[]               szPsw = new byte[NET_MAX_CARDPWD_LEN];                  // UserID+密码开门时密码
        public int                  nDoorNum;                                   			// 有效的门数目;
        public int[]                nDoors = new int[NET_MAX_DOOR_NUM];                     // 有权限的门序号,即 CFG_CMD_ACCESS_EVENT 配置的数组下标
        public int                  nTimeSectionNum;                            			// 有效的的开门时间段数目
        public int[]                nTimeSectionNo = new int[NET_MAX_TIMESECTION_NUM];      // 开门时间段索引,即 CFG_ACCESS_TIMESCHEDULE_INFO 的数组下标
        public int				    nSpecialDaysScheduleNum;								// 假日计划表示数量
        public int[]				nSpecialDaysSchedule = new int[MAX_ACCESSDOOR_NUM];		// 假日计划标识, 即 NET_EM_CFG_ACCESSCTL_SPECIALDAYS_SCHEDULE 配置的下标
        public NET_TIME             stuValidBeginTime = new NET_TIME();                     // 开始有效期
        public NET_TIME             stuValidEndTime = new NET_TIME();                       // 结束有效期
        public int                  bFirstEnter;                                			// 是否拥有首卡权限, 1-true, 0-false
        public int                  nFirstEnterDoorsNum;                        			// 拥有首用户权限的门数量
        public int[]                nFirstEnterDoors = new int[NET_MAX_DOOR_NUM];           // 拥有首用户权限的门序号，bFirstEnter为TRUE时有效,-1表示全通道
        public int    				emAuthority;                                			// 用户权限，可选, 对应枚举   NET_ATTENDANCE_AUTHORITY
        public int                  nRepeatEnterRouteTimeout;                   			// 反潜超时时间
        public int                  nFloorNum;                                              // 有效的楼层数量
        public ACCESS_FLOOR_INFO[]  szFloorNos = (ACCESS_FLOOR_INFO[])new ACCESS_FLOOR_INFO().toArray(MAX_ACCESS_FLOOR_NUM); // 楼层号列表
        public int			        nRoom;												    // 房间个数
        public ROOM_INFO[]		    szRoomNos = (ROOM_INFO[])new ROOM_INFO().toArray(MAX_ROOMNUM_COUNT); 	    			 // 房间号列表
        public boolean			    bFloorNoExValid;										// szFloorNoEx 是否有效
        public int                  nFloorNumEx;											// 有效的楼层数量扩展
        public FloorNoEx_INFO[]     szFloorNoEx=(FloorNoEx_INFO[])new FloorNoEx_INFO().toArray(256);	// 楼层号扩展
        public byte[]				szClassInfo=new byte[256];										// 班级信息
        public byte[]				szStudentNo=new byte[64];										// 学号（定制）
        public byte[]				szCitizenAddress=new byte[128];									// 身份证地址
        public NET_TIME				stuBirthDay;											// 出生日期（年月日有效）
        public int                  emSex;                             						// 性别,枚举值参考NET_ACCESSCTLCARD_SEX
        public byte[]				szDepartment=new byte[128];										// 部门
        public byte[]				szSiteCode=new byte[32];											// 站点码（定制）
        public byte[]				szPhoneNumber=new byte[32];										// 手机号码
        public byte[]				szDefaultFloor=new byte[8];										// 默认楼层号
        public boolean				bFloorNoEx2Valid;										// 是否使用扩展结构体
        /**
         * 对应结构体,{@link NET_FLOORS_INFO}
         */
        public Pointer			    pstuFloorsEx2;											// 楼层号（再次扩展）
        public boolean				bHealthStatus;										// 人员健康状态 (定制)
        public int					nUserTimeSectionsNum;								// 用户自身的开门时间段校验有效个数
        // 针对用户自身的开门时间段校验
        public USER_TIME_SECTION[]	szUserTimeSections=(USER_TIME_SECTION[]) new USER_TIME_SECTION().toArray(6);
        public byte[]				szEthnicity=new byte[64];										// 民族
        /**
         * EM_TYPE_OF_CERTIFICATE
         */
        public int		            emTypeOfCertificate;				// 证件类型
        public byte[]				szCountryOrAreaCode=new byte[8];	// 国籍或所在地区代码，符合GB/T2659-2000的规范
        public byte[]				szCountryOrAreaName=new byte[64];	// 国籍或所在地区名称，符合GB/T2659-2000的规范
        public byte[]				szCertificateVersionNumber=new byte[64];// 永久居住证的证件版本号
        public byte[]				szApplicationAgencyCode=new byte[64];	// 申请受理机关代码
        public byte[]				szIssuingAuthority=new byte[64];		// 签发机关
        public byte[]				szStartTimeOfCertificateValidity=new byte[64];	// 证件有效开始时间
        public byte[]				szEndTimeOfCertificateValidity=new byte[64];	// 证件有效结束时间
        public int					nSignNum;												// 证件签发次数
        public byte[]				szActualResidentialAddr=new byte[108];		// 实际家庭住址
        public byte[]               byReserved=new byte[1732];					// 保留字节
    }
    public static class FloorNoEx_INFO extends SdkStructure{
        public byte[] szFloorNoEx=new byte[4];
    }
    public static class ACCESS_FLOOR_INFO extends SdkStructure
    {
        public byte[]              szFloorNo = new byte[NET_COMMON_STRING_16];   			// 楼层号
    }

    public static class ROOM_INFO extends SdkStructure
    {
        public byte[]		       szRoomNo = new byte[NET_COMMON_STRING_16]; 	 			// 房间号
    }

    // 操作错误码
    public static class NET_EM_FAILCODE extends SdkStructure
    {
        public static final int NET_EM_FAILCODE_NOERROR = 0;                                // 没有错误
        public static final int NET_EM_FAILCODE_UNKNOWN = 1;                                // 未知错误
        public static final int NET_EM_FAILCODE_INVALID_PARAM = 2;                          // 参数错误
        public static final int NET_EM_FAILCODE_INVALID_PASSWORD = 3;                       // 无效密码
        public static final int NET_EM_FAILCODE_INVALID_FP = 4;                             // 无效指纹数据
        public static final int NET_EM_FAILCODE_INVALID_FACE = 5;                           // 无效人脸数据
        public static final int NET_EM_FAILCODE_INVALID_CARD = 6;                           // 无效卡数据
        public static final int NET_EM_FAILCODE_INVALID_USER = 7;                           // 无效人数据
        public static final int NET_EM_FAILCODE_FAILED_GET_SUBSERVICE = 8;                  // 能力集子服务获取失败
        public static final int NET_EM_FAILCODE_FAILED_GET_METHOD = 9;                      // 获取组件的方法集失败
        public static final int NET_EM_FAILCODE_FAILED_GET_SUBCAPS = 10;                    // 获取资源实体能力集失败
        public static final int NET_EM_FAILCODE_ERROR_INSERT_LIMIT = 11;                    // 已达插入上限
        public static final int NET_EM_FAILCODE_ERROR_MAX_INSERT_RATE = 12;                 // 已达最大插入速度
        public static final int NET_EM_FAILCODE_FAILED_ERASE_FP = 13;						// 清除指纹数据失败
        public static final int NET_EM_FAILCODE_FAILED_ERASE_FACE = 14;						// 清除人脸数据失败
        public static final int NET_EM_FAILCODE_FAILED_ERASE_CARD = 15;						// 清除卡数据失败
        public static final int NET_EM_FAILCODE_NO_RECORD = 16;								// 没有记录
        public static final int NET_EM_FAILCODE_NOMORE_RECORD = 17;							// 查找到最后，没有更多记录
        public static final int NET_EM_FAILCODE_RECORD_ALREADY_EXISTS = 18;					// 下发卡或指纹时，数据重复
        public static final int NET_EM_FAILCODE_MAX_FP_PERUSER = 19;						// 超过个人最大指纹记录数
        public static final int NET_EM_FAILCODE_MAX_CARD_PERUSER = 20;						// 超过个人最大卡片记录数
        public static final int NET_EM_FAILCODE_EXCEED_MAX_PHOTOSIZE=21;									// 超出最大照片大小
        public static final int NET_EM_FAILCODE_INVALID_USERID=22;											// 用户ID无效（未找到客户）
        public static final int NET_EM_FAILCODE_EXTRACTFEATURE_FAIL=23;									// 提取人脸特征失败
        public static final int NET_EM_FAILCODE_PHOTO_EXIST=24;											// 人脸照片已存在
        public static final int NET_EM_FAILCODE_PHOTO_OVERFLOW=25;											// 超出最大人脸照片数
        public static final int NET_EM_FAILCODE_INVALID_PHOTO_FORMAT=26;									// 照片格式无效
        public static final int NET_EM_FAILCODE_EXCEED_ADMINISTRATOR_LIMIT=27;								// 超出管理员人数限制
        public static final int NET_EM_FAILECODE_FACE_FEATURE_ALREADY_EXIST=28;							// 人脸特征已存在
        public static final int NET_EM_FAILECODE_FINGERPRINT_EXIST=29;										// 指纹已存在
        public static final int NET_EM_FAILECODE_CITIZENID_EXIST=30;										// 身份证号已存在
        public static final int NET_EM_FAILECODE_NORMAL_USER_NOTSUPPORT=31;								// 不支持普通用户下发
        public static final int NET_EM_FAILCODE_NO_FACE_DETECTED=32;										// 图片中检测到0个人脸目标
        public static final int NET_EM_FAILCODE_MULTI_FACE_DETECTED=33;									// 图片中检测到多个人脸，无法返回特征
        public static final int NET_EM_FAILCODE_PICTURE_DECODING_ERROR=34;									// 图片解码错误
        public static final int NET_EM_FAILCODE_LOW_PICTURE_QUALITY=35;									// 图片质量太低
        public static final int NET_EM_FAILCODE_NOT_RECOMMENDED=36;										// 结果不推荐使用，比如：对外国人，特征提取成功，但算法支持不好，容易造成误识别
        public static final int NET_EM_FAILCODE_FACE_ANGLE_OVER_THRESHOLDS=37;								// 人脸角度超过配置阈值
        public static final int NET_EM_FAILCODE_FACE_RADIO_EXCEEDS_RANGE=38;								// 人脸占比超出范围，算法建议占比:不要超过2/3;不要小于1/3
        public static final int NET_EM_FAILCODE_FACE_OVER_EXPOSED=39;										// 人脸过爆
        public static final int NET_EM_FAILCODE_FACE_UNDER_EXPOSED=40;										// 人脸欠爆
        public static final int NET_EM_FAILCODE_BRIGHTNESS_IMBALANCE=41;									// 人脸亮度不均衡 ,用于判断阴阳脸
        public static final int NET_EM_FAILCODE_FACE_LOWER_CONFIDENCE=42;									// 人脸的置信度低
        public static final int NET_EM_FAILCODE_FACE_LOW_ALIGN=43;										// 人脸对齐分数低
        public static final int NET_EM_FAILCODE_FRAGMENTARY_FACE_DETECTED=44;								// 人脸存在遮挡、残缺不全
        public static final int NET_EM_FAILCODE_PUPIL_DISTANCE_NOT_ENOUGH=45;								// 人脸瞳距小于阈值
        public static final int NET_EM_FAILCODE_FACE_DATA_DOWNLOAD_FAILED=46;								// 人脸数据下载失败
        public static final int NET_EM_FAILCODE_FACE_FFE_FAILED=47;										// 人脸可检测，但特征值提取失败（算法场景）
        public static final int NET_EM_FAILCODE_PHOTO_FEATURE_FAILED_FOR_FA=48;							// 人脸照片因口罩，帽子，墨镜等人脸属性不符合而提取特征值错误
        public static final int NET_EM_FAILCODE_FACE_DATA_PHOTO_INCOMPLETE=49;								// 人脸照片不完整
    }

    /*************************************************************************************************
     * 							门禁卡信息操作：增、删、改、查、清空
     ************************************************************************************************/
    // 卡片信息操作类型
    public static class NET_EM_ACCESS_CTL_CARD_SERVICE extends SdkStructure
    {
        public static final int NET_EM_ACCESS_CTL_CARD_SERVICE_INSERT = 0;                  // 添加, pstInParam = NET_IN_ACCESS_CARD_SERVICE_INSERT , pstOutParam = NET_OUT_ACCESS_CARD_SERVICE_INSERT
        public static final int NET_EM_ACCESS_CTL_CARD_SERVICE_GET = 1;                     // 获取, pstInParam = NET_IN_ACCESS_CARD_SERVICE_GET , pstOutParam = NET_OUT_ACCESS_CARD_SERVICE_GET
        public static final int NET_EM_ACCESS_CTL_CARD_SERVICE_UPDATE = 2;                  // 更新, pstInParam = NET_IN_ACCESS_CARD_SERVICE_UPDATE , pstOutParam = NET_OUT_ACCESS_CARD_SERVICE_UPDATE
        public static final int NET_EM_ACCESS_CTL_CARD_SERVICE_REMOVE = 3;                  // 删除, pstInParam = NET_IN_ACCESS_CARD_SERVICE_REMOVE , pstOutParam = NET_OUT_ACCESS_CARD_SERVICE_REMOVE
        public static final int NET_EM_ACCESS_CTL_CARD_SERVICE_CLEAR = 4;                   // 清空, pstInParam = NET_IN_ACCESS_CARD_SERVICE_CLEAR , pstOutParam = NET_OUT_ACCESS_CARD_SERVICE_CLEAR
    }

    // 卡片信息
    public static class NET_ACCESS_CARD_INFO extends SdkStructure
    {
        public byte[]               szCardNo = new byte[NET_MAX_CARDNO_LEN];                // 卡号
        public byte[]				szUserID = new byte[NET_MAX_USERID_LEN];				// 用户ID
        public int      			emType;                                     			// 卡类型,只支持一般卡、胁迫卡和母卡, 对应 NET_ACCESSCTLCARD_TYPE
        public byte[]			    szDynamicCheckCode = new byte[MAX_COMMON_STRING_16];	// 动态校验码
        public byte[]               byReserved = new byte[4096];                            // 保留字节
    }

    // 新增卡片信息入参
    public static class NET_IN_ACCESS_CARD_SERVICE_INSERT extends SdkStructure
    {
        public int                  dwSize;	                                    			// 结构体大小
        public int                  nInfoNum;                                   			// 用户信息数量
        public Pointer       		pCardInfo;                                  			// 卡片信息,对应数组NET_ACCESS_CARD_INFO,用户分配释放内存,大小为sizeof(NET_ACCESS_CARD_INFO)*nInfoNum

        public NET_IN_ACCESS_CARD_SERVICE_INSERT() {
            this.dwSize = this.size();
        }
    }

    // 新增卡片信息出参
    public static class NET_OUT_ACCESS_CARD_SERVICE_INSERT extends SdkStructure
    {
        public int                  dwSize;	                                    			// 结构体大小
        public int                  nMaxRetNum;                                 			// 最大返回的用户信息数量,不小于NET_IN_ACCESS_CARD_SERVICE_INSERT中nInfoNum
        public Pointer              pFailCode;                                  			// 对应  FAIL_CODE, 用户分配释放内存,插入失败时,对应插入的每一项的结果,返回个数同NET_IN_ACCESS_CARD_SERVICE_INSERT中nInfoNum
        public byte[]               byReserved = new byte[4];

        public NET_OUT_ACCESS_CARD_SERVICE_INSERT() {
            this.dwSize = this.size();
        }
    }

    // 获取卡片信息入参
    public static class NET_IN_ACCESS_CARD_SERVICE_GET extends SdkStructure
    {
        public int                   dwSize;	                                   			// 结构体大小
        public int                   nCardNum;                                   			// 查询的数量
        public CARDNO[]              szCardNos = (CARDNO[])new CARDNO().toArray(100);   	// 卡号列表

        public NET_IN_ACCESS_CARD_SERVICE_GET() {
            this.dwSize = this.size();
        }
    }

    public static class CARDNO extends SdkStructure
    {
        public byte[]               szCardNo = new byte[32];                          		// 卡号
    }

    // 获取卡片信息出参
    public static class NET_OUT_ACCESS_CARD_SERVICE_GET extends SdkStructure
    {
        public int                  dwSize;                                     			// 结构体大小
        public int                  nMaxRetNum;                                 			// 查询返回的最大数量
        public Pointer       		pCardInfo;                                  			// 卡片信息,对应数组NET_ACCESS_CARD_INFO,内存由用户申请释放，申请大小不小于nCardNum*sizeof(NET_ACCESS_CARD_INFO);                                                                           // 返回个数同NET_IN_ACCESS_CARD_SERVICE_GET中nCardNum
        public Pointer           	pFailCode;                                  			// 对应FAIL_CODE, 查询失败时，对应查询的每一项的结果,返回个数同NET_IN_ACCESS_CARD_SERVICE_GET中nCardNum

        public NET_OUT_ACCESS_CARD_SERVICE_GET() {
            this.dwSize = this.size();
        }
    }

    // 更新卡片信息入参
    public static class NET_IN_ACCESS_CARD_SERVICE_UPDATE extends SdkStructure
    {
        public int                  dwSize;	                                    			// 结构体大小
        public int                  nInfoNum;                                   			// 用户信息数量
        public Pointer       		pCardInfo;                                  			// 卡片信息, 对应数组NET_ACCESS_CARD_INFO,用户分配释放内存,大小为sizeof(NET_ACCESS_CARD_INFO)*nInfoNum

        public NET_IN_ACCESS_CARD_SERVICE_UPDATE() {
            this.dwSize = this.size();
        }
    }

    // 更新卡片信息出参
    public static class NET_OUT_ACCESS_CARD_SERVICE_UPDATE extends SdkStructure
    {
        public int                   dwSize;	                                    		// 结构体大小
        public int                   nMaxRetNum;                                 			// 最大返回的用户信息数量,不小于NET_IN_ACCESS_CARD_SERVICE_UPDATE中nInfoNum
        public Pointer               pFailCode;                                  			// 对应 FAIL_CODE, 用户分配释放内存,插入失败时，对应插入的每一项的结果,返回个数同NET_IN_ACCESS_CARD_SERVICE_UPDATE中nInfoNum
        public byte[]                byReserved = new byte[4];

        public NET_OUT_ACCESS_CARD_SERVICE_UPDATE() {
            this.dwSize = this.size();
        }
    }

    // 删除指定卡号信息入参
    public static class NET_IN_ACCESS_CARD_SERVICE_REMOVE extends SdkStructure
    {
        public int                   dwSize;	                                    		// 结构体大小
        public int                   nCardNum;                                   			// 删除的数量
        public CARDNO[]              szCardNos = (CARDNO[])new CARDNO().toArray(100);       // 卡号列表

        public NET_IN_ACCESS_CARD_SERVICE_REMOVE() {
            this.dwSize = this.size();
        }
    }

    // 删除指定卡号信息出参
    public static class NET_OUT_ACCESS_CARD_SERVICE_REMOVE extends SdkStructure
    {
        public int                   dwSize;	                                    		// 结构体大小
        public int                   nMaxRetNum;                                 			// 最大返回信息数量,不小于 NET_IN_ACCESS_CARD_SERVICE_REMOVE中nCardNum
        public Pointer            	 pFailCode;                                  			// 对应 FAIL_CODE, 用户分配释放内存,插入失败时,对应删除的每一项的结果,返回个数同NET_IN_ACCESS_CARD_SERVICE_REMOVE中nCardNum
        public byte[]                byReserved = new byte[4];

        public NET_OUT_ACCESS_CARD_SERVICE_REMOVE() {
            this.dwSize = this.size();
        }
    }

    // 删除所有卡片信息入参
    public static class NET_IN_ACCESS_CARD_SERVICE_CLEAR extends SdkStructure
    {
        public int                   dwSize;	                                    		// 结构体大小

        public NET_IN_ACCESS_CARD_SERVICE_CLEAR() {
            this.dwSize = this.size();
        }
    }

    // 删除所有卡片信息出参
    public static class NET_OUT_ACCESS_CARD_SERVICE_CLEAR extends SdkStructure
    {
        public int                   dwSize;	                                    	    // 结构体大小

        public NET_OUT_ACCESS_CARD_SERVICE_CLEAR() {
            this.dwSize = this.size();
        }
    }

    // 产品定义
    public static class NET_PRODUCTION_DEFNITION extends SdkStructure
    {
        public int                 dwSize;
        public int                 nVideoInChannel;                        // 视频输入通道数
        public int                 nVideoOutChannel;                       // 视频输出通道数
        public int                 nRemoteDecChannel;                      // 远程解码通道数
        public byte[]              szDevType = new byte[NET_DEV_TYPE_LEN]; // 设备类型
        public byte[]              szVendor = new byte[NET_MAX_NAME_LEN];  // OEM客户
        public int                 nOEMVersion;                            // OEM版本
        public int                 nMajorVerion;                           // 主版本号
        public int                 nMinorVersion;                          // 次版本号
        public int                 nRevision;                              // 修订版本
        public byte[]              szWebVerion = new byte[NET_MAX_NAME_LEN];   // Web版本
        public byte[]              szDefLanguage = new byte[NET_MAX_NAME_LEN]; // 默认语言
        public NET_TIME            stuBuildDateTime;                       // 发布时间, 精确到秒
        public int                 nAudioInChannel;                        // 音频输入通道数
        public int                 nAudioOutChannel;                       // 音频输出通道数
        public int                 bGeneralRecord;                         // 是否支持定时存储
        public int                 bLocalStore;                            // 是否支持本地存储
        public int                 bRemoteStore;                           // 是否支持网络存储
        public int                 bLocalurgentStore;                      // 是否支持紧急存储到本地
        public int                 bRealtimeCompress;                      // 是否支持实时压缩存储
        public int                 dwVideoStandards;                       // 支持的视频制式列表, bit0-PAL, bit1-NTSC
        public int                 nDefVideoStandard;                      // 默认视频制式, 0-PAL, 1-NTSC
        public int                 nMaxExtraStream;                        // 最大辅码流路数
        public int                 nRemoteRecordChannel;                   // 远程录像通道数
        public int                 nRemoteSnapChannel;                     // 远程抓图通道数
        public int                 nRemoteVideoAnalyseChannel;             // 远程视频分析通道数
        public int                 nRemoteTransmitChannel;                 // 远程实时流转发最大通道数
        public int                 nRemoteTransmitFileChannel;             // 远程文件流竹筏通道通道数
        public int                 nStreamTransmitChannel;                 // 最大网络传输通道总数
        public int                 nStreamReadChannel;                     // 最大读文件流通道总数
        public int                 nMaxStreamSendBitrate;                  // 最大码流网络发送能力, kbps
        public int                 nMaxStreamRecvBitrate;                  // 最大码流网络接口能力, kbps
        public int                 bCompressOldFile;                       // 是否压缩旧文件, 去除P帧, 保留I帧
        public int                 bRaid;                                  // 是否支持RAID
        public int                 nMaxPreRecordTime;                      // 最大预录时间, s
        public int                 bPtzAlarm;                              // 是否支持云台报警
        public int                 bPtz;                                   // 是否支持云台
        public int                 bATM;                                   // 是否显示ATM相关功能
        public int                 b3G;                                    // 是否支持3G模块
        public int                 bNumericKey;                            // 是否带数字键
        public int                 bShiftKey;                              // 是否带Shift键
        public int                 bCorrectKeyMap;                         // 数字字母映射表是否正确
        public int                 bNewATM;                                // 新的二代ATM前面板
        public int                 bDecoder;                               // 是否是解码器
        public DEV_DECODER_INFO    stuDecoderInfo;                         // 解码器信息, bDecoder=true时有效
        public int                 nVideoOutputCompositeChannels;          // 融合屏输出通道上限
        public int                 bSupportedWPS;                          // 是否支持WPS功能
        public int                 nVGAVideoOutputChannels;                // VGA视频输出通道数
        public int                 nTVVideoOutputChannels;                 // TV视频输出通道数
        public int                 nMaxRemoteInputChannels;                // 最大远程通道数
        public int                 nMaxMatrixInputChannels;                // 最大矩阵通道数
        public int                 nMaxRoadWays;                           // 智能交通最大车道数 1~6
        public int                 nMaxParkingSpaceScreen;                 // 和相机对接最多支持的区域屏个数 0~20

        public int                 nPtzHorizontalAngleMin;                 // 云台水平最小角度, [0-360]
        public int                 nPtzHorizontalAngleMax;                 // 云台水平最大角度, [0-360]
        public int                 nPtzVerticalAngleMin;                   // 云台垂直最小角度, [-90,90]
        public int                 nPtzVerticalAngleMax;                   // 云台垂直最大角度, [-90,90]
        public int                 bPtzFunctionMenu;                       // 是否支持云台功能菜单
        public int                 bLightingControl;                       // 是否支持灯光控制
        public int                 dwLightingControlMode;                  // 手动灯光控制模式, 按位, 见NET_LIGHTING_CTRL_ON_OFF
        public int                 nNearLightNumber;                       // 近光灯组数量, 0表示不支持
        public int                 nFarLightNumber;                        // 远光灯组数量, 0表示不支持
        public int                 bFocus;                                 // 是否支持控制聚焦
        public int                 bIris;                                  // 是否支持控制光圈
        public byte[]              szPtzProtocolList = new byte[NET_COMMON_STRING_1024];// 云台支持的协议列表, 可以是多个, 每个用';'分隔
        public int                 bRainBrushControl;                      // 是否支持雨刷控制
        public int                 nBrushNumber;                           // 雨刷数量, 为0时表示不支持
        public int[]               nLowerMatrixInputChannels = new int[NET_MAX_LOWER_MITRIX_NUM]; // 下位矩阵视频输入通道, 下标对应矩阵编号
        public int[]               nLowerMatrixOutputChannels = new int[NET_MAX_LOWER_MITRIX_NUM];// 下位矩阵视频输出通道, 下标对应矩阵编号
        public int                 bSupportVideoAnalyse;                   // 是否支持智能分析
        public int                 bSupportIntelliTracker;                 // 是否支持智能跟踪

        public int                 nSupportBreaking;                       //设备支持的违章类型掩码(按位获取)
        //0-闯红灯 1-压线 2-逆行 3-欠速 4-超速 5-有车占道 6-黄牌占道 7-违章行驶（左转、右转、调头）
        //8-违章进入待行区 9-违章停车 10-交通拥堵 11-不按车道行驶 12-违章变道 13-压黄线 14-路肩行驶
        //15-手动抓拍 16-违章滞留 17-斑马线行人优先 18-流量过大 19-流量过小 20-违章占道 21-违章倒车
        //22-压停止线 23-闯黄灯 24-黄网格线停车 25-车位有车 26-车位无车 27-车位有车压线 28-受限车牌
        //29-禁行 30-不系安全带 31-驾驶员抽烟
        public int                 nSupportBreaking1;                      //0-驾驶员打电话 1-行人闯红灯 2-车辆拥堵禁入 3-未按规定依次交替通行
        public NET_PD_VIDEOANALYSE stuVideoAnalyse;                        //智能分析
        public int                 bTalkTransfer;                          //是否支持转发对讲功能
        public int				   bCameraAttribute;						// 是否支持球机摄像头属性页面
        public int				   bPTZFunctionViaApp;						// 是否支持由应用主控的云台功能逻辑
        public int				   bAudioProperties;						// 喇叭是否支持语音播报
        public int				   bIsCameraIDOsd;							// 是否支持摄像机编号叠加
        public int				   bIsPlaceOsd;								// 是否支持地点信息叠加

        public int				   nMaxGeographyTitleLine;					// 地理位置叠加最大支持行数
        public int 				   emAudioChannel;					    	// 设备声道支持类型,详见EM_AUDIO_CHANNEL_TYPE
        public byte[]			   szVendorAbbr = new byte[NET_COMMON_STRING_32];		// 厂商缩写
        public byte[]			   szTypeVersion = new byte[NET_COMMON_STRING_32];		// 软件发布类型
        public int				   bIsVideoNexus;							// 是否是视讯互联大基线
        public int                 emWlanScanAndConfig;        // WIFI扫描及配置支持的版本类型,EM_WLAN_SCAN_AND_CONFIG_TYPE
        public boolean             bSupportLensMasking;                    // IPC是否支持镜头调节到负角度，进行结构遮挡
        public NET_PRODUCTION_DEFNITION(){
            this.dwSize =  this.size();
        }
    }


    // 解码器信息
    public static class DEV_DECODER_INFO extends SdkStructure
    {
        public byte[]            	szDecType = new byte[64];           // 类型
        public int             		nMonitorNum;                        // TV个数
        public int             		nEncoderNum;                        // 解码通道个数
        public byte[]            	szSplitMode = new byte[16];         // 支持的TV画面分割数,以数组形式表示,0为结尾
        public byte[]            	bMonitorEnable = new byte[16];      // 各TV使能
        public byte            		bTVTipDisplay;                      // 指示是否支持TV提示信息叠加设置, 0:不支持 1:支持.
        public byte[]            	reserved1 = new byte[3];
        public byte[]            	byLayoutEnable = new byte[48];      // 各解码通道显示叠加信息使能
        public int[]           		dwLayoutEnMask = new int[2];        // 各解码通道显示叠加信息使能掩码,从低位到高位支持64个通道,其中dwLayoutEnMask[0]是低32位
        public byte[]            	reserved = new byte[4];
    }

    // 智能分析
    public static class NET_PD_VIDEOANALYSE extends SdkStructure
    {
        public int                	   bSupport;                   // 是否支持智能分析
        public NET_COMMON_STRING_64[]  szSupportScenes = (NET_COMMON_STRING_64[])new NET_COMMON_STRING_64().toArray(NET_VIDEOANALYSE_SCENES);   // 支持的场景
        public NET_COMMON_STRING_64[]  SupportRules = (NET_COMMON_STRING_64[])new NET_COMMON_STRING_64().toArray(NET_VIDEOANALYSE_RULES);;       // 支持的规则
    }

    public static class NET_COMMON_STRING_64 extends SdkStructure
    {
        public byte[]     szCommon = new byte[NET_COMMON_STRING_64];   // 通用64位字符串
    }

    /*************************************************************************************************
     * 							门禁人脸信息操作：增、删、改、查、清空
     ************************************************************************************************/
    // 人脸信息操作类型
    public static class NET_EM_ACCESS_CTL_FACE_SERVICE extends SdkStructure
    {
        public static final int NET_EM_ACCESS_CTL_FACE_SERVICE_INSERT = 0;                  // 添加, pInbuf = NET_IN_ACCESS_FACE_SERVICE_INSERT , pOutBuf = NET_OUT_ACCESS_FACE_SERVICE_INSERT
        public static final int NET_EM_ACCESS_CTL_FACE_SERVICE_GET = 1;                     // 获取, pInbuf = NET_IN_ACCESS_FACE_SERVICE_GET , pOutBuf = NET_OUT_ACCESS_FACE_SERVICE_GET
        public static final int NET_EM_ACCESS_CTL_FACE_SERVICE_UPDATE = 2;                  // 更新, pInbuf = NET_IN_ACCESS_FACE_SERVICE_UPDATE , pOutBuf = NET_OUT_ACCESS_FACE_SERVICE_UPDATE
        public static final int NET_EM_ACCESS_CTL_FACE_SERVICE_REMOVE = 3;                  // 删除, pInbuf = NET_IN_ACCESS_FACE_SERVICE_REMOVE , pOutBuf = NET_OUT_ACCESS_FACE_SERVICE_REMOVE
        public static final int NET_EM_ACCESS_CTL_FACE_SERVICE_CLEAR = 4;                   // 清空, pInbuf = NET_IN_ACCESS_FACE_SERVICE_CLEAR , pOutBuf = NET_OUT_ACCESS_FACE_SERVICE_CLEAR
    }

    // 人脸信息
    public static class NET_ACCESS_FACE_INFO extends SdkStructure
    {
        public byte[]					szUserID = new byte[32];	                            // 用户ID
        public int 		                nFaceData;												// 人脸模板数据个数,最大20
        public FACEDATA[]		        szFaceDatas = (FACEDATA[])new FACEDATA().toArray(20);	// 人脸模板数据
        public int[]                    nFaceDataLen = new int[20];                             // 人脸模版数据大小
        public int                      nFacePhoto;                                         	// 人脸照片个数,不超过5个
        public int[]                    nInFacePhotoLen = new int[5];                           // 用户申请的每张图片的大小
        public int[]                    nOutFacePhotoLen = new int[5];                          // 每张图片实际的大小
        public FACEPHOTO[]              pFacePhotos = (FACEPHOTO[])new FACEPHOTO().toArray(5);  // 人脸照片数据数组
        public boolean					bFaceDataExEnable;									// 是否使用扩展人脸模板数据
        public FACEDATAEX[]				pFaceDataEx=(FACEDATAEX[])new FACEDATAEX().toArray(20);	// 人脸模板数据扩展字段 当bFaceDataExEnable有效时，建议使用扩展字段pFaceDataEx
        public byte[]                    byReserved=new byte[1960];                                   // 保留字节
    }

    public static class FACEDATA extends SdkStructure
    {
        public byte[]		            szFaceData = new byte[2048];		                    // 人脸模板数据
    }
    public static class FACEDATAEX extends SdkStructure{
        public Pointer pFaceDataEx;//人脸模板数据拓展,当bFaceDataExEnable为true有效
    }
    public static class FACEPHOTO extends SdkStructure
    {
        public Pointer        			pFacePhoto;												// 人脸照片数据,大小不超过200K
    }

    // 添加人脸记录信息输入参数(NET_EM_ACCESS_CTL_FACE_SERVICE_INSERT)
    public static class NET_IN_ACCESS_FACE_SERVICE_INSERT extends SdkStructure
    {
        public int 					    dwSize;                                                 // 结构体大小
        public int                      nFaceInfoNum;                                       	// 人脸信息数量
        public Pointer	    			pFaceInfo;					                        	// 人脸数据,用户自行分配数据, 对应数组NET_ACCESS_FACE_INFO

        public NET_IN_ACCESS_FACE_SERVICE_INSERT() {
            this.dwSize = this.size();
        }
    }

    // 添加人脸记录信息输出参数(NET_EM_ACCESS_CTL_FACE_SERVICE_INSERT)
    public static class NET_OUT_ACCESS_FACE_SERVICE_INSERT extends SdkStructure
    {
        public int 			            dwSize;                                             	// 结构体大小
        public int                      nMaxRetNum;                                         	// 最大返回数量,不小于 NET_IN_ACCESS_FACE_SERVICE_INSERT 中的nFaceInfoNum
        public Pointer            		pFailCode;                                          	// 对应FAIL_CODE, 用户分配内存,添加失败时,对应插入的每一项的结果,返回个数同NET_IN_ACCESS_FACE_SERVICE_INSERT中的nFaceInfoNum

        public NET_OUT_ACCESS_FACE_SERVICE_INSERT() {
            this.dwSize = this.size();
        }
    }

    // 批量获取多用户多个人脸输入参数(NET_EM_ACCESS_CTL_FACE_SERVICE_GET)
    public static class NET_IN_ACCESS_FACE_SERVICE_GET extends SdkStructure
    {
        public int 			            dwSize;                                             	// 结构体大小
        public int                      nUserNum;                                           	// 用户ID数量,最大100
        public USERID[]			        szUserIDs = (USERID[])new USERID().toArray(100);	    // 用户ID

        public NET_IN_ACCESS_FACE_SERVICE_GET() {
            this.dwSize = this.size();
        }
    }

    // 批量获取多用户多个人脸输出参数(NET_EM_ACCESS_CTL_FACE_SERVICE_GET)
    public static class NET_OUT_ACCESS_FACE_SERVICE_GET extends SdkStructure
    {
        public int 			            dwSize;                                             	// 结构体大小
        public int                      nMaxRetNum;                                         	// 最大返回数量,不小于 NET_IN_ACCESS_FACE_SERVICE_GET 中的 nUserNum
        public Pointer	    			pFaceInfo;					                        	// 人脸数据, 对应数组NET_ACCESS_FACE_INFO,用户分配内存,返回个数同NET_IN_ACCESS_FACE_SERVICE_GET中的nUserNum,只返回人脸模版数据
        public Pointer            		pFailCode;                                          	// 对应 FAIL_CODE, 用户分配内存,获取失败时,对应获取的每一项的结果,返回个数同NET_IN_ACCESS_FACE_SERVICE_GET中的nUserNum

        public NET_OUT_ACCESS_FACE_SERVICE_GET() {
            this.dwSize = this.size();
        }
    }

    // 更新多用户多个人脸记录信息输入参数(NET_EM_ACCESS_CTL_FACE_SERVICE_UPDATE)
    public static class NET_IN_ACCESS_FACE_SERVICE_UPDATE extends SdkStructure
    {
        public int 					    dwSize;                                             // 结构体大小
        public int                      nFaceInfoNum;                                       // 人脸信息数量
        public Pointer	    			pFaceInfo;					                        // 人脸数据,用户分配内存, 对应数组 NET_ACCESS_FACE_INFO

        public NET_IN_ACCESS_FACE_SERVICE_UPDATE() {
            this.dwSize = this.size();
        }
    }

    // 更新多用户多个人脸记录信息输出参数(NET_EM_ACCESS_CTL_FACE_SERVICE_UPDATE)
    public static class NET_OUT_ACCESS_FACE_SERVICE_UPDATE extends SdkStructure
    {
        public int  			        dwSize;                                             // 结构体大小
        public int                      nMaxRetNum;                                         // 最大返回数量,不小于 NET_IN_ACCESS_FACE_SERVICE_UPDATE中的nFaceInfoNum
        public Pointer            		pFailCode;                                          // 对应 FAIL_CODE, 用户分配内存.更新失败时,对应更新的每一项的结果,返回个数同NET_IN_ACCESS_FACE_SERVICE_UPDATE中的nFaceInfoNum

        public NET_OUT_ACCESS_FACE_SERVICE_UPDATE() {
            this.dwSize = this.size();
        }
    }

    // 删除多用户的多个人脸信息输入参数(NET_EM_ACCESS_CTL_FACE_SERVICE_REMOVE)
    public static class NET_IN_ACCESS_FACE_SERVICE_REMOVE extends SdkStructure
    {
        public int 			            dwSize;                                             // 结构体大小
        public int                      nUserNum;                                           // 用户ID数量,最大100
        public USERID[]			        szUserIDs = (USERID[])new USERID().toArray(100);	// 用户ID

        public NET_IN_ACCESS_FACE_SERVICE_REMOVE() {
            this.dwSize = this.size();
        }
    }

    // 删除多用户的多个人脸信息输出参数(NET_EM_ACCESS_CTL_FACE_SERVICE_REMOVE)
    public static class NET_OUT_ACCESS_FACE_SERVICE_REMOVE extends SdkStructure
    {
        public int 			            dwSize;                                             // 结构体大小
        public int                      nMaxRetNum;                                         // 最大返回数量,不小于 NET_IN_ACCESS_FACE_SERVICE_REMOVE中的nUserNum
        public Pointer           		pFailCode;                                          // 对应 FAIL_CODE, 用户分配内存.删除失败时,对应删除的每一项的结果,返回个数同NET_IN_ACCESS_FACE_SERVICE_REMOVE中的nUserNum

        public NET_OUT_ACCESS_FACE_SERVICE_REMOVE() {
            this.dwSize = this.size();
        }
    }

    // 清空所有人脸记录信息输入参数(NET_EM_ACCESS_CTL_FACE_SERVICE_CLEAR)
    public static class NET_IN_ACCESS_FACE_SERVICE_CLEAR extends SdkStructure
    {
        public int 			            dwSize;                                             // 结构体大小

        public NET_IN_ACCESS_FACE_SERVICE_CLEAR() {
            this.dwSize = this.size();
        }
    }

    // 清空所有人脸记录信息输出参数(NET_EM_ACCESS_CTL_FACE_SERVICE_CLEAR)
    public static class NET_OUT_ACCESS_FACE_SERVICE_CLEAR extends SdkStructure
    {
        public int 			            dwSize;                                             // 结构体大小

        public NET_OUT_ACCESS_FACE_SERVICE_CLEAR() {
            this.dwSize = this.size();
        }
    }

    /*************************************************************************************************
     * 							门禁指纹信息操作：增、删、改、查、清空
     ************************************************************************************************/
    // 指纹信息操作类型
    public static class NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE extends SdkStructure
    {
        public static final int NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE_INSERT = 0;             // 添加, pInbuf = NET_IN_ACCESS_FINGERPRINT_SERVICE_INSERT , pOutBuf = NET_OUT_ACCESS_FINGERPRINT_SERVICE_INSERT
        public static final int NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE_GET = 1;                // 获取, pInbuf = NET_IN_ACCESS_FINGERPRINT_SERVICE_GET , pOutBuf = NET_OUT_ACCESS_FINGERPRINT_SERVICE_GET
        public static final int NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE_UPDATE = 2;             // 更新, pInbuf = NET_IN_ACCESS_FINGERPRINT_SERVICE_UPDATE , pOutBuf = NET_OUT_ACCESS_FINGERPRINT_SERVICE_UPDATE
        public static final int NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE_REMOVE = 3;             // 删除, pInbuf = NET_IN_ACCESS_FINGERPRINT_SERVICE_REMOVE , pOutBuf = NET_OUT_ACCESS_FINGERPRINT_SERVICE_REMOVE
        public static final int NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE_CLEAR = 4;              // 清空, pInbuf = NET_IN_ACCESS_FINGERPRINT_SERVICE_CLEAR , pOutBuf = NET_OUT_ACCESS_FINGERPRINT_SERVICE_CLEAR
    }

    // 指纹信息
    public static class NET_ACCESS_FINGERPRINT_INFO extends SdkStructure
    {
        public byte[]			         szUserID = new byte[NET_MAX_USERID_LEN];	         // 用户ID
        public int                       nPacketLen;                                     	 // 单个指纹数据包长度
        public int                       nPacketNum;                                     	 // 指纹数据包个数
        public Pointer                   szFingerPrintInfo;                              	 // 指纹数据(数据总长度即nPacketLen*nPacketNum),用户分配释放内存
        public int                       nDuressIndex;                                   	 // 胁迫指纹序号,取值范围[1,nPacketNum] 非法取值的话，该字段无效
        public byte[]                    byReserved = new byte[4096];                        // 保留字节
    }

    // 插入指纹信息入参
    public static class NET_IN_ACCESS_FINGERPRINT_SERVICE_INSERT extends SdkStructure
    {
        public int 			             dwSize;                                     		// 结构体大小
        public int                       nFpNum;                                     		// 指纹信息的数量
        public Pointer    				 pFingerPrintInfo;                           		// 指纹信息,用户分配释放内存, 对应 NET_ACCESS_FINGERPRINT_INFO

        public NET_IN_ACCESS_FINGERPRINT_SERVICE_INSERT() {
            this.dwSize = this.size();
        }
    }

    // 插入指纹信息出参
    public static class NET_OUT_ACCESS_FINGERPRINT_SERVICE_INSERT extends SdkStructure
    {
        public int 			             dwSize;                                     		// 结构体大小
        public int                       nMaxRetNum;                                 		// 返回信息数量,不小于NET_IN_ACCESS_FINGERPRINT_SERVICE_INSERT 中 nFpNum
        public Pointer                	 pFailCode;                                  		// 对应FAIL_CODE, 用户分配释放内存,插入失败时，对应插入的每一项的结果,返回个数同NET_IN_ACCESS_FINGERPRINT_SERVICE_INSERT 中nFpNum

        public NET_OUT_ACCESS_FINGERPRINT_SERVICE_INSERT() {
            this.dwSize = this.size();
        }
    }

    // 更新指纹信息入参
    public static class NET_IN_ACCESS_FINGERPRINT_SERVICE_UPDATE extends SdkStructure
    {
        public int  			         dwSize;                                     		// 结构体大小
        public int                       nFpNum;                                     		// 指纹信息的数量
        public Pointer    				 pFingerPrintInfo;                           		// 指纹信息,用户分配释放内存, 对应数组 NET_ACCESS_FINGERPRINT_INFO

        public NET_IN_ACCESS_FINGERPRINT_SERVICE_UPDATE() {
            this.dwSize = this.size();
        }
    }

    // 更新指纹信息出参
    public static class NET_OUT_ACCESS_FINGERPRINT_SERVICE_UPDATE extends SdkStructure
    {
        public int 			             dwSize;                                     		// 结构体大小
        public int                       nMaxRetNum;                                 		// 最大返回信息数量,不小于 NET_IN_ACCESS_FINGERPRINT_SERVICE_UPDATE中nFpNum
        public Pointer                	 pFailCode;                                  		// 对应 FAIL_CODE, 用户分配释放内存,插入失败时，对应插入的每一项的结果,返回个数同NET_IN_ACCESS_FINGERPRINT_SERVICE_UPDATE中nFpNum

        public NET_OUT_ACCESS_FINGERPRINT_SERVICE_UPDATE() {
            this.dwSize = this.size();
        }
    }

    // 获取指纹信息入参
    public static class NET_IN_ACCESS_FINGERPRINT_SERVICE_GET extends SdkStructure
    {
        public int 			             dwSize;                                     		// 结构体大小
        public byte[]			         szUserID = new byte[NET_MAX_USERID_LEN];	        // 用户ID

        public NET_IN_ACCESS_FINGERPRINT_SERVICE_GET() {
            this.dwSize = this.size();
        }
    }

    // 获取指纹信息出参
    public static class NET_OUT_ACCESS_FINGERPRINT_SERVICE_GET extends SdkStructure
    {
        public int 			             dwSize;                                     		// 结构体大小
        public int						 nRetFingerPrintCount;					    		// 实际返回的指纹个数
        public int						 nSinglePacketLength;					    		// 单个指纹数据包长度
        public int                       nDuressIndex;                               		// 胁迫指纹序号
        public int					     nMaxFingerDataLength;					    		// 接受指纹数据的缓存的最大长度
        public int					     nRetFingerDataLength;					    		// 实际返回的总的指纹数据包的长度
        public Pointer                   pbyFingerData;                       	    		// 用户分配释放内存,指纹数据

        public NET_OUT_ACCESS_FINGERPRINT_SERVICE_GET() {
            this.dwSize = this.size();
        }
    }

    // 删除用户指纹信息入参
    public static class NET_IN_ACCESS_FINGERPRINT_SERVICE_REMOVE extends SdkStructure
    {
        public int 			             dwSize;                                     		// 结构体大小
        public int                       nUserNum;                                   		// 删除的用户数量
        public USERID[]                  szUserIDs = (USERID[])new USERID().toArray(100);   // 用户ID

        public NET_IN_ACCESS_FINGERPRINT_SERVICE_REMOVE() {
            this.dwSize = this.size();
        }
    }

    // 删除用户指纹信息出参
    public static class NET_OUT_ACCESS_FINGERPRINT_SERVICE_REMOVE extends SdkStructure
    {
        public int 			             dwSize;                                     		// 结构体大小
        public int                       nMaxRetNum;                                 		// 最大返回数量,不小于 NET_IN_ACCESS_FINGERPRINT_SERVICE_REMOVE中nUserNum
        public Pointer               	 pFailCode;                                  		// 对应 FAIL_CODE, 用户分配释放内存,删除失败时，对应插入的每一项的结果,返回个数同NET_IN_ACCESS_FINGERPRINT_SERVICE_REMOVE中nUserNum

        public NET_OUT_ACCESS_FINGERPRINT_SERVICE_REMOVE() {
            this.dwSize = this.size();
        }
    }

    // 清除所有指纹信息入参
    public static class NET_IN_ACCESS_FINGERPRINT_SERVICE_CLEAR extends SdkStructure
    {
        public int 			             dwSize;                                         	// 结构体大小

        public NET_IN_ACCESS_FINGERPRINT_SERVICE_CLEAR() {
            this.dwSize = this.size();
        }
    }

    // 清除所有指纹信息出参
    public static class NET_OUT_ACCESS_FINGERPRINT_SERVICE_CLEAR extends SdkStructure
    {
        public int 			            dwSize;                                         	// 结构体大小

        public NET_OUT_ACCESS_FINGERPRINT_SERVICE_CLEAR() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_StartFindUserInfo 输入参数
    public static class NET_IN_USERINFO_START_FIND extends SdkStructure
    {
        public int 			            dwSize;                                     	    // 结构体大小
        public byte[]			        szUserID = new byte[MAX_COMMON_STRING_32];	        // 用户ID

        public NET_IN_USERINFO_START_FIND() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_StartFindUserInfo 输出参数
    public static class NET_OUT_USERINFO_START_FIND extends SdkStructure
    {
        public int 			            dwSize;                                     		// 结构体大小
        public int                      nTotalCount;                                		// 符合查询条件的总数
        public int                      nCapNum;                                    		// doFind一次查询的最大数量

        public NET_OUT_USERINFO_START_FIND() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_DoFindUserInfo 输入参数
    public static class NET_IN_USERINFO_DO_FIND extends SdkStructure
    {
        public int 			            dwSize;                                     		// 结构体大小
        public int                      nStartNo;                                   		// 起始序号
        public int                      nCount;                                     		// 本次查询的条数

        public NET_IN_USERINFO_DO_FIND() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_DoFindUserInfo 输出参数
    public static class NET_OUT_USERINFO_DO_FIND extends SdkStructure
    {
        public int 			            dwSize;                                     		// 结构体大小
        public int                      nRetNum;                                    		// 本次查询到的个数
        public Pointer       			pstuInfo;                                   		// 查询结果, 对应 NET_ACCESS_USER_INFO数组, 用户分配释放内存,大小为sizeof(NET_ACCESS_USER_INFO)*nMaxNum
        public int	                    nMaxNum;                                    		// 用户分配内存的个数
        public byte[]                   byReserved = new byte[4];

        public NET_OUT_USERINFO_DO_FIND() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_StartFindCardInfo 输入参数
    public static class NET_IN_CARDINFO_START_FIND extends SdkStructure
    {
        public int 			            dwSize;                                     		// 结构体大小
        public byte[]			        szUserID = new byte[32];	                        // 用户ID
        public byte[]                   szCardNo = new byte[32];                            // 卡号
        public int      				emType;                                     		// 卡类型,只支持一般卡、胁迫卡和母卡, 参考  NET_ACCESSCTLCARD_TYPE

        public NET_IN_CARDINFO_START_FIND() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_StartFindCardInfo 输出参数
    public static class NET_OUT_CARDINFO_START_FIND extends SdkStructure
    {
        public int 			            dwSize;                                     		// 结构体大小
        public int                      nTotalCount;                                		// 符合查询条件的总数
        public int                      nCapNum;                                    		// CLIENT_DoFindCardInfo接口一次查询的最大数量

        public NET_OUT_CARDINFO_START_FIND() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_DoFindCardInfo 输入参数
    public static class NET_IN_CARDINFO_DO_FIND extends SdkStructure
    {
        public int 			            dwSize;                                     		// 结构体大小
        public int                      nStartNo;                                  			// 起始序号
        public int                      nCount;                                     		// 本次查询的条数

        public NET_IN_CARDINFO_DO_FIND() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_DoFindCardInfo 输出参数
    public static class NET_OUT_CARDINFO_DO_FIND extends SdkStructure
    {
        public int 			            dwSize;                                     		// 结构体大小
        public int                      nRetNum;                                    		// 本次查询到的个数
        public Pointer       			pstuInfo;                                   		// 查询结果, 对应 NET_ACCESS_CARD_INFO数组, 用户分配释放内存,大小为sizeof(NET_FACEINFO)*nMaxNum
        public int	                    nMaxNum;                                    		// 用户分配内存的个数
        public byte[]                   byReserved = new byte[4];                           // 保留字节

        public NET_OUT_CARDINFO_DO_FIND() {
            this.dwSize = this.size();
        }
    }

    // 升级类型
    public static class EM_UPGRADE_TYPE extends SdkStructure
    {
        public static final int DH_UPGRADE_BIOS_TYPE = 1;				// BIOS升级
        public static final int DH_UPGRADE_WEB_TYPE = 2;				// WEB升级
        public static final int DH_UPGRADE_BOOT_YPE = 3;				// BOOT升级
        public static final int DH_UPGRADE_CHARACTER_TYPE = 4;			// 汉字库
        public static final int DH_UPGRADE_LOGO_TYPE = 5;				// LOGO
        public static final int DH_UPGRADE_EXE_TYPE = 6;				// EXE,例如播放器等
        public static final int DH_UPGRADE_DEVCONSTINFO_TYPE = 7;		// 设备固有信息设置(如：硬件ID,MAC,序列号)
        public static final int DH_UPGRADE_PERIPHERAL_TYPE = 8;			// 外设接入从片(如车载287芯片)
        public static final int DH_UPGRADE_GEOINFO_TYPE = 9;			// 地理信息定位芯片
        public static final int DH_UPGRADE_MENU = 10;					// 菜单（设备操作界面的图片）
        public static final int DH_UPGRADE_ROUTE = 11;					// 线路文件（如公交线路）
        public static final int DH_UPGRADE_ROUTE_STATE_AUTO = 12;		// 报站音频（与线路配套的报站音频）
        public static final int DH_UPGRADE_SCREEN = 13;					// 调度屏（如公交操作屏）

    }

    /***********************************************************************
     ** 回调
     ***********************************************************************/
    //JNA Callback方法定义,断线回调
    public interface fDisConnect extends StdCallCallback {
        public void invoke(LLong lLoginID, String pchDVRIP, int nDVRPort, Pointer dwUser);
    }

    // 网络连接恢复回调函数原形
    public interface fHaveReConnect extends StdCallCallback {
        public void invoke(LLong lLoginID, String pchDVRIP, int nDVRPort, Pointer dwUser);
    }

    // 消息回调函数原形(pBuf内存由SDK内部申请释放)
    public interface fMessCallBack extends StdCallCallback{
        public boolean invoke(int lCommand, LLong lLoginID, Pointer pStuEvent, int dwBufLen, String strDeviceIP, NativeLong nDevicePort, Pointer dwUser);
    }

    // 消息回调函数原形(pBuf内存由SDK内部申请释放)
    // 新增参数说明
    // bAlarmAckFlag : TRUE,该事件为可以进行确认的事件；FALSE,该事件无法进行确认
    // nEventID 用于对 CLIENT_AlarmAck 接口的入参进行赋值,当 bAlarmAckFlag 为 TRUE 时,该数据有效
    // pBuf内存由SDK内部申请释放
    public interface fMessCallBackEx1 extends StdCallCallback{
        public boolean invoke(int lCommand, LLong lLoginID, Pointer pStuEvent, int dwBufLen, String strDeviceIP, NativeLong nDevicePort, int bAlarmAckFlag, NativeLong nEventID, Pointer dwUser);
    }

    // 订阅人脸回调函数
    public interface fFaceFindState extends StdCallCallback {
        // pstStates 指向NET_CB_FACE_FIND_STATE的指针
        public void invoke(LLong lLoginID, LLong lAttachHandle, Pointer pstStates, int nStateNum, Pointer dwUser);
    }

    // 智能分析数据回调;nSequence表示上传的相同图片情况，为0时表示是第一次出现，为2表示最后一次出现或仅出现一次，为1表示此次之后还有
    // int nState = *(int*) reserved 表示当前回调数据的状态, 为0表示当前数据为实时数据，为1表示当前回调数据是离线数据，为2时表示离线数据传送结束
    // pAlarmInfo 对应智能事件信息, pBuffer 对应智能图片信息, dwBufSize 智能图片信息大小
    public interface fAnalyzerDataCallBack extends StdCallCallback {
        public int invoke(LLong lAnalyzerHandle, int dwAlarmType, Pointer pAlarmInfo, Pointer pBuffer, int dwBufSize, Pointer dwUser, int nSequence, Pointer reserved);
    }

    // 抓图回调函数原形(pBuf内存由SDK内部申请释放)
    // EncodeType 编码类型，10：表示jpeg图片      0：mpeg4    CmdSerial : 操作流水号，同步抓图的情况下用不上
    public interface fSnapRev extends StdCallCallback{
        public void invoke(LLong lLoginID, Pointer pBuf, int RevLen, int EncodeType, int CmdSerial, Pointer dwUser);
    }

    // 异步搜索设备回调(pDevNetInfo内存由SDK内部申请释放)
    public interface fSearchDevicesCB extends StdCallCallback{
        public void invoke(Pointer pDevNetInfo, Pointer pUserData);
    }

    // 按时间回放进度回调函数原形
    public interface fTimeDownLoadPosCallBack extends StdCallCallback {
        public void invoke(LLong lPlayHandle, int dwTotalSize, int dwDownLoadSize, int index, NET_RECORDFILE_INFO.ByValue recordfileinfo, Pointer dwUser);
    }

    // 回放数据回调函数原形
    public interface fDataCallBack extends StdCallCallback {
        public int invoke(LLong lRealHandle, int dwDataType, Pointer pBuffer, int dwBufSize, Pointer dwUser);
    }

    // 回放进度回调函数原形
    public interface fDownLoadPosCallBack extends StdCallCallback {
        public void invoke(LLong lPlayHandle, int dwTotalSize, int dwDownLoadSize, Pointer dwUser);
    }

    // 视频统计摘要信息回调函数原形，lAttachHandle 是 CLIENT_AttachVideoStatSummary 返回值
    public interface fVideoStatSumCallBack extends StdCallCallback {
        public void invoke(LLong lAttachHandle, NET_VIDEOSTAT_SUMMARY pBuf, int dwBufLen, Pointer dwUser);
    }

    // 用户自定义的数据回调   lTalkHandle是CLIENT_StartTalkEx的返回值
    // byAudioFlag：   0表示是本地录音库采集的音频数据 ，  1表示收到的设备发过来的音频数据
    public interface pfAudioDataCallBack extends StdCallCallback {
        public void invoke(LLong lTalkHandle, Pointer pDataBuf, int dwBufSize, byte byAudioFlag, Pointer dwUser);
    }

    // lHandle是文件传输句柄 ，nTransType是文件传输类型，nState是文件传输状态，
    public interface fTransFileCallBack extends StdCallCallback {
        public void invoke(LLong lHandle, int nTransType, int nState, int nSendSize, int nTotalSize, Pointer dwUser);
    }

    // GPS信息订阅回调--扩展
    public interface fGPSRevEx extends StdCallCallback {
        public void invoke(LLong lLoginID, GPS_Info.ByValue GpsInfo, ALARM_STATE_INFO.ByValue stAlarmInfo, Pointer dwUserData, Pointer reserved);
    }

    // GPS信息订阅回调--扩展2
    public interface fGPSRevEx2 extends StdCallCallback {
        public void invoke(LLong lLoginID, NET_GPS_LOCATION_INFO lpData, Pointer dwUserData, Pointer reserved);
    }

    // 实时监视数据回调函数--扩展(pBuffer内存由SDK内部申请释放)
    // lRealHandle实时监视           dwDataType: 0-原始数据   1-帧数据    2-yuv数据   3-pcm音频数据
    // pBuffer对应BYTE*
    // param:当类型为0(原始数据)和2(YUV数据) 时为0。当回调的数据类型为1时param为一个tagVideoFrameParam结构体指针。
    // param:当数据类型是3时,param也是一个tagCBPCMDataParam结构体指针
    public interface fRealDataCallBackEx extends StdCallCallback {
        public void invoke(LLong lRealHandle, int dwDataType, Pointer pBuffer, int dwBufSize, int param, Pointer dwUser);
    }
    // 实时监视数据回调函数原形--扩展(pBuffer内存由SDK内部申请释放)
    // 通过 dwDataType 过滤得到对应码流，具体码流类型请参考 EM_REALDATA_FLAG; 转码流时 dwDataType 值请参考 NET_DATA_CALL_BACK_VALUE 说明
    // 当转码流时，param 为具体的转码信息（视频帧、音频帧等信息），对应结构体 NET_STREAMCONVERT_INFO
    public interface fRealDataCallBackEx2 extends StdCallCallback{
        void invoke(LLong lRealHandle, int dwDataType, Pointer pBuffer, int dwBufSize, LLong param, Pointer dwUser);
    }
    // 视频监视断开回调函数, (param内存由SDK内部申请释放 )
    // lOperateHandle监控句柄   dwEventType对应EM_REALPLAY_DISCONNECT_EVENT_TYPE   param对应void*,事件参数
    public interface fRealPlayDisConnect extends StdCallCallback {
        public void invoke(LLong lOperateHandle, int dwEventType, Pointer param, Pointer dwUser);
    }

    // 订阅过车记录数据回调函数原型     lAttachHandle为CLIENT_ParkingControlAttachRecord返回值
    public interface fParkingControlRecordCallBack extends StdCallCallback {
        public void invoke(LLong lLoginID, LLong lAttachHandle, NET_CAR_PASS_ITEM pInfo, int nBufLen, Pointer dwUser);
    }

    // 订阅车位信息回调函数原型
    public interface fParkInfoCallBack extends StdCallCallback {
        public void invoke(LLong lLoginID, LLong lAttachHandle, NET_PARK_INFO_ITEM pInfo, int nBufLen, Pointer dwUser);
    }

    // 订阅监测点位信息回调函数原型
    public interface fSCADAAttachInfoCallBack extends StdCallCallback {
        public void invoke(LLong lLoginID, LLong lAttachHandle, NET_SCADA_NOTIFY_POINT_INFO_LIST pInfo, int nBufLen, Pointer dwUser);
    }

    // 透明串口回调函数原形(pBuffer内存由SDK内部申请释放))
    public interface fTransComCallBack extends StdCallCallback {
        public void invoke(LLong lLoginID, LLong lTransComChannel, Pointer pBuffer, int dwBufSize, Pointer dwUser);
    }

    //视频分析进度状态实时回调函数
    public interface fVideoAnalyseState extends StdCallCallback {
        public int invoke(LLong lAttachHandle, NET_VIDEOANALYSE_STATE pAnalyseStateInfos, Pointer dwUser, Pointer pReserved);
    }

    // 侦听服务器回调函数原形
    public interface fServiceCallBack extends StdCallCallback {
        public int invoke(LLong lHandle, String pIp, int wPort, int lCommand, Pointer pParam, int dwParamLen, Pointer dwUserData);
    }

    // CLIENT_ListenServer 接口回调fServiceCallBack函数支持的命令类型
    public static class EM_LISTEN_TYPE extends SdkStructure
    {
        public static final int NET_DVR_DISCONNECT = -1;                           // 验证期间设备断线回调
        public static final int NET_DVR_SERIAL_RETURN = 1;                         // 设备注册携带序列号 对应 char* szDevSerial
        public static final int NET_DEV_AUTOREGISTER_RETURN = 2;                   // 设备注册携带序列号和令牌 对应NET_CB_AUTOREGISTER
        public static final int NET_DEV_NOTIFY_IP_RETURN = 3;                      // 设备仅上报IP, 不作为主动注册用, 用户获取ip后只能按照约定的端口按照非主动注册的类型登录
    }

    //订阅Bus状态回调函数原型
    public interface fBusStateCallBack extends StdCallCallback {
        public void invoke(LLong lAttachHandle, int lCommand, Pointer pBuf, int dwBufLen, Pointer dwUser);
    }

    // GPS温湿度信息订阅回调
    public interface fGPSTempHumidityRev extends StdCallCallback {
        public void invoke(LLong lLoginID, GPS_TEMP_HUMIDITY_INFO.ByValue GpsTHInfo, Pointer dwUserData);
    }

    // 向设备注册的回调函数原型
    public interface fDeviceStateCallBack extends StdCallCallback {
        public void invoke(LLong lAttachHandle, NET_CB_ATTACH_DEVICE_STATE pstDeviceState, Pointer dwUser);
    }

    // 注册添加设备的回调函数原型
    public interface fAddDeviceCallBack extends StdCallCallback {
        public void invoke(LLong lAttachHandle, NET_CB_ATTACH_ADD_DEVICE pstAddDevice, Pointer dwUser);
    }

    // 定义监测点报警信息回调函数原型
    public interface fSCADAAlarmAttachInfoCallBack extends StdCallCallback {
        public void invoke(LLong lAttachHandle, NET_SCADA_NOTIFY_POINT_ALARM_INFO_LIST pInfo, int nBufLen, Pointer dwUser);
    }

    //视频诊断结果上报回调函数
    public interface fRealVideoDiagnosis extends StdCallCallback {
        public int invoke(LLong lDiagnosisHandle, NET_REAL_DIAGNOSIS_RESULT pDiagnosisInfo, Pointer pBuf, int nBufLen, Pointer dwUser);
    }

    /// \fn 温度分布数据状态回调函数
    /// \brief
    /// \param  LLONG lAttachHandle [OUT] 订阅句柄, CLIENT_RadiometryAttach 的返回值
    /// \param  NET_RADIOMETRY_DATA pBuf [OUT] 热图数据信息
    /// \param  int nBufLen [OUT] 状态信息长度
    /// \param  LDWORD dwUser 用户数据
    /// \return 无
    public interface fRadiometryAttachCB extends StdCallCallback {
        public void invoke(LLong lAttachHandle, NET_RADIOMETRY_DATA pBuf, int nBufLen, Pointer dwUser);
    }

    // 刻录设备回调函数原形,lAttachHandle是CLIENT_AttachBurnState返回值, 每次1条,pBuf->dwSize == nBufLen
    public interface fAttachBurnStateCB extends StdCallCallback {
        public void invoke(LLong lLoginID, LLong lAttachHandle, NET_CB_BURNSTATE pBuf, int nBufLen, Pointer dwUser);
    }

    // 刻录设备回调扩展函数原形
    public interface fAttachBurnStateCBEx extends StdCallCallback {
        public void invoke(LLong lLoginID, LLong lAttachHandle, NET_OUT_BURN_GET_STATE pBuf, int nBufLen, Pointer dwUser);
    }

    //刻录设备回调函数,lUploadHandle是CLIENT_StartUploadFileBurned返回值
    //typedef void (CALLBACK *fBurnFileCallBack) (LLONG lLoginID, LLONG lUploadHandle, int nTotalSize, int nSendSize, LDWORD dwUser);
    public interface fBurnFileCallBack extends StdCallCallback {
        public void invoke(LLong lLoginID, LLong lUploadHandle, int nTotalSize, int nSendSize, Pointer dwUser);
    }


    // 升级回调
    public interface fUpgradeCallBackEx extends StdCallCallback {
        public void invoke(LLong lLoginID, LLong lUpgradechannel, int nTotalSize, int nSendSize, Pointer dwUserData);
    }

    /************************************************************************
     ** 接口
     ***********************************************************************/
    //  JNA直接调用方法定义，cbDisConnect 实际情况并不回调Java代码，仅为定义可以使用如下方式进行定义。 fDisConnect 回调
    public boolean CLIENT_Init(Callback cbDisConnect, Pointer dwUser);

    //  JNA直接调用方法定义，SDK退出清理
    public void CLIENT_Cleanup();

    //  JNA直接调用方法定义，设置断线重连成功回调函数，设置后SDK内部断线自动重连, fHaveReConnect 回调
    public void CLIENT_SetAutoReconnect(Callback cbAutoConnect, Pointer dwUser);

    // 返回函数执行失败代码
    public int CLIENT_GetLastError();

    // 设置连接设备超时时间和尝试次数
    public void CLIENT_SetConnectTime(int nWaitTime, int nTryTimes);

    // 设置登陆网络环境
    public void CLIENT_SetNetworkParam(NET_PARAM pNetParam);

    //
    public boolean CLIENT_SetDeviceSearchParam(NET_DEVICE_SEARCH_PARAM pstParam);

    // 获取SDK的版本信息
    public int CLIENT_GetSDKVersion();

    //  JNA直接调用方法定义，登陆接口
    public LLong CLIENT_LoginEx(String pchDVRIP, int wDVRPort, String pchUserName, String pchPassword, int nSpecCap, Pointer pCapParam, NET_DEVICEINFO lpDeviceInfo, IntByReference error/*= 0*/);

    //  JNA直接调用方法定义，登陆扩展接口///////////////////////////////////////////////////
    //  nSpecCap 对应  EM_LOGIN_SPAC_CAP_TYPE 登陆类型
    public LLong CLIENT_LoginEx2(String pchDVRIP, int wDVRPort, String pchUserName, String pchPassword, int nSpecCap, Pointer pCapParam, NET_DEVICEINFO_Ex lpDeviceInfo, IntByReference error/*= 0*/);

    //  JNA直接调用方法定义，向设备注销
    public boolean CLIENT_Logout(LLong lLoginID);

    // 获取配置
    // error 为设备返回的错误码： 0-成功 1-失败 2-数据不合法 3-暂时无法设置 4-没有权限
    public boolean CLIENT_GetNewDevConfig(LLong lLoginID, String szCommand, int nChannelID, byte[] szOutBuffer, int dwOutBufferSize, IntByReference error, int waiitime);

    // 设置配置
    public boolean CLIENT_SetNewDevConfig(LLong lLoginID, String szCommand, int nChannelID, byte[] szInBuffer, int dwInBufferSize, IntByReference error, IntByReference restart, int waittime);

    // 删除配置接口(Json格式)
    public boolean CLIENT_DeleteDevConfig(LLong lLoginID, NET_IN_DELETECFG pInParam, NET_OUT_DELETECFG pOutParam, int waittime);

    // 获取配置成员名称接口(Json格式)(pInParam, pOutParam内存由用户申请释放)
    public boolean CLIENT_GetMemberNames(LLong lLoginID, NET_IN_MEMBERNAME pInParam, NET_OUT_MEMBERNAME pOutParam, int waittime);

    // 解析查询到的配置信息
    public boolean CLIENT_ParseData(String szCommand, byte[] szInBuffer, Pointer lpOutBuffer, int dwOutBufferSize, Pointer pReserved);

    // 组成要设置的配置信息
    public boolean CLIENT_PacketData(String szCommand, Pointer lpInBuffer, int dwInBufferSize, byte[] szOutBuffer, int dwOutBufferSize);

    // 设置报警回调函数, fMessCallBack 回调
    public void  CLIENT_SetDVRMessCallBack(Callback cbMessage, Pointer dwUser);

    // 设置报警回调函数, fMessCallBackEx1 回调
    public void  CLIENT_SetDVRMessCallBackEx1(fMessCallBackEx1 cbMessage, Pointer dwUser);

    // 向设备订阅报警--扩展
    public boolean  CLIENT_StartListenEx(LLong lLoginID);

    // 停止订阅报警
    public boolean CLIENT_StopListen(LLong lLoginID);

    /////////////////////////////////人脸识别接口/////////////////////////////////////////
    //人脸识别数据库信息操作（包括添加,修改和删除）
    // pstInParam指向NET_IN_OPERATE_FACERECONGNITIONDB类型的指针
    // pstOutParam指向NET_OUT_OPERATE_FACERECONGNITIONDB类型的指针
    public boolean  CLIENT_OperateFaceRecognitionDB(LLong lLoginID, NET_IN_OPERATE_FACERECONGNITIONDB pstInParam, NET_OUT_OPERATE_FACERECONGNITIONDB pstOutParam, int nWaitTime);

    // 按条件查询人脸识别结果
    // pstInParam指向NET_IN_STARTFIND_FACERECONGNITION类型的指针
    // pstOutParam指向NET_OUT_STARTFIND_FACERECONGNITION类型的指针
    public boolean  CLIENT_StartFindFaceRecognition(LLong lLoginID, NET_IN_STARTFIND_FACERECONGNITION pstInParam, NET_OUT_STARTFIND_FACERECONGNITION pstOutParam, int nWaitTime);

    // 查找人脸识别结果:nFilecount:需要查询的条数, 返回值为媒体文件条数 返回值<nFilecount则相应时间段内的文件查询完毕(每次最多只能查询20条记录)
    // pstInParam指向NET_IN_DOFIND_FACERECONGNITION类型的指针
    // pstOutParam指向NET_OUT_DOFIND_FACERECONGNITION类型的指针
    public boolean  CLIENT_DoFindFaceRecognition(final NET_IN_DOFIND_FACERECONGNITION pstInParam, NET_OUT_DOFIND_FACERECONGNITION pstOutParam, int nWaitTime);

    //结束查询
    public boolean  CLIENT_StopFindFaceRecognition(LLong lFindHandle);

    // 人脸检测(输入一张大图,输入大图中被检测出来的人脸图片)
    // pstInParam指向NET_IN_DETECT_FACE类型的指针
    // pstOutParam指向NET_OUT_DETECT_FACE类型的指针
    public boolean  CLIENT_DetectFace(LLong lLoginID, NET_IN_DETECT_FACE pstInParam, NET_OUT_DETECT_FACE pstOutParam, int nWaitTime);

    // 人脸识别人员组操作（包括添加,修改和删除）
    // pstInParam指向NET_IN_OPERATE_FACERECONGNITION_GROUP类型的指针
    // pstOutParam指向NET_OUT_OPERATE_FACERECONGNITION_GROUP类型的指针
    public boolean  CLIENT_OperateFaceRecognitionGroup(LLong lLoginID, NET_IN_OPERATE_FACERECONGNITION_GROUP pstInParam, NET_OUT_OPERATE_FACERECONGNITION_GROUP pstOutParam, int nWaitTime);

    // 查询人脸识别人员组信息
    // pstInParam指向NET_IN_FIND_GROUP_INFO类型的指针
    // pstOutParam指向NET_OUT_FIND_GROUP_INFO类型的指针
    public boolean  CLIENT_FindGroupInfo(LLong LLong, NET_IN_FIND_GROUP_INFO pstInParam, NET_OUT_FIND_GROUP_INFO pstOutParam, int nWaitTime);

    // 获取布控在视频通道的组信息,pstInParam与pstOutParam内存由用户申请释放
    public boolean CLIENT_GetGroupInfoForChannel(LLong lLoginID, NET_IN_GET_GROUPINFO_FOR_CHANNEL pstInParam, NET_OUT_GET_GROUPINFO_FOR_CHANNEL pstOutParam, int nWaitTime);

    // 布控通道人员组信息
    // pstInParam指向NET_IN_SET_GROUPINFO_FOR_CHANNEL类型的指针
    // pstOutParam指向NET_OUT_SET_GROUPINFO_FOR_CHANNEL类型的指针
    public boolean CLIENT_SetGroupInfoForChannel(LLong lLoginID, NET_IN_SET_GROUPINFO_FOR_CHANNEL pstInParam, NET_OUT_SET_GROUPINFO_FOR_CHANNEL pstOutParam, int nWaitTime);

    // 以人脸库的角度进行布控, pstInParam与pstOutParam内存由用户申请释放
    public boolean CLIENT_FaceRecognitionPutDisposition(LLong lLoginID, NET_IN_FACE_RECOGNITION_PUT_DISPOSITION_INFO pstInParam, NET_OUT_FACE_RECOGNITION_PUT_DISPOSITION_INFO pstOutParam, int nWaitTime);

    // 以人脸库的角度进行撤控, pstInParam与pstOutParam内存由用户申请释放
    public boolean CLIENT_FaceRecognitionDelDisposition(LLong lLoginID, NET_IN_FACE_RECOGNITION_DEL_DISPOSITION_INFO pstInParam, NET_OUT_FACE_RECOGNITION_DEL_DISPOSITION_INFO pstOutParam, int nWaitTime);

    // 订阅人脸查询状态
    // pstInParam指向NET_IN_FACE_FIND_STATE类型的指针
    // pstOutParam指向NET_OUT_FACE_FIND_STATE类型的指针
    public LLong CLIENT_AttachFaceFindState(LLong lLoginID, NET_IN_FACE_FIND_STATE pstInParam, NET_OUT_FACE_FIND_STATE pstOutParam, int nWaitTime);

    //取消订阅人脸查询状态,lAttachHandle为CLIENT_AttachFaceFindState返回的句柄
    public boolean CLIENT_DetachFaceFindState(LLong lAttachHandle);

    // 文件下载, 只适用于小文件,pInParam与pOutParam内存由用户申请释放
    public boolean CLIENT_DownloadRemoteFile(LLong lLoginID, NET_IN_DOWNLOAD_REMOTE_FILE pInParam, NET_OUT_DOWNLOAD_REMOTE_FILE pOutParam, int nWaitTime);

    // 打开日志功能
    // pstLogPrintInfo指向LOG_SET_PRINT_INFO的指针
    public boolean CLIENT_LogOpen(LOG_SET_PRINT_INFO pstLogPrintInfo);

    // 关闭日志功能
    public boolean CLIENT_LogClose();

    // 获取符合查询条件的文件总数
    // reserved为void *
    public boolean CLIENT_GetTotalFileCount(LLong lFindHandle, IntByReference pTotalCount, Pointer reserved, int waittime);

    // 设置查询跳转条件
    // reserved为void *
    public boolean  CLIENT_SetFindingJumpOption(LLong lFindHandle, NET_FINDING_JUMP_OPTION_INFO pOption, Pointer reserved, int waittime);

    // 按查询条件查询文件
    // pQueryCondition为void *, 具体类型根据emType的类型确定,对应 EM_FILE_QUERY_TYPE
    // reserved为void *, 具体类型根据emType的类型确定
    public LLong CLIENT_FindFileEx(LLong lLoginID, int emType, Pointer pQueryCondition, Pointer reserved, int waittime);

    // 查找文件:nFilecount:需要查询的条数, 返回值为媒体文件条数 返回值<nFilecount则相应时间段内的文件查询完毕
    // pMediaFileInfo为void *
    // reserved为void *
    public int CLIENT_FindNextFileEx(LLong lFindHandle, int nFilecount, Pointer pMediaFileInfo, int maxlen, Pointer reserved, int waittime);

    // 结束录像文件查找
    public boolean CLIENT_FindCloseEx(LLong lFindHandle);

    // 实时上传智能分析数据－图片(扩展接口,bNeedPicFile表示是否订阅图片文件,Reserved类型为RESERVED_PARA)
    // bNeedPicFile为BOOL类型，取值范围为0或者1, fAnalyzerDataCallBack回调
    public LLong CLIENT_RealLoadPictureEx(LLong lLoginID, int nChannelID, int dwAlarmType, int bNeedPicFile, Callback cbAnalyzerData, Pointer dwUser, Pointer Reserved);

    // 停止上传智能分析数据－图片
    public boolean CLIENT_StopLoadPic(LLong lAnalyzerHandle);

    // 设置抓图回调函数, fSnapRev回调
    public void CLIENT_SetSnapRevCallBack(Callback OnSnapRevMessage, Pointer dwUser);

    // 抓图请求扩展接口
    public boolean CLIENT_SnapPictureEx(LLong lLoginID, SNAP_PARAMS stParam, IntByReference reserved);

    // 异步搜索局域网内IPC、NVS等设备, fSearchDevicesCB回调
    public LLong CLIENT_StartSearchDevices(Callback cbSearchDevices, Pointer pUserData, String szLocalIp);

    // 停止异步搜索局域网内IPC、NVS等设备
    public boolean CLIENT_StopSearchDevices(LLong lSearchHandle);

    // 同步跨网段搜索设备IP (pIpSearchInfo内存由用户申请释放)DEVICE_IP_SEARCH_INFO
    // szLocalIp为本地IP，可不做输入, fSearchDevicesCB回调
    // 接口调用1次只发送搜索信令1次
    public boolean CLIENT_SearchDevicesByIPs(Pointer pIpSearchInfo, Callback cbSearchDevices, Pointer dwUserData, String szLocalIp, int dwWaitTime);

    // 开始实时监视
    // rType  : NET_RealPlayType    返回监控句柄
    public LLong CLIENT_RealPlayEx(LLong lLoginID, int nChannelID, Pointer hWnd, int rType);

    // 停止实时预览--扩展     lRealHandle为CLIENT_RealPlayEx的返回值
    public boolean CLIENT_StopRealPlayEx(LLong lRealHandle);

    // 开始实时监视支持设置码流回调接口     rType  : NET_RealPlayType   返回监控句柄
    // cbRealData 对应 fRealDataCallBackEx 回调
    // cbDisconnect 对应 fRealPlayDisConnect 回调
    public LLong CLIENT_StartRealPlay(LLong lLoginID, int nChannelID, Pointer hWnd, int rType, Callback cbRealData, Callback cbDisconnect, Pointer dwUser, int dwWaitTime);

    // 停止实时预览
    public boolean CLIENT_StopRealPlay(LLong lRealHandle);

    // 设置实时监视数据回调函数扩展接口    lRealHandle监控句柄,fRealDataCallBackEx 回调
    public boolean CLIENT_SetRealDataCallBackEx(LLong lRealHandle, Callback cbRealData, Pointer dwUser, int dwFlag);

    // 设置图象流畅性
    // 将要调整图象的等级(0-6),当level为0时，图象最流畅；当level为6时，图象最实时。Level的默认值为3。注意：直接解码下有效
    public boolean CLIENT_AdjustFluency(LLong lRealHandle, int nLevel);


    // 保存数据为文件,lRealHandle为CLIENT_RealPlayEx的返回值,pchFileName为实时监视保存文件名
    public boolean CLIENT_SaveRealData(LLong lRealHandle, String pchFileName);

    // 结束保存数据为文件,lRealHandle为CLIENT_RealPlayEx的返回值
    public boolean CLIENT_StopSaveRealData(LLong lRealHandle);

    // 打开声音
    public boolean CLIENT_OpenSound(LLong hPlayHandle);

    // 关闭声音
    public boolean CLIENT_CloseSound();

    // 设置显示源(pInparam, pOutParam内存由用户申请释放)
    public boolean CLIENT_MatrixSetCameras(LLong lLoginID, NET_IN_MATRIX_SET_CAMERAS pInParam, NET_OUT_MATRIX_SET_CAMERAS pOutParam, int nWaitTime);

    // 获取所有有效显示源
    // pInParam  对应  NET_IN_MATRIX_GET_CAMERAS
    // pOutParam 对应  NET_OUT_MATRIX_GET_CAMERAS
    public boolean CLIENT_MatrixGetCameras(LLong lLoginID, NET_IN_MATRIX_GET_CAMERAS pInParam, NET_OUT_MATRIX_GET_CAMERAS pOutParam, int nWaitTime);

    // 抓图同步接口,将图片数据直接返回给用户
    public boolean CLIENT_SnapPictureToFile(LLong lLoginID, NET_IN_SNAP_PIC_TO_FILE_PARAM pInParam, NET_OUT_SNAP_PIC_TO_FILE_PARAM pOutParam, int nWaitTime);

    // 查询时间段内的所有录像文件
    // nRecordFileType 录像类型 0:所有录像  1:外部报警  2:动态监测报警  3:所有报警  4:卡号查询   5:组合条件查询   6:录像位置与偏移量长度   8:按卡号查询图片(目前仅HB-U和NVS特殊型号的设备支持)  9:查询图片(目前仅HB-U和NVS特殊型号的设备支持)  10:按字段查询    15:返回网络数据结构(金桥网吧)  16:查询所有透明串数据录像文件
    // nriFileinfo 返回的录像文件信息，是一个 NET_RECORDFILE_INFO 结构数组
    // maxlen 是 nriFileinfo缓冲的最大长度(单位字节，建议在(100~200)*sizeof(NET_RECORDFILE_INFO)之间)
    // filecount返回的文件个数，属于输出参数最大只能查到缓冲满为止的录像记录;
    // bTime 是否按时间查(目前无效)
    public boolean CLIENT_QueryRecordFile(LLong lLoginID, int nChannelId, int nRecordFileType, NET_TIME tmStart, NET_TIME tmEnd, String pchCardid, NET_RECORDFILE_INFO[] stFileInfo, int maxlen, IntByReference filecount, int waittime, boolean bTime);

    // 查询时间段内是否有录像文件   bResult输出参数，true有录像，false没录像
    public boolean CLIENT_QueryRecordTime(LLong lLoginID, int nChannelId, int nRecordFileType, NET_TIME tmStart, NET_TIME tmEnd, String pchCardid, IntByReference bResult, int waittime);

    // 通过时间下载录像--扩展
    // nRecordFileType 对应 EM_QUERY_RECORD_TYPE
    // cbTimeDownLoadPos 对应 fTimeDownLoadPosCallBack 回调
    // fDownLoadDataCallBack 对应 fDataCallBack 回调
    public LLong CLIENT_DownloadByTimeEx(LLong lLoginID, int nChannelId, int nRecordFileType,
                                         NET_TIME tmStart, NET_TIME tmEnd, String sSavedFileName,
                                         Callback cbTimeDownLoadPos, Pointer dwUserData,
                                         Callback fDownLoadDataCallBack, Pointer dwDataUser,
                                         Pointer pReserved);

    // 停止录像下载
    public boolean CLIENT_StopDownload(LLong lFileHandle);

    /******************************************************************************
     功能描述	:	通过时间下载录像--扩展,可加载码流转换库
     输入参数	:
     lLoginID:       登录接口返回的句柄
     nChannelId:     视频通道号,从0开始
     nRecordFileType:录像类型 0 所有录像文件
     1 外部报警
     2 动态检测报警
     3 所有报警
     4 卡号查询
     5 组合条件查询
     6 录像位置与偏移量长度
     8 按卡号查询图片(目前仅HB-U和NVS特殊型号的设备支持)
     9 查询图片(目前仅HB-U和NVS特殊型号的设备支持)
     10 按字段查询
     15 返回网络数据结构(金桥网吧)
     16 查询所有透明串数据录像文件
     tmStart:        开始时间
     tmEnd:          结束时间
     sSavedFileName: 保存录像文件名,支持全路径
     cbTimeDownLoadPos: 下载进度回调函数(回调下载进度,下载结果), 对应回调   fTimeDownLoadPosCallBack
     dwUserData:     下载进度回调对应用户数据
     fDownLoadDataCallBack: 录像数据回调函数(回调形式暂不支持转换PS流)，对应回调  fDataCallBack
     dwDataUser:     录像数据回调对应用户数据
     scType:         码流转换类型,0-DAV码流(默认); 1-PS流,3-MP4
     pReserved:      保留参数,后续扩展
     输出参数	：	N/A
     返 回 值	：	LLONG 下载录像句柄
     其他说明	：	特殊接口,SDK默认不支持转PS流,需定制SDK
     ******************************************************************************/
    public LLong CLIENT_DownloadByTimeEx2(LLong lLoginID, int nChannelId, int nRecordFileType,
                                          NET_TIME tmStart, NET_TIME tmEnd, String sSavedFileName,
                                          Callback cbTimeDownLoadPos, Pointer dwUserData,
                                          Callback fDownLoadDataCallBack, Pointer dwDataUser,
                                          int scType, Pointer pReserved);

    // 私有云台控制扩展接口,支持三维快速定位
    public boolean CLIENT_DHPTZControlEx(LLong lLoginID, int nChannelID, int dwPTZCommand, int lParam1, int lParam2, int lParam3, int dwStop);

    // 云台控制扩展接口,支持三维快速定位,鱼眼
    // dwStop类型为BOOL, 取值0或者1
    // dwPTZCommand取值为NET_EXTPTZ_ControlType中的值或者是NET_PTZ_ControlType中的值
    // NET_IN_PTZBASE_MOVEABSOLUTELY_INFO
    // 精准绝对移动控制命令, param4对应结构 NET_IN_PTZBASE_MOVEABSOLUTELY_INFO（通过 CFG_CAP_CMD_PTZ 命令获取云台能力集( CFG_PTZ_PROTOCOL_CAPS_INFO )，若bSupportReal为TRUE则设备支持该操作）
    public boolean CLIENT_DHPTZControlEx2(LLong lLoginID, int nChannelID, int dwPTZCommand, int lParam1, int lParam2, int lParam3, int dwStop, Pointer param4);

    // 设备控制(param内存由用户申请释放)  emType对应 枚举 CtrlType
    public boolean CLIENT_ControlDevice(LLong lLoginID, int emType, Pointer param, int waittime);

    // 设备控制扩展接口，兼容 CLIENT_ControlDevice (pInBuf, pOutBuf内存由用户申请释放)
    // emType的取值为CtrlType中的值
    public boolean CLIENT_ControlDeviceEx(LLong lLoginID, int emType, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);

    // 查询配置信息(lpOutBuffer内存由用户申请释放)
    public boolean CLIENT_GetDevConfig(LLong lLoginID, int dwCommand, int lChannel, Pointer lpOutBuffer, int dwOutBufferSize, IntByReference lpBytesReturned, int waittime);

    // 设置配置信息(lpInBuffer内存由用户申请释放)
    public boolean CLIENT_SetDevConfig(LLong lLoginID, int dwCommand, int lChannel, Pointer lpInBuffer, int dwInBufferSize, int waittime);

    // 查询设备状态(pBuf内存由用户申请释放)
    // pBuf指向char *,输出参数
    // pRetLen指向int *;输出参数，实际返回的数据长度，单位字节
    public boolean CLIENT_QueryDevState(LLong lLoginID, int nType, Pointer pBuf, int nBufLen, IntByReference pRetLen, int waittime);

    // 查询远程设备状态(pBuf内存由用户申请释放)
    // nType为DH_DEVSTATE_ALARM_FRONTDISCONNECT时，通道号从1开始
    public boolean CLIENT_QueryRemotDevState(LLong lLoginID, int nType, int nChannelID, Pointer pBuf, int nBufLen, IntByReference pRetLen, int waittime);

    // 获取设备能力接口
    // pInBuf指向void*，输入参数结构体指针       pOutBuf指向void*，输出参数结构体指针
    public boolean CLIENT_GetDevCaps(LLong lLoginID, int nType, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);

    // 新系统能力查询接口，查询系统能力信息(以Json格式，具体见配置SDK)(szOutBuffer内存由用户申请释放)
    // szCommand: 对应命令查看上文
    // szOutBuffer: 获取到的信息, 通过 CLIENT_ParseData 解析
    // error 指向 int * ： 错误码大于0表示设备返回的，小于0表示缓冲不够或数据校验引起的
    public boolean CLIENT_QueryNewSystemInfo(LLong lLoginID, String szCommand, int nChannelID, byte[] szOutBuffer, int dwOutBufferSize, IntByReference error, int waittime);

    // 新系统能力查询接口扩展，查询系统能力信息，入参新增扩展数据(以Json格式，具体见配置SDK)(szOutBuffer内存由用户申请释放)
    public boolean CLIENT_QueryNewSystemInfoEx(LLong lLoginID, String szCommand, int nChannelID, byte[] szOutBuffer, int dwOutBufferSize, IntByReference error, Pointer pExtendInfo , int waittime);

    // 查询系统能力信息(pSysInfoBuffer内存由用户申请释放，大小参照DH_SYS_ABILITY对应的结构体，若nSystemType为 ABILITY_DYNAMIC_CONNECT ，内存大小至少为sizeof(BOOL),若nSystemType为ABILITY_TRIGGER_MODE，内存大小为sizeof(int))
    public boolean CLIENT_QuerySystemInfo(LLong lLoginID, int nSystemType, String pSysInfoBuffer, int nChannelID, byte[] szOutBuffer, int dwOutBufferSize, IntByReference error, int waittime);

    // 订阅视频统计摘要信息
    public LLong CLIENT_AttachVideoStatSummary(LLong lLoginID, NET_IN_ATTACH_VIDEOSTAT_SUM pInParam, NET_OUT_ATTACH_VIDEOSTAT_SUM pOutParam, int nWaitTime);

    // 取消订阅视频统计摘要信息，lAttachHandle为CLIENT_AttachVideoStatSummary的返回值
    public boolean CLIENT_DetachVideoStatSummary(LLong lAttachHandle);

    // 开始查询视频统计信息/获取人数统计信息
    public LLong CLIENT_StartFindNumberStat(LLong lLoginID, NET_IN_FINDNUMBERSTAT pstInParam, NET_OUT_FINDNUMBERSTAT pstOutParam);

    // 继续查询视频统计/继续查询人数统计
    public int CLIENT_DoFindNumberStat(LLong lFindHandle, NET_IN_DOFINDNUMBERSTAT pstInParam, NET_OUT_DOFINDNUMBERSTAT pstOutParam);

    // 结束查询视频统计/结束查询人数统计
    public boolean CLIENT_StopFindNumberStat(LLong lFindHandle);

    // 设置语音对讲模式,客户端方式还是服务器方式
    // emType : 方式类型 参照 EM_USEDEV_MODE
    public boolean CLIENT_SetDeviceMode(LLong lLoginID, int emType, Pointer pValue);

    ///////////////// 录像回放相关接口 ///////////////////////
    // 按时间方式回放
    public LLong CLIENT_PlayBackByTime(LLong lLoginID, int nChannelID, NET_TIME lpStartTime, NET_TIME lpStopTime, Pointer hWnd, fDownLoadPosCallBack cbDownLoadPos, Pointer dwPosUser);

    // 按时间方式回放--扩展接口
    // cbDownLoadPos 对应 fDownLoadPosCallBack 回调
    // fDownLoadDataCallBack 对应 fDataCallBack 回调
    public LLong CLIENT_PlayBackByTimeEx(LLong lLoginID, int nChannelID, NET_TIME lpStartTime, NET_TIME lpStopTime, Pointer hWnd,
                                         Callback cbDownLoadPos, Pointer dwPosUser,
                                         Callback fDownLoadDataCallBack, Pointer dwDataUser);

    public LLong CLIENT_PlayBackByTimeEx2(LLong lLoginID, int nChannelID, NET_IN_PLAY_BACK_BY_TIME_INFO pstNetIn, NET_OUT_PLAY_BACK_BY_TIME_INFO pstNetOut);

    // 停止录像回放接口
    public boolean CLIENT_StopPlayBack(LLong lPlayHandle);

    // 获取回放OSD时间
    public boolean CLIENT_GetPlayBackOsdTime(LLong lPlayHandle, NET_TIME lpOsdTime, NET_TIME lpStartTime, NET_TIME lpEndTime);

    // 暂停或恢复录像回放
    // bPause: 1 - 暂停	0 - 恢复
    public boolean CLIENT_PausePlayBack(LLong lPlayHandle, int bPause);

    // 快进录像回放
    public boolean CLIENT_FastPlayBack(LLong lPlayHandle);

    // 慢进录像回放
    public boolean CLIENT_SlowPlayBack(LLong lPlayHandle);

    // 恢复正常回放速度
    public boolean CLIENT_NormalPlayBack(LLong lPlayHandle);

    // 设置录像回放速度, emSpeed 对应枚举 EM_PLAY_BACK_SPEED
    public boolean CLIENT_SetPlayBackSpeed(LLong lPlayHandle, int emSpeed);

    // 查询设备当前时间
    public boolean CLIENT_QueryDeviceTime(LLong lLoginID, NET_TIME pDeviceTime, int waittime);

    // 设置设备当前时间
    public boolean CLIENT_SetupDeviceTime(LLong lLoginID, NET_TIME pDeviceTime);

    // 获得亮度、色度、对比度、饱和度的参数
    // param1/param2/param3/param4 四个参数范围0~255
    public boolean CLIENT_ClientGetVideoEffect(LLong lPlayHandle, byte[] nBrightness, byte[] nContrast, byte[] nHue, byte[] nSaturation);

    // 设置亮度、色度、对比度、饱和度的参数
    // nBrightness/nContrast/nHue/nSaturation四个参数为 unsigned byte 范围0~255
    public boolean CLIENT_ClientSetVideoEffect(LLong lPlayHandle, byte nBrightness, byte nContrast, byte nHue, byte nSaturation);

    //------------------------用户管理-----------------------
    // 查询用户信息--扩展(info内存由用户申请释放,大小为sizeof(USER_MANAGE_INFO_EX))
    public boolean CLIENT_QueryUserInfoEx(LLong lLoginID, USER_MANAGE_INFO_EX info, int waittime);

    // 查询用户信息--最大支持64通道设备
    // pReserved指向void*
    public boolean CLIENT_QueryUserInfoNew(LLong lLoginID, USER_MANAGE_INFO_NEW info, Pointer pReserved, int nWaittime);

    // 设置用户信息接口--操作设备用户--最大支持64通道设备
    // opParam指向void*           subParam指向void*
    // pReserved指向void*
    // opParam（设置用户信息的输入缓冲）和subParam（设置用户信息的辅助输入缓冲）对应结构体类型USER_GROUP_INFO_NEW或USER_INFO_NEW
    public boolean CLIENT_OperateUserInfoNew(LLong lLoginID, int nOperateType, Pointer opParam, Pointer subParam, Pointer pReserved, int nWaittime);

    /**
     * // 查询设备日志，以分页方式查询(pQueryParam, pLogBuffer内存由用户申请释放)
     * CLIENT_NET_API BOOL CALL_METHOD CLIENT_QueryDeviceLog(LLONG lLoginID, QUERY_DEVICE_LOG_PARAM *pQueryParam, char *pLogBuffer, int nLogBufferLen, int *pRecLogNum, int waittime=3000);
     * pQueryParam 对应结构体QUERY_DEVICE_LOG_PARAM
     * pLogBuffer:char *
     * waitTime:默认3000
     */
    public boolean CLIENT_QueryDeviceLog(LLong lLoginID, Pointer pQueryParam, Pointer pLogBuffer, int nLogBufferLen, IntByReference pRecLogNum, int waittime);


    //----------------------语音对讲--------------------------
    // 向设备发起语音对讲请求          pfcb是用户自定义的数据回调接口, pfAudioDataCallBack 回调
    public LLong CLIENT_StartTalkEx(LLong lLoginID, Callback pfcb, Pointer dwUser);

    // 停止语音对讲        lTalkHandle语音对讲句柄，是CLIENT_StartTalkEx的返回 值
    public boolean CLIENT_StopTalkEx(LLong lTalkHandle);

    // 启动本地录音功能(只在Windows平台下有效)，录音采集出来的音频数据通过CLIENT_StartTalkEx的回调函数回调给用户，对应操作是CLIENT_RecordStopEx
    // lLoginID是CLIENT_Login的返回值
    public boolean CLIENT_RecordStartEx(LLong lLoginID);

    // 开始PC端录音
    public boolean CLIENT_RecordStart();

    // 结束PC端录音
    public boolean CLIENT_RecordStop();

    // 停止本地录音(只在Windows平台下有效)，对应操作是CLIENT_RecordStartEx。
    public boolean CLIENT_RecordStopEx(LLong lLoginID);

    // 向设备发送用户的音频数据，这里的数据可以是从CLIENT_StartTalkEx的回调接口中回调出来的数据
    public LLong CLIENT_TalkSendData(LLong lTalkHandle, Pointer pSendBuf, int dwBufSize);

    // 解码音频数据扩展接口(只在Windows平台下有效)    pAudioDataBuf是要求解码的音频数据内容
    public void CLIENT_AudioDec(Pointer pAudioDataBuf, int dwBufSize);
    public boolean CLIENT_AudioDecEx(LLong lTalkHandle, Pointer pAudioDataBuf, int dwBufSize);

    // 音频格式信息
    public class NET_AUDIO_FORMAT extends SdkStructure
    {
        public byte              byFormatTag;                   // 编码类型,如0：PCM
        public short             nChannels;                     // 声道数
        public short             wBitsPerSample;                // 采样深度
        public int               nSamplesPerSec;                // 采样率
    }
    // 音频格式信息
    public class LPDH_AUDIO_FORMAT extends SdkStructure
    {
        public byte              byFormatTag;                   // 编码类型,如0：PCM
        public short             nChannels;                     // 声道数
        public short             wBitsPerSample;                // 采样深度
        public int               nSamplesPerSec;                // 采样率
    }

    // 音频编码--初始化(特定标准格式->私有格式) 初始化对讲中的音频编码接口，告诉SDK内部要编码的源音频数据的音频格式，对不支持的音频格式初始化会失败
    public int CLIENT_InitAudioEncode(NET_AUDIO_FORMAT aft);

    // 进行音频的数据二次编码，从标准音频格式转换成设备支持的格式
    // 音频编码--数据编码(lpInBuf, lpOutBuf内存由用户申请释放)
    public int CLIENT_AudioEncode(LLong lTalkHandle, Pointer lpInBuf, IntByReference lpInLen, Pointer lpOutBuf, IntByReference lpOutLen);

    // 音频编码--完成退出  解码功能使用完毕后，告诉接口清理内部资源
    public int CLIENT_ReleaseAudioEncode();

    //-------------------白名单-------------------------
    // 按查询条件查询记录          pInParam查询记录参数        pOutParam返回查询句柄
    // 可以先调用本接口获得查询句柄，再调用  CLIENT_FindNextRecord函数获取记录列表，查询完毕可以调用CLIENT_FindRecordClose关闭查询句柄。
    public boolean CLIENT_FindRecord(LLong lLoginID, NET_IN_FIND_RECORD_PARAM pInParam, NET_OUT_FIND_RECORD_PARAM pOutParam, int waittime);

    // 查找记录:nFilecount:需要查询的条数, 返回值为媒体文件条数 返回值小于nFilecount则相应时间段内的文件查询完毕
    public boolean CLIENT_FindNextRecord(NET_IN_FIND_NEXT_RECORD_PARAM pInParam, NET_OUT_FIND_NEXT_RECORD_PARAM pOutParam, int waittime);

    // 结束记录查找,lFindHandle是CLIENT_FindRecord的返回值
    public boolean CLIENT_FindRecordClose(LLong lFindHandle);

    // 查找记录条数,pInParam与pOutParam内存由用户申请释放
    public boolean CLIENT_QueryRecordCount(NET_IN_QUEYT_RECORD_COUNT_PARAM pInParam, NET_OUT_QUEYT_RECORD_COUNT_PARAM pOutParam, int waittime);

    // 黑白名单操作 ,pstOutParam = null;
    public boolean CLIENT_OperateTrafficList(LLong lLoginID, NET_IN_OPERATE_TRAFFIC_LIST_RECORD pstInParam, NET_OUT_OPERATE_TRAFFIC_LIST_RECORD pstOutParam, int waittime);

    // 文件上传控制接口，白名单上传需要三个步骤配合使用，CLIENT_FileTransmit的 NET_DEV_BLACKWHITETRANS_START、  NET_DEV_BLACKWHITETRANS_SEND、   NET_DEV_BLACKWHITETRANS_STOP，如下所示
    // fTransFileCallBack 回调
    public LLong CLIENT_FileTransmit(LLong lLoginID, int nTransType, Pointer szInBuf, int nInBufLen, Callback cbTransFile, Pointer dwUserData, int waittime);

    // 查询设备信息
    public boolean CLIENT_QueryDevInfo(LLong lLoginID, int nQueryType, Pointer pInBuf, Pointer pOutBuf, Pointer pReservedL, int nWaitTime);

    // ------------------车载GPS-------------------------
    // 设置GPS订阅回调函数--扩展, fGPSRevEx 回调
    public void CLIENT_SetSubcribeGPSCallBackEX(Callback OnGPSMessage, Pointer dwUser);

    // 设置GPS订阅回调函数--扩展2， fGPSRevEx2 回调
    public void CLIENT_SetSubcribeGPSCallBackEX2(Callback OnGPSMessage, Pointer dwUser);

    // GPS信息订阅
    // bStart:表明是订阅还是取消          InterTime:订阅时间内GPS发送频率(单位秒)
    // KeepTime:订阅持续时间(单位秒) 值为-1时,订阅时间为极大值,可视为永久订阅
    // 订阅时间内GPS发送频率(单位秒)
    public boolean CLIENT_SubcribeGPS(LLong lLoginID, int bStart, int KeepTime, int InterTime);

    // 设置文件长度, pInParam与pOutParam内存由用户申请释放
    public boolean CLIENT_PreUploadRemoteFile(LLong lLoginID, NET_IN_PRE_UPLOAD_REMOTE_FILE pInParam, NET_OUT_PRE_UPLOAD_REMOTE_FILE pOutParam, int nWaitTime);

    // 同步文件上传, 只适用于小文件
    public boolean CLIENT_UploadRemoteFile(LLong lLoginID, NET_IN_UPLOAD_REMOTE_FILE pInParam, NET_OUT_UPLOAD_REMOTE_FILE pOutParam, int nWaitTime);

    // 显示目录中文件和子目录,pInParam与pOutParam内存由用户申请释放
    public boolean CLIENT_ListRemoteFile(LLong lLoginID, NET_IN_LIST_REMOTE_FILE pInParam, NET_OUT_LIST_REMOTE_FILE pOutParam, int nWaitTime);

    // 删除文件或目录,pInParam与pOutParam内存由用户申请释放
    public boolean CLIENT_RemoveRemoteFiles(LLong lLoginID, NET_IN_REMOVE_REMOTE_FILES pInParam, NET_OUT_REMOVE_REMOTE_FILES pOutParam, int nWaitTime);

    // 过车记录订阅
    public LLong CLIENT_ParkingControlAttachRecord(LLong lLoginID, NET_IN_PARKING_CONTROL_PARAM pInParam, NET_OUT_PARKING_CONTROL_PARAM pOutParam, int nWaitTime);

    // 取消过车记录订阅
    public boolean CLIENT_ParkingControlDetachRecord(LLong lAttachHandle);

    // 开始过车记录查询
    public LLong CLIENT_ParkingControlStartFind(LLong lLoginID, NET_IN_PARKING_CONTROL_START_FIND_PARAM pInParam, NET_OUT_PARKING_CONTROL_START_FIND_PARAM pOutParam, int waittime);

    // 获取过车记录
    public boolean CLIENT_ParkingControlDoFind(LLong lFindeHandle, NET_IN_PARKING_CONTROL_DO_FIND_PARAM pInParam, NET_OUT_PARKING_CONTROL_DO_FIND_PARAM pOutParam, int waittime);

    // 结束过车记录查询
    public boolean CLIENT_ParkingControlStopFind(LLong lFindHandle);

    // 车位状态订阅,pInParam与pOutParam内存由用户申请释放
    public LLong CLIENT_ParkingControlAttachParkInfo(LLong lLoginID, NET_IN_PARK_INFO_PARAM pInParam, NET_OUT_PARK_INFO_PARAM pOutParam, int nWaitTime);

    // 取消车位状态订阅
    public boolean CLIENT_ParkingControlDetachParkInfo(LLong lAttachHandle);

    // 清除异常车位车辆信息 NET_IN_REMOVE_PARKING_CAR_INFO, NET_OUT_REMOVE_PARKING_CAR_INFO
    public boolean CLIENT_RemoveParkingCarInfo(LLong lLoginID, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    // 电源控制,pInParam与pOutParam内存由用户申请释放
    public boolean CLIENT_PowerControl(LLong lLoginID, NET_IN_WM_POWER_CTRL pInParam, NET_OUT_WM_POWER_CTRL pOutParam, int nWaitTime);

    // 载入/保存预案,pInParam与pOutParam内存由用户申请释放
    public boolean CLIENT_LoadMonitorWallCollection(LLong lLoginID, NET_IN_WM_LOAD_COLLECTION pInParam, NET_OUT_WM_LOAD_COLLECTION pOutParam, int nWaitTime);
    public boolean CLIENT_SaveMonitorWallCollection(LLong lLoginID, NET_IN_WM_SAVE_COLLECTION pInParam, NET_OUT_WM_SAVE_COLLECTION pOutParam, int nWaitTime);

    // 获取电视墙预案,pInParam与pOutParam内存由用户申请释放
    public boolean CLIENT_GetMonitorWallCollections(LLong lLoginID, NET_IN_WM_GET_COLLECTIONS pInParam, NET_OUT_WM_GET_COLLECTIONS pOutParam, int nWaitTime);

    // 查询/设置显示源(pstuSplitSrc内存由用户申请释放),  nWindow为-1表示所有窗口 ; pstuSplitSrc 对应 NET_SPLIT_SOURCE 指针
    public boolean CLIENT_GetSplitSource(LLong lLoginID, int nChannel, int nWindow, NET_SPLIT_SOURCE[] pstuSplitSrc, int nMaxCount, IntByReference pnRetCount, int nWaitTime);
    public boolean CLIENT_SetSplitSource(LLong lLoginID, int nChannel, int nWindow, NET_SPLIT_SOURCE pstuSplitSrc, int nSrcCount, int nWaitTime);

    // 设置显示源, 支持同时设置多个窗口(pInparam, pOutParam内存由用户申请释放)
    public boolean CLIENT_SplitSetMultiSource(LLong lLoginID, NET_IN_SPLIT_SET_MULTI_SOURCE pInParam, NET_OUT_SPLIT_SET_MULTI_SOURCE pOutParam, int nWaitTime);

    // 查询矩阵子卡信息(pstuCardList内存由用户申请释放)
    public boolean CLIENT_QueryMatrixCardInfo(LLong lLoginID, NET_MATRIX_CARD_LIST pstuCardList, int nWaitTime);

    // 开始查找录像文件帧信息(pInParam, pOutParam内存由用户申请释放)
    public boolean CLIENT_FindFrameInfo(LLong lLoginID, NET_IN_FIND_FRAMEINFO_PRAM pInParam, NET_OUT_FIND_FRAMEINFO_PRAM pOutParam, int nWaitTime);

    // 获取标签信息
    public boolean CLIENT_FileStreamGetTags(LLong lFindHandle, NET_IN_FILE_STREAM_GET_TAGS_INFO pInParam, NET_OUT_FILE_STREAM_GET_TAGS_INFO pOutParam, int nWaitTime);

    // 设置标签信息
    public boolean CLIENT_FileStreamSetTags(LLong lFindHandle, NET_IN_FILE_STREAM_TAGS_INFO pInParam, NET_OUT_FILE_STREAM_TAGS_INFO pOutParam, int nWaitTime);

    // 查询/设置分割模式(pstuSplitInfo内存由用户申请释放)
    public boolean CLIENT_GetSplitMode(LLong lLoginID, int nChannel, NET_SPLIT_MODE_INFO pstuSplitInfo, int nWaitTime);
    public boolean CLIENT_SetSplitMode(LLong lLoginID, int nChannel, NET_SPLIT_MODE_INFO pstuSplitInfo, int nWaitTime);

    // 开窗/关窗(pInparam, pOutParam内存由用户申请释放)
    public boolean CLIENT_OpenSplitWindow(LLong lLoginID, NET_IN_SPLIT_OPEN_WINDOW pInParam, NET_OUT_SPLIT_OPEN_WINDOW pOutParam, int nWaitTime);
    public boolean CLIENT_CloseSplitWindow(LLong lLoginID, NET_IN_SPLIT_CLOSE_WINDOW pInParam, NET_OUT_SPLIT_CLOSE_WINDOW pOutParam, int nWaitTime);

    // 获取当前显示的窗口信息(pInparam, pOutParam内存由用户申请释放)
    public boolean CLIENT_GetSplitWindowsInfo(LLong lLoginID, NET_IN_SPLIT_GET_WINDOWS pInParam, NET_OUT_SPLIT_GET_WINDOWS pOutParam, int nWaitTime);

    // 查询分割能力(pstuCaps内存由用户申请释放)
    public boolean CLIENT_GetSplitCaps(LLong lLoginID, int nChannel, NET_SPLIT_CAPS pstuCaps, int nWaitTime);

    // 下位矩阵切换(pInparam, pOutParam内存由用户申请释放)
    public boolean CLIENT_MatrixSwitch(LLong lLoginID, NET_IN_MATRIX_SWITCH pInParam, NET_OUT_MATRIX_SWITCH pOutParam, int nWaitTime);

    // 打开刻录会话, 返回刻录会话句柄,pstInParam与pstOutParam内存由用户申请释放
    public LLong CLIENT_StartBurnSession(LLong lLoginID, NET_IN_START_BURN_SESSION pstInParam, NET_OUT_START_BURN_SESSION pstOutParam, int nWaitTime);

    // 关闭刻录会话
    public boolean CLIENT_StopBurnSession(LLong lBurnSession);

    //------------有盘/无盘刻录----lBurnSession 是 CLIENT_StartBurnSession返回的句柄//
    // 开始刻录,pstInParam与pstOutParam内存由用户申请释放
    public boolean CLIENT_StartBurn(LLong lBurnSession, NET_IN_START_BURN pstInParam, NET_OUT_START_BURN pstOutParam, int nWaitTime);
    // 停止刻录
    public boolean CLIENT_StopBurn(LLong lBurnSession);
    // 暂停/恢复刻录
    public boolean CLIENT_PauseBurn(LLong lBurnSession, int bPause);

    // 获取刻录状态
    public boolean CLIENT_BurnGetState(LLong lBurnSession, NET_IN_BURN_GET_STATE pstInParam, NET_OUT_BURN_GET_STATE pstOutParam, int nWaitTime);

    // 监听刻录状态,pstInParam与pstOutParam内存由用户申请释放
    public LLong CLIENT_AttachBurnState(LLong lLoginID, NET_IN_ATTACH_STATE pstInParam, NET_OUT_ATTACH_STATE pstOutParam, int nWaitTime);

    // 取消监听刻录状态,lAttachHandle是CLIENT_AttachBurnState返回值
    public boolean CLIENT_DetachBurnState(LLong lAttachHandle);

    // 开始刻录附件上传
    // 刻录上传开始 返回此次上传操作句柄, 注意以下接口不能在fAttachBurnStateCB回调函数里面调用,pstInParam与pstOutParam内存由用户申请释放
    public LLong CLIENT_StartUploadFileBurned(LLong lLoginID, NET_IN_FILEBURNED_START pstInParam, NET_OUT_FILEBURNED_START pstOutParam, int nWaitTime);

    //上传刻录附件,lUploadHandle是CLIENT_StartUploadFileBurned返回值
    public boolean CLIENT_SendFileBurned(LLong lUploadHandle);

    //停止刻录附件上传
    // 刻录上传停止,lUploadHandle是CLIENT_StartUploadFileBurned返回值,此接口不能在fBurnFileCallBack回调函数中调用
    public boolean CLIENT_StopUploadFileBurned(LLong lUploadHandle);


    // 下载指定的智能分析数据 - 图片, fDownLoadPosCallBack 回调
    // emType 参考 EM_FILE_QUERY_TYPE
    public LLong CLIENT_DownloadMediaFile(LLong lLoginID, int emType, Pointer lpMediaFileInfo, String sSavedFileName, Callback cbDownLoadPos, Pointer dwUserData, Pointer reserved);

    // 停止下载数据
    public boolean CLIENT_StopDownloadMediaFile(LLong lFileHandle);

    // 下发通知到设备 接口, 以emNotifyType来区分下发的通知类型, pInParam 和 pOutParam 都由用户来分配和释放, emNotifyType对应结构体 NET_EM_NOTIFY_TYPE
    public boolean CLIENT_SendNotifyToDev(LLong lLoginID, int emNotifyType, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    // 查询IO状态(pState内存由用户申请释放,根据emType对应的类型找到相应的结构体，进而确定申请内存大小), emType 参考 NET_IOTYPE
    public boolean CLIENT_QueryIOControlState(LLong lLoginID, int emType,
                                              Pointer pState, int maxlen, IntByReference nIOCount, int waittime);

    // IO控制(pState内存由用户申请释放,根据emType对应的类型找到相应的结构体，进而确定申请内存大小),emType 参考 NET_IOTYPE
    public boolean CLIENT_IOControl(LLong lLoginID, int emType, Pointer pState, int maxlen);

    // 订阅监测点位信息,pInParam与pOutParam内存由用户申请释放
    public LLong CLIENT_SCADAAttachInfo(LLong lLoginID, NET_IN_SCADA_ATTACH_INFO pInParam, NET_OUT_SCADA_ATTACH_INFO pOutParam, int nWaitTime);

    // 取消监测点位信息订阅
    public boolean CLIENT_SCADADetachInfo(LLong lAttachHandle);

    // 创建透明串口通道,TransComType高2个字节表示串口序号,低2个字节表示串口类型,目前类型支持 0：串口(232), 1:485
    // baudrate 串口的波特率，1~8分别表示1200，2400，4800，9600，19200，38400，57600，115200
    // databits 串口的数据位 4~8表示4位~8位
    // stopbits 串口的停止位   232串口 ： 数值0 代表停止位1; 数值1 代表停止位1.5; 数值2 代表停止位2.    485串口 ： 数值1 代表停止位1; 数值2 代表停止位2.
    // parity 串口的检验位，0：无校验，1：奇校验；2：偶校验;
    // cbTransCom 串口数据回调，回调出前端设备发过来的信息
    // fTransComCallBack 回调
    public LLong CLIENT_CreateTransComChannel(LLong lLoginID, int TransComType, int baudrate, int databits, int stopbits, int parity, Callback cbTransCom, Pointer dwUser);

    // 透明串口发送数据(pBuffer内存由用户申请释放)
    public boolean CLIENT_SendTransComData(LLong lTransComChannel, byte[] pBuffer, int dwBufSize);

    // 释放通明串口通道
    public boolean CLIENT_DestroyTransComChannel(LLong lTransComChannel);

    // 查询透明串口状态(pCommState内存由用户申请释放), TransComType 低2个字节表示串口类型， 0:串口(232)， 1:485口；高2个字节表示串口通道号，从0开始
    public boolean CLIENT_QueryTransComParams(LLong lLoginID, int TransComType, NET_COMM_STATE pCommState, int nWaitTime);

    // 订阅智能分析进度（适用于视频分析源为录像文件时）,pstInParam与pstOutParam内存由用户申请释放
    public boolean CLIENT_AttachVideoAnalyseState(LLong lLoginID, NET_IN_ATTACH_VIDEOANALYSE_STATE pstInParam, NET_OUT_ATTACH_VIDEOANALYSE_STATE pstOutParam, int nWaittime);

    // 停止订阅
    public boolean CLIENT_DetachVideoAnalyseState(LLong lAttachHandle);

    // 抓图, hPlayHandle为监视或回放句柄
    public boolean CLIENT_CapturePicture(LLong hPlayHandle, String pchPicFileName);

    // 抓图, hPlayHandle为监视或回放句柄
    public boolean CLIENT_CapturePictureEx(LLong hPlayHandle, String pchPicFileName, int eFormat);

    // 获取设备自检信息,pInParam与pOutParam内存由用户申请释放
    public boolean CLIENT_GetSelfCheckInfo(LLong lLoginID, NET_IN_GET_SELTCHECK_INFO pInParam, NET_SELFCHECK_INFO pOutParam, int nWaitTime);

    // 主动注册功能,启动服务；nTimeout参数已无效 .
    // cbListen对象为  fServiceCallBack 子类
    public LLong CLIENT_ListenServer(String ip, int port, int nTimeout, Callback cbListen, Pointer dwUserData);

    // 停止服务
    public boolean CLIENT_StopListenServer(LLong lServerHandle);

    // 指定回调数据类型 实施监视(预览), 数据回调函数 cbRealData 中得到的码流类型为 emDataType 所指定的类型
    public LLong CLIENT_RealPlayByDataType(LLong lLoginID, NET_IN_REALPLAY_BY_DATA_TYPE pstInParam, NET_OUT_REALPLAY_BY_DATA_TYPE pstOutParam, int dwWaitTime);

    // 指定回调数据格式  开始回放,  数据回调函数 fDownLoadDataCallBack 中得到的码流类型为 emDataType 所指定的类型
    public LLong CLIENT_PlayBackByDataType(LLong lLoginID, NET_IN_PLAYBACK_BY_DATA_TYPE pstInParam, NET_OUT_PLAYBACK_BY_DATA_TYPE pstOutParam, int dwWaitTime);

    // 指定码流类型 开始下载, 下载得到的文件和数据回调函数 fDownLoadDataCallBack 中得到的码流类型均为 emDataType 所指定的类型
    // NET_IN_DOWNLOAD_BY_DATA_TYPE pstInParam, NET_OUT_DOWNLOAD_BY_DATA_TYPE pstOutParam
    public LLong CLIENT_DownloadByDataType(LLong lLoginID, Pointer pstInParam, Pointer pstOutParam, int dwWaitTime);

    /************************************************************************/
    /*                            BUS订阅                                   */
    /************************************************************************/
    // 订阅Bus状态,pstuInBus与pstuOutBus内存由用户申请释放
    public LLong CLIENT_AttachBusState(LLong lLoginID, NET_IN_BUS_ATTACH pstuInBus, NET_OUT_BUS_ATTACH pstuOutBus, int nWaitTime);

    // 停止订阅Bus状态,lAttachHandle是CLIENT_AttachBusState返回值
    public boolean CLIENT_DetachBusState(LLong lAttachHandle);

    //订阅事件重传,pInParam内存由用户申请释放
    public LLong CLIENT_AttachEventRestore(LLong lLoginID, NET_IN_ATTACH_EVENT_RESTORE pInParam, int nWaitTime);

    // 停止订阅事件重传,pInParam内存由用户申请释放
    public boolean CLIENT_DetachEventRestore(LLong lAttachHandle);

    // 设置GPS温湿度订阅回调函数, fGPSTempHumidityRev
    public void CLIENT_SetSubcribeGPSTHCallBack(Callback OnGPSMessage, Pointer dwUser);

    // GPS温湿度信息订阅, bStart为BOOL类型
    public boolean CLIENT_SubcribeGPSTempHumidity(LLong lLoginID, int bStart, int InterTime, Pointer Reserved);

    // 人脸信息记录操作函数
    public boolean CLIENT_FaceInfoOpreate(LLong lLoginID, int emType, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    // 下发人脸图片信息
    public boolean CLIENT_DeliverUserFacePicture(LLong lLoginID, NET_IN_DELIVER_USER_PICTURE pInParam, NET_OUT_DELIVER_USER_PICTURE pOutParam, int nWaitTime);

    //开始查询人脸信息
    public LLong CLIENT_StartFindFaceInfo(LLong lLoginID, NET_IN_FACEINFO_START_FIND pstIn, NET_OUT_FACEINFO_START_FIND pstOut, int nWaitTime);

    //获取人脸信息
    public boolean CLIENT_DoFindFaceInfo(LLong lFindHandle, NET_IN_FACEINFO_DO_FIND pstIn, NET_OUT_FACEINFO_DO_FIND pstOut, int nWaitTime);

    //停止查询人脸信息
    public boolean CLIENT_StopFindFaceInfo(LLong lFindHandle);

    /***********************************************************************************
     *						                     诱导屏相关接口									  *
     **********************************************************************************/
    // 设置诱导屏配置信息接口
    public boolean CLIENT_SetGuideScreenCfg(LLong lLoginID, NET_IN_SET_GUIDESCREEN_CFG pInParam, NET_OUT_SET_GUIDESCREEN_CFG pstOutPqram, int nWaitTime);

    // 添加一个节目信息到诱导屏
    public boolean CLIENT_AddOneProgramme(LLong lLoginID, NET_IN_ADD_ONE_PROGRAMME pInParam, NET_OUT_ADD_ONE_PROGRAMME pOutParam, int nWaitTime);

    // 通过节目ID 修改节目
    public boolean CLIENT_ModifyOneProgrammeByID(LLong lLoginID, NET_IN_MODIFY_ONE_PROGRAMME pInParam, NET_OUT_MODIFY_ONE_PROGRAMME pOutParam, int nWaitTime);

    // 批量删除节目信息
    public boolean CLIENT_DelMultiProgrammesById(LLong lLoginID, NET_IN_DEL_PROGRAMMES pInParam, NET_OUT_DEL_PROGRAMMES pOutParam, int nWaitTime);

    // 增加一个即时节目计划
    public boolean CLIENT_AddOneImmediProgrammePlan(LLong lLoginID, NET_IN_ADD_IMME_PROGRAMMEPLAN pInParam, NET_OUT_ADD_PROGRAMMEPLAN pOutParam, int nWaitTime);

    // 修改一个即时节目计划
    public boolean CLIENT_ModifyOneImmediProgrammePlan(LLong lLoginID, NET_IN_MODIFY_IMME_PROGRAMMEPLAN pInParam, NET_OUT_MODIFY_IMME_PROGRAMMEPLAN pOutParam, int nWaitTime);

    // 增加一个定时节目计划
    public boolean CLIENT_AddOneTimerProgrammePlan(LLong lLoginID, NET_IN_ADD_TIMER_PROGRAMMEPLAN pInParam, NET_OUT_ADD_PROGRAMMEPLAN pOutParam, int nWaitTime);

    // 修改一个定时节目计划
    public boolean CLIENT_ModifyOneTimerProgrammePlan(LLong lLoginID, NET_IN_MODIFY_TIMER_PROGRAMMEPLAN pInParam, NET_OUT_MODIFY_TIMER_PROGRAMMEPLAN pOutParam, int nWaitTime);

    // 删除多个节目计划
    public boolean CLIENT_DelMultiProgrammePlans(LLong lLoginID, NET_IN_DEL_PROGRAMMEPLANS pInParam, NET_OUT_DEL_PROGRAMMEPLANS pOutParam, int nWaitTime);

    // 通过诱导屏ID 获取诱导屏配置信息
    public boolean CLIENT_GetOneGuideScreenCfgById(LLong lLoginID, NET_IN_GET_GUIDESCREEN_CFG_BYID pInParam, NET_OUT_GET_GUIDESCREEN_CFG_BYID pOutParam, int nWaitTime);

    // 获取所有诱导屏配置信息
    public boolean CLIENT_GetAllGuideScreenCfg(LLong lLoginID, NET_IN_GET_ALL_GUIDESCREEN_CFG pInParam, NET_OUT_GET_ALL_GUIDESCREEN_CFG pOutParam, int nWaitTime);

    // 通过节目ID 获取节目信息
    public boolean CLIENT_GetOneProgrammeById(LLong lLoginID, NET_IN_GET_PROGRAMME_BYID pInParam, NET_OUT_GET_PROGRAMME_BYID pOutParam, int nWaitTime);

    // 获取所有节目信息
    public boolean CLIENT_GetAllProgrammes(LLong lLoginID, NET_IN_GET_ALL_PROGRAMMES pInParam, NET_OUT_GET_ALL_PROGRAMMES pOutParam, int nWaitTime);

    // 获取所有节目的简要信息
    public boolean CLIENT_GetAllBrieflyProgrammes(LLong lLoginID, NET_IN_GET_ALL_BRIEFLYPROGRAMMES pInParam, NET_OUT_GET_ALL_BRIEFLYPROGRAMMES pOutParam, int nWaitTime);

    // 获取所有节目计划信息
    public boolean CLIENT_GetAllProgrammePlans(LLong lLoginID, NET_IN_GET_ALL_PROGRAMMEPLANS pInParam, NET_OUT_GET_ALL_PROGRAMMEPLANS pOutParam, int nWaitTime);

    // 通过节目计划ID 获取节目计划
    public boolean CLIENT_GetOneProgrammePlanByID(LLong lLoginID, NET_IN_GET_PROGRAMMEPLAN_BYID pInParam, NET_OUT_GET_PROGRAMMEPLAN_BYID pOutParam, int nWaitTime);

    // 设置光带状态信息
    public boolean CLIENT_SetGuideScreenGDStatus(LLong lLoginID, NET_IN_SET_GD_STATUS pInParam, NET_OUT_SET_GD_STATUS pOutParam, int nWaitTime);

    /***********************************************************************************
     *						                  播放盒与广告机的节目操作接口					      *
     **********************************************************************************/
    // 获取播放盒上全部节目信息
    public boolean CLIENT_GetAllProgramOnPlayBox(LLong lLoginID, NET_IN_GET_ALL_PLAYBOX_PROGRAM pInParam, NET_OUT_GET_ALL_PLAYBOX_PROGRAM pOutParam, int nWaitTime);

    // 通过programme ID 获取播放盒上对应的节目信息
    public boolean CLIENT_GetOneProgramByIdOnPlayBox(LLong lLoginID, NET_IN_GET_PLAYBOX_PROGRAM_BYID pInParam, NET_OUT_GET_PLAYBOX_PROGRAM_BYID pOutParam, int nWaitTime);

    // 在播放盒上添加一个节目
    public boolean CLIENT_AddOneProgramToPlayBox(LLong lLoginID, NET_IN_ADD_ONE_PLAYBOX_PRAGROM pInParam, NET_OUT_ADD_ONE_PLAYBOX_PRAGROM pOutParam, int nWaitTime);

    // 在播放盒上修改指定ID的节目信息
    public boolean CLIENT_ModifyProgramOnPlayBoxById(LLong lLoginID, NET_IN_MODIFY_PLAYBOX_PROGRAM_BYID pInParam, NET_OUT_MODIFY_PLAYBOX_PROGRAM_BYID pOutParam, int nWaitTime);



    // 获取配置信息(szOutBuffer内存由用户申请释放, 具体见枚举类型 NET_EM_CFG_OPERATE_TYPE 说明)
    public boolean CLIENT_GetConfig(LLong lLoginID, int emCfgOpType, int nChannelID, Pointer szOutBuffer, int dwOutBufferSize, int waittime, Pointer reserve);

    // 设置配置信息(szInBuffer内存由用户申请释放, 具体见枚举类型 NET_EM_CFG_OPERATE_TYPE 说明)
    public boolean CLIENT_SetConfig(LLong lLoginID, int emCfgOpType, int nChannelID, Pointer szInBuffer, int dwInBufferSize, int waittime, IntByReference restart, Pointer reserve);

    // 显示私有数据，例如规则框，规则框报警，移动侦测等       lPlayHandle:播放句柄      bTrue=1 打开, bTrue= 0 关闭
    public boolean CLIENT_RenderPrivateData(LLong lPlayHandle, int bTrue);

    // 按设备信息添加显示源,pInParam与pOutParam内存由用户申请释放
    public boolean CLIENT_MatrixAddCamerasByDevice(LLong lLoginID, NET_IN_ADD_LOGIC_BYDEVICE_CAMERA pInParam, NET_OUT_ADD_LOGIC_BYDEVICE_CAMERA pOutParam, int nWaitTime);

    // 订阅监测点位报警信息,pInParam与pOutParam内存由用户申请释放
    public LLong CLIENT_SCADAAlarmAttachInfo(LLong lLoginID, NET_IN_SCADA_ALARM_ATTACH_INFO pInParam, NET_OUT_SCADA_ALARM_ATTACH_INFO pOutParam, int nWaitTime);

    // 取消订阅监测点位报警信息
    public boolean CLIENT_SCADAAlarmDetachInfo(LLong lAttachHandle);

    /***********************************************************************************
     *						           IVSS设备添加相关接口				             *
     **********************************************************************************/
    // 注册设备状态回调
    public LLong CLIENT_AttachDeviceState(LLong lLoginID, NET_IN_ATTACH_DEVICE_STATE pInParam, NET_OUT_ATTACH_DEVICE_STATE pOutParam, int nWaitTime);

    // 注销设备状态回调
    public boolean CLIENT_DetachDeviceState(LLong lAttachHandle);

    // 添加设备
    public boolean CLIENT_AsyncAddDevice(LLong lLoginID, NET_IN_ASYNC_ADD_DEVICE pInParam, NET_OUT_ASYNC_ADD_DEVICE pOutParam, int nWaitTime);

    // 注册添加设备回调
    public LLong CLIENT_AttachAddDevice(LLong lLoginID, NET_IN_ATTACH_ADD_DEVICE pInParam, NET_OUT_ATTACH_ADD_DEVICE pOutParam, int nWaitTime);

    // 注销添加设备回调
    public boolean CLIENT_DetachAddDevice(LLong lAttachHandle);

    // 获取添加中的设备状态
    public boolean CLIENT_GetAddDeviceInfo(LLong lLoginID, NET_IN_GET_ADD_DEVICE_LIST_INFO pInParam, NET_OUT_GET_ADD_DEVICE_LIST_INFO pOutParam, int nWaitTime);

    // 获取已添加的设备状态
    public boolean CLIENT_GetDeviceInfo(LLong lLoginID, NET_IN_GET_DEVICE_LIST_INFO pInParam, NET_OUT_GET_DEVICE_LIST_INFO pOutParam, int nWaitTime);

    // 设置连接通道
    public boolean CLIENT_SetConnectChannel(LLong lLoginID, NET_IN_SET_CONNECT_CHANNEL pInParam, NET_OUT_SET_CONNECT_CHANNEL pOutParam, int nWaitTime);

    // 获取设备通道信息
    public boolean CLIENT_GetChannelInfo(LLong lLoginID, NET_IN_GET_CHANNEL_INFO pInParam, NET_OUT_GET_CHANNEL_INFO pOutParam, int nWaitTime);

    // 删除设备
    public boolean CLIENT_RemoveDevice(LLong lLoginID, NET_IN_REMOVE_DEVICE pInParam, NET_OUT_REMOVE_DEVICE pOutParam, int nWaitTime);

    // 中止添加设备任务
    public boolean CLIENT_CancelAddDeviceTask(LLong lLoginID, NET_IN_CANCEL_ADD_TASK pInParam, NET_OUT_CANCEL_ADD_TASK pOutParam, int nWaitTime);

    // 确认添加设备任务
    public boolean CLIENT_ConfirmAddDeviceTask(LLong lLoginID, NET_IN_CONFIRM_ADD_TASK pInParam, NET_OUT_CONFIRM_ADD_TASK pOutParam, int nWaitTime);

    // 球机定制，地磁车位同步上报车位信息,如有车停入、或车从车位开出
    public boolean CLIENT_SyncParkingInfo(LLong lLoginID, NET_IN_SYNC_PARKING_INFO pInParam, NET_OUT_SYNC_PARKING_INFO pOutParam, int nWaitTime);

    // 初始化账户
    public boolean CLIENT_InitDevAccount(NET_IN_INIT_DEVICE_ACCOUNT pInitAccountIn, NET_OUT_INIT_DEVICE_ACCOUNT pInitAccountOut, int dwWaitTime, String szLocalIp);

    // 根据设备IP初始化账户
    public boolean CLIENT_InitDevAccountByIP(NET_IN_INIT_DEVICE_ACCOUNT pInitAccountIn, NET_OUT_INIT_DEVICE_ACCOUNT pInitAccountOut, int dwWaitTime, String szLocalIp, String szDeviceIP);

    public boolean CLIENT_ModifyDevice(DEVICE_NET_INFO_EX pDevNetInfo, int nWaitTime, IntByReference iError, String szLocalIp);

    /**
     * 门禁控制器操作接口
     * @param lLoginID 登录句柄
     * @param emtype 门禁控制器操作类型, 对应 枚举{@link NET_EM_ACCESS_CTL_MANAGER}
     * @param pstInParam 入参, 根据 emtype 来填
     * @param pstOutParam 出参, 根据 emtype 来填
     * @param nWaitTime 超时等待时间
     * @return true：成功    false：失败
     */
    public boolean CLIENT_OperateAccessControlManager(LLong lLoginID, int emtype, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);

    /**
     * 设置安全密钥(播放加密码流使用)
     * @param lPlayHandle 拉流句柄
     * @param szKey 密钥
     * @param nKeyLen 密钥的长度
     * @return true：成功    false：失败
     */
    public boolean CLIENT_SetSecurityKey(LLong lPlayHandle, String szKey, int nKeyLen);

    /***********************************************************************************
     *						           	  考勤机相关接口						         *
     **********************************************************************************/
    //考勤新增加用户
    public boolean CLIENT_Attendance_AddUser(LLong lLoginID, NET_IN_ATTENDANCE_ADDUSER pstuInAddUser, NET_OUT_ATTENDANCE_ADDUSER pstuOutAddUser, int nWaitTime);

    //考勤删除用户
    public boolean CLIENT_Attendance_DelUser(LLong lLoginID, NET_IN_ATTENDANCE_DELUSER pstuInDelUser, NET_OUT_ATTENDANCE_DELUSER pstuOutDelUser, int nWaitTime);

    //考勤修改用户信息
    public boolean CLIENT_Attendance_ModifyUser(LLong lLoginID, NET_IN_ATTENDANCE_ModifyUSER pstuInModifyUser, NET_OUT_ATTENDANCE_ModifyUSER pstuOutModifyUser, int nWaitTime);

    //考勤获取用户信息
    public boolean CLIENT_Attendance_GetUser(LLong lLoginID, NET_IN_ATTENDANCE_GetUSER pstuInGetUser, NET_OUT_ATTENDANCE_GetUSER pstuOutGetUser, int nWaitTime);

    //考勤机  通过用户ID插入指纹数据
    public boolean CLIENT_Attendance_InsertFingerByUserID(LLong lLoginID, NET_IN_FINGERPRINT_INSERT_BY_USERID pstuInInsert, NET_OUT_FINGERPRINT_INSERT_BY_USERID pstuOutInsert, int nWaitTime);

    //考勤机 删除单个用户下所有指纹数据
    public boolean CLIENT_Attendance_RemoveFingerByUserID(LLong lLoginID, NET_CTRL_IN_FINGERPRINT_REMOVE_BY_USERID pstuInRemove, NET_CTRL_OUT_FINGERPRINT_REMOVE_BY_USERID pstuOutRemove, int nWaitTime);

    //考勤机 通过指纹ID获取指纹数据
    public boolean CLIENT_Attendance_GetFingerRecord(LLong lLoginID, NET_CTRL_IN_FINGERPRINT_GET pstuInGet, NET_CTRL_OUT_FINGERPRINT_GET pstuOutGet, int nWaitTime);

    //考勤机 通过指纹ID删除指纹数据
    public boolean CLIENT_Attendance_RemoveFingerRecord(LLong lLoginID, NET_CTRL_IN_FINGERPRINT_REMOVE pstuInRemove, NET_CTRL_OUT_FINGERPRINT_REMOVE pstuOutRemove, int nWaitTime);

    //考勤机 查找用户
    public boolean CLIENT_Attendance_FindUser(LLong lLoginID, NET_IN_ATTENDANCE_FINDUSER pstuInFindUser, NET_OUT_ATTENDANCE_FINDUSER pstuOutFindUser, int nWaitTime);

    //考勤机 通过用户ID查找该用户下的所有指纹数据
    public boolean CLIENT_Attendance_GetFingerByUserID(LLong lLoginID, NET_IN_FINGERPRINT_GETBYUSER pstuIn, NET_OUT_FINGERPRINT_GETBYUSER pstuOut, int nWaitTime);

    //获取考勤机在线状态
    public boolean CLIENT_Attendance_GetDevState(LLong lLoginID, NET_IN_ATTENDANCE_GETDEVSTATE pstuInParam, NET_OUT_ATTENDANCE_GETDEVSTATE pstuOutParam, int nWaitTime);

    /*********************************************************************************************************
     * 									视频诊断功能接口														 *												 												     *
     * 视频诊断参数表配置 CFG_CMD_VIDEODIAGNOSIS_PROFILE														 *
     * 视频诊断任务表配置 CFG_CMD_VIDEODIAGNOSIS_TASK_ONE						 								 *
     * 视频诊断计划表配置 CFG_CMD_VIDEODIAGNOSIS_PROJECT														 *
     * 删除任务接口  CLIENT_DeleteDevConfig																	 *
     * 获取成员配置接口 CLIENT_GetMemberNames	  对应命令  CFG_CMD_VIDEODIAGNOSIS_TASK					         *
     * 获取诊断状态  CLIENT_QueryNewSystemInfo CFG_CMD_VIDEODIAGNOSIS_GETSTATE							 	 *
     *********************************************************************************************************/

    // 实时获取视频诊断结果,pstInParam与pstOutParam内存由用户申请释放
    public boolean CLIENT_StartVideoDiagnosis(LLong lLoginID, NET_IN_VIDEODIAGNOSIS pstInParam, NET_OUT_VIDEODIAGNOSIS pstOutParam);

    // 停止视频诊断结果上报
    public boolean CLIENT_StopVideoDiagnosis(LLong hDiagnosisHandle);

    // 开始视频诊断结果查询,pstInParam与pstOutParam内存由用户申请释放
    public boolean CLIENT_StartFindDiagnosisResult(LLong lLoginID, NET_IN_FIND_DIAGNOSIS pstInParam, NET_OUT_FIND_DIAGNOSIS pstOutParam);

    // 获取视频诊断结果信息,pstInParam与pstOutParam内存由用户申请释放
    public boolean CLIENT_DoFindDiagnosisResult(LLong hFindHandle, NET_IN_DIAGNOSIS_INFO pstInParam, NET_OUT_DIAGNOSIS_INFO pstOutParam);

    // 结束视频诊断结果查询
    public boolean CLIENT_StopFindDiagnosis(LLong hFindHandle);

    // 获取视频诊断进行状态
    public boolean CLIENT_GetVideoDiagnosisState(LLong lLoginID, NET_IN_GET_VIDEODIAGNOSIS_STATE pstInParam, NET_OUT_GET_VIDEODIAGNOSIS_STATE pstOutParam, int nWaitTime);

    /********************************************************************************************
     * 									热成像												    *
     ********************************************************************************************/

    // 订阅温度分布数据（热图）,pInParam与pOutParam内存由用户申请释放
    public LLong CLIENT_RadiometryAttach(LLong lLoginID, NET_IN_RADIOMETRY_ATTACH pInParam, NET_OUT_RADIOMETRY_ATTACH pOutParam, int nWaitTime);

    // 取消订阅温度分布数据,lAttachHandle是 CLIENT_RadiometryAttach 的返回值
    public boolean CLIENT_RadiometryDetach(LLong lAttachHandle);

    // 通知开始获取热图数据,pInParam与pOutParam内存由用户申请释放
    public boolean CLIENT_RadiometryFetch(LLong lLoginID, NET_IN_RADIOMETRY_FETCH pInParam, NET_OUT_RADIOMETRY_FETCH pOutParam, int nWaitTime);

    // 热图数据解压与转换接口
    /// \brief
    /// \param  pRadiometryData [IN] 热图数据， 由 fRadiometryAttachCB 获得
    /// \param  pGrayImg [IN, OUT] 解压后的数据，是一张灰度图，
    ///			传空指针表示不需要此数据
    ///         用户需保证传入的缓冲区足够大（不小于 图像像素数*sizeof(unsigned short)）
    ///         每个像素对应一个 unsigned short 型数据，表示图像某个像素的热成像灰度（范围 0 ~ 16383），
    ///         低地址对应画面左上角，高地址对应画面右下角
    /// \param  pTempForPixels [IN, OUT] 每个像素的温度数据
    ///			传空指针表示不需要此数据
    ///         用户需保证传入的缓冲区足够大（不小于 图像像素数*sizeof(float)）
    ///         每个像素对应一个 float 型数据，表示该像素位置的摄氏温度
    ///         低地址对应画面左上角，高地址对应画面右下角
    /// \return TRUE 成功，FALSE 失败
    public boolean CLIENT_RadiometryDataParse(NET_RADIOMETRY_DATA pRadiometryData, short[] pGrayImg, float[] pTempForPixels);

    // 开始查询信息（获取查询句柄）(pInBuf, pOutBuf内存由用户申请释放,根据emType对应的类型找到相应的结构体，进而确定申请内存大小)
    public boolean  CLIENT_StartFind(LLong lLoginID, int emType, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);
    // 查询信息(pInBuf, pOutBuf内存由用户申请释放,根据emType对应的类型找到相应的结构体，进而确定申请内存大小
    public boolean  CLIENT_DoFind(LLong lLoginID, int emType, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);
    // 停止查询信息（销毁查询句柄）(pInBuf, pOutBuf内存由用户申请释放,根据emType对应的类型找到相应的结构体，进而确定申请内存大小)
    public boolean  CLIENT_StopFind(LLong lLoginID, int emType, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);


    // 智能锁添加更新用户信息接口
    public boolean CLIENT_UpdateSmartLockUser(LLong lLoginID, NET_IN_SMARTLOCK_UPDATE_USER_INFO pstInParam, NET_OUT_SMARTLOCK_UPDATE_USER_INFO pstOutParam, int nWaitTime);

    // 获取当前智能锁的注册用户信息
    public boolean CLIENT_GetSmartLockRegisterInfo(LLong lLoginID, NET_IN_GET_SMART_LOCK_REGISTER_INFO pstInParam, NET_OUT_GET_SMART_LOCK_REGISTER_INFO pstOutParam, int nWaitTime);

    // 智能锁修改用户信息
    public boolean CLIENT_SetSmartLockUsername(LLong lLoginID, NET_IN_SET_SMART_LOCK_USERNAME pstInParam, NET_OUT_SET_SMART_LOCK_USERNAME pstOutParam, int nWaitTime);

    // 智能锁删除用户接口
    public boolean CLIENT_RemoveSmartLockUser(LLong lLoginID, NET_IN_SMARTLOCK_REMOVE_USER_INFO pstInParam, NET_OUT_SMARTLOCK_REMOVE_USER_INFO pstOutParam, int nWaitTime);

    // 字符串加密接口 (pInParam, pOutParam内存由用户申请释放) 定制接口
    public boolean CLIENT_EncryptString(NET_IN_ENCRYPT_STRING pInParam, NET_OUT_ENCRYPT_STRING pOutParam, int nWaitTime);

    /*************************************************************************************************************
     * 门禁用户、卡、人脸、指纹操作新接口
     * 1、添加一个用户
     * 2、根据用户ID可以来添加多张卡、多张人脸、多个指纹
     *************************************************************************************************************/
    /**
     *  门禁人员信息管理接口
     * @param emtype 对应 {@link NET_EM_ACCESS_CTL_USER_SERVICE}
     */
    public boolean CLIENT_OperateAccessUserService(LLong lLoginID, int emtype, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);

    // 开始查询人员信息
    public LLong CLIENT_StartFindUserInfo(LLong lLoginID, NET_IN_USERINFO_START_FIND pstIn, NET_OUT_USERINFO_START_FIND pstOut, int nWaitTime);

    // 获取人员信息 ,lFindHandle 为 CLIENT_StartFindUserInfo 接口返回值
    public boolean CLIENT_DoFindUserInfo(LLong lFindHandle, NET_IN_USERINFO_DO_FIND pstIn, NET_OUT_USERINFO_DO_FIND pstOut, int nWaitTime);

    // 停止查询人员信息 ,lFindHandle 为 CLIENT_StartFindUserInfo 接口返回值
    public boolean CLIENT_StopFindUserInfo(LLong lFindHandle);

    /**
     * 门禁卡片信息管理接口
     * @param emtype 对应 {@link NET_EM_ACCESS_CTL_CARD_SERVICE}
     */
    public boolean CLIENT_OperateAccessCardService(LLong lLoginID, int emtype, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);

    // 开始查询卡片信息
    public LLong CLIENT_StartFindCardInfo(LLong lLoginID, NET_IN_CARDINFO_START_FIND pstIn, NET_OUT_CARDINFO_START_FIND pstOut, int nWaitTime);

    // 获取卡片信息,lFindHandle 为CLIENT_StartFindCardInfo接口返回值
    public boolean CLIENT_DoFindCardInfo(LLong lFindHandle, NET_IN_CARDINFO_DO_FIND pstIn, NET_OUT_CARDINFO_DO_FIND pstOut, int nWaitTime);

    // 停止查询卡片信息,lFindHandle 为CLIENT_StartFindCardInfo接口返回值
    public boolean CLIENT_StopFindCardInfo(LLong lFindHandle);

    /**
     * 门禁人脸信息管理接口
     * @param emtype 对应 {@link NET_EM_ACCESS_CTL_FACE_SERVICE}
     */
    public boolean CLIENT_OperateAccessFaceService(LLong lLoginID, int emtype, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);

    /**
     * 指纹信息管理接口
     * @param emtype 对应 {@link NET_EM_ACCESS_CTL_FINGERPRINT_SERVICE}
     */
    public boolean CLIENT_OperateAccessFingerprintService(LLong lLoginID, int emtype, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);

    // 开始升级
    public LLong CLIENT_StartUpgradeEx(LLong lLoginID, int emtype, String pchFileName, Callback cbUpgrade, Pointer dwUser);

    // 发送数据
    public boolean CLIENT_SendUpgrade(LLong lUpgradeID);

    // 结束升级设备程序
    public boolean CLIENT_StopUpgrade(LLong lUpgradeID);

    // 查询产品定义
    public boolean CLIENT_QueryProductionDefinition(LLong lLoginID, NET_PRODUCTION_DEFNITION pstuProdDef, int nWaitTime);

    // 录播主机窗口最大个数
    public static final int NET_MAX_WINDOWS_NUMBER = 64;
    // 录播主机模式最大个数
    public static final int NET_MAX_MODE_NUMBER = 64;

    /**
     * 录播主机相关 添加新的课程记录
     * NET_IN_ADD_COURSE *pstInParam, NET_OUT_ADD_COURSE *pstOutParam
     */
    public boolean CLIENT_AddCourse(LLong lLoginID, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);

    /**
     *  录播主机相关 修改课程
     *  NET_IN_MODIFY_COURSE *pstInParam, NET_OUT_MODIFY_COURSE *pstOutParam
     */
    public boolean CLIENT_ModifyCourse(LLong lLoginID, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);

    /**
     *  录播主机相关 删除课程
     *  NET_IN_DELETE_COURSE *pstInParam, NET_OUT_DELETE_COURSE *pstOutParam
     */
    public boolean CLIENT_DeleteCourse(LLong lLoginID, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);

    /**
     * 开始查询课程
     * NET_IN_QUERY_COURSE_OPEN *pstInParam, NET_OUT_QUERY_COURSE_OPEN *pstOutParam
     */
    public boolean CLIENT_QueryCourseOpen(LLong lLoginID, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);

    /**
     * 查询课程
     * NET_IN_QUERY_COURSE *pstInParam, NET_OUT_QUERY_COURSE *pstOutParam
     */
    public boolean CLIENT_QueryCourse(LLong lLoginID, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);

    /**
     * 结束查询课程
     * NET_IN_QUERY_COURSE_CLOSE *pstInParam, NET_OUT_QUERY_COURSE_CLOSE *pstOutParam
     */
    public boolean CLIENT_QueryCourseClose(LLong lLoginID, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);

    /**
     * 获取真实预览通道号，pInBuf与pOutBuf内存由用户申请释放
     * NET_IN_GET_REAL_PREVIEW_CHANNEL* pInBuf, NET_OUT_GET_REAL_PREVIEW_CHANNEL* pOutBuf
     */
    public boolean CLIENT_GetRealPreviewChannel(LLong lLoginID, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);

    /**
     * 录播主机组合通道模式操作 emOperateType NET_COURSECOMPOSITE_MODE_OPERATE_TYPE
     *
     * NET_COURSECOMPOSITE_MODE_OPERATE_TYPE {
     *
     *      NET_COURSECOMPOSITE_MODE_ADD,      // 添加模式,对应结构体
     *                                         // pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_ADD,
     *                                         // pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_ADD
     * 	    NET_COURSECOMPOSITE_MODE_DELETE,   // 删除模式,对应结构体
     * 	                                       // pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_DELETE,
     * 	                                       // pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_DELETE
     * 	    NET_COURSECOMPOSITE_MODE_MODIFY,   // 修改模式,对应结构体
     * 	                                       // pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_MODIFY,
     * 	                                       // pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_MODIFY
     * 	    NET_COURSECOMPOSITE_MODE_GET,      // 获取模式,对应结构体
     * 	                                       // pInParam = NET_IN_COURSECOMPOSITE_CHANNEL_MODE_GET,
     * 	                                       // pOutParam = NET_OUT_COURSECOMPOSITE_CHANNEL_MODE_GET
     * }
     */
    public boolean CLIENT_OperateCourseCompositeChannelMode(LLong lLoginID, int emOperateType, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    /**
     * 获取录播主机默认真实通道号,pInBuf与pOutBuf内存由用户申请释放
     * NET_IN_GET_DEFAULT_REAL_CHANNEL* pInBuf, NET_OUT_GET_DEFAULT_REAL_CHANNEL* pOutBuf
     */
    public boolean CLIENT_GetDefaultRealChannel(LLong lLoginID, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);

    /**
     * 获取录播主机逻辑通道号,pInBuf与pOutBuf内存由用户申请释放
     * NET_IN_GET_COURSE_LOGIC_CHANNEL* pInBuf,NET_OUT_GET_COURSE_LOGIC_CHANNEL* pOutBuf
     */
    public boolean CLIENT_GetLogicChannel(LLong lLoginID, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);

    /**
     * 设置逻辑通道号和真实通道号的绑定关系,pInBuf与pOutBuf内存由用户申请释放
     * NET_IN_SET_BLIND_REAL_CHANNEL* pInBuf,NET_OUT_SET_BLIND_REAL_CHANNEL* pOutBuf
     */
    public boolean CLIENT_SetBlindRealChannel(LLong lLoginID, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);

    /**
     * 设置课程录像模式,pInBuf与pOutBuf内存由用户申请释放
     * NET_IN_SET_COURSE_RECORD_MODE* pInBuf, NET_OUT_SET_COURSE_RECORD_MODE* pOutBuf
     */
    public boolean CLIENT_SetCourseRecordMode(LLong lLoginID, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);

    /**
     * 获取课程录像模式,pInBuf与pOutBuf内存由用户申请释放
     * NET_IN_GET_COURSE_RECORD_MODE* pInBuf, NET_OUT_GET_COURSE_RECORD_MODE* pOutBuf
     */
    public boolean CLIENT_GetCourseRecordMode(LLong lLoginID, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);

    /**
     * 获取录播主机通道输入媒体介质,pInBuf与pOutBuf内存由用户申请释放
     * NET_IN_GET_INPUT_CHANNEL_MEDIA* pInBuf,NET_OUT_GET_INPUT_CHANNEL_MEDIA* pOutBuf
     */
    public boolean CLIENT_GetInputChannelMedia(LLong lLoginID, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);

    /**
     * 开启/关闭指定通道录像
     * NET_IN_SET_COURSE_RECORD_STATE *pInBuf, NET_OUT_SET_COURSE_RECORD_STATE *pOutBuf
     */
    public boolean CLIENT_SetCourseRecordState(LLong lLoginID, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);

    /**
     * 开始查询课程视频信息,pInBuf与pOutBuf内存由用户申请释放
     * NET_IN_QUERY_COURSEMEDIA_FILEOPEN *pInBuf, NET_OUT_QUERY_COURSEMEDIA_FILEOPEN *pOutBuf
     */
    public boolean CLIENT_OpenQueryCourseMediaFile(LLong lLoginID, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);

    /**
     * 查询课程视频信息,pInBuf与pOutBuf内存由用户申请释放
     * NET_IN_QUERY_COURSEMEDIA_FILE *pInBuf, NET_OUT_QUERY_COURSEMEDIA_FILE *pOutBuf
     */
    public boolean CLIENT_DoQueryCourseMediaFile(LLong lLoginID, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);

    /**
     * 关闭课程视频查询,pInBuf与pOutBuf内存由用户申请释放
     * NET_IN_QUERY_COURSEMEDIA_FILECLOSE *pInBuf, NET_OUT_QUERY_COURSEMEDIA_FILECLOSE *pOutBuf
     */
    public boolean CLIENT_CloseQueryCourseMediaFile(LLong lLoginID, Pointer pInBuf, Pointer pOutBuf, int nWaitTime);

    public static final int MAX_COURSE_LOGIC_CHANNEL = 64;              // 录播主机最大逻辑通道数

    /**
     * 录播主机录像信息操作接口 EM_COURSERECORD_OPERATE_TYPE emOperateType
     * {
     *         EM_COURSERECORDE_TYPE_GET_INFO,    //获取教室录像信息,对应结构体
     *              pInParam = NET_IN_COURSERECORD_GETINFO,pOutParam = NET_OUT_COURSERECORD_GETINFO
     *         EM_COURSERECORDE_TYPE_SET_INFO,    //设置教室录像信息,对应结构体
     *              pInParam = NET_IN_COURSERECORD_SETINFO,pOutParam = NET_OUT_COURSERECORD_SETINFO
     *         EM_COURSERECORDE_TYPE_UPDATE_INFO, //将录像信息更新到time时的信息,对应结构体
     *              pInParam = NET_IN_COURSERECORD_UPDATE_INFO, pOutParam = NET_OUT_COURSERECORD_UPDATE_INFO
     *         EM_COURSERECORDE_TYPE_GET_TIME,     //获取当前课程教室已录制时间,对应结构体
     *              pInParam = NET_IN_COURSERECORD_GET_TIME, pOutParam = NET_OUT_COURSERECORD_GET_TIME
     *     }
     */
    public boolean CLIENT_OperateCourseRecordManager(LLong lLoginID, int emOperateType, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    /**
     *  录播主机组合通道操作 EM_COURSECOMPOSITE_OPERATE_TYPE
     *  {
     *         EM_COURSECOMPOSITE_TYPE_LOCK_CONTROL,                   //控制组合通道与逻辑通道，对应结构体
     *              pInParam = NET_IN_COURSECOMPOSITE_LOCK_CONTROL,pOutParam = NET_OUT_COURSECOMPOSITE_LOCK_CONTROL
     *         EM_COURSECOMPOSITE_TYPE_GET_LOCKINFO,                   //获取组合通道与逻辑通道的锁定信息，对应结构体
     *              pInParam = NET_IN_COURSECOMPOSITE_GET_LOCKINFO，pOutParam = NET_OUT_COURSECOMPOSITE_GET_LOCKINFO
     *         EM_COURSECOMPOSITE_TYPE_GET_INFO,                       //获取组合通道信息,对应结构体
     *              pInParam = NET_IN_COURSECOMPOSITE_GET_INFO,pOutParam = NET_OUT_COURSECOMPOSITE_GET_INFO
     *         EM_COURSECOMPOSITE_TYPE_SET_INFO,                       //设置组合通道信息,对应结构体
     *              pInParam = NET_IN_COURSECOMPOSITE_SET_INFO,pOutParam = NET_OUT_COURSECOMPOSITE_SET_INFO
     *         EM_COURSECOMPOSITE_TYPE_UPDATE_INFO,                    //将组合通道信息更新到time时的信息，对应结构体
     *              pInParam = NET_IN_COURSECOMPOSITE_UPDATE_INFO, pOutParam = NET_OUT_COURSECOMPOSITE_UPDATE_INFO
     *     }
     */
    public boolean CLIENT_OperateCourseCompositeChannel(LLong lLoginID, int emOperateType, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    /**
     * 获取录像状态
     * NET_IN_GET_RECORD_STATE *pInParam, NET_OUT_GET_RECORD_STATE *pOutParam
     */
    public boolean CLIENT_GetRecordState(LLong lLoginID, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    /**
     * 电视墙操作
     * NET_MONITORWALL_OPERATE_TYPE emType, void* pInParam, void* pOutParam
     */
    public boolean CLIENT_OperateMonitorWall(LLong lLoginID, int emType, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    /**
     * 分页获取信息标注信息列表
     * NET_IN_SCENICSPOT_GETPOINTINFOS_INFO *pInstuParam, NET_OUT_SCENICSPOT_GETPOINTINFOS_INFO *pstuOutParam
     */
    public boolean CLIENT_ScenicSpotGetPointInfos(LLong lLoginID, Pointer pInstuParam, Pointer pstuOutParam, int nWaitTime);

    /**
     * 设置景物点，原编号的景物点将会被覆盖
     * NET_IN_SCENICSPOT_SETPOINTINFO_INFO *pInstuParam, NET_OUT_SCENICSPOT_SETPOINTINFO_INFO *pstuOutParam
     */
    public boolean CLIENT_ScenicSpotSetPointInfo(LLong lLoginID, Pointer pInstuParam, Pointer pstuOutParam, int nWaitTime);

    /**
     * 获取景物点支持的能力
     * NET_IN_SCENICSPOT_GETCAPS_INFO *pInstuParam, NET_OUT_SCENICSPOT_GETCAPS_INFO *pstuOutParam
     */
    public boolean CLIENT_ScenicSpotGetCaps(LLong lLoginID, Pointer pInstuParam, Pointer pstuOutParam, int nWaitTime);

    /**
     * 以景物标注点为中心，进行三维定位(倍率不变)
     * NET_IN_SCENICSPOT_TURNTOPOINT_INFO *pInParam, NET_OUT_SCENICSPOT_TURNTOPOINT_INFO *pOutParam
     */
    public boolean CLIENT_ScenicSpotTurnToPoint(LLong lLoginID, Pointer pInstuParam, Pointer pstuOutParam, int nWaitTime);

    ///////////////////////////////////////// 舟曲项目新增接口 ///////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * 设置停车车位状态
     * NET_IN_SET_PARKINGSPACE_STATE_INFO *pInParam, NET_OUT_SET_PARKINGSPACE_STATE_INFO *pOutParam
     */
    public boolean CLIENT_SetParkingSpaceState(LLong lLoginID, Pointer pstInParm, Pointer pstOutParam, int nWaitTime);

    /**
     * 修改停车记录信息
     * NET_IN_MODIFY_PARKINGRECORD_INFO *pInParam, NET_OUT_MODIFY_PARKINGRECORD_INFO *pOutParam
     */
    public boolean CLIENT_ModifyParkingRecord(LLong lLoginID, Pointer pstInParm, Pointer pstOutParam, int nWaitTime);

    /**
     * 按照事件类型抓图（配合CLIENT_RealLoadPic()、CLIENT_RealLoadPicEx()接口使用, 按照手动抓拍模式(Manual)订阅,图片通过回调给用户）(pInParam, pOutParam内存由用户申请释放)
     * NET_IN_SNAP_BY_EVENT *pInParam, NET_OUT_SNAP_BY_EVENT *pOutParam
     */
    public boolean CLIENT_SnapPictureByEvent(LLong lLoginID, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    public static class NET_IN_SET_MARK_FILE_BY_TIME extends SdkStructure
    {
        public int           					dwSize;
        public int           					nChannel;			//需要锁定的通道号,从0开始,元素为-1时,表示全通道。
        public NET_TIME_EX  					stuStartTime;		//开始时间
        public NET_TIME_EX  					stuEndTime;			//结束时间
        public int            	  				bFlag;				// 标记动作	true : 标记, false : 清除
        public NET_IN_SET_MARK_FILE_BY_TIME() {
            this.dwSize = this.size();
        }
    }

    public static class NET_OUT_SET_MARK_FILE_BY_TIME extends SdkStructure
    {
        public int           					dwSize;

        public NET_OUT_SET_MARK_FILE_BY_TIME() {
            this.dwSize = this.size();
        }
    }

    // 按时间标记录像
    public boolean CLIENT_SetMarkFileByTime(LLong lUpgradeID, NET_IN_SET_MARK_FILE_BY_TIME pInParam, NET_OUT_SET_MARK_FILE_BY_TIME pOutParam, int nWaitTime);

    public static class NET_IN_SET_MARK_FILE extends SdkStructure
    {
        public int                          dwSize;
        public int	                    	emLockMode;								// 录像加锁方式，详见EM_MARKFILE_MODE
        public int							emFileNameMadeType;						// 文件名产生的方式，详见EM_MARKFILE_NAMEMADE_TYPE
        public int							nChannelID;								// 通道号
        public byte[]						szFilename = new byte[MAX_PATH];	    // 文件名
        public int							nFramenum;								// 文件总帧数
        public int							nSize;									// 文件长度
        public NET_TIME						stuStartTime;							// 开始时间
        public NET_TIME						stuEndTime;								// 结束时间
        public int							nDriveNo;								// 磁盘号(区分网络录像和本地录像的类型,0－127表示本地录像,其中64表示光盘1,128表示网络录像)
        public int							nStartCluster;							// 起始簇号
        public byte							byRecordFileType;						// 录象文件类型  0：普通录象；1：报警录象；2：移动检测；3：卡号录象；4：图片, 5: 智能录像
        public byte							byImportantRecID;						// 0:普通录像 1:重要录像
        public byte							byHint;									// 文件定位索引(nRecordFileType==4<图片>时,bImportantRecID<<8 +bHint ,组成图片定位索引 )
        public byte							byRecType;								// 0-主码流录像  1-辅码流1录像 2-辅码流2录像 3-辅码流3录像

        public NET_IN_SET_MARK_FILE() {
            this.dwSize = this.size();
        }
    }

    // 录像加锁方式
    public static class EM_MARKFILE_MODE extends SdkStructure
    {
        public static final int EM_MARK_FILE_BY_TIME_MODE = 0;		// 通过时间方式对录像加锁
        public static final int EM_MARK_FILE_BY_NAME_MODE = 1;		// 通过文件名方式对录像加锁
    }

    // 文件名产生的方式
    public static class EM_MARKFILE_NAMEMADE_TYPE extends SdkStructure
    {
        public static final int EM_MARKFILE_NAMEMADE_DEFAULT = 0;	// 默认方式：需要用户传递录像文件名参数szFilename
        public static final int EM_MARKFILE_NAMEMADE_JOINT = 1;		// 拼接文件名方式：用户传递磁盘号(nDriveNo)、起始簇号(nStartCluster)，不需要传递录像文件名
    }

    public static class NET_OUT_SET_MARK_FILE extends SdkStructure
    {
        public int           					dwSize;

        public NET_OUT_SET_MARK_FILE() {
            this.dwSize = this.size();
        }
    }

    // 按文件标记录像
    public boolean CLIENT_SetMarkFile(LLong lLoginID, NET_IN_SET_MARK_FILE pInParam, NET_OUT_SET_MARK_FILE pOutParam, int nWaitTime);


    public static class NET_IN_DEV_GPS_INFO extends SdkStructure
    {
        public int                     dwSize;                         // 该结构体大小
        public int                     nChannel;

        public NET_IN_DEV_GPS_INFO() {
            this.dwSize =this.size();
        }
    }

    public static class NET_OUT_DEV_GPS_INFO extends SdkStructure
    {
        public int                     	dwSize;                          // 该结构体大小
        public NET_TIME				   	stuLocalTime;                    // 当前时间
        public double                  	dbLongitude;                     // 经度(单位是百万分之度,范围0-360度)
        public double                  	dbLatitude;                      // 纬度(单位是百万分之度,范围0-180度)
        public double                  	dbAltitude;                      // 高度(单位:米)
        public double                  	dbSpeed;                         // 速度(单位:km/H)
        public double                  	dbBearing;                       // 方向角(单位:度)
        public int   					emAntennasStatus;				 // 天线状态(0:坏 1:好)
        public int   					emPositioningResult;             // 定位状态(0:不定位 1:定位)
        public int						dwSatelliteCount;				 // 卫星个数
        public int     					emworkStatus;                    // 工作状态
        public int                     	nAlarmCount;					 // 报警个数
        public int[] 					nAlarmState = new int[128];		 // 发生的报警位置,值可能多个
        public float					fHDOP;							 // 水平精度因子

        public NET_OUT_DEV_GPS_INFO() {
            this.dwSize = this.size();
        }
    }

    // 实时抽帧配置,EVS定制
    public static class CFG_BACKUP_LIVE_INFO extends SdkStructure
    {
        public int                 bEnable;                                        // 是否启动抽帧
        public int                 nBackupRate;                                    // 抽帧备份比率，如为0表示只保留I帧，其它情况下表示保留I帧以及紧邻其后的若干P帧
        // 单位：百分比
        // 如果GOP为50，20表示保留50*20%=10帧数据(即1个I帧和9个P帧)。如果计算结果带小数，则取整
        public CFG_TIME_SECTION    stuTimeSection;                                 // 抽帧时间段
    } ;

    // 定时录像配置信息
    public static class CFG_RECORD_INFO extends SdkStructure
    {
        public int                 			nChannelID;					// 通道号(0开始)
        public TIME_SECTION_WEEK_DAY_6[] 	stuTimeSection = (TIME_SECTION_WEEK_DAY_6[])new TIME_SECTION_WEEK_DAY_6().toArray(WEEK_DAY_NUM); // 时间表
        public int							nPreRecTime;				// 预录时间，为零时表示关闭(0~300)
        public int							bRedundancyEn;				// 录像冗余开关
        public int							nStreamType;				// 0－主码流，1－辅码流1，2－辅码流2，3－辅码流3
        public int							nProtocolVer;				// 协议版本号, 只读
        public int							abHolidaySchedule;          // 为true时有假日配置信息，bHolidayEn、stuHolTimeSection才有效;
        public int                			bHolidayEn;                 // 假日录像使能TRUE:使能,FALSE:未使能
        public TIME_SECTION_WEEK_DAY_6 		stuHolTimeSection;			// 假日录像时间表
        public int                          nBackupLiveNum;             // 实时抽帧配置个数
        public CFG_BACKUP_LIVE_INFO[]       stuBackupLiveInfo=(CFG_BACKUP_LIVE_INFO[]) new CFG_BACKUP_LIVE_INFO().toArray(8);          // 实时抽帧配置,EVS定制
    }

    //获取云升级信息入参
    public static class NET_IN_UPGRADER_GETSERIAL extends SdkStructure
    {
        public int               dwSize;					// 此结构体大小

        public NET_IN_UPGRADER_GETSERIAL() {
            this.dwSize = this.size();
        }
    }


    //云升级信息
    public static class NET_UPGRADER_SERIAL_INO extends SdkStructure
    {
        public int    		emVendor;               						// 厂商,详见ENUM_VENDOR_TYPE
        public int  		emStandard;             						// 视频制式, 详见ENUM_STANDARD_TYPE
        public NET_TIME_EX  stuBuild;                      					// 发布日期
        public byte[]    	szChip = new byte[NET_COMMON_STRING_16];        // 可升级的程序名
        public byte[]    	szSerial = new byte[NET_COMMON_STRING_256];     // 内部型号
        public byte[]    	szLanguage = new byte[NET_COMMON_STRING_128];   // 语言
        public byte[]    	szSn = new byte[NET_COMMON_STRING_64];          // 序列号
        public byte[]    	szSWVersion = new byte[NET_COMMON_STRING_64];   // 软件版本
        public byte[]    	szTag = new byte[NET_COMMON_STRING_256];        // 自定义标记
        public byte[]    	szTag2 = new byte[NET_COMMON_STRING_256];       // 自定义标记2
        public byte[]    	reserved = new byte[1024];
    }

    public static final int  MAX_UPGRADER_SERIAL_INFO  = 8;

    //获取云升级信息出参
    public static class NET_OUT_UPGRADER_GETSERIAL extends SdkStructure
    {
        public int                     		dwSize;					               // 此结构体大小
        public NET_UPGRADER_SERIAL_INO[]   	stuSerialInfo = new NET_UPGRADER_SERIAL_INO[MAX_UPGRADER_SERIAL_INFO]; // 云升级信息
        public int                       	nRetNum;                                 // 返回个数

        public NET_OUT_UPGRADER_GETSERIAL() {
            this.dwSize = this.size();

            for (int i = 0; i < stuSerialInfo.length; ++i) {
                stuSerialInfo[i] = new NET_UPGRADER_SERIAL_INO();
            }
        }
    }

    //从设备获取信息，用于向大华云确认是否有升级包
    public boolean CLIENT_GetUpdateSerial(LLong lLoginID, NET_IN_UPGRADER_GETSERIAL pstuInGetSerial, NET_OUT_UPGRADER_GETSERIAL pstuOutGetSerial, int nWaitTime);

    // 云升级软件检查入参
    public static class NET_IN_CLOUD_UPGRADER_CHECK extends SdkStructure
    {
        public int          dwSize;
        public int    		emVendor;               						// 厂商,详见ENUM_VENDOR_TYPE
        public int  		emStandard;             						// 视频制式, 详见ENUM_STANDARD_TYPE
        public NET_TIME_EX  stuBuild;                      					// 编译时间，用于比较版本
        public byte[]       szUrl = new byte[NET_COMMON_STRING_1024];      	// 云URL
        public byte[]       szClass = new byte[NET_COMMON_STRING_64];      	// 设备大类
        public byte[]       szSerial = new byte[NET_COMMON_STRING_256];    	// 设备硬件信号系列
        public byte[]       szLanguage = new byte[NET_COMMON_STRING_128];  	// 语言
        public byte[]       szSN = new byte[NET_COMMON_STRING_64];         	// 设备序列号
        public byte[]       szSWVersion = new byte[NET_COMMON_STRING_64];  	// 版本号，用于显示
        public byte[]       szTag1 = new byte[NET_COMMON_STRING_256];      	// 预留字段，可用于后续定制或扩展
        public byte[]       szTag2 = new byte[NET_COMMON_STRING_256];       // 预留字段，可用于后续定制或扩展
        public byte[]       szAccessKeyId = new byte[NET_COMMON_STRING_128];//Access Key ID
        public byte[]       szSecretAccessKey = new byte[NET_COMMON_STRING_128];//Secret Access Key

        public NET_IN_CLOUD_UPGRADER_CHECK() {
            this.dwSize = this.size();
        }
    }

    //设备制造商
    public static class ENUM_VENDOR_TYPE extends SdkStructure
    {
        public static final int ENUM_VENDOR_TYPE_UNKNOWN = 0;   // 未知
        public static final int ENUM_VENDOR_TYPE_GENERAL = 1;   // General
        public static final int ENUM_VENDOR_TYPE_DH = 2;       	// DH
        public static final int ENUM_VENDOR_TYPE_OEM = 3;       // OEM
        public static final int ENUM_VENDOR_TYPE_LC = 4;       	// LC
        public static final int ENUM_VENDOR_TYPE_EZIP = 5;      // EZIP
    }

    //视频制式
    public static class ENUM_STANDARD_TYPE extends SdkStructure
    {
        public static final int ENUM_STANDARD_TYPE_UNKNOWN = 0;   	// 未知
        public static final int ENUM_STANDARD_TYPE_PAL = 1;   		// P-PAL
        public static final int ENUM_STANDARD_TYPE_NTSC = 2;       	// N-NTSC
        public static final int ENUM_STANDARD_TYPE_PAL_NTSC = 3;    // PN-PAL/NTSC默认P制
        public static final int ENUM_STANDARD_TYPE_NTSC_PAL = 4;    // NP-NTSC/PAL默认N制
        public static final int ENUM_STANDARD_TYPE_SECAM = 5;       // S-SECAM
    }

    // 云升级软件检查出参
    public static class NET_OUT_CLOUD_UPGRADER_CHECK extends SdkStructure
    {
        public int                  dwSize;
        public int                  bHasNewVersion;                  					// 是否有可升级版本
        public byte[]               szVersion = new byte[NET_COMMON_STRING_64];  		// 版本信息
        public byte[]               szAttention = new byte[NET_COMMON_STRING_1024]; 	// 提醒设备升级的提示信息
        public byte[]               szPackageUrl = new byte[NET_COMMON_STRING_1024]; 	// 设备升级包的URL
        public byte[] 			    szPackageId = new byte[NET_COMMON_STRING_64];    	// 升级包ID

        public NET_OUT_CLOUD_UPGRADER_CHECK() {
            this.dwSize = this.size();
        }
    }

    // 检查云端是否有可升级软件, 使用HTTP协议
    public boolean CLIENT_CloudUpgraderCheck(NET_IN_CLOUD_UPGRADER_CHECK pIn, NET_OUT_CLOUD_UPGRADER_CHECK pOut, int dwWaitTime);

    //云下载状态
    public static class emCloudDownloadState extends SdkStructure
    {
        public static final int emCloudDownloadState_Unknown = 0;            	// 未知
        public static final int emCloudDownloadState_Success = 1;            	// 云下载成功(需要关闭句柄)
        public static final int emCloudDownloadState_Failed = 2;            	// 云下载失败(不需要关闭句柄，会不断尝试下载)
        public static final int emCloudDownloadState_Downloading = 3;           // 正在下载中
        public static final int emCloudDownloadState_NoEnoughDiskSpace = 4;     // 磁盘空间不足
    }

    // 云下载回调函数
    public interface fCloudDownload_Process_callback extends StdCallCallback {
        public void invoke(LLong lDownHandle, int emState, double dwDownloadSpeed, int dwProgressPercentage, Pointer dwUser);
    }

    // 云升级下载升级包入参
    public static class NET_IN_CLOUD_UPGRADER_DOWN extends SdkStructure
    {
        public int                          dwSize;
        public byte[]                       szPackageUrl = new byte[NET_COMMON_STRING_1024];// 设备升级包的URL
        public byte[]                       szSaveFile = new byte[NET_COMMON_STRING_1024];  // 保存文件名
        public Callback     			pfProcessCallback;                   			// 进度回调，实现fCloudDownload_Process_callback
        public Pointer                      dwUser;                              			// 回调用户数据

        public NET_IN_CLOUD_UPGRADER_DOWN() {
            this.dwSize = this.size();
        }
    }

    // 云升级下载升级包出参
    public static class NET_OUT_CLOUD_UPGRADER_DOWN extends SdkStructure
    {
        public int                  dwSize;

        public NET_OUT_CLOUD_UPGRADER_DOWN() {
            this.dwSize = this.size();
        }
    }

    // 云 下载升级软件, 使用HTTP协议
    public LLong CLIENT_CloudUpgraderDownLoad(NET_IN_CLOUD_UPGRADER_DOWN pIn, NET_OUT_CLOUD_UPGRADER_DOWN pOut);

    // 停止云下载, 使用HTTP协议
    public boolean CLIENT_CloudUpgraderStop(LLong lDownloadHandle);

    // 暂停云下载, 使用HTTP协议
    public boolean CLIENT_CloudUpgraderPause(LLong lDownloadHandle, int bPause);

    //升级结果
    public static class NET_UPGRADE_REPORT_RESULT extends SdkStructure
    {
        public static final int NET_UPGRADE_REPORT_RESULT_UNKNWON = 0;         // 未知
        public static final int NET_UPGRADE_REPORT_RESULT_SUCCESS = 1;         // 成功
        public static final int NET_UPGRADE_REPORT_RESULT_FAILED = 2;          // 失败
    }

    public static final int NET_UPGRADE_COUNT_MAX = 256;  // 最大升级个数

    //上报升级结果结构体
    public static class NET_UPGRADE_REPORT extends SdkStructure
    {
        public int     			nDeviceNum;
        public DEVICE_SERIAL[]	szDevSerialArr = (DEVICE_SERIAL[])new DEVICE_SERIAL().toArray(NET_UPGRADE_COUNT_MAX); // 序列号
        public byte[]    		szPacketID = new byte[MAX_COMMON_STRING_128];                          // 升级包ID
        public int 				emResult;                                							   // 升级结果,详见NET_UPGRADE_REPORT_RESULT
        public byte[]    		szCode = new byte[MAX_COMMON_STRING_128];                              // 错误码信息
        public byte[]    		reserved = new byte[256];
    }

    public static class DEVICE_SERIAL extends SdkStructure
    {
        public byte[]    	szDevSerial = new byte[MAX_COMMON_STRING_64];   // 序列号
    }

    //上报升级结果入参
    public static class NET_IN_UPGRADE_REPORT extends SdkStructure
    {
        public int                   	dwSize;
        public int                      nCount;                                  // 升级包个数
        public Pointer      			pstuUpgradeReport;                      // 升级结果信息 , 大小 nCount * sizeof(NET_UPGRADE_REPORT)
        public byte[]                   szAccessKeyId = new byte[NET_COMMON_STRING_128];     //访问ID
        public byte[]                   szSecretAccessKey = new byte[NET_COMMON_STRING_128]; //访问秘钥
        public byte[]                   szUrl = new byte[NET_COMMON_STRING_1024];            // 云URL

        public NET_IN_UPGRADE_REPORT() {
            this.dwSize = this.size();
        }
    }

    //上报升级结果出参
    public static class NET_OUT_UPGRADE_REPORT extends SdkStructure
    {
        public int                  dwSize;

        public NET_OUT_UPGRADE_REPORT() {
            this.dwSize = this.size();
        }
    }

    //上报升级结果, 使用HTTP协议
    public boolean CLIENT_CloudUpgraderReport(NET_IN_UPGRADE_REPORT pIn, NET_OUT_UPGRADE_REPORT pOut, int dwWaitTime);

    // 升级状态回调结构体
    public static class NET_CLOUD_UPGRADER_STATE extends SdkStructure
    {
        public int						dwSize;
        public int 						emState;							// 升级状态,详见EM_UPGRADE_STATE
        public int						nProgress;							// 升级百分比
        public byte[]					szFileName = new byte[NET_COMMON_STRING_128];	// 升级文件
        public long                     nTotalLen;                          // 升级文件总大小，单位字节
        public NET_CLOUD_UPGRADER_STATE() {
            this.dwSize = this.size();
        }
    }

    // 升级状态回调函数
    public interface fUpgraderStateCallback extends StdCallCallback {
        public void invoke(LLong lLoginId, LLong lAttachHandle, NET_CLOUD_UPGRADER_STATE pBuf, int dwBufLen, Pointer pReserved, Pointer dwUser);
    }

    // 订阅升级状态入参
    public static class NET_IN_CLOUD_UPGRADER_ATTACH_STATE extends SdkStructure
    {
        public int					dwSize;
        public Callback		cbUpgraderState;  // 升级状态回调实现fUpgraderStateCallback
        public Pointer				dwUser;

        public NET_IN_CLOUD_UPGRADER_ATTACH_STATE() {
            this.dwSize = this.size();
        }
    }

    // 订阅升级状态出参
    public static class NET_OUT_CLOUD_UPGRADER_ATTACH_STATE extends SdkStructure
    {
        public int					dwSize;

        public NET_OUT_CLOUD_UPGRADER_ATTACH_STATE() {
            this.dwSize = this.size();
        }
    }

    // 获取升级状态入参
    public static class NET_IN_CLOUD_UPGRADER_GET_STATE extends SdkStructure
    {
        public int					dwSize;

        public NET_IN_CLOUD_UPGRADER_GET_STATE() {
            this.dwSize = this.size();
        }
    }

    // 获取升级状态出参
    public static class NET_OUT_CLOUD_UPGRADER_GET_STATE extends SdkStructure
    {
        public int					dwSize;
        public int					emState;							// 升级状态,详见EM_UPGRADE_STATE
        public int					nProgress;							// 升级进度
        public byte[]				szFileName = new byte[NET_COMMON_STRING_128];	// 升级文

        public NET_OUT_CLOUD_UPGRADER_GET_STATE() {
            this.dwSize = this.size();
        }
    }

    // 升级包和升级状态
    public static class EM_UPGRADE_STATE extends SdkStructure
    {
        public static final int EM_UPGRADE_STATE_UNKNOWN = 0;   // 未知状态
        public static final int EM_UPGRADE_STATE_NONE = 1;      // 没有检测到更新状态
        public static final int EM_UPGRADE_STATE_INVALID = 2;   // 升级包不正确
        public static final int EM_UPGRADE_STATE_NOT_ENOUGH_MEMORY = 3;  // 内存不够
        public static final int EM_UPGRADE_STATE_DOWNLOADING = 4;        // 正在下载数据
        public static final int EM_UPGRADE_STATE_DOWNLOAD_FAILED = 5;	 // 下载失败
        public static final int EM_UPGRADE_STATE_DOWNLOAD_SUCCESSED = 6; // 下载成功
        public static final int EM_UPGRADE_STATE_PREPARING = 7;			 // 准备升级
        public static final int EM_UPGRADE_STATE_UPGRADING = 8;			 // 升级中
        public static final int EM_UPGRADE_STATE_UPGRADE_FAILED = 9;	 // 升级失败
        public static final int EM_UPGRADE_STATE_UPGRADE_SUCCESSED = 10; // 升级成功
        public static final int EM_UPGRADE_STATE_UPGRADE_CANCELLED = 11; // 取消升级
        public static final int EM_UPGRADE_STATE_FILE_UNMATCH = 12; 	 // 升级包不匹配
    }

    // 订阅升级状态观察接口
    public LLong CLIENT_CloudUpgraderAttachState(LLong lLoginID, NET_IN_CLOUD_UPGRADER_ATTACH_STATE pInParam, NET_OUT_CLOUD_UPGRADER_ATTACH_STATE pOutParam, int nWaitTime);

    // 退订升级状态观察接口
    public boolean CLIENT_CloudUpgraderDetachState(LLong lAttachHandle);

    // 获取升级状态
    public boolean CLIENT_CloudUpgraderGetState(LLong lLoginID, NET_IN_CLOUD_UPGRADER_GET_STATE pInParam, NET_OUT_CLOUD_UPGRADER_GET_STATE pOutParam, int nWaitTime);

    // 代理服务器地址
    public static class NET_PROXY_SERVER_INFO extends SdkStructure
    {
        public byte[]						szIP = new byte[NET_MAX_IPADDR_LEN_EX];	// IP地址
        public int							nPort;									// 端口
        public byte[]						byReserved = new byte[84];
    }

    // CLIENT_CheckCloudUpgrader 入参
    public static class NET_IN_CHECK_CLOUD_UPGRADER extends SdkStructure
    {
        public int								dwSize;			// 结构体大小
        public int								nWay;			// 检测路径, 0-直连升级服务器检测, 1-通过代理服务器检测, 2-获取缓存的检测结果
        public NET_PROXY_SERVER_INFO			stProxy;		// 代理服务器地址, way==1时有意义

        public NET_IN_CHECK_CLOUD_UPGRADER() {
            this.dwSize = this.size();
        }
    }

    // 云升级状态
    public static class EM_CLOUD_UPGRADER_CHECK_STATE extends SdkStructure
    {
        public static final int EM_CLOUD_UPGRADER_CHECK_STATE_UNKNOWN = 0;				// 未知
        public static final int EM_CLOUD_UPGRADER_CHECK_STATE_NONE = 1;					// 没有检测到更新
        public static final int EM_CLOUD_UPGRADER_CHECK_STATE_REGULAR = 2;				// 一般升级 (需要用户确认, 只能向高版本)
        public static final int EM_CLOUD_UPGRADER_CHECK_STATE_EMERGENCY = 3;			// 强制升级 (设备自动检测执行, 可以向低版本)
        public static final int EM_CLOUD_UPGRADER_CHECK_STATE_AUTOMATIC = 4;			// 自动升级 (有新升级包, 自动升级, 当前为定制使用, 需使能页面自动升级选项)
    }

    // 云升级新版本升级包类型
    public static class EM_CLOUD_UPGRADER_PACKAGE_TYPE extends SdkStructure
    {
        public static final int EM_CLOUD_UPGRADER_PACKAGE_TYPE_UNKNOWN = 0;				// 未知
        public static final int EM_CLOUD_UPGRADER_PACKAGE_TYPE_ALL = 1;					// 整包
        public static final int EM_CLOUD_UPGRADER_PACKAGE_TYPE_PTZ = 2;					// 云台主控包
        public static final int EM_CLOUD_UPGRADER_PACKAGE_TYPE_WEB = 3;					// Web
        public static final int EM_CLOUD_UPGRADER_PACKAGE_TYPE_LOGO = 4;				// Logo
        public static final int EM_CLOUD_UPGRADER_PACKAGE_TYPE_CUSTOM = 5;				// Custom
        public static final int EM_CLOUD_UPGRADER_PACKAGE_TYPE_GUI = 6;					// Gui
        public static final int EM_CLOUD_UPGRADER_PACKAGE_TYPE_PD = 7;					// PD
        public static final int EM_CLOUD_UPGRADER_PACKAGE_TYPE_DATA = 8;				// Data
        public static final int EM_CLOUD_UPGRADER_PACKAGE_TYPE_PTZ_POWER = 9;			// 云台电源
        public static final int EM_CLOUD_UPGRADER_PACKAGE_TYPE_PTZ_LIGHT = 10;			// 云台灯光
        public static final int EM_CLOUD_UPGRADER_PACKAGE_TYPE_PTZ_HEATER = 11;			// 云台加热器
    }

    // CLIENT_CheckCloudUpgrader 出参
    public static class NET_OUT_CHECK_CLOUD_UPGRADER extends SdkStructure
    {
        public int					dwSize;									// 结构体大小
        public int					emState;								// 升级状态,详见EM_CLOUD_UPGRADER_CHECK_STATE
        public int					emPackageType;							// 新版本升级包类型, State不为None需要返回,详见EM_CLOUD_UPGRADER_PACKAGE_TYPE
        public byte[]				szOldVersion = new byte[MAX_COMMON_STRING_64];		// 旧版本号, State不为None需要返回
        public byte[]				szNewVersion = new byte[MAX_COMMON_STRING_64];		// 新版本号,State不为None需要返回
        public byte[]				szAttention = new byte[NET_COMMON_STRING_2048];		// 新的升级包更新内容
        public byte[]				szPackageURL = new byte[NET_COMMON_STRING_256];		// 升级包下载地址(代理升级需要)
        public byte[]				szPackageID = new byte[MAX_COMMON_STRING_64];		// 升级包ID
        public byte[]				szCheckSum = new byte[MAX_COMMON_STRING_64];		// 升级包的SHA-256校验和
        public byte[]				szBuildTime = new byte[MAX_COMMON_STRING_32];		// 升级包构建时间

        public NET_OUT_CHECK_CLOUD_UPGRADER() {
            this.dwSize = this.size();
        }
    }

    // 在线升级检查是否有可用升级包, pInParam和pOutParam内存由用户申请和释放
    public boolean CLIENT_CheckCloudUpgrader(LLong lLoginID, NET_IN_CHECK_CLOUD_UPGRADER pInParam, NET_OUT_CHECK_CLOUD_UPGRADER pOutParam, int nWaitTime);

    // 升级包信息
    public static class NET_CLOUD_UPGRADER_INFO extends SdkStructure
    {
        public byte[]					szPackageURL = new byte[NET_COMMON_STRING_256];		// 升级包下载地址(代理升级需要)
        public byte[]					szPackageID = new byte[MAX_COMMON_STRING_64];		// 升级包ID
        public byte[]					szCheckSum = new byte[MAX_COMMON_STRING_64];		// 升级包的SHA-256校验和
        public byte[]					byReserved = new byte[1024];						// 保留字节
    }

    // CLIENT_ExecuteCloudUpgrader 入参
    public static class NET_IN_EXECUTE_CLOUD_UPGRADER extends SdkStructure
    {
        public int								dwSize;									// 结构体大小
        public byte[]							szNewVersion = new byte[MAX_COMMON_STRING_64];		// 上一次check得到的新版本号
        public int								nWay;									// 检测路径, 0-直连升级服务器检测, 1-通过代理服务器检测
        public NET_PROXY_SERVER_INFO			stProxy;								// 代理服务器地址, nWay==1时有意义
        public NET_CLOUD_UPGRADER_INFO			stInfo;									// 升级包信息

        public NET_IN_EXECUTE_CLOUD_UPGRADER() {
            this.dwSize = this.size();
        }
    }

    // CLIENT_ExecuteCloudUpgrader 出参
    public static class NET_OUT_EXECUTE_CLOUD_UPGRADER extends SdkStructure
    {
        public int								dwSize;									// 结构体大小

        public NET_OUT_EXECUTE_CLOUD_UPGRADER() {
            this.dwSize = this.size();
        }
    }

    // 执行在线云升级, pInParam和pOutParam内存由用户申请和释放
    public boolean CLIENT_ExecuteCloudUpgrader(LLong lLoginID, NET_IN_EXECUTE_CLOUD_UPGRADER pInParam, NET_OUT_EXECUTE_CLOUD_UPGRADER pOutParam, int nWaitTime);

    // CLIENT_GetCloudUpgraderState 入参
    public static class NET_IN_GET_CLOUD_UPGRADER_STATE extends SdkStructure
    {
        public int								dwSize;									// 结构体大小

        public NET_IN_GET_CLOUD_UPGRADER_STATE() {
            this.dwSize = this.size();
        }
    }

    // 在线升级状态
    public static class EM_CLOUD_UPGRADER_STATE extends SdkStructure
    {
        public static final int EM_CLOUD_UPGRADER_STATE_UNKNOWN = 0;				// 未知
        public static final int EM_CLOUD_UPGRADER_STATE_NOUPGRADE = 1;				// "Noupgrade"-未进行升级
        public static final int EM_CLOUD_UPGRADER_STATE_PREPARING = 2;				// "Preparing"-准备升级
        public static final int EM_CLOUD_UPGRADER_STATE_DOWNLOADING = 3;			// "Downloading"-正在下载数据
        public static final int EM_CLOUD_UPGRADER_STATE_DOWNLOADFAILED = 4;			// "DownloadFailed"-下载失败
        public static final int EM_CLOUD_UPGRADER_STATE_UPGRADING = 5;				// "Upgrading"-正在升级
        public static final int EM_CLOUD_UPGRADER_STATE_INVALID = 6;				// "Invalid"-升级包不正确
        public static final int EM_CLOUD_UPGRADER_STATE_FAILED = 7;					// "Failed"-升级包写入Flash失败
        public static final int EM_CLOUD_UPGRADER_STATE_SUCCEEDED = 8;				// "Succeeded"-升级包写入Flash成功
    }

    // CLIENT_GetCloudUpgraderState 出参
    public static class NET_OUT_GET_CLOUD_UPGRADER_STATE extends SdkStructure
    {
        public int					dwSize;					// 结构体大小
        public int					emState;				// 升级状态，详见EM_CLOUD_UPGRADER_STATE
        public int					nProgress;				// 升级进度, 状态是Downloading/Upgrading时有意义

        public NET_OUT_GET_CLOUD_UPGRADER_STATE() {
            this.dwSize = this.size();
        }
    }

    // 获取云升级在线升级状态, pInParam和pOutParam内存由用户申请和释放
    public boolean CLIENT_GetCloudUpgraderState(LLong lLoginID, NET_IN_GET_CLOUD_UPGRADER_STATE pInParam, NET_OUT_GET_CLOUD_UPGRADER_STATE pOutParam, int nWaitTime);


    // 事件类型 EVENT_IVS_PHONECALL_DETECT(打电话检测事件) 对应的数据块描述信息
    public static class DEV_EVENT_PHONECALL_DETECT_INFO extends SdkStructure
    {
        public int                 	nChannelID;										// 通道号
        public int                 	nAction;										// 0:脉冲 1:开始 2:停止
        public byte[]              	szName = new byte[MAX_EVENT_NAME];				// 事件名称
        public double              	PTS;											// 时间戳(单位是毫秒)
        public NET_TIME_EX         	UTC;											// 事件发生的时间
        public int                 	nEventID;										// 事件ID

        public int					nGroupID;										// 事件组ID
        public int					nCountInGroup;									// 一个事件组内的抓拍张数
        public int					nIndexInGroup;									// 一个事件组内的抓拍序号，从1开始
        public int					UTCMS;											// UTC对应的毫秒数
        public NET_MSG_OBJECT		stuObject;										// 检测到的物体
        public int					nDetectRegionNum;								// 规则检测区域顶点数
        public NET_POINT[]  		stuDetectRegion = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM);	// 规则检测区域
        public EVENT_INTELLI_COMM_INFO  stuIntelliCommInfo;							// 智能事件公共信息
        public int                nRuleID;                                        // 智能事件规则编号
        public int                nObjectNum;                                     // 检测到的物体数量
        public DH_MSG_OBJECT[]		stuObjects=(DH_MSG_OBJECT[])new DH_MSG_OBJECT().toArray(128);								// 多个检测到的物体信息
        public int                nSerialUUIDNum;                                 // 智能物体数量
        public byte[]             szSerialUUID=new byte[128*22];                          // 智能物体全局唯一物体标识
        // 有效数据位21位，包含’\0’
        // 前2位%d%d:01-视频片段, 02-图片, 03-文件, 99-其他
        // 中间14位YYYYMMDDhhmmss:年月日时分秒
        // 后5位%u%u%u%u%u：物体ID，如00001
        public boolean				bSceneImage;									// stuSceneImage 是否有效
        public SCENE_IMAGE_INFO_EX stuSceneImage;									// 全景广角图
        public byte[]				byReserved=new byte[232];								// 保留字节
    }

    // 事件类型 EVENT_IVS_SMOKING_DETECT(吸烟检测事件)对应的数据块描述信息
    public static class DEV_EVENT_SMOKING_DETECT_INFO extends SdkStructure
    {
        public int                 	nChannelID;										// 通道号
        public int                 	nAction;										// 0:脉冲 1:开始 2:停止
        public byte[]              	szName = new byte[MAX_EVENT_NAME];				// 事件名称
        public double              	PTS;											// 时间戳(单位是毫秒)
        public NET_TIME_EX         	UTC;											// 事件发生的时间
        public int                 	nEventID;										// 事件ID

        public int					nGroupID;										// 事件组ID
        public int					nCountInGroup;									// 一个事件组内的抓拍张数
        public int					nIndexInGroup;									// 一个事件组内的抓拍序号，从1开始
        public int					UTCMS;											// UTC对应的毫秒数
        public NET_MSG_OBJECT		stuObject;										// 检测到的物体
        public int					nDetectRegionNum;								// 规则检测区域顶点数
        public NET_POINT[]  		stuDetectRegion = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM);	// 规则检测区域
        public EVENT_INTELLI_COMM_INFO  stuIntelliCommInfo;							// 智能事件公共信息
        public byte[]				byReserved = new byte[1024];					// 保留字节
    }

    // 事件类型 EVENT_IVS_FIREWARNING(火警事件) 对应的数据块描述信息
    public static class DEV_EVENT_FIREWARNING_INFO extends SdkStructure
    {
        public int						nChannelID;									// 通道号
        public byte[]					szName = new byte[NET_EVENT_NAME_LEN];      // 事件名称
        public NET_EVENT_FILE_INFO		stuFileInfo;								// 事件对应文件信息
        public int						nAction;									// 1:开始 2:停止
        public int						nFSID;										// Uint32	火情编号ID
        public int						emPicType;									// 图片类型,详见 EM_FIREWARNING_PIC_TYPE
        public byte[]					byReserved = new byte[1016];				// 保留字节
    }

    // 图片类型
    public static class EM_FIREWARNING_PIC_TYPE extends SdkStructure
    {
        public static final int EM_PIC_UNKNOWN = 0;		// 未知
        public static final int EM_PIC_NONE = 1;		// 无
        public static final int EM_PIC_OVERVIEW = 2;	// 全景图
        public static final int EM_PIC_DETAIL = 3;		// 细节图
    }

    // 事件类型EVENT_IVS_LEFTDETECTION(物品遗留事件)对应的数据块描述信息
    public static class DEV_EVENT_LEFT_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[128];               // 事件名称
        public byte[]                         bReserved1 = new byte[4];             // 字节对齐
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID
        public NET_MSG_OBJECT                 stuObject;                            // 检测到的物体
        public NET_EVENT_FILE_INFO            stuFileInfo;                          // 事件对应文件信息
        public byte                           bEventAction;
        public byte[]                         byReserved = new byte[2];
        public byte                           byImageIndex;                         // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                            nDetectRegionNum;                     // 规则检测区域顶点数
        public NET_POINT[]                    DetectRegion = new NET_POINT[NET_MAX_DETECT_REGION_NUM];  // 规则检测区域
        public int                            dwSnapFlagMask;                       // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public int                            nSourceIndex;                         // 事件源设备上的index,-1表示数据无效
        public byte[]                         szSourceDevice = new byte[MAX_PATH];  // 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int                            nOccurrenceCount;                     // 事件触发累计次数
        public EVENT_INTELLI_COMM_INFO        stuIntelliCommInfo;                   // 智能事件公共信息
        public short                          nPreserID;                            // 事件触发的预置点号，从1开始（没有表示未知）
        public byte[]                         szPresetName = new byte[64];          // 事件触发的预置名称
        public NET_EXTENSION_INFO             stuExtensionInfo;                     // 扩展信息
        public byte[]                         bReserved = new byte[290];            // 保留字节,留待扩展.

        public DEV_EVENT_LEFT_INFO()
        {
            for (int i = 0; i < DetectRegion.length; ++i) {
                DetectRegion[i] = new NET_POINT();
            }
        }
    }

    // 事件类型 EVENT_IVS_RIOTERDETECTION (聚众事件)对应的数据块描述信息
    public static class DEV_EVENT_RIOTERL_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[128];               // 事件名称
        public byte[]                         bReserved1 = new byte[4];             // 字节对齐
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID
        public int                            nObjectNum;                           // 检测到的物体个数
        public NET_MSG_OBJECT[]               stuObjectIDs = new NET_MSG_OBJECT[NET_MAX_OBJECT_LIST];  // 检测到的物体列表
        public NET_EVENT_FILE_INFO            stuFileInfo;                          // 事件对应文件信息
        public byte                           bEventAction;
        public byte[]                         byReserved = new byte[2];             // 保留字节
        public byte                           byImageIndex;                         // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                            nDetectRegionNum;                     // 规则检测区域顶点数
        public NET_POINT[]                    DetectRegion = new NET_POINT[NET_MAX_DETECT_REGION_NUM];  // 规则检测区域

        public int                            dwSnapFlagMask;                       // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public int                            nSourceIndex;                         // 事件源设备上的index,-1表示数据无效
        public byte[]                         szSourceDevice = new byte[MAX_PATH];  // 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int                            nOccurrenceCount;                     // 事件触发累计次数
        public EVENT_INTELLI_COMM_INFO        stuIntelliCommInfo;                   // 智能事件公共信息
        public NET_EXTENSION_INFO             stuExtensionInfo;                     // 扩展信息
        public byte[]                         szSourceID=new byte[32];              // 事件关联ID。应用场景是同一个物体或者同一张图片做不同分析，产生的多个事件的SourceID相同
        // 缺省时为空字符串，表示无此信息
        // 格式：类型+时间+序列号，其中类型2位，时间14位，序列号5位
        public byte[]                         bReserved = new byte[328];            // 保留字节,留待扩展.

        public DEV_EVENT_RIOTERL_INFO()
        {
            for (int i = 0; i < stuObjectIDs.length; ++i) {
                stuObjectIDs[i] = new NET_MSG_OBJECT();
            }

            for (int i = 0; i < DetectRegion.length; ++i) {
                DetectRegion[i] = new NET_POINT();
            }
        }
    }

    // 事件类型EVENT_IVS_TAKENAWAYDETECTION(物品搬移事件)对应的数据块描述信息
    public static class DEV_EVENT_TAKENAWAYDETECTION_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[128];               // 事件名称
        public byte[]                         bReserved1 = new byte[4];             // 字节对齐
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID
        public NET_MSG_OBJECT                 stuObject;                            // 检测到的物体
        public int                            nDetectRegionNum;                     // 规则检测区域顶点数
        public NET_POINT[]                    DetectRegion = new NET_POINT[NET_MAX_DETECT_REGION_NUM];  // 规则检测区域
        public NET_EVENT_FILE_INFO            stuFileInfo;                          // 事件对应文件信息
        public byte                           bEventAction;
        public byte[]                         byReserved = new byte[2];
        public byte                           byImageIndex;                         // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                            dwSnapFlagMask;                       // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public int                            nSourceIndex;                         // 事件源设备上的index,-1表示数据无效
        public byte[]                         szSourceDevice = new byte[MAX_PATH];  // 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int                            nOccurrenceCount;                     // 事件触发累计次数
        public EVENT_INTELLI_COMM_INFO        stuIntelliCommInfo;                   // 智能事件公共信息
        public short                          nPreserID;                            // 事件触发的预置点号，从1开始（没有表示未知）
        public byte[]                         szPresetName = new byte[64];          // 事件触发的预置名称
        public NET_EXTENSION_INFO             stuExtensionInfo;                     // 扩展信息
        public byte[]                         bReserved = new byte[418];            // 保留字节,留待扩展.

        public DEV_EVENT_TAKENAWAYDETECTION_INFO()
        {
            for (int i = 0; i < DetectRegion.length; ++i) {
                DetectRegion[i] = new NET_POINT();
            }
        }
    }

    // 事件类型EVENT_IVS_PARKINGDETECTION(非法停车事件)对应的数据块描述信息
    public static class DEV_EVENT_PARKINGDETECTION_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[128];               // 事件名称
        public byte[]                         bReserved1 = new byte[4];             // 字节对齐
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID
        public NET_MSG_OBJECT                 stuObject;                            // 检测到的物体
        public int                            nDetectRegionNum;                     // 规则检测区域顶点数
        public NET_POINT[]                    DetectRegion = new NET_POINT[NET_MAX_DETECT_REGION_NUM];  // 规则检测区域
        public NET_EVENT_FILE_INFO            stuFileInfo;                          // 事件对应文件信息
        public byte                           bEventAction;
        public byte[]                         byReserved = new byte[2];
        public byte                           byImageIndex;                         // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                            dwSnapFlagMask;                       // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public int                            nSourceIndex;                         // 事件源设备上的index,-1表示数据无效
        public byte[]                         szSourceDevice = new byte[MAX_PATH];  // 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int                            nOccurrenceCount;                     // 事件触发累计次数
        public EVENT_INTELLI_COMM_INFO        stuIntelliCommInfo;                   // 智能事件公共信息
        public NET_EXTENSION_INFO             stuExtensionInfo;                     // 扩展信息
        public byte[]                         szCustomParkNo=new byte[64];          // 车位名称
        public byte[]                         bReserved = new byte[420];            // 保留字节,留待扩展.

        public DEV_EVENT_PARKINGDETECTION_INFO()
        {
            for (int i = 0; i < DetectRegion.length; ++i) {
                DetectRegion[i] = new NET_POINT();
            }
        }
    }

    // 事件类型EVENT_IVS_ABNORMALRUNDETECTION(异常奔跑事件)对应的数据块描述信息
    public static class DEV_EVENT_ABNORMALRUNDETECTION_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[128];               // 事件名称
        public byte[]                         bReserved1 = new byte[4];             // 字节对齐
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID
        public NET_MSG_OBJECT                 stuObject;                            // 检测到的物体
        public double                         dbSpeed;                              // 物体运动速度,km/h
        public double                         dbTriggerSpeed;                       // 触发速度,km/h
        public int                            nDetectRegionNum;                     // 规则检测区域顶点数
        public NET_POINT[]                    DetectRegion = new NET_POINT[NET_MAX_DETECT_REGION_NUM];  // 规则检测区域
        public int                            nTrackLineNum;                        // 物体运动轨迹顶点数
        public NET_POINT[]                    TrackLine = new NET_POINT[NET_MAX_TRACK_LINE_NUM];  // 物体运动轨迹
        public NET_EVENT_FILE_INFO            stuFileInfo;                          // 事件对应文件信息
        public byte                           bEventAction;
        public byte                           bRunType;                             // 异常奔跑类型, 0-快速奔跑, 1-突然加速, 2-突然减速
        public byte[]                         byReserved = new byte[1];
        public byte                           byImageIndex;                         // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                            dwSnapFlagMask;                       // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public int                            nSourceIndex;                         // 事件源设备上的index,-1表示数据无效
        public byte[]                         szSourceDevice = new byte[MAX_PATH];  // 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int                            nOccurrenceCount;                     // 事件触发累计次数
        public EVENT_INTELLI_COMM_INFO        stuIntelliCommInfo;                   // 智能事件公共信息
        public byte[]                         bReserved = new byte[616];            // 保留字节,留待扩展.

        public DEV_EVENT_ABNORMALRUNDETECTION_INFO()
        {
            for (int i = 0; i < DetectRegion.length; ++i) {
                DetectRegion[i] = new NET_POINT();
            }

            for (int i = 0; i < TrackLine.length; ++i) {
                TrackLine[i] = new NET_POINT();
            }
        }
    }

    // 设置停车信息,对应CTRLTYPE_CTRL_SET_PARK_INFO命令参数
    public static class NET_CTRL_SET_PARK_INFO extends SdkStructure
    {
        public int                            dwSize;
        public byte[]                         szPlateNumber = new byte[MAX_PLATE_NUMBER_LEN];  		// 车牌号码
        public int                            nParkTime;                            				// 停车时长,单位:分钟
        public byte[]                         szMasterofCar = new byte[MAX_MASTER_OF_CAR_LEN];  	// 车主姓名
        public byte[]                         szUserType = new byte[MAX_USER_TYPE_LEN];  			// 用户类型,非通用,用于出入口抓拍一体机
        // monthlyCardUser表示月卡用户,yearlyCardUser表示年卡用户,longTimeUser表示长期用户/VIP,casualUser表示临时用户/Visitor
        public int                            nRemainDay;                          					// 到期天数
        public byte[]                         szParkCharge = new byte[MAX_PARK_CHARGE_LEN];  		// 停车费
        public int                            nRemainSpace;                         				// 停车库余位数
        public int                            nPassEnable;                          				// 0:不允许车辆通过 1:允许车辆通过
        public NET_TIME                       stuInTime;                            				// 车辆入场时间
        public NET_TIME                       stuOutTime;                           				// 车辆出场时间
        public int                            emCarStatus;                          				// 过车状态 详见EM_CARPASS_STATUS
        public byte[]                         szCustom = new byte[MAX_CUSTOM_LEN];  				// 自定义显示字段，默认空
        public byte[]                         szSubUserType = new byte[MAX_SUB_USER_TYPE_LEN];  	// 用户类型（szUserType字段）的子类型
        public byte[]                         szRemarks = new byte[MAX_REMARKS_LEN];  				// 备注信息
        public byte[]                         szResource = new byte[MAX_RESOURCE_LEN];  			// 资源文件（视频或图片）视频支持:mp4格式; 图片支持:BMP/jpg/JPG/jpeg/JPEG/png/PNG格式
        public int                            nParkTimeout;                                // 停车超时时间，单位分钟。为0表示未超时，不为0表示超时时间。
        public NET_CTRL_SET_PARK_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 过车状态
    public static class EM_CARPASS_STATUS extends SdkStructure
    {
        public static final int EM_CARPASS_STATUS_UNKNOWN            = 0;   // 未知状态
        public static final int EM_CARPASS_STATUS_CARPASS            = 1;   // 过车状态
        public static final int EM_CARPASS_STATUS_NORMAL             = 2;   // 无车状态
    }

    // 事件类型EVENT_IVS_MOVEDETECTION(移动事件)对应的数据块描述信息
    public static class DEV_EVENT_MOVE_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[128];               // 事件名称
        public byte[]                         bReserved1 = new byte[4];             // 字节对齐
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID
        public NET_MSG_OBJECT                 stuObject;                            // 检测到的物体
        public NET_EVENT_FILE_INFO            stuFileInfo;                          // 事件对应文件信息
        public byte                           bEventAction;                         // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]                         byReserved = new byte[2];
        public byte                           byImageIndex;                         // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                            nDetectRegionNum;                     // 规则检测区域顶点数
        public NET_POINT[]                    DetectRegion = new NET_POINT[NET_MAX_DETECT_REGION_NUM];  // 规则检测区域
        public int                            dwSnapFlagMask;                       // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public int                            nSourceIndex;                         // 事件源设备上的index,-1表示数据无效
        public byte[]                         szSourceDevice = new byte[MAX_PATH];  // 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int                            nTrackLineNum;                        // 物体运动轨迹顶点数
        public NET_POINT[]                    stuTrackLine = new NET_POINT[NET_MAX_TRACK_LINE_NUM];  // 物体运动轨迹
        public int                            nOccurrenceCount;                     // 事件触发累计次数
        public EVENT_INTELLI_COMM_INFO        stuIntelliCommInfo;                   // 智能事件公共信息
        public NET_EXTENSION_INFO             stuExtensionInfo;                     // 扩展信息
        public byte[]                         bReserved = new byte[272];            // 保留字节,留待扩展.

        public DEV_EVENT_MOVE_INFO()
        {
            for (int i = 0; i < DetectRegion.length; ++i) {
                DetectRegion[i] = new NET_POINT();
            }

            for (int i = 0; i < stuTrackLine.length; ++i) {
                stuTrackLine[i] = new NET_POINT();
            }
        }
    }

    // 监测控制和数据采集设备的点位表路径信息输入参数, 查询条件
    public static class NET_IN_SCADA_POINT_LIST_INFO extends SdkStructure
    {
        public int                            dwSize;
        public byte[]                         szDevType = new byte[NET_COMMON_STRING_64];  // 设备类型

        public NET_IN_SCADA_POINT_LIST_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 点位表路径信息
    public static class NET_SCADA_POINT_LIST extends SdkStructure
    {
        public int                            dwSize;
        public int                            nIndexValidNum;                       // 有效的配置下标个数
        public int[]                          nIndex = new int[MAX_SCADA_POINT_LIST_INDEX];  // SCADADev配置下标值, 从0开始
        public byte[]                         szPath = new byte[NET_COMMON_STRING_256];  // 点表的完整路径

        public NET_SCADA_POINT_LIST()
        {
            this.dwSize = this.size();
        }
    }

    // 监测控制和数据采集设备的点位表路径信息输出参数, 查询结果
    public static class NET_OUT_SCADA_POINT_LIST_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            nList;                                // 有效点位表路径信息个数
        public NET_SCADA_POINT_LIST[]         stuList = new NET_SCADA_POINT_LIST[MAX_SCADA_POINT_LIST_INFO_NUM];  // 点位表路径信息

        public NET_OUT_SCADA_POINT_LIST_INFO()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuList.length; ++i) {
                stuList[i] = new NET_SCADA_POINT_LIST();
            }
        }
    }

    // 监测控制和数据采集设备的点位表信息, (对应 DH_DEVSTATE_SCADA_POINT_LIST 命令)
    public static class NET_SCADA_POINT_LIST_INFO extends SdkStructure
    {
        public int                            dwSize;
        public NET_IN_SCADA_POINT_LIST_INFO   stuIn;                                // 查询条件
        public NET_OUT_SCADA_POINT_LIST_INFO  stuOut;                               // 查询结果

        public NET_SCADA_POINT_LIST_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // SCADA监测点位查询条件
    public static class NET_IN_SCADA_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            emPointType;                          // 待查询的点位类型，详见EM_NET_SCADA_POINT_TYPE

        public NET_IN_SCADA_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 点表信息
    public static class NET_SCADA_POINT_INFO extends SdkStructure
    {
        public int                            dwSize;
        public byte[]                         szDevName = new byte[NET_COMMON_STRING_64];  // 设备名称
        public int                            nYX;                                  // 有效遥信个数
        public int[]                          anYX = new int[MAX_SCADA_YX_NUM];     // 遥信信息
        public int                            nYC;                                  // 有效遥测个数
        public float[]                        afYC = new float[MAX_SCADA_YC_NUM];   // 遥测信息

        public NET_SCADA_POINT_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // SCADA监测点位查询结果
    public static class NET_OUT_SCADA_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            nPointInfoNum;                        // 有效点表个数
        public NET_SCADA_POINT_INFO[]         stuPointInfo = new NET_SCADA_POINT_INFO[MAX_SCADA_POINT_INFO_NUM];  // 点表信息

        public NET_OUT_SCADA_INFO()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuPointInfo.length; ++i) {
                stuPointInfo[i] = new NET_SCADA_POINT_INFO();
            }
        }
    }

    // 监测控制和数据采集设备的监测点位信息(对应 DH_DEVSTATE_SCADA_INFO 命令)
    public static class NET_SCADA_INFO extends SdkStructure
    {
        public int                            dwSize;
        public NET_IN_SCADA_INFO              stuIn;                                // 查询条件
        public NET_OUT_SCADA_INFO             stuOut;                               // 查询结果

        public NET_SCADA_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // SCADA能力名称
    public static class EM_NET_SCADA_CAPS_TYPE extends SdkStructure
    {
        public static final int EM_NET_SCADA_CAPS_TYPE_UNKNOWN       = 0;
        public static final int EM_NET_SCADA_CAPS_TYPE_ALL           = 1;   // 所有类型
        public static final int EM_NET_SCADA_CAPS_TYPE_DEV           = 2;   // DevInfo
    }

    // 监测控制和数据采集设备能力信息查询条件
    public static class NET_IN_SCADA_CAPS extends SdkStructure
    {
        public int                            dwSize;
        public int                            emType;                               // 查询类型，详见EM_NET_SCADA_CAPS_TYPE

        public NET_IN_SCADA_CAPS()
        {
            this.dwSize = this.size();
        }
    }

    // 监测控制和数据采集设备类型能力信息
    public static class NET_OUT_SCADA_CAPS_ITEM extends SdkStructure
    {
        public int                            dwSize;
        public byte[]                         szDevType = new byte[NET_COMMON_STRING_32];  // 设备类型
        public int                            nValidName;                           // 有效设备名称个数
        public SCADA_DEVICE_NAME[]            stuScadaDevNames = new SCADA_DEVICE_NAME[MAX_NET_SCADA_CAPS_NAME];  // 设备名称, 唯一标示设备

        public NET_OUT_SCADA_CAPS_ITEM()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuScadaDevNames.length; ++i) {
                stuScadaDevNames[i] = new SCADA_DEVICE_NAME();
            }
        }
    }

    public static class SCADA_DEVICE_NAME extends SdkStructure
    {
        public byte[]            szDevName = new byte[NET_COMMON_STRING_32];  // 数据采集设备名称
    }

    // 监测控制和数据采集设备能力信息查询结果
    public static class NET_OUT_SCADA_CAPS extends SdkStructure
    {
        public int                            dwSize;
        public int                            nValidType;                           // 有效设备类型个数
        public NET_OUT_SCADA_CAPS_ITEM[]      stuItems = new NET_OUT_SCADA_CAPS_ITEM[MAX_NET_SCADA_CAPS_TYPE];  // 最多16个类型

        public NET_OUT_SCADA_CAPS()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuItems.length; ++i) {
                stuItems[i] = new NET_OUT_SCADA_CAPS_ITEM();
            }
        }
    }

    // 监测控制和数据采集设备能力信息(对应 DH_DEVSTATE_SCADA_CAPS 命令)
    public static class NET_SCADA_CAPS extends SdkStructure
    {
        public int                            dwSize;
        public NET_IN_SCADA_CAPS              stuIn;                                // 查询条件
        public NET_OUT_SCADA_CAPS             stuOut;                               // 查询结果

        public NET_SCADA_CAPS()
        {
            this.dwSize = this.size();
        }
    }

    // 点位信息(通过设备、传感器点位获取)
    public static class NET_SCADA_POINT_BY_ID_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            emType;                               // 点位类型，详见EM_NET_SCADA_POINT_TYPE
        public byte[]                         szID = new byte[NET_COMMON_STRING_64];  // 监测点位ID
        public int                            nMeasuredVal;                         // 点位类型为YX时有效
        public float                          fMeasureVal;                          // 点位类型为YC时有效
        public int                            nSetupVal;                            // 点位类型为YK时有效
        public float                          fSetupVal;                            // 点位类型为YT时有效
        public int                            nStatus;                              // 数据状态, -1:未知, 0:正常, 1:1级告警, 2:2级告警, 3:3级告警, 4:4级告警, 5:操作事件, 6:无效数据
        public NET_TIME                       stuTime;                              // 记录时间
        public byte[]                    szPointName=new byte[32];                // 点位名称
        public NET_SCADA_POINT_BY_ID_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 通过设备、获取监测点位信息(对应 NET_SCADA_INFO_BY_ID)
    public static class NET_SCADA_INFO_BY_ID extends SdkStructure
    {
        public int                            dwSize;
        public byte[]                         szSensorID = new byte[NET_COMMON_STRING_64];  // 输入参数, 探测器ID
        public int                            nIDs;                                 // 输入参数, 有效点位ID个数
        public SCADA_ID_EX[]                  stuIDs = new SCADA_ID_EX[MAX_SCADA_ID_OF_SENSOR_NUM];  // 输入参数, 点位ID
        public int                            bIsHandle;                            // 输入参数，返回数据是否经过处理（无效数据过滤等）:"false"：未处理，"true"：处理
        public int                            nMaxCount;                            // 输入参数, pstuInfo对应数组个数
        public int                            nRetCount;                            // 输出参数, pstInfo实际返回有效个数, 可能大于用户分配个数nMaxCount
        public Pointer                        pstuInfo;                             // 输入输出参数, 用户分配缓存,大小为sizeof(NET_SCADA_POINT_BY_ID_INFO)*nMaxCount，指向NET_SCADA_POINT_BY_ID_INFO

        public NET_SCADA_INFO_BY_ID()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuIDs.length; ++i) {
                stuIDs[i] = new SCADA_ID_EX();
            }
        }
    }

    public static class SCADA_ID_EX extends SdkStructure
    {
        public byte[]                       szID = new byte[NET_COMMON_STRING_64];  // 监测点位ID
    }

    // 监测设备信息
    public static class NET_SCADA_DEVICE_ID_INFO extends SdkStructure
    {
        public byte[]                         szDeviceID = new byte[NET_COMMON_STRING_64];  // 设备id
        public byte[]                         szDevName = new byte[NET_COMMON_STRING_64];  // 设备名称, 和CFG_SCADA_DEV_INFO配置中的szDevName一致
        public byte[]                         reserve = new byte[1024];
    }

    // 获取当前主机所接入的外部设备ID
    public static class NET_SCADA_DEVICE_LIST extends SdkStructure
    {
        public int                            dwSize;
        public int                            nMax;                                 // 用户分配的结构体个数
        public int                            nRet;                                 // 设备实际返回的有效结构体个数
        public Pointer                        pstuDeviceIDInfo;                     // 监测设备信息,用户分配内存,大小为sizeof(NET_SCADA_DEVICE_ID_INFO)*nMax，指向NET_SCADA_DEVICE_ID_INFO

        public NET_SCADA_DEVICE_LIST()
        {
            this.dwSize = this.size();
        }
    }

    // 点位阈值信息
    public static class NET_SCADA_ID_THRESHOLD_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            emPointType;                          // 点位类型，详见EM_NET_SCADA_POINT_TYPE
        public byte[]                         szID = new byte[NET_COMMON_STRING_32];  // 点位ID
        public float                          fThreshold;                           // 告警门限
        public float                          fAbsoluteValue;                       // 绝对阈值
        public float                          fRelativeValue;                       // 相对阈值
        public int                            nStatus;                              // 数据状态, -1:未知, 0:正常, 1:1级告警, 2:2级告警, 3:3级告警, 4:4级告警, 5:操作事件, 6:无效数据

        public NET_SCADA_ID_THRESHOLD_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // CLIENT_SCADAGetThreshold输入参数
    public static class NET_IN_SCADA_GET_THRESHOLD extends SdkStructure
    {
        public int                            dwSize;
        public byte[]                         szDeviceID = new byte[NET_COMMON_STRING_64];  // 外接设备id
        public int                            nIDs;                                 		// 有效监测点位个数
        public SCADA_ID[]                     stuIDs = new SCADA_ID[MAX_SCADA_ID_NUM];  	// 待获取的监测点位ID

        public NET_IN_SCADA_GET_THRESHOLD()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuIDs.length; ++i) {
                stuIDs[i] = new SCADA_ID();
            }
        }
    }

    public static class SCADA_ID extends SdkStructure
    {
        public byte[]                       szID = new byte[NET_COMMON_STRING_32];  // 监测点位ID
    }

    // CLIENT_SCADAGetThreshold输出参数
    public static class NET_OUT_SCADA_GET_THRESHOLD extends SdkStructure
    {
        public int                            dwSize;
        public int                            nMax;                                 // 用户分配的点位阈值信息个数
        public int                            nRet;                                 // 实际返回的点位阈值信息
        public Pointer                        pstuThresholdInfo;                    // 点位阈值信息, 用户分配内存,大小为sizeof(NET_SCADA_ID_THRESHOLD_INFO)*nMax，指向NET_SCADA_ID_THRESHOLD_INFO

        public NET_OUT_SCADA_GET_THRESHOLD()
        {
            this.dwSize = this.size();
        }
    }

    //////////////////////////////////////////////////////////////////////////
    // CLIENT_SCADASetThreshold输入参数
    public static class NET_IN_SCADA_SET_THRESHOLD extends SdkStructure
    {
        public int                            dwSize;
        public byte[]                         szDeviceID = new byte[NET_COMMON_STRING_64];  // 外接设备id
        public int                            nMax;                                 // 用户分配的点位阈值信息个数
        public Pointer                        pstuThresholdInfo;                    // 点位阈值信息, 用户分配内存,大小为sizeof(NET_SCADA_ID_THRESHOLD_INFO)*nMax，指向NET_SCADA_ID_THRESHOLD_INFO

        public NET_IN_SCADA_SET_THRESHOLD()
        {
            this.dwSize = this.size();
        }
    }

    // CLIENT_SCADASetThreshold输出参数
    public static class NET_OUT_SCADA_SET_THRESHOLD extends SdkStructure
    {
        public int                            dwSize;
        public int                            nSuccess;                             // 有效的存放设置阈值成功的id个数
        public SCADA_ID[]                     stuSuccessIDs = new SCADA_ID[MAX_SCADA_ID_NUM];  // 设置阈值成功的id,用户分配内存
        public int                            nFail;                                // 用户分配的存放设置阈值失败的id个数
        public SCADA_ID[]                     stuFailIDs = new SCADA_ID[MAX_SCADA_ID_NUM];  // 设置阈值失败的id, 用户分配内存

        public NET_OUT_SCADA_SET_THRESHOLD()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuSuccessIDs.length; ++i) {
                stuSuccessIDs[i] = new SCADA_ID();
            }

            for (int i = 0; i < stuFailIDs.length; ++i) {
                stuFailIDs[i] = new SCADA_ID();
            }
        }
    }

    //////////////////////////////////////////////////////////////////////////
    // CLIENT_StartFindSCADA输入参数
    public static class NET_IN_SCADA_START_FIND extends SdkStructure
    {
        public int                            dwSize;
        public NET_TIME                       stuStartTime;                         // 开始时间, 必填
        public int                            bEndTime;                             // 是否限制结束时间, TRUE: 必填stuEndTime, FLASE: 不限制结束时间
        public NET_TIME                       stuEndTime;                           // 结束时间
        public byte[]                         szDeviceID = new byte[NET_COMMON_STRING_64];  // DeviceID, 必填
        public byte[]                         szID = new byte[NET_COMMON_STRING_32];  // 监测点位ID, 必填
        public int                            nIDsNum;                              // 监测点ID数组长度
        public SCADA_ID[]                     stuIDs = new SCADA_ID[32];  			// 监控点ID号数组，SDT离网供电扩展字段

        public NET_IN_SCADA_START_FIND()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuIDs.length; ++i) {
                stuIDs[i] = new SCADA_ID();
            }
        }
    }

    // CLIENT_StartFindSCADA输出参数
    public static class NET_OUT_SCADA_START_FIND extends SdkStructure
    {
        public int                            dwSize;
        public int                            dwTotalCount;                         // 符合查询条件的总数

        public NET_OUT_SCADA_START_FIND()
        {
            this.dwSize = this.size();
        }
    }

    // CLIENT_DoFindSCADA输入参数
    public static class NET_IN_SCADA_DO_FIND extends SdkStructure
    {
        public int                            dwSize;
        public int                            nStartNo;                             // 起始序号
        public int                            nCount;                               // 本次欲获得结果的个数

        public NET_IN_SCADA_DO_FIND()
        {
            this.dwSize = this.size();
        }
    }

    // CLIENT_DoFindSCADA输出参数
    public static class NET_OUT_SCADA_DO_FIND extends SdkStructure
    {
        public int                            dwSize;
        public int                            nRetNum;                              // 本次查询到的个数
        public Pointer                        pstuInfo;                             // 查询结果, 用户分配内存,大小为sizeof(NET_SCADA_POINT_BY_ID_INFO)*nMaxNum，指向NET_SCADA_POINT_BY_ID_INFO
        public int                            nMaxNum;                              // 用户分配内存的个数

        public NET_OUT_SCADA_DO_FIND()
        {
            this.dwSize = this.size();
        }
    }

    // 监控点值设置参数
    public static class NET_SCADA_POINT_SET_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            emType;                               // 监控点位类型,取YK、YT两种类型，详见EM_NET_SCADA_POINT_TYPE
        public byte[]                         szPointID = new byte[NET_COMMON_STRING_64];  // 监控点位ID
        public int                            nSetupVal;                            // 点位类型为YK时有效
        public float                          fSetupVal;                            // 点位类型为YT时有效

        public NET_SCADA_POINT_SET_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 监控点值设置参数列表,CLIENT_SetSCADAInfo()接口输入参数
    public static class NET_IN_SCADA_POINT_SET_INFO_LIST extends SdkStructure
    {
        public int                            dwSize;
        public byte[]                         szDevID = new byte[NET_COMMON_STRING_32];  // 设备ID
        public int                            nPointNum;                            // 监控点个数
        public NET_SCADA_POINT_SET_INFO[]     stuList = new NET_SCADA_POINT_SET_INFO[MAX_SCADA_ID_OF_SENSOR_NUM];  // 监控点列表信息

        public NET_IN_SCADA_POINT_SET_INFO_LIST()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuList.length; ++i) {
                stuList[i] = new NET_SCADA_POINT_SET_INFO();
            }
        }
    }

    // 设置监控点值返回的结果列表,CLIENT_SetSCADAInfo()接口输出参数
    public static class NET_OUT_SCADA_POINT_SET_INFO_LIST extends SdkStructure
    {
        public int                            dwSize;
        public int                            nSuccess;                             // 有效的控制或调节成功的ID个数
        public SCADA_ID[]                     stuSuccessIDs = new SCADA_ID[MAX_SCADA_ID_OF_SENSOR_NUM];  // 控制或调节成功的ID的列表
        public int                            nFail;                                // 有效的控制或调节失败的ID个数
        public SCADA_ID[]                     stuFailIDs = new SCADA_ID[MAX_SCADA_ID_OF_SENSOR_NUM];  // 控制或调节失败的ID的列表

        public NET_OUT_SCADA_POINT_SET_INFO_LIST()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuSuccessIDs.length; ++i) {
                stuSuccessIDs[i] = new SCADA_ID();
            }

            for (int i = 0; i < stuFailIDs.length; ++i) {
                stuFailIDs[i] = new SCADA_ID();
            }
        }
    }

    // 获取阈值,pInParam与pOutParam内存由用户申请释放
    public boolean CLIENT_SCADAGetThreshold(LLong lLoginID, NET_IN_SCADA_GET_THRESHOLD pInParam, NET_OUT_SCADA_GET_THRESHOLD pOutParam, int nWaitTime);

    // 设置阈值,pInParam与pOutParam内存由用户申请释放
    public boolean CLIENT_SCADASetThreshold(LLong lLoginID, NET_IN_SCADA_SET_THRESHOLD pInParam, NET_OUT_SCADA_SET_THRESHOLD pOutParam, int nWaitTime);

    // 开始查询SCADA点位历史数据,pInParam与pOutParam内存由用户申请释放
    public LLong CLIENT_StartFindSCADA(LLong lLoginID, NET_IN_SCADA_START_FIND pInParam, NET_OUT_SCADA_START_FIND pOutParam, int nWaitTime);

    // 获取SCADA点位历史数据,pInParam与pOutParam内存由用户申请释放
    public boolean CLIENT_DoFindSCADA(LLong lFindHandle, NET_IN_SCADA_DO_FIND pInParam, NET_OUT_SCADA_DO_FIND pOutParam, int nWaitTime);

    // 停止查询SCADA点位历史数据
    public boolean CLIENT_StopFindSCADA(LLong lFindHandle);

    // 设置监测点位信息,pInParam与pOutParam内存由用户申请释放
    public boolean CLIENT_SCADASetInfo(LLong lLoginID, NET_IN_SCADA_POINT_SET_INFO_LIST pInParam, NET_OUT_SCADA_POINT_SET_INFO_LIST pOutParam, int nWaitTime);

    public static class CFG_SCADA_DEV_INFO extends SdkStructure
    {
        public int                            bEnable;                              // 是否启用
        public byte[]                         szDevType = new byte[CFG_COMMON_STRING_64];  // 设备类型
        public byte[]                         szDevName = new byte[CFG_COMMON_STRING_64];  // 设备名称, 唯一标示设备用
        public int                            nSlot;                                // 虚拟槽位号, 详见AlarmSlotBond配置
        public int                            nLevel;                               // 如果Slot绑定的是NetCollection类型的话，该字段为-1
        public CFG_ALARM_MSG_HANDLE           stuEventHandler;                      // 报警联动
    }

    // 高频次报警
    public static class CFG_HIGH_FREQUENCY extends SdkStructure
    {
        public int                            nPeriod;                              // 统计周期, 以秒为单位, 默认30分钟(1800s)
        public int                            nMaxCount;                            // 在对应统计周期内最大允许上报报警数
    }

    // 告警屏蔽规则配置(对应 CFG_CMD_ALARM_SHIELD_RULE)
    public static class CFG_ALARM_SHIELD_RULE_INFO extends SdkStructure
    {
        public CFG_HIGH_FREQUENCY             stuHighFreq;                          // 高频次报警, 在一定周期内允许上报的报警次数，以此过滤对于报警的频繁上报导致信息干扰
    }

    // 获取车位锁状态接口，CLIENT_GetParkingLockState 入参
    public static class NET_IN_GET_PARKINGLOCK_STATE_INFO extends SdkStructure
    {
        public int                            dwSize;                               // 结构体大小

        public NET_IN_GET_PARKINGLOCK_STATE_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 车位锁状态
    public static class EM_STATE_TYPE extends SdkStructure
    {
        public static final int EM_STATE_TYPE_UNKNOW                 = 0;   // 未知
        public static final int EM_STATE_TYPE_LOCKRISE               = 1;   // 车位锁升起
        public static final int EM_STATE_TYPE_LOCKDOWN               = 2;   // 车位锁降下
        public static final int EM_STATE_TYPE_LOCKERROR              = 3;   // 车位锁异常
    }

    // 车位锁状态通信接口参数
    public static class NET_STATE_LIST_INFO extends SdkStructure
    {
        public int                            nLane;                                // 车位号
        public int                            emState;                              // 车位锁状态，详见EM_STATE_TYPE
        public byte[]                         byReserved = new byte[256];           // 保留
    }

    // 获取车位锁状态， CLIENT_GetParkingLockState 出参
    public static class NET_OUT_GET_PARKINGLOCK_STATE_INFO extends SdkStructure
    {
        public int                            dwSize;                               // 结构体大小
        public int                            nStateListNum;                        // 车位锁状态个数
        public NET_STATE_LIST_INFO[]          stuStateList = new NET_STATE_LIST_INFO[MAX_PARKINGLOCK_STATE_NUM];  // 车位锁状态

        public NET_OUT_GET_PARKINGLOCK_STATE_INFO()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuStateList.length; ++i) {
                stuStateList[i] = new NET_STATE_LIST_INFO();
            }
        }
    }

    // 设置车位锁状态接口，CLIENT_SetParkingLockState 入参
    public static class NET_IN_SET_PARKINGLOCK_STATE_INFO extends SdkStructure
    {
        public int                            dwSize;                               // 结构体大小
        public int                            nStateListNum;                        // 车位锁状态个数
        public NET_STATE_LIST_INFO[]          stuStateList = new NET_STATE_LIST_INFO[MAX_PARKINGLOCK_STATE_NUM];  // 车位锁状态

        public NET_IN_SET_PARKINGLOCK_STATE_INFO()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuStateList.length; ++i) {
                stuStateList[i] = new NET_STATE_LIST_INFO();
            }
        }
    }

    // 设置车位锁状态接口，CLIENT_SetParkingLockState 出参
    public static class NET_OUT_SET_PARKINGLOCK_STATE_INFO extends SdkStructure
    {
        public int                            dwSize;                               // 结构体大小

        public NET_OUT_SET_PARKINGLOCK_STATE_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 获取车位锁状态
    public boolean CLIENT_GetParkingLockState(LLong lLoginID, NET_IN_GET_PARKINGLOCK_STATE_INFO pstInParam, NET_OUT_GET_PARKINGLOCK_STATE_INFO pstOutParam, int nWaitTime);

    // 设置车位锁状态
    public boolean CLIENT_SetParkingLockState(LLong lLoginID, NET_IN_SET_PARKINGLOCK_STATE_INFO pstInParm, NET_OUT_SET_PARKINGLOCK_STATE_INFO pstOutParam, int nWaitTIme);

    // 司法刻录配置
    public static class CFG_JUDICATURE_INFO extends SdkStructure
    {
        public byte[]                         szDiskPassword = new byte[MAX_PASSWORD_LEN];  // 光盘密码(废弃, 使用szPassword和nPasswordLen)
        public byte[]                         szCaseNo = new byte[MAX_OSD_SUMMARY_LEN];  // 案件编号
        public int                            bCaseNoOsdEn;                         // 案件编号叠加使能
        public byte[]                         szCaseTitle = new byte[MAX_OSD_SUMMARY_LEN];  // 案件名称
        public int                            bCaseTitleOsdEn;                      // 案件名称叠加使能
        public byte[]                         szOfficer = new byte[MAX_OSD_SUMMARY_LEN];  // 办案人员
        public int                            bOfficerOsdEn;                        // 办案人员叠加使能
        public byte[]                         szLocation = new byte[MAX_OSD_SUMMARY_LEN];  // 办案地点
        public int                            bLocationOsdEn;                       // 办案地点叠加使能
        public byte[]                         szRelatedMan = new byte[MAX_OSD_SUMMARY_LEN];  // 涉案人员
        public int                            bRelatedManOsdEn;                     // 涉案人员叠加使能
        public byte[]                         szDiskNo = new byte[MAX_OSD_SUMMARY_LEN];  // 光盘编号
        public int                            bDiskNoOsdEn;                         // 光盘编号叠加使能

        public int                            bCustomCase;                          // TRUE:自定义司法案件信息,FALSE: 上边szCaseNo等字段有效
        public int                            nCustomCase;                          // 实际CFG_CUSTOMCASE个数
        public CFG_CUSTOMCASE[]               stuCustomCases = new CFG_CUSTOMCASE[MAX_CUSTOMCASE_NUM];  // 自定义司法案件信息

        public int                            bDataCheckOsdEn;                      // 光盘刻录数据校验配置 叠加使能
        public int                            bAttachFileEn;                        // 附件上传使能
        public byte[]                         szPassword = new byte[MAX_PASSWORD_LEN];  // 密码, 刻录光盘时、配置读保护密码
        public int                            nPasswordLen;                         // 密码长度
        public CFG_NET_TIME                   stuStartTime;                         // 片头信息叠加开始时间
        public int                            nPeriod;                              // 片头信息叠加时间长度，单位：分钟

        public CFG_JUDICATURE_INFO()
        {
            for (int i = 0; i < stuCustomCases.length; ++i) {
                stuCustomCases[i] = new CFG_CUSTOMCASE();
            }
        }
    }

    // 自定义司法案件信息
    public static class CFG_CUSTOMCASE extends SdkStructure
    {
        public byte[]                         szCaseTitle = new byte[MAX_OSD_TITLE_LEN];  // 案件名称
        public byte[]                         szCaseContent = new byte[MAX_OSD_SUMMARY_LEN];  // 案件名称
        public int                            bCaseNoOsdEn;                         // 案件编号叠加使能
    }

    // 叠加类型
    public static class NET_EM_OSD_BLEND_TYPE extends SdkStructure
    {
        public static final int NET_EM_OSD_BLEND_TYPE_UNKNOWN        = 0;   // 未知叠加类型
        public static final int NET_EM_OSD_BLEND_TYPE_MAIN           = 1;   // 叠加到主码流
        public static final int NET_EM_OSD_BLEND_TYPE_EXTRA1         = 2;   // 叠加到辅码流1
        public static final int NET_EM_OSD_BLEND_TYPE_EXTRA2         = 3;   // 叠加到辅码流2
        public static final int NET_EM_OSD_BLEND_TYPE_EXTRA3         = 4;   // 叠加到辅码流3
        public static final int NET_EM_OSD_BLEND_TYPE_SNAPSHOT       = 5;   // 叠加到抓图
        public static final int NET_EM_OSD_BLEND_TYPE_PREVIEW        = 6;   // 叠加到预览视频
    }

    // 编码物件-通道标题
    public static class NET_OSD_CHANNEL_TITLE extends SdkStructure
    {
        public int                            dwSize;
        public int                            emOsdBlendType;                       // 叠加类型，不管是获取还是设置都要设置该字段，详见NET_EM_OSD_BLEND_TYPE
        public int                            bEncodeBlend;                         // 是否叠加
        public NET_COLOR_RGBA                 stuFrontColor;                        // 前景色
        public NET_COLOR_RGBA                 stuBackColor;                         // 背景色
        public NET_RECT                       stuRect;                              // 区域, 坐标取值[0~8191], 仅使用left和top值, 点(left,top)应和(right,bottom)设置成同样的点

        public NET_OSD_CHANNEL_TITLE()
        {
            this.dwSize = this.size();
        }
    }

    // 编码物件-时间标题
    public static class NET_OSD_TIME_TITLE extends SdkStructure
    {
        public int                            dwSize;
        public int                            emOsdBlendType;                       // 叠加类型，不管是获取还是设置都要设置该字段，详见NET_EM_OSD_BLEND_TYPE
        public int                            bEncodeBlend;                         // 是否叠加
        public NET_COLOR_RGBA                 stuFrontColor;                        // 前景色
        public NET_COLOR_RGBA                 stuBackColor;                         // 背景色
        public NET_RECT                       stuRect;                              // 区域, 坐标取值[0~8191], 仅使用left和top值, 点(left,top)应和(right,bottom)设置成同样的点
        public int                            bShowWeek;                            // 是否显示星期

        public NET_OSD_TIME_TITLE()
        {
            this.dwSize = this.size();
        }
    }

    // 编码物件-自定义标题信息
    public static class NET_CUSTOM_TITLE_INFO extends SdkStructure
    {
        public int                            bEncodeBlend;                         // 是否叠加
        public NET_COLOR_RGBA                 stuFrontColor;                        // 前景色
        public NET_COLOR_RGBA                 stuBackColor;                         // 背景色
        public NET_RECT                       stuRect;                              // 区域, 坐标取值[0~8191], 仅使用left和top值, 点(left,top)应和(right,bottom)设置成同样的点
        public byte[]                         szText = new byte[CUSTOM_TITLE_LEN];  // 标题内容
        public byte[]                         byReserved = new byte[512];           // 保留字节
    }

    // 编码物件-自定义标题
    public static class NET_OSD_CUSTOM_TITLE extends SdkStructure
    {
        public int                            dwSize;
        public int                            emOsdBlendType;                       // 叠加类型，不管是获取还是设置都要设置该字段，详见NET_EM_OSD_BLEND_TYPE
        public int                            nCustomTitleNum;                      // 自定义标题数量
        public NET_CUSTOM_TITLE_INFO[]        stuCustomTitle = new NET_CUSTOM_TITLE_INFO[MAX_CUSTOM_TITLE_NUM];  // 自定义标题

        public NET_OSD_CUSTOM_TITLE()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuCustomTitle.length; ++i) {
                stuCustomTitle[i] = new NET_CUSTOM_TITLE_INFO();
            }
        }
    }

    // 标题文本对齐方式
    public static class EM_TITLE_TEXT_ALIGNTYPE extends SdkStructure
    {
        public static final int EM_TEXT_ALIGNTYPE_INVALID            = 0;   // 无效的对齐方式
        public static final int EM_TEXT_ALIGNTYPE_LEFT               = 1;   // 左对齐
        public static final int EM_TEXT_ALIGNTYPE_XCENTER            = 2;   // X坐标中对齐
        public static final int EM_TEXT_ALIGNTYPE_YCENTER            = 3;   // Y坐标中对齐
        public static final int EM_TEXT_ALIGNTYPE_CENTER             = 4;   // 居中
        public static final int EM_TEXT_ALIGNTYPE_RIGHT              = 5;   // 右对齐
        public static final int EM_TEXT_ALIGNTYPE_TOP                = 6;   // 按照顶部对齐
        public static final int EM_TEXT_ALIGNTYPE_BOTTOM             = 7;   // 按照底部对齐
        public static final int EM_TEXT_ALIGNTYPE_LEFTTOP            = 8;   // 按照左上角对齐
        public static final int EM_TEXT_ALIGNTYPE_CHANGELINE         = 9;   // 换行对齐
    }

    // 自定义标题文本对齐
    public static class NET_OSD_CUSTOM_TITLE_TEXT_ALIGN extends SdkStructure
    {
        public int                            dwSize;
        public int                            nCustomTitleNum;                      // 自定义标题数量
        public int[]                          emTextAlign = new int[MAX_CUSTOM_TITLE_NUM];  // 自定义标题文本对齐方式，详见EM_TITLE_TEXT_ALIGNTYPE

        public NET_OSD_CUSTOM_TITLE_TEXT_ALIGN()
        {
            this.dwSize = this.size();
        }
    }

    //编码物件-公共配置信息
    public static class NET_OSD_COMM_INFO extends SdkStructure
    {
        public int                            dwSize;
        public double                         fFontSizeScale;                       // 叠加字体大小放大比例
        //当fFontSizeScale≠0时,nFontSize不起作用
        //当fFontSizeScale=0时,nFontSize起作用
        //设备默认fFontSizeScale=1.0
        //如果需要修改倍数，修改该值
        //如果需要按照像素设置，则置该值为0，nFontSize的值生效
        public int                            nFontSize;                            // 叠加到主码流上的全局字体大小,单位 px, 默认24.
        //和fFontSizeScale共同作用
        public int                            nFontSizeExtra1;                      // 叠加到辅码流1上的全局字体大小,单位 px
        public int                            nFontSizeExtra2;                      // 叠加到辅码流2上的全局字体大小,单位 px
        public int                            nFontSizeExtra3;                      // 叠加到辅码流3上的全局字体大小,单位 px
        public int                            nFontSizeSnapshot;                    // 叠加到抓图流上的全局字体大小, 单位 px
        public int                            nFontSizeMergeSnapshot;               // 叠加到抓图流上合成图片的字体大小,单位 px

        public NET_OSD_COMM_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 播报单元类型
    public static class NET_PLAYAUDIO_TYPE extends SdkStructure
    {
        public static final int NET_PLAYAUDIO_TYPE_UNKNOWN           = 0;
        public static final int NET_PLAYAUDIO_TYPE_PHRASE            = 1;   // 短语类型,不进行解析,依次读每个字,有该字的语音文件支持
        public static final int NET_PLAYAUDIO_TYPE_FILE              = 2;   // 播放指定路径的语音文件(设备端完整路径)
        public static final int NET_PLAYAUDIO_TYPE_PLATERNUM         = 3;   // 播报车牌号码,按车牌号码格式读出
        public static final int NET_PLAYAUDIO_TYPE_MONEY             = 4;   // 播报金额,按金额形式读出
        public static final int NET_PLAYAUDIO_TYPE_DATE              = 5;   // 播报日期,按日期形式读出
        public static final int NET_PLAYAUDIO_TYPE_TIME              = 6;   // 播报时间,按时间形式读出
        public static final int NET_PLAYAUDIO_TYPE_EMPTY             = 7;   // 空类型,停顿一个字符时间
    }

    // 语音播报内容
    public static class NET_CTRL_PLAYAUDIO_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            emPlayAudioType;                      // 播报单元类型,详见NET_PLAYAUDIO_TYPE，详见NET_PLAYAUDIO_TYPE
        public byte[]                         szDetail = new byte[NET_COMMON_STRING_128];  // 详细内容各类型详细内容：
        // Phrase类型:"欢迎"
        // File类型: "/home/停车.pcm"
        // PlateNumbe类型: "浙A12345"
        // Money类型: "80.12元"
        // Date类型: "2014年4月10日"
        // Time类型: "1天10小时20分5秒
        public int							nRepeatTimes;					// 播放重复次数
        public int		emPriority;						// 播放优先级,对应枚举EM_PLAYAUDIO_PRIORITY
        public NET_CTRL_PLAYAUDIO_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // CLIENT_ControlDevice接口的 DH_CTRL_START_PLAYAUDIOEX 命令参数
    public static class NET_CTRL_START_PLAYAUDIOEX extends SdkStructure
    {
        public int                            dwSize;
        public int                            nAudioCount;                          // 播报内容数目
        public NET_CTRL_PLAYAUDIO_INFO[]      stuAudioInfos = new NET_CTRL_PLAYAUDIO_INFO[NET_MAX_PLAYAUDIO_COUNT];  // 语音播报内容
        public int                        nListRepeatTimes;                       // 语音播报内容重复次数, 描述所有播报单元
        public NET_CTRL_START_PLAYAUDIOEX()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuAudioInfos.length; ++i) {
                stuAudioInfos[i] = new NET_CTRL_PLAYAUDIO_INFO();
            }
        }
    }

    // 串口基本属性
    public static class CFG_COMM_PROP extends SdkStructure
    {
        public byte                           byDataBit;                            // 数据位；0：5，1：6，2：7，3：8
        public byte                           byStopBit;                            // 停止位；0：1位，1：1.5位，2：2位
        public byte                           byParity;                             // 校验位；0：无校验，1：奇校验；2：偶校验
        public byte                           byBaudRate;                           // 波特率；0：300，1：600，2：1200，3：2400，4：4800，
        // 5：9600，6：19200，7：38400，8：57600，9：115200
    }

    // 归位预置点配置
    public static class CFG_PRESET_HOMING extends SdkStructure
    {
        public int                            nPtzPresetId;                         // 云台预置点编号	0~65535
        //-1表示无效
        public int                            nFreeSec;                             // 空闲的时间，单位为秒
    }

    // 云台配置
    public static class CFG_PTZ_INFO extends SdkStructure
    {
        // 能力
        public byte                           abMartixID;
        public byte                           abCamID;
        public byte                           abPTZType;

        // 信息
        public int                            nChannelID;                           // 通道号(0开始)
        public int                            bEnable;                              // 使能开关
        public byte[]                         szProName = new byte[MAX_NAME_LEN];   // 协议名称
        public int                            nDecoderAddress;                      // 解码器地址；0 - 255
        public CFG_COMM_PROP                  struComm;
        public int                            nMartixID;                            // 矩阵号
        public int                            nPTZType;                             // 云台类型0-兼容，本地云台 1-远程网络云台
        public int                            nCamID;                               // 摄像头ID
        public int                            nPort;                                // 使用的串口端口号
        public CFG_PRESET_HOMING              stuPresetHoming;                      // 一段时间不操作云台，自动归位到某个预置点
        public int                            nControlMode;                         // 控制模式, 0:"RS485"串口控制(默认);1:"Coaxial" 同轴口控制
    }

    // 抓拍物体信息
    public static class NET_SNAP_OBJECT_INFO extends SdkStructure
    {
        public NET_RECT                       stuBoundingBox;                       // 物体包围盒, 点坐标归一化到[0, 8192]坐标
        public byte[]                         byReserved = new byte[512];           // 保留字节
    }

    // CLIENT_SnapPictureByAnalyseObject 接口输入参数
    public static class NET_IN_SNAP_BY_ANALYSE_OBJECT extends SdkStructure
    {
        public int                            dwSize;                               // 结构体大小
        public int                            nChannelID;                           // 通道号
        public byte[]                         byReserved = new byte[4];      		// 字节对齐
        public int                            nSnapObjectNum;                       // 抓拍物体个数
        public NET_SNAP_OBJECT_INFO[]         stuSnapObjects = new NET_SNAP_OBJECT_INFO[32];  // 抓拍物体信息

        public NET_IN_SNAP_BY_ANALYSE_OBJECT()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuSnapObjects.length; ++i) {
                stuSnapObjects[i] = new NET_SNAP_OBJECT_INFO();
            }
        }
    }

    // CLIENT_SnapPictureByAnalyseObject 接口输出参数
    public static class NET_OUT_SNAP_BY_ANALYSE_OBJECT extends SdkStructure
    {
        public int                            dwSize;                               // 结构体大小

        public NET_OUT_SNAP_BY_ANALYSE_OBJECT()
        {
            this.dwSize = this.size();
        }
    }

    // 选中目标进行抓拍
    public boolean CLIENT_SnapPictureByAnalyseObject(LLong lLoginID, NET_IN_SNAP_BY_ANALYSE_OBJECT pInParam, NET_OUT_SNAP_BY_ANALYSE_OBJECT pOutParam, int nWaitTime);

    // 热成像着火点报警
    public static class ALARM_FIREWARNING_INFO extends SdkStructure
    {
        public int                            nPresetId;                            // 该字段废弃，请由NET_ALARM_FIREWARNING_INFO事件获取此信息
        public int                            nState;                               // 0 - 开始,1 - 结束,-1:无意义
        public NET_RECT                       stBoundingBox;                        // 该字段废弃,请由NET_ALARM_FIREWARNING_INFO事件获取此信息
        public int                            nTemperatureUnit;                     // 该字段废弃,请由NET_ALARM_FIREWARNING_INFO事件获取此信息
        public float                          fTemperature;                         // 该字段废弃,请由NET_ALARM_FIREWARNING_INFO事件获取此信息
        public int       					  nDistance;                          	// 该字段废弃,请由DH_ALARM_FIREWARNING_INFO事件获取此信息
        public GPS_POINT                      stGpsPoint;                           // 该字段废弃,请由NET_ALARM_FIREWARNING_INFO事件获取此信息
        public int                            nChannel;                             // 对应视频通道号
        public byte[]                         reserved = new byte[252];
    }

    // 时间类型
    public static class EM_TIME_TYPE extends SdkStructure
    {
        public static final int NET_TIME_TYPE_ABSLUTE                = 0;   // 绝对时间
        public static final int NET_TIME_TYPE_RELATIVE               = 1;   // 相对时间,相对于视频文件头帧为时间基点,头帧对应于UTC(0000-00-00 00:00:00)
    }

    // 卡号省份
    public static class EM_CARD_PROVINCE extends SdkStructure
    {
        public static final int EM_CARD_UNKNOWN                      = 10;  // 解析出错，未知省份
        public static final int EM_CARD_BEIJING                      = 11;  // 北京
        public static final int EM_CARD_TIANJIN                      = 12;  // 天津
        public static final int EM_CARD_HEBEI                        = 13;  // 河北
        public static final int EM_CARD_SHANXI_TAIYUAN               = 14;  // 山西
        public static final int EM_CARD_NEIMENGGU                    = 15;  // 内蒙古
        public static final int EM_CARD_LIAONING                     = 21;  // 辽宁
        public static final int EM_CARD_JILIN                        = 22;  // 吉林
        public static final int EM_CARD_HEILONGJIANG                 = 23;  // 黑龙江
        public static final int EM_CARD_SHANGHAI                     = 31;  // 上海
        public static final int EM_CARD_JIANGSU                      = 32;  // 江苏
        public static final int EM_CARD_ZHEJIANG                     = 33;  // 浙江
        public static final int EM_CARD_ANHUI                        = 34;  // 安徽
        public static final int EM_CARD_FUJIAN                       = 35;  // 福建
        public static final int EM_CARD_JIANGXI                      = 36;  // 江西
        public static final int EM_CARD_SHANDONG                     = 37;  // 山东
        public static final int EM_CARD_HENAN                        = 41;  // 河南
        public static final int EM_CARD_HUBEI                        = 42;  // 湖北
        public static final int EM_CARD_HUNAN                        = 43;  // 湖南
        public static final int EM_CARD_GUANGDONG                    = 44;  // 广东
        public static final int EM_CARD_GUANGXI                      = 45;  // 广西
        public static final int EM_CARD_HAINAN                       = 46;  // 海南
        public static final int EM_CARD_CHONGQING                    = 50;  // 重庆
        public static final int EM_CARD_SICHUAN                      = 51;  // 四川
        public static final int EM_CARD_GUIZHOU                      = 52;  // 贵州
        public static final int EM_CARD_YUNNAN                       = 53;  // 云南
        public static final int EM_CARD_XIZANG                       = 54;  // 西藏
        public static final int EM_CARD_SHANXI_XIAN                  = 61;  // 陕西
        public static final int EM_CARD_GANSU                        = 62;  // 甘肃
        public static final int EM_CARD_QINGHAI                      = 63;  // 青海
        public static final int EM_CARD_NINGXIA                      = 64;  // 宁夏
        public static final int EM_CARD_XINJIANG                     = 65;  // 新疆
        public static final int EM_CARD_XIANGGANG                    = 71;  // 香港
        public static final int EM_CARD_AOMEN                        = 82;  // 澳门
    }

    // 车辆类型
    public static class EM_CAR_TYPE extends SdkStructure
    {
        public static final int EM_CAR_0                             = 0;   // 其他车辆
        public static final int EM_CAR_1                             = 1;   // 大型普通客车
        public static final int EM_CAR_2                             = 2;   // 大型双层客车
        public static final int EM_CAR_3                             = 3;   // 大型卧铺客车
        public static final int EM_CAR_4                             = 4;   // 大型铰接客车
        public static final int EM_CAR_5                             = 5;   // 大型越野客车
        public static final int EM_CAR_6                             = 6;   // 大型轿车
        public static final int EM_CAR_7                             = 7;   // 大型专用客车
        public static final int EM_CAR_8                             = 8;   // 大型专用校车
        public static final int EM_CAR_9                             = 9;   // 中型普通客车
        public static final int EM_CAR_10                            = 10;  // 中型双层客车
        public static final int EM_CAR_11                            = 11;  // 中型卧铺客车
        public static final int EM_CAR_12                            = 12;  // 中型铰接客车
        public static final int EM_CAR_13                            = 13;  // 中型越野客车
        public static final int EM_CAR_14                            = 14;  // 中型轿车
        public static final int EM_CAR_15                            = 15;  // 中型专用客车
        public static final int EM_CAR_16                            = 16;  // 中型专用校车
        public static final int EM_CAR_17                            = 17;  // 小型普通客车
        public static final int EM_CAR_18                            = 18;  // 小型越野客车
        public static final int EM_CAR_19                            = 19;  // 小型轿车
        public static final int EM_CAR_20                            = 20;  // 小型专用客车
        public static final int EM_CAR_21                            = 21;  // 小型专用校车
        public static final int EM_CAR_22                            = 22;  // 小型面包车
        public static final int EM_CAR_23                            = 23;  // 微型普通客车
        public static final int EM_CAR_24                            = 24;  // 微型越野客车
        public static final int EM_CAR_25                            = 25;  // 微型轿车
        public static final int EM_CAR_26                            = 26;  // 微型面包车
        public static final int EM_CAR_27                            = 27;  // 重型半挂牵引车
        public static final int EM_CAR_28                            = 28;  // 重型全挂牵引车
        public static final int EM_CAR_29                            = 29;  // 中型半挂牵引车
        public static final int EM_CAR_30                            = 30;  // 中型全挂牵引车
        public static final int EM_CAR_31                            = 31;  // 轻型半挂牵引车
        public static final int EM_CAR_32                            = 32;  // 轻型全挂牵引车
        public static final int EM_CAR_33                            = 33;  // 大型非载货专项作业车
        public static final int EM_CAR_34                            = 34;  // 大型载货专项作业车
        public static final int EM_CAR_35                            = 35;  // 中型非载货专项作业车
        public static final int EM_CAR_36                            = 36;  // 中型载货专项作业车
        public static final int EM_CAR_37                            = 37;  // 小型非载货专项作业车
        public static final int EM_CAR_38                            = 38;  // 小型载货专项作业车
        public static final int EM_CAR_39                            = 39;  // 微型非载货专项作业车
        public static final int EM_CAR_40                            = 40;  // 微型载货专项作业车
        public static final int EM_CAR_41                            = 41;  // 重型非载货专项作业车
        public static final int EM_CAR_42                            = 42;  // 重型载货专项作业车
        public static final int EM_CAR_43                            = 43;  // 轻型非载货专项作业车
        public static final int EM_CAR_44                            = 44;  // 轻型载货专项作业车
        public static final int EM_CAR_45                            = 45;  // 普通正三轮摩托车
        public static final int EM_CAR_46                            = 46;  // 轻便正三轮摩托车
        public static final int EM_CAR_47                            = 47;  // 正三轮载客摩托车
        public static final int EM_CAR_48                            = 48;  // 正三轮载货摩托车
        public static final int EM_CAR_49                            = 49;  // 侧三轮摩托车
        public static final int EM_CAR_50                            = 50;  // 普通二轮摩托车
        public static final int EM_CAR_51                            = 51;  // 轻便二轮摩托车
        public static final int EM_CAR_52                            = 52;  // 无轨电车
        public static final int EM_CAR_53                            = 53;  // 有轨电车
        public static final int EM_CAR_54                            = 54;  // 三轮汽车
        public static final int EM_CAR_55                            = 55;  // 轮式装载机械
        public static final int EM_CAR_56                            = 56;  // 轮式挖掘机械
        public static final int EM_CAR_57                            = 57;  // 轮式平地机械
        public static final int EM_CAR_58                            = 58;  // 重型普通货车
        public static final int EM_CAR_59                            = 59;  // 重型厢式货车
        public static final int EM_CAR_60                            = 60;  // 重型封闭货车
        public static final int EM_CAR_61                            = 61;  // 重型罐式货车
        public static final int EM_CAR_62                            = 62;  // 重型平板货车
        public static final int EM_CAR_63                            = 63;  // 重型集装箱车
        public static final int EM_CAR_64                            = 64;  // 重型自卸货车
        public static final int EM_CAR_65                            = 65;  // 重型特殊结构货车
        public static final int EM_CAR_66                            = 66;  // 重型仓栅式货车
        public static final int EM_CAR_67                            = 67;  // 重型车辆运输车
        public static final int EM_CAR_68                            = 68;  // 重型厢式自卸货车
        public static final int EM_CAR_69                            = 69;  // 重型罐式自卸货车
        public static final int EM_CAR_70                            = 70;  // 重型平板自卸货车
        public static final int EM_CAR_71                            = 71;  // 重型集装箱自卸货车
        public static final int EM_CAR_72                            = 72;  // 重型特殊结构自卸货车
        public static final int EM_CAR_73                            = 73;  // 重型仓栅式自卸货车
        public static final int EM_CAR_74                            = 74;  // 中型普通货车
        public static final int EM_CAR_75                            = 75;  // 中型厢式货车
        public static final int EM_CAR_76                            = 76;  // 中型封闭货车
        public static final int EM_CAR_77                            = 77;  // 中型罐式货车
        public static final int EM_CAR_78                            = 78;  // 中型平板货车
        public static final int EM_CAR_79                            = 79;  // 中型集装箱车
        public static final int EM_CAR_80                            = 80;  // 中型自卸货车
        public static final int EM_CAR_81                            = 81;  // 中型特殊结构货车
        public static final int EM_CAR_82                            = 82;  // 中型仓栅式货车
        public static final int EM_CAR_83                            = 83;  // 中型车辆运输车
        public static final int EM_CAR_84                            = 84;  // 中型厢式自卸货车
        public static final int EM_CAR_85                            = 85;  // 中型罐式自卸货车
        public static final int EM_CAR_86                            = 86;  // 中型平板自卸货车
        public static final int EM_CAR_87                            = 87;  // 中型集装箱自卸货车
        public static final int EM_CAR_88                            = 88;  // 中型特殊结构自卸货车
        public static final int EM_CAR_89                            = 89;  // 中型仓栅式自卸货车
        public static final int EM_CAR_90                            = 90;  // 轻型普通货车
        public static final int EM_CAR_91                            = 91;  // 轻型厢式货车
        public static final int EM_CAR_92                            = 92;  // 轻型封闭货车
        public static final int EM_CAR_93                            = 93;  // 轻型罐式货车
        public static final int EM_CAR_94                            = 94;  // 轻型平板货车
        public static final int EM_CAR_95                            = 95;  // 轻型自卸货车
        public static final int EM_CAR_96                            = 96;  // 轻型特殊结构货车
        public static final int EM_CAR_97                            = 97;  // 轻型仓栅式货车
        public static final int EM_CAR_98                            = 98;  // 轻型车辆运输车
        public static final int EM_CAR_99                            = 99;  // 轻型厢式自卸货车
        public static final int EM_CAR_100                           = 100;  // 轻型罐式自卸货车
        public static final int EM_CAR_101                           = 101;  // 轻型平板自卸货车
        public static final int EM_CAR_102                           = 102;  // 轻型特殊结构自卸货车
        public static final int EM_CAR_103                           = 103;  // 轻型仓栅式自卸货车
        public static final int EM_CAR_104                           = 104;  // 微型普通货车
        public static final int EM_CAR_105                           = 105;  // 微型厢式货车
        public static final int EM_CAR_106                           = 106;  // 微型封闭货车
        public static final int EM_CAR_107                           = 107;  // 微型罐式货车
        public static final int EM_CAR_108                           = 108;  // 微型自卸货车
        public static final int EM_CAR_109                           = 109;  // 微型特殊结构货车
        public static final int EM_CAR_110                           = 110;  // 微型仓栅式货车
        public static final int EM_CAR_111                           = 111;  // 微型车辆运输车
        public static final int EM_CAR_112                           = 112;  // 微型厢式自卸货车
        public static final int EM_CAR_113                           = 113;  // 微型罐式自卸货车
        public static final int EM_CAR_114                           = 114;  // 微型特殊结构自卸货车
        public static final int EM_CAR_115                           = 115;  // 微型仓栅式自卸货车
        public static final int EM_CAR_116                           = 116;  // 普通低速货车
        public static final int EM_CAR_117                           = 117;  // 厢式低速货车
        public static final int EM_CAR_118                           = 118;  // 罐式低速货车
        public static final int EM_CAR_119                           = 119;  // 自卸低速货车
        public static final int EM_CAR_120                           = 120;  // 仓栅式低速货车
        public static final int EM_CAR_121                           = 121;  // 厢式自卸低速货车
        public static final int EM_CAR_122                           = 122;  // 罐式自卸低速货车
        public static final int EM_CAR_123                           = 123;  // 重型普通全挂车
        public static final int EM_CAR_124                           = 124;  // 重型厢式全挂车
        public static final int EM_CAR_125                           = 125;  // 重型罐式全挂车
        public static final int EM_CAR_126                           = 126;  // 重型平板全挂车
        public static final int EM_CAR_127                           = 127;  // 重型集装箱全挂车
        public static final int EM_CAR_128                           = 128;  // 重型自卸全挂车
        public static final int EM_CAR_129                           = 129;  // 重型仓栅式全挂车
        public static final int EM_CAR_130                           = 130;  // 重型旅居全挂车
        public static final int EM_CAR_131                           = 131;  // 重型专项作业全挂车
        public static final int EM_CAR_132                           = 132;  // 重型厢式自卸全挂车
        public static final int EM_CAR_133                           = 133;  // 重型罐式自卸全挂车
        public static final int EM_CAR_134                           = 134;  // 重型平板自卸全挂车
        public static final int EM_CAR_135                           = 135;  // 重型集装箱自卸全挂车
        public static final int EM_CAR_136                           = 136;  // 重型仓栅式自卸全挂车
        public static final int EM_CAR_137                           = 137;  // 重型专项作业自卸全挂车
        public static final int EM_CAR_138                           = 138;  // 中型普通全挂车
        public static final int EM_CAR_139                           = 139;  // 中型厢式全挂车
        public static final int EM_CAR_140                           = 140;  // 中型罐式全挂车
        public static final int EM_CAR_141                           = 141;  // 中型平板全挂车
        public static final int EM_CAR_142                           = 142;  // 中型集装箱全挂车
        public static final int EM_CAR_143                           = 143;  // 中型自卸全挂车
        public static final int EM_CAR_144                           = 144;  // 中型仓栅式全挂车
        public static final int EM_CAR_145                           = 145;  // 中型旅居全挂车
        public static final int EM_CAR_146                           = 146;  // 中型专项作业全挂车
        public static final int EM_CAR_147                           = 147;  // 中型厢式自卸全挂车
        public static final int EM_CAR_148                           = 148;  // 中型罐式自卸全挂车
        public static final int EM_CAR_149                           = 149;  // 中型平板自卸全挂车
        public static final int EM_CAR_150                           = 150;  // 中型集装箱自卸全挂车
        public static final int EM_CAR_151                           = 151;  // 中型仓栅式自卸全挂车
        public static final int EM_CAR_152                           = 152;  // 中型专项作业自卸全挂车
        public static final int EM_CAR_153                           = 153;  // 轻型普通全挂车
        public static final int EM_CAR_154                           = 154;  // 轻型厢式全挂车
        public static final int EM_CAR_155                           = 155;  // 轻型罐式全挂车
        public static final int EM_CAR_156                           = 156;  // 轻型平板全挂车
        public static final int EM_CAR_157                           = 157;  // 轻型自卸全挂车
        public static final int EM_CAR_158                           = 158;  // 轻型仓栅式全挂车
        public static final int EM_CAR_159                           = 159;  // 轻型旅居全挂车
        public static final int EM_CAR_160                           = 160;  // 轻型专项作业全挂车
        public static final int EM_CAR_161                           = 161;  // 轻型厢式自卸全挂车
        public static final int EM_CAR_162                           = 162;  // 轻型罐式自卸全挂车
        public static final int EM_CAR_163                           = 163;  // 轻型平板自卸全挂车
        public static final int EM_CAR_164                           = 164;  // 轻型集装箱自卸全挂车
        public static final int EM_CAR_165                           = 165;  // 轻型仓栅式自卸全挂车
        public static final int EM_CAR_166                           = 166;  // 轻型专项作业自卸全挂车
        public static final int EM_CAR_167                           = 167;  // 重型普通半挂车
        public static final int EM_CAR_168                           = 168;  // 重型厢式半挂车
        public static final int EM_CAR_169                           = 169;  // 重型罐式半挂车
        public static final int EM_CAR_170                           = 170;  // 重型平板半挂车
        public static final int EM_CAR_171                           = 171;  // 重型集装箱半挂车
        public static final int EM_CAR_172                           = 172;  // 重型自卸半挂车
        public static final int EM_CAR_173                           = 173;  // 重型特殊结构半挂车
        public static final int EM_CAR_174                           = 174;  // 重型仓栅式半挂车
        public static final int EM_CAR_175                           = 175;  // 重型旅居半挂车
        public static final int EM_CAR_176                           = 176;  // 重型专项作业半挂车
        public static final int EM_CAR_177                           = 177;  // 重型低平板半挂车
        public static final int EM_CAR_178                           = 178;  // 重型车辆运输半挂车
        public static final int EM_CAR_179                           = 179;  // 重型罐式自卸半挂车
        public static final int EM_CAR_180                           = 180;  // 重型平板自卸半挂车
        public static final int EM_CAR_181                           = 181;  // 重型集装箱自卸半挂车
        public static final int EM_CAR_182                           = 182;  // 重型特殊结构自卸半挂车
        public static final int EM_CAR_183                           = 183;  // 重型仓栅式自卸半挂车
        public static final int EM_CAR_184                           = 184;  // 重型专项作业自卸半挂车
        public static final int EM_CAR_185                           = 185;  // 重型低平板自卸半挂车
        public static final int EM_CAR_186                           = 186;  // 重型中置轴旅居挂车
        public static final int EM_CAR_187                           = 187;  // 重型中置轴车辆运输车
        public static final int EM_CAR_188                           = 188;  // 重型中置轴普通挂车
        public static final int EM_CAR_189                           = 189;  // 中型普通半挂车
        public static final int EM_CAR_190                           = 190;  // 中型厢式半挂车
        public static final int EM_CAR_191                           = 191;  // 中型罐式半挂车
        public static final int EM_CAR_192                           = 192;  // 中型平板半挂车
        public static final int EM_CAR_193                           = 193;  // 中型集装箱半挂车
        public static final int EM_CAR_194                           = 194;  // 中型自卸半挂车
        public static final int EM_CAR_195                           = 195;  // 中型特殊结构半挂车
        public static final int EM_CAR_196                           = 196;  // 中型仓栅式半挂车
        public static final int EM_CAR_197                           = 197;  // 中型旅居半挂车
        public static final int EM_CAR_198                           = 198;  // 中型专项作业半挂车
        public static final int EM_CAR_199                           = 199;  // 中型低平板半挂车
        public static final int EM_CAR_200                           = 200;  // 中型车辆运输半挂车
        public static final int EM_CAR_201                           = 201;  // 中型罐式自卸半挂车
        public static final int EM_CAR_202                           = 202;  // 中型平板自卸半挂车
        public static final int EM_CAR_203                           = 203;  // 中型集装箱自卸半挂车
        public static final int EM_CAR_204                           = 204;  // 中型特殊结构自卸挂车
        public static final int EM_CAR_205                           = 205;  // 中型仓栅式自卸半挂车
        public static final int EM_CAR_206                           = 206;  // 中型专项作业自卸半挂车
        public static final int EM_CAR_207                           = 207;  // 中型低平板自卸半挂车
        public static final int EM_CAR_208                           = 208;  // 中型中置轴旅居挂车
        public static final int EM_CAR_209                           = 209;  // 中型中置轴车辆运输车
        public static final int EM_CAR_210                           = 210;  // 中型中置轴普通挂车
        public static final int EM_CAR_211                           = 211;  // 轻型普通半挂车
        public static final int EM_CAR_212                           = 212;  // 轻型厢式半挂车
        public static final int EM_CAR_213                           = 213;  // 轻型罐式半挂车
        public static final int EM_CAR_214                           = 214;  // 轻型平板半挂车
        public static final int EM_CAR_215                           = 215;  // 轻型自卸半挂车
        public static final int EM_CAR_216                           = 216;  // 轻型仓栅式半挂车
        public static final int EM_CAR_217                           = 217;  // 轻型旅居半挂车
        public static final int EM_CAR_218                           = 218;  // 轻型专项作业半挂车
        public static final int EM_CAR_219                           = 219;  // 轻型低平板半挂车
        public static final int EM_CAR_220                           = 220;  // 轻型车辆运输半挂车
        public static final int EM_CAR_221                           = 221;  // 轻型罐式自卸半挂车
        public static final int EM_CAR_222                           = 222;  // 轻型平板自卸半挂车
        public static final int EM_CAR_223                           = 223;  // 轻型集装箱自卸半挂车
        public static final int EM_CAR_224                           = 224;  // 轻型特殊结构自卸挂车
        public static final int EM_CAR_225                           = 225;  // 轻型仓栅式自卸半挂车
        public static final int EM_CAR_226                           = 226;  // 轻型专项作业自卸半挂车
        public static final int EM_CAR_227                           = 227;  // 轻型低平板自卸半挂车
        public static final int EM_CAR_228                           = 228;  // 轻型中置轴旅居挂车
        public static final int EM_CAR_229                           = 229;  // 轻型中置轴车辆运输车
        public static final int EM_CAR_230                           = 230;  // 轻型中置轴普通挂车
    }

    // 号牌类型
    public static class EM_PLATE_TYPE extends SdkStructure
    {
        public static final int EM_PLATE_OTHER                       = 0;   // 其他车
        public static final int EM_PLATE_BIG_CAR                     = 1;   // 大型汽车
        public static final int EM_PLATE_SMALL_CAR                   = 2;   // 小型汽车
        public static final int EM_PLATE_EMBASSY_CAR                 = 3;   // 使馆汽车
        public static final int EM_PLATE_CONSULATE_CAR               = 4;   // 领馆汽车
        public static final int EM_PLATE_ABROAD_CAR                  = 5;   // 境外汽车
        public static final int EM_PLATE_FOREIGN_CAR                 = 6;   // 外籍汽车
        public static final int EM_PLATE_LOW_SPEED_CAR               = 7;   // 低速车
        public static final int EM_PLATE_COACH_CAR                   = 8;   // 教练车
        public static final int EM_PLATE_MOTORCYCLE                  = 9;   // 摩托车
        public static final int EM_PLATE_NEW_POWER_CAR               = 10;  // 新能源车
        public static final int EM_PLATE_POLICE_CAR                  = 11;  // 警用车
        public static final int EM_PLATE_HONGKONG_MACAO_CAR          = 12;  // 港澳两地车
        public static final int EM_PLATE_ARMEDPOLICE_CAR             = 13;  // 武警车辆
        public static final int EM_PLATE_MILITARY_CAR                = 14;  // JD车辆
    }

    // 车身颜色
    public static class EM_CAR_COLOR_TYPE extends SdkStructure
    {
        public static final int EM_CAR_COLOR_WHITE                   = 0;   // 白色
        public static final int EM_CAR_COLOR_BLACK                   = 1;   // 黑色
        public static final int EM_CAR_COLOR_RED                     = 2;   // 红色
        public static final int EM_CAR_COLOR_YELLOW                  = 3;   // 黄色
        public static final int EM_CAR_COLOR_GRAY                    = 4;   // 灰色
        public static final int EM_CAR_COLOR_BLUE                    = 5;   // 蓝色
        public static final int EM_CAR_COLOR_GREEN                   = 6;   // 绿色
        public static final int EM_CAR_COLOR_PINK                    = 7;   // 粉色
        public static final int EM_CAR_COLOR_PURPLE                  = 8;   // 紫色
        public static final int EM_CAR_COLOR_DARK_PURPLE             = 9;   // 暗紫色
        public static final int EM_CAR_COLOR_BROWN                   = 10;  // 棕色
        public static final int EM_CAR_COLOR_MAROON                  = 11;  // 粟色
        public static final int EM_CAR_COLOR_SILVER_GRAY             = 12;  // 银灰色
        public static final int EM_CAR_COLOR_DARK_GRAY               = 13;  // 暗灰色
        public static final int EM_CAR_COLOR_WHITE_SMOKE             = 14;  // 白烟色
        public static final int EM_CAR_COLOR_DEEP_ORANGE             = 15;  // 深橙色
        public static final int EM_CAR_COLOR_LIGHT_ROSE              = 16;  // 浅玫瑰色
        public static final int EM_CAR_COLOR_TOMATO_RED              = 17;  // 番茄红色
        public static final int EM_CAR_COLOR_OLIVE                   = 18;  // 橄榄色
        public static final int EM_CAR_COLOR_GOLDEN                  = 19;  // 金色
        public static final int EM_CAR_COLOR_DARK_OLIVE              = 20;  // 暗橄榄色
        public static final int EM_CAR_COLOR_YELLOW_GREEN            = 21;  // 黄绿色
        public static final int EM_CAR_COLOR_GREEN_YELLOW            = 22;  // 绿黄色
        public static final int EM_CAR_COLOR_FOREST_GREEN            = 23;  // 森林绿
        public static final int EM_CAR_COLOR_OCEAN_BLUE              = 24;  // 海洋绿
        public static final int EM_CAR_COLOR_DEEP_SKYBLUE            = 25;  // 深天蓝
        public static final int EM_CAR_COLOR_CYAN                    = 26;  // 青色
        public static final int EM_CAR_COLOR_DEEP_BLUE               = 27;  // 深蓝色
        public static final int EM_CAR_COLOR_DEEP_RED                = 28;  // 深红色
        public static final int EM_CAR_COLOR_DEEP_GREEN              = 29;  // 深绿色
        public static final int EM_CAR_COLOR_DEEP_YELLOW             = 30;  // 深黄色
        public static final int EM_CAR_COLOR_DEEP_PINK               = 31;  // 深粉色
        public static final int EM_CAR_COLOR_DEEP_PURPLE             = 32;  // 深紫色
        public static final int EM_CAR_COLOR_DEEP_BROWN              = 33;  // 深棕色
        public static final int EM_CAR_COLOR_DEEP_CYAN               = 34;  // 深青色
        public static final int EM_CAR_COLOR_ORANGE                  = 35;  // 橙色
        public static final int EM_CAR_COLOR_DEEP_GOLDEN             = 36;  // 深金色
        public static final int EM_CAR_COLOR_OTHER                   = 255;  // 未识别、其他
    }

    // 使用性质
    public static class EM_USE_PROPERTY_TYPE extends SdkStructure
    {
        public static final int EM_USE_PROPERTY_NONOPERATING         = 0;   // 非营运
        public static final int EM_USE_PROPERTY_HIGWAY               = 1;   // 公路客运,旅游客运
        public static final int EM_USE_PROPERTY_BUS                  = 2;   // 公交客运
        public static final int EM_USE_PROPERTY_TAXI                 = 3;   // 出租客运
        public static final int EM_USE_PROPERTY_FREIGHT              = 4;   // 货运
        public static final int EM_USE_PROPERTY_LEASE                = 5;   // 租赁
        public static final int EM_USE_PROPERTY_SECURITY             = 6;   // 警用,消防,救护,工程救险
        public static final int EM_USE_PROPERTY_COACH                = 7;   // 教练
        public static final int EM_USE_PROPERTY_SCHOOLBUS            = 8;   // 幼儿校车,小学生校车,其他校车
        public static final int EM_USE_PROPERTY_FOR_DANGE_VEHICLE    = 9;   // 危化品运输
        public static final int EM_USE_PROPERTY_OTHER                = 10;  // 其他
        public static final int EM_USE_PROPERTY_ONLINE_CAR_HAILING   = 11;  // 网约车
    }

    // 大类业务方案
    public static class EM_CLASS_TYPE extends SdkStructure
    {
        public static final int EM_CLASS_UNKNOWN                     = 0;   // 未知业务
        public static final int EM_CLASS_VIDEO_SYNOPSIS              = 1;   // 视频浓缩
        public static final int EM_CLASS_TRAFFIV_GATE                = 2;   // 卡口
        public static final int EM_CLASS_ELECTRONIC_POLICE           = 3;   // 电警
        public static final int EM_CLASS_SINGLE_PTZ_PARKING          = 4;   // 单球违停
        public static final int EM_CLASS_PTZ_PARKINBG                = 5;   // 主从违停
        public static final int EM_CLASS_TRAFFIC                     = 6;   // 交通事件"Traffic"
        public static final int EM_CLASS_NORMAL                      = 7;   // 通用行为分析"Normal"
        public static final int EM_CLASS_PRISON                      = 8;   // 监所行为分析"Prison"
        public static final int EM_CLASS_ATM                         = 9;   // 金融行为分析"ATM"
        public static final int EM_CLASS_METRO                       = 10;  // 地铁行为分析
        public static final int EM_CLASS_FACE_DETECTION              = 11;  // 人脸检测"FaceDetection"
        public static final int EM_CLASS_FACE_RECOGNITION            = 12;  // 人脸识别"FaceRecognition"
        public static final int EM_CLASS_NUMBER_STAT                 = 13;  // 人数统计"NumberStat"
        public static final int EM_CLASS_HEAT_MAP                    = 14;  // 热度图"HeatMap"
        public static final int EM_CLASS_VIDEO_DIAGNOSIS             = 15;  // 视频诊断"VideoDiagnosis"
        public static final int EM_CLASS_VIDEO_ENHANCE               = 16;  // 视频增强
        public static final int EM_CLASS_SMOKEFIRE_DETECT            = 17;  // 烟火检测
        public static final int EM_CLASS_VEHICLE_ANALYSE             = 18;  // 车辆特征识别"VehicleAnalyse"
        public static final int EM_CLASS_PERSON_FEATURE              = 19;  // 人员特征识别
        public static final int EM_CLASS_SDFACEDETECTION             = 20;  // 多预置点人脸检测"SDFaceDetect"
        //配置一条规则但可以在不同预置点下生效
        public static final int EM_CLASS_HEAT_MAP_PLAN               = 21;  // 球机热度图计划"HeatMapPlan"
        public static final int EM_CLASS_NUMBERSTAT_PLAN             = 22;  // 球机客流量统计计划 "NumberStatPlan"
        public static final int EM_CLASS_ATMFD                       = 23;  // 金融人脸检测，包括正常人脸、异常人脸、相邻人脸、头盔人脸等针对ATM场景特殊优化
        public static final int EM_CLASS_HIGHWAY                     = 24;  // 高速交通事件检测"Highway"
        public static final int EM_CLASS_CITY                        = 25;  // 城市交通事件检测 "City"
        public static final int EM_CLASS_LETRACK                     = 26;  // 民用简易跟踪"LeTrack"
        public static final int EM_CLASS_SCR                         = 27;  // 打靶相机"SCR"
        public static final int EM_CLASS_STEREO_VISION               = 28;  // 立体视觉(双目)"StereoVision"
        public static final int EM_CLASS_HUMANDETECT                 = 29;  // 人体检测"HumanDetect"
        public static final int EM_CLASS_FACE_ANALYSIS               = 30;  // 人脸分析 "FaceAnalysis"
        public static final int EM_CALSS_XRAY_DETECTION              = 31;  // X光检测 "XRayDetection"
        public static final int EM_CLASS_STEREO_NUMBER               = 32;  // 双目相机客流量统计 "StereoNumber"
        public static final int EM_CLASS_CROWDDISTRIMAP              = 33;  // 人群分布图
        public static final int EM_CLASS_OBJECTDETECT                = 34;  // 目标检测
        public static final int EM_CLASS_FACEATTRIBUTE               = 35;  // IVSS人脸检测 "FaceAttribute"
        public static final int EM_CLASS_FACECOMPARE                 = 36;  // IVSS人脸识别 "FaceCompare"
        public static final int EM_CALSS_STEREO_BEHAVIOR             = 37;  // 立体行为分析 "StereoBehavior"
        public static final int EM_CALSS_INTELLICITYMANAGER          = 38;  // 智慧城管 "IntelliCityMgr"
        public static final int EM_CALSS_PROTECTIVECABIN             = 39;  // 防护舱（ATM舱内）"ProtectiveCabin"
        public static final int EM_CALSS_AIRPLANEDETECT              = 40;  // 飞机行为检测 "AirplaneDetect"
        public static final int EM_CALSS_CROWDPOSTURE                = 41;  // 人群态势（人群分布图服务）"CrowdPosture"
        public static final int EM_CLASS_PHONECALLDETECT             = 42;  // 打电话检测 "PhoneCallDetect"
        public static final int EM_CLASS_SMOKEDETECTION              = 43;  // 烟雾检测 "SmokeDetection"
        public static final int EM_CLASS_BOATDETECTION               = 44;  // 船只检测 "BoatDetection"
        public static final int EM_CLASS_SMOKINGDETECT               = 45;  // 吸烟检测 "SmokingDetect"
        public static final int EM_CLASS_WATERMONITOR                = 46;  // 水利监测 "WaterMonitor"
        public static final int EM_CLASS_GENERATEGRAPHDETECTION      = 47;  // 生成图规则 "GenerateGraphDetection"
        public static final int EM_CLASS_TRAFFIC_PARK                = 48;  // 交通停车 "TrafficPark"
        public static final int EM_CLASS_OPERATEMONITOR              = 49;  // 作业检测 "OperateMonitor"
        public static final int EM_CLASS_INTELLI_RETAIL              = 50;  // 智慧零售大类 "IntelliRetail"
        public static final int EM_CLASS_CLASSROOM_ANALYSE           = 51;  // 教育智慧课堂"ClassroomAnalyse"
        public static final int EM_CLASS_FEATURE_ABSTRACT            = 52;  // 特征向量提取大类 "FeatureAbstract"
        public static final int EM_CLASS_CROWD_ABNORMAL				 = 60;	// 人群异常检测 "CrowdAbnormal"
        public static final int EM_CLASS_ANATOMY_TEMP_DETECT		 = 63;	// 人体温智能检测 "AnatomyTempDetect"
        public static final int EM_CLASS_WEATHER_MONITOR			 = 64;	// 天气监控 "WeatherMonitor"
    }

    // 交通车辆行驶方向类型
    public static class EM_TRAFFICCAR_MOVE_DIRECTION extends SdkStructure
    {
        public static final int EM_TRAFFICCAR_MOVE_DIRECTION_UNKNOWN = 0;   // 未知的
        public static final int EM_TRAFFICCAR_MOVE_DIRECTION_STRAIGHT = 1;   // 直行
        public static final int EM_TRAFFICCAR_MOVE_DIRECTION_TURN_LEFT = 2;   // 左转
        public static final int EM_TRAFFICCAR_MOVE_DIRECTION_TURN_RIGHT = 3;   // 右转
        public static final int EM_TRAFFICCAR_MOVE_DIRECTION_TURN_AROUND = 4;   // 掉头
    }

    // 货物通道信息（IPC捷克物流定制）
    public static class NET_CUSTOM_INFO extends SdkStructure
    {
        public int                            nCargoChannelNum;                     // 货物通道个数
        public float[]                        fCoverageRate = new float[MAX_CARGO_CHANNEL_NUM];  // 货物覆盖率
        public byte[]                         byReserved = new byte[40];            // 保留字节
    }

    // 车辆物件类型
    public static class EM_COMM_ATTACHMENT_TYPE extends SdkStructure
    {
        public static final int COMM_ATTACHMENT_TYPE_UNKNOWN         = 0;   // 未知类型
        public static final int COMM_ATTACHMENT_TYPE_FURNITURE       = 1;   // 摆件
        public static final int COMM_ATTACHMENT_TYPE_PENDANT         = 2;   // 挂件
        public static final int COMM_ATTACHMENT_TYPE_TISSUEBOX       = 3;   // 纸巾盒
        public static final int COMM_ATTACHMENT_TYPE_DANGER          = 4;   // 危险品
        public static final int COMM_ATTACHMENT_TYPE_PERFUMEBOX      = 5;   // 香水
    }

    // 按功能划分的车辆类型
    public static class EM_VEHICLE_TYPE_BY_FUNC extends SdkStructure
    {
        public static final int EM_VEHICLE_TYPE_BY_FUNC_UNKNOWN      = 0;   // 未知
        /*以下为特种车辆类型*/
        public static final int EM_VEHICLE_TYPE_BY_FUNC_TANK_CAR     = 1;   // 危化品车辆
        public static final int EM_VEHICLE_TYPE_BY_FUNC_SLOT_TANK_CAR = 2;   // 槽罐车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_DREGS_CAR    = 3;   // 渣土车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_CONCRETE_MIXER_TRUCK = 4;   // 混凝土搅拌车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_TAXI         = 5;   // 出租车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_POLICE       = 6;   // 警车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_AMBULANCE    = 7;   // 救护车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_GENERAL      = 8;   // 普通车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_WATERING_CAR = 9;   // 洒水车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_FIRE_ENGINE  = 10;  // 消防车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_MACHINESHOP_TRUCK = 11;  // 工程车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_POWER_LOT_VEHICLE = 12;  // 粉粒物料车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_SUCTION_SEWAGE_TRUCK = 13;  // 吸污车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_NORMAL_TANK_TRUCK = 14;  // 普通罐车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_SCHOOL_BUS   = 15;  // 校车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_EXCAVATOR    = 16;  // 挖掘机
        public static final int EM_VEHICLE_TYPE_BY_FUNC_BULLDOZER    = 17;  // 推土车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_CRANE        = 18;  // 吊车
        public static final int EM_VEHICLE_TYPE_BY_FUNC_PUMP_TRUCK   = 19;  // 泵车
        /*以上为特种车辆类型*/
    }

    // 标准车辆类型
    public static class EM_STANDARD_VEHICLE_TYPE extends SdkStructure
    {
        public static final int EM_STANDARD_VEHICLE_UNKNOWN          = 0;   // 未知
        public static final int EM_STANDARD_VEHICLE_MOTOR            = 1;   // 机动车
        public static final int EM_STANDARD_VEHICLE_BUS              = 2;   // 公交车
        public static final int EM_STANDARD_VEHICLE_UNLICENSED_MOTOR = 3;   // 无牌机动车
        public static final int EM_STANDARD_VEHICLE_LARGE_CAR        = 4;   // 大型汽车
        public static final int EM_STANDARD_VEHICLE_MICRO_CAR        = 5;   // 小型汽车
        public static final int EM_STANDARD_VEHICLE_EMBASSY_CAR      = 6;   // 使馆汽车
        public static final int EM_STANDARD_VEHICLE_MARGINAL_CAR     = 7;   // 领馆汽车
        public static final int EM_STANDARD_VEHICLE_AREAOUT_CAR      = 8;   // 境外汽车
        public static final int EM_STANDARD_VEHICLE_FOREIGN_CAR      = 9;   // 外籍汽车
        public static final int EM_STANDARD_VEHICLE_FARM_TRANS_CAR   = 10;  // 农用运输车
        public static final int EM_STANDARD_VEHICLE_TRACTOR          = 11;  // 拖拉机
        public static final int EM_STANDARD_VEHICLE_TRAILER          = 12;  // 挂车
        public static final int EM_STANDARD_VEHICLE_COACH_CAR        = 13;  // 教练汽车
        public static final int EM_STANDARD_VEHICLE_TRIAL_CAR        = 14;  // 试验汽车
        public static final int EM_STANDARD_VEHICLE_TEMPORARYENTRY_CAR = 15;  // 临时入境汽车
        public static final int EM_STANDARD_VEHICLE_TEMPORARYENTRY_MOTORCYCLE = 16;  // 临时入境摩托
        public static final int EM_STANDARD_VEHICLE_TEMPORARY_STEER_CAR = 17;  // 临时行驶车
        public static final int EM_STANDARD_VEHICLE_LARGE_TRUCK      = 18;  // 大货车
        public static final int EM_STANDARD_VEHICLE_MID_TRUCK        = 19;  // 中货车
        public static final int EM_STANDARD_VEHICLE_MICRO_TRUCK      = 20;  // 小货车
        public static final int EM_STANDARD_VEHICLE_MICROBUS         = 21;  // 面包车
        public static final int EM_STANDARD_VEHICLE_SALOON_CAR       = 22;  // 轿车
        public static final int EM_STANDARD_VEHICLE_CARRIAGE         = 23;  // 小轿车
        public static final int EM_STANDARD_VEHICLE_MINI_CARRIAGE    = 24;  // 微型轿车
        public static final int EM_STANDARD_VEHICLE_SUV_MPV          = 25;  // SUV或者MPV
        public static final int EM_STANDARD_VEHICLE_SUV              = 26;  // SUV
        public static final int EM_STANDARD_VEHICLE_MPV              = 27;  // MPV
        public static final int EM_STANDARD_VEHICLE_PASSENGER_CAR    = 28;  // 客车
        public static final int EM_STANDARD_VEHICLE_MOTOR_BUS        = 29;  // 大客车
        public static final int EM_STANDARD_VEHICLE_MID_PASSENGER_CAR = 30;  // 中客车
        public static final int EM_STANDARD_VEHICLE_MINI_BUS         = 31;  // 小客车
        public static final int EM_STANDARD_VEHICLE_PICKUP           = 32;  // 皮卡车
        public static final int EM_STANDARD_VEHICLE_OILTANK_TRUCK    = 33;  // 油罐车
    }

    // 报警事件类型 EVENT_ALARM_LOCALALARM(外部报警),EVENT_ALARM_MOTIONALARM(动检报警)报警)
    public static class DEV_EVENT_ALARM_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[128];               // 事件名称
        public byte[]                         Reserved = new byte[4];               // 保留字节对齐
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID

        public NET_EVENT_FILE_INFO            stuFileInfo;                          // 事件对应文件信息
        public EVENT_COMM_INFO                stCommInfo;                           // 公共信息
        public byte                           byEventAction;								// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]                         byReserved=new byte[3];
    }

    // 报警事件类型 EVENT_ALARM_VIDEOBLIND(视频遮挡报警)
    public static class DEV_EVENT_ALARM_VIDEOBLIND extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[128];               // 事件名称
        public byte[]                         Reserved = new byte[4];               // 保留字节对齐
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID

        public NET_TIME_EX                    stuTime;                              // 事件发生的时间, (设备时间, 不一定是utc时间)
        public byte[]                         szDriverID=new byte[32];                             // 司机ID
        public NET_GPS_STATUS_INFO stuGPSStatus;                               // GPS信息
        public byte[]             szVideoPath=new byte[256];                           // 违章关联视频FTP上传路径
        public byte[]             byReserved2=new byte[1024];//保留字段
    }

    // 事件类型 EVENT_IVS_HIGHSPEED(车辆超速报警事件）对应的数据块描述信息
    public static class DEV_EVENT_HIGHSPEED_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public int                            nAction;                              // 事件动作,1表示持续性事件开始,2表示持续性事件结束;
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public byte[]                         byReserved = new byte[4];             // 保留字节
        public double                         dbPTS;                                // 时间戳(单位是毫秒)
        public NET_GPS_STATUS_INFO            stGPSStatusInfo;                      // GPS信息
        public int                            nSpeedLimit;                          // 车连限速值(km/h)
        public int                            nCurSpeed;                            // 当前车辆速度(km/h)
        public int                            nMaxSpeed;                            // 最高速度(Km/h)
        public NET_TIME_EX                    stuStartTime;                         // 开始时间(车载定制需求),nAction为2时上报此字段
        public byte[]                         byReserved1 = new byte[1024];         // 保留字节
    }

    // 事件类型EVENT_IVS_TIREDPHYSIOLOGICAL(生理疲劳驾驶事件)对应的数据块描述信息
    public static class DEV_EVENT_TIREDPHYSIOLOGICAL_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[NET_EVENT_NAME_LEN];  // 事件名称
        public byte[]                         bReserved1 = new byte[4];             // 字节对齐
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID

        public int                            nAction;                              // 0:脉冲 1:开始 2:停止
        public NET_GPS_STATUS_INFO            stuGPSStatus;                         // GPS信息
        public byte[]                         bReserved = new byte[1024];           // 保留字节,留待扩展.
    }

    // 事件类型EVENT_IVS_TRAFFIC_TIREDLOWERHEAD(开车低头报警事件)对应的数据块描述信息
    public static class DEV_EVENT_TIREDLOWERHEAD_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[NET_EVENT_NAME_LEN];  // 事件名称
        public byte[]                         bReserved1 = new byte[4];             // 字节对齐
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID

        public NET_GPS_STATUS_INFO            stuGPSStatus;                         // GPS信息
        public byte[]                         bReserved = new byte[1024];           // 保留字节,留待扩展.
    }

    // 事件类型EVENT_IVS_TRAFFIC_DRIVERLEAVEPOST(开车离岗报警事件)对应的数据块描述信息
    public static class DEV_EVENT_DRIVERLEAVEPOST_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[NET_EVENT_NAME_LEN];  // 事件名称
        public byte[]                         bReserved1 = new byte[4];             // 字节对齐
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID

        public NET_GPS_STATUS_INFO            stuGPSStatus;                         // GPS信息
        public byte[]                         bReserved = new byte[1024];           // 保留字节,留待扩展.
    }

    // 事件类型 EVENT_IVS_TRAFFIC_DRIVERYAWN (开车打哈欠事件) 对应的数据块描述信息
    public static class DEV_EVENT_DRIVERYAWN_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[NET_EVENT_NAME_LEN];  // 事件名称
        public byte[]                         szReserved1 = new byte[4];            // 字节对齐
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID

        public NET_GPS_STATUS_INFO            stuGPSStatus;                         // GPS信息
        public byte[]                         byReserved = new byte[1024];          // 保留字节,留待扩展.
    }

    // 事件类型 EVENT_IVS_FORWARDCOLLISION_WARNNING(前向碰撞预警) 对应的数据块描述信息
    public static class DEV_EVENT_FORWARDCOLLISION_WARNNING_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public int                            nEventID;                             // 事件ID
        public byte[]                         szName = new byte[NET_EVENT_NAME_LEN];  // 事件名称
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nAction;                              // 0:脉冲 1:开始 2:停止

        public NET_GPS_STATUS_INFO            stuGPSStatusInfo;                     // GPS信息
        public byte[]                         byReserved = new byte[1024];          // 保留字节
    }

    // 事件类型 EVNET_IVS_LANEDEPARTURE_WARNNING(车道偏移预警) 对应的数据块描述信息
    public static class DEV_EVENT_LANEDEPARTURE_WARNNING_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public int                            nEventID;                             // 事件ID
        public byte[]                         szName = new byte[NET_EVENT_NAME_LEN];  // 事件名称
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nAction;                              // 0:脉冲 1:开始 2:停止

        public NET_GPS_STATUS_INFO            stuGPSStatusInfo;                     // GPS信息
        public byte[]                         byReserved = new byte[1024];          // 保留字节
    }

    //图片路径类型
    public static class NET_PICTURE_PATH_TYPE extends SdkStructure
    {
        public static final int NET_PATH_LOCAL_PATH                  = 0;   // 本地硬盘或者sd卡成功写入路径
        public static final int NET_PATH_FTP_PATH                    = 1;   // 设备成功写到ftp服务器的路径
        public static final int NET_PATH_VIDEO_PATH                  = 2;   // 当前接入需要获取当前违章的关联视频的FTP上传路径
    }

    public static final int MAX_PIC_PATH_NUM               = 16;
    public static class NET_RESERVED_PATH extends SdkStructure
    {
        public int                            nMaxPathNum;                          // 图片路径总数,为0时采用设备默认路径
        public int[]                          emPictruePaths = new int[MAX_PIC_PATH_NUM];  // 图片路径类型，详见NET_PICTURE_PATH_TYPE
    }

    //离线传输参数
    public static class NET_OFFLINE_PARAM extends SdkStructure
    {
        public byte[]                         szClientID = new byte[20];            // 客户端mac地址，冒号分隔形式
        public byte[]                         byReserved = new byte[108];           // 保留
    }

    public static class NET_RESERVED_COMMON extends SdkStructure
    {
        public int                            dwStructSize;
        public Pointer                        pIntelBox;                            // 兼容RESERVED_TYPE_FOR_INTEL_BOX，指向ReservedDataIntelBox
        public int                            dwSnapFlagMask;                       // 抓图标志(按位),0位:"*",1位:"Timing",2位:"Manual",3位:"Marked",4位:"Event",5位:"Mosaic",6位:"Cutout"
        public Pointer                        pstuOfflineParam;                     // 离线传输参数，指向NET_OFFLINE_PARAM
        public Pointer                        pstuPath;                             // 兼容RESERVED_TYPE_FOR_PATH，指向NET_RESERVED_PATH
        public int            emPathMode;         // 返回的图片存储路径模式,对应枚举EM_PATH_MODE
        /**
         * 对应结构体{@link EM_FILTER_IMAGE_TYPE}
         */
        public Pointer   pImageType;         // 返回的图片类型, 由用户申请释放
        public int                     nImageTypeNum;      // pImageType 有效个数
        public NET_RESERVED_COMMON()
        {
            this.dwStructSize = this.size();
        }
    }

    // 事件类型EVENT_IVS_TRAFFIC_DRIVER_SMOKING (驾驶员抽烟事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_DRIVER_SMOKING extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[NET_EVENT_NAME_LEN];  // 事件名称
        public int                            nTriggerType;                         // TriggerType:触发类型,0车检器,1雷达,2视频
        public int                            PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID
        public int                            nSequence;                            // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public byte                           byEventAction;                        // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;    BYTE                    byReserved1[2];
        public byte                           byImageIndex;                         // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public byte[]                         byReserved1 = new byte[2];
        public NET_EVENT_FILE_INFO            stuFileInfo;                          // 事件对应文件信息
        public int                            nLane;                                // 对应车道号
        public int                            nMark;                                // 底层产生的触发抓拍帧标记
        public int                            nFrameSequence;                       // 视频分析帧序号
        public int                            nSource;                              // 视频分析的数据源地址
        public NET_MSG_OBJECT                 stuObject;                            // 检测到的物体
        public NET_MSG_OBJECT                 stuVehicle;                           // 车身信息
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;                        // 交通车辆信息
        public int                            nSpeed;                               // 车辆实际速度,Km/h
        public int                            dwSnapFlagMask;                       // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public NET_RESOLUTION_INFO            stuResolution;                        // 对应图片的分辨率
        public EVENT_COMM_INFO                stCommInfo;                           // 公共信息
        public NET_GPS_INFO                   stuGPSInfo;                           // GPS信息 车载定制
        public byte[]                         byReserved = new byte[984];           // 保留字节
    }

    // 事件类型EVENT_IVS_TRAFFIC_DRIVER_CALLING(驾驶员打电话事件)对应的数据块描述信息
    public static class DEV_EVENT_TRAFFIC_DRIVER_CALLING extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[NET_EVENT_NAME_LEN];  // 事件名称
        public int                            nTriggerType;                         // TriggerType:触发类型,0车检器,1雷达,2视频
        public int                            PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID
        public int                            nSequence;                            // 表示抓拍序号,如3,2,1,1表示抓拍结束,0表示异常结束
        public byte                           byEventAction;                        // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;    BYTE                    byReserved1[2];
        public byte                           byImageIndex;                         // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public byte[]                         byReserved1 = new byte[2];
        public NET_EVENT_FILE_INFO            stuFileInfo;                          // 事件对应文件信息
        public int                            nLane;                                // 对应车道号
        public int                            nMark;                                // 底层产生的触发抓拍帧标记
        public int                            nFrameSequence;                       // 视频分析帧序号
        public int                            nSource;                              // 视频分析的数据源地址
        public NET_MSG_OBJECT                 stuObject;                            // 检测到的物体
        public NET_MSG_OBJECT                 stuVehicle;                           // 车身信息
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO stuTrafficCar;                        // 交通车辆信息
        public int                            nSpeed;                               // 车辆实际速度,Km/h
        public int                            dwSnapFlagMask;                       // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public NET_RESOLUTION_INFO            stuResolution;                        // 对应图片的分辨率
        public EVENT_COMM_INFO                stCommInfo;                           // 公共信息
        public NET_GPS_INFO                   stuGPSInfo;                           // GPS信息 车载定制
        public byte[]                         byReserved = new byte[984];           // 保留字节
    }

    // 事件类型EVENT_IVS_TRAFFIC_DRIVERLOOKAROUND(开车左顾右盼报警事件)对应的数据块描述信息
    public static class DEV_EVENT_DRIVERLOOKAROUND_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[NET_EVENT_NAME_LEN];  // 事件名称
        public byte[]                         bReserved1 = new byte[4];             // 字节对齐
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID

        public NET_GPS_STATUS_INFO            stuGPSStatus;                         // GPS信息
        public byte[]                         bReserved = new byte[1024];           // 保留字节,留待扩展.
    }

    // 进站离站状态
    public static class NET_BUS_STATE extends SdkStructure
    {
        public static final int NET_BUS_STATE_UNKNOWN                = 0;   // 未知
        public static final int NET_BUS_STATE_ILLEGAL                = 1;   // 非法
        public static final int NET_BUS_STATE_LEGAL                  = 2;   // 合法
    }

    // 报警事件类型NET_ALARM_ENCLOSURE_ALARM(电子围栏事件)对应的数据描述信息
    public static class ALARM_ENCLOSURE_ALARM_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            dwAlarmType;                          // 报警类型, 按位分别表示,
        // 0:LimitSpeed, 1:DriveAllow, 2:ForbidDrive, 3:LoadGoods, 4:UploadGoods
        public int                            dwAlarmDetail;                        // 报警描述, 按位分别表示,
        // 0:DriveIn, 1:DriveOut, 2:Overspeed, 3:SpeedClear
        public int                            emState;                              // 是否按规定时间触发事件，详见NET_BUS_STATE
        public int                            dwDriverNo;                           // 司机编号
        public int                            dwEnclosureID;                        // 围栏ID
        public int                            dwLimitSpeed;                         // 限速
        public int                            dwCurrentSpeed;                       // 当前速度
        public NET_TIME_EX                    stuTime;                              // 当前时间
        public NET_GPS_STATUS_INFO            stuGPSStatusInfo;                     // GPS信息

        public ALARM_ENCLOSURE_ALARM_INFO()
        {
            this.dwSize = this.size();
        }
    }

    public static class DEV_SET_RESULT extends SdkStructure
    {
        public int               dwType;                     // 类型(即GetDevConfig和SetDevConfig的类型)
        public short             wResultCode;                // 返回码；0：成功,1：失败,2：数据不合法,3：暂时无法设置,4：没有权限
        public short             wRebootSign;                // 重启标志；0：不需要重启,1：需要重启才生效
        public int[]             dwReserved = new int[2];              // 保留
    }

    // ALARM_ENCLOSURE_INFO
    // 电子围栏报警
    public static class ALARM_ENCLOSURE_INFO extends SdkStructure
    {
        public int           nTypeNumber;                          // 有效电子围栏类型个数
        public byte[]        bType = new byte[16];                 // 电子围栏类型, 见 ENCLOSURE_TYPE
        public int           nAlarmTypeNumber;                     // 有效报警类型个数
        public byte[]        bAlarmType = new byte[16];            // 报警类型,见ENCLOSURE_ALARM_TYPE
        public byte[]        szDriverId = new byte[32];            // 司机工号
        public int           unEnclosureId;                        // 电子围栏ID
        public int           unLimitSpeed;                         // 限速,单位km/h
        public int           unCurrentSpeed;                       // 当前速度
        public NET_TIME      stAlarmTime;                          // 报警发生时间
        public int           dwLongitude;                          // 经度(单位是百万分之度,范围0-360度)如东经120.178274度表示为300178274
        public int           dwLatidude;                           // 纬度(单位是百万分之度,范围0-180度)如北纬30.183382度表示为12018338
        // 经纬度的具体转换方式可以参考结构体 NET_WIFI_GPS_INFO 中的注释
        public byte          bOffline;                             // 0-实时 1-补传
        public int           unTriggerCount;                       // 围栏触发次数
        public byte[]        byReserved = new byte[115];          // 保留字节
    }

    // NETDEV_3GFLOW_EXCEED_STATE_INFO
    // 3G流量超出阈值状态信息
    public static class NETDEV_3GFLOW_EXCEED_STATE_INFO extends SdkStructure
    {
        public byte                bState;                 // 3G流量超出阈值状态,0表示未超出阀值,1表示超出阀值
        public byte[]              reserve = new byte[31];
    }

    // 飞行器类型
    public static class ENUM_UAV_TYPE extends SdkStructure
    {
        public static final int ENUM_UAV_TYPE_GENERIC                = 0;   // 通用
        public static final int ENUM_UAV_TYPE_FIXED_WING             = 1;   // 固定翼
        public static final int ENUM_UAV_TYPE_QUADROTOR              = 2;   // 四轴
        public static final int ENUM_UAV_TYPE_COAXIAL                = 3;   // 共轴
        public static final int ENUM_UAV_TYPE_HELICOPTER             = 4;   // 直机
        public static final int ENUM_UAV_TYPE_ANTENNA_TRACKER        = 5;   // 地面跟踪天线
        public static final int ENUM_UAV_TYPE_GCS                    = 6;   // 地面站
        public static final int ENUM_UAV_TYPE_AIRSHIP                = 7;   // 有控飞艇
        public static final int ENUM_UAV_TYPE_FREE_BALLOON           = 8;   // 自由飞气球
        public static final int ENUM_UAV_TYPE_ROCKET                 = 9;   // 火箭
        public static final int ENUM_UAV_TYPE_GROUND_ROVER           = 10;  // 地面车辆
        public static final int ENUM_UAV_TYPE_SURFACE_BOAT           = 11;  // 水面船艇
        public static final int ENUM_UAV_TYPE_SUBMARINE              = 12;  // 潜艇
        public static final int ENUM_UAV_TYPE_HEXAROTOR              = 13;  // 六轴
        public static final int ENUM_UAV_TYPE_OCTOROTOR              = 14;  // 八轴
        public static final int ENUM_UAV_TYPE_TRICOPTER              = 15;  // 三轴
        public static final int ENUM_UAV_TYPE_FLAPPING_WING          = 16;  // 扑翼机
        public static final int ENUM_UAV_TYPE_KITE                   = 17;  // 风筝
        public static final int ENUM_UAV_TYPE_ONBOARD_CONTROLLER     = 18;  // 控制器
        public static final int ENUM_UAV_TYPE_VTOL_DUOROTOR          = 19;  // 两翼VTOL
        public static final int ENUM_UAV_TYPE_VTOL_QUADROTOR         = 20;  // 四翼VTOL
        public static final int ENUM_UAV_TYPE_VTOL_TILTROTOR         = 21;  // 倾转旋翼机
        public static final int ENUM_UAV_TYPE_VTOL_RESERVED2         = 22;  // VTOL 保留2
        public static final int ENUM_UAV_TYPE_VTOL_RESERVED3         = 23;  // VTOL 保留3
        public static final int ENUM_UAV_TYPE_VTOL_RESERVED4         = 24;  // VTOL 保留4
        public static final int ENUM_UAV_TYPE_VTOL_RESERVED5         = 25;  // VTOL 保留5
        public static final int ENUM_UAV_TYPE_GIMBAL                 = 26;  // 常平架
        public static final int ENUM_UAV_TYPE_ADSB                   = 27;  // ADSB
    }

    // 飞行器模式
    public static class ENUM_UAV_MODE extends SdkStructure
    {
        public static final int ENUM_UAV_MODE_UNKNOWN                = 0;   // 未知模式
        public static final int ENUM_UAV_MODE_FIXED_WING_MANUAL      = 0;   // 固定翼 手动模式
        public static final int ENUM_UAV_MODE_FIXED_WING_CIRCLE      = 1;   // 固定翼 绕圈模式
        public static final int ENUM_UAV_MODE_FIXED_WING_STABILIZE   = 2;   // 固定翼 自稳模式
        public static final int ENUM_UAV_MODE_FIXED_WING_TRAINING    = 3;   // 固定翼 训练模式
        public static final int ENUM_UAV_MODE_FIXED_WING_ACRO        = 4;   // 固定翼 特技模式
        public static final int ENUM_UAV_MODE_FIXED_WING_FLY_BY_WIRE_A = 5;   // 固定翼 A翼飞行模式
        public static final int ENUM_UAV_MODE_FIXED_WING_FLY_BY_WIRE_B = 6;   // 固定翼 B翼飞行模式
        public static final int ENUM_UAV_MODE_FIXED_WING_CRUISE      = 7;   // 固定翼 巡航模式
        public static final int ENUM_UAV_MODE_FIXED_WING_AUTOTUNE    = 8;   // 固定翼 自动统调
        public static final int ENUM_UAV_MODE_FIXED_WING_AUTO        = 10;  // 固定翼 智能模式
        public static final int ENUM_UAV_MODE_FIXED_WING_RTL         = 11;  // 固定翼 返航模式
        public static final int ENUM_UAV_MODE_FIXED_WING_LOITER      = 12;  // 固定翼 定点模式
        public static final int ENUM_UAV_MODE_FIXED_WING_GUIDED      = 15;  // 固定翼 引导模式

        public static final int ENUM_UAV_MODE_QUADROTOR_STABILIZE    = 100;  // 四轴 自稳模式
        public static final int ENUM_UAV_MODE_QUADROTOR_ACRO         = 101;  // 四轴 特技模式
        public static final int ENUM_UAV_MODE_QUADROTOR_ALT_HOLD     = 102;  // 四轴 定高模式
        public static final int ENUM_UAV_MODE_QUADROTOR_AUTO         = 103;  // 四轴 智能模式
        public static final int ENUM_UAV_MODE_QUADROTOR_GUIDED       = 104;  // 四轴 引导模式
        public static final int ENUM_UAV_MODE_QUADROTOR_LOITER       = 105;  // 四轴 定点模式
        public static final int ENUM_UAV_MODE_QUADROTOR_RTL          = 106;  // 四轴 返航模式
        public static final int ENUM_UAV_MODE_QUADROTOR_CIRCLE       = 107;  // 四轴 绕圈模式
        public static final int ENUM_UAV_MODE_QUADROTOR_LAND         = 109;  // 四轴 降落模式
        public static final int ENUM_UAV_MODE_QUADROTOR_OF_LOITER    = 110;  // 四轴 启用光流的悬停模式需要光流传感器来保持位置和高度
        public static final int ENUM_UAV_MODE_QUADROTOR_TOY          = 111;  // 四轴 飘移模式
        public static final int ENUM_UAV_MODE_QUADROTOR_SPORT        = 113;  // 四轴 运动模式
        public static final int ENUM_UAV_MODE_QUADROTOR_AUTOTUNE     = 115;  // 四轴 自动统调
        public static final int ENUM_UAV_MODE_QUADROTOR_POSHOLD      = 116;  // 四轴 保持模式
        public static final int ENUM_UAV_MODE_QUADROTOR_BRAKE        = 117;  // 四轴 制动模式

        public static final int ENUM_UAV_MODE_GROUND_ROVER_MANUAL    = 200;  // 地面车辆 手动模式
        public static final int ENUM_UAV_MODE_GROUND_ROVER_LEARNING  = 202;  // 地面车辆 学习模式
        public static final int ENUM_UAV_MODE_GROUND_ROVER_STEERING  = 203;  // 地面车辆 驾驶模式
        public static final int ENUM_UAV_MODE_GROUND_ROVER_HOLD      = 204;  // 地面车辆 锁定模式
        public static final int ENUM_UAV_MODE_GROUND_ROVER_AUTO      = 210;  // 地面车辆 智能模式
        public static final int ENUM_UAV_MODE_GROUND_ROVER_RTL       = 211;  // 地面车辆 返航模式
        public static final int ENUM_UAV_MODE_GROUND_ROVER_GUIDED    = 215;  // 地面车辆 引导模式
        public static final int ENUM_UAV_MODE_GROUND_ROVER_INITIALIZING = 216;  // 地面车辆 初始化模式

        public static final int ENUM_UAV_MODE_HEXAROTOR_STABILIZE    = 300;  // 六轴 自稳模式
        public static final int ENUM_UAV_MODE_HEXAROTOR_ACRO         = 301;  // 六轴 特技模式
        public static final int ENUM_UAV_MODE_HEXAROTOR_ALT_HOLD     = 302;  // 六轴 定高模式
        public static final int ENUM_UAV_MODE_HEXAROTOR_AUTO         = 303;  // 六轴 智能模式
        public static final int ENUM_UAV_MODE_HEXAROTOR_GUIDED       = 304;  // 六轴 引导模式
        public static final int ENUM_UAV_MODE_HEXAROTOR_LOITER       = 305;  // 六轴 定点模式
        public static final int ENUM_UAV_MODE_HEXAROTOR_RTL          = 306;  // 六轴 返航模式
        public static final int ENUM_UAV_MODE_HEXAROTOR_CIRCLE       = 307;  // 六轴 绕圈模式
        public static final int ENUM_UAV_MODE_HEXAROTOR_LAND         = 309;  // 六轴 降落模式
        public static final int ENUM_UAV_MODE_HEXAROTOR_OF_LOITER    = 310;  // 六轴 启用光流的悬停模式需要光流传感器来保持位置和高度
        public static final int ENUM_UAV_MODE_HEXAROTOR_DRIFT        = 311;  // 六轴 飘移模式
        public static final int ENUM_UAV_MODE_HEXAROTOR_SPORT        = 313;  // 六轴 运动模式
        public static final int ENUM_UAV_MODE_HEXAROTOR_AUTOTUNE     = 315;  // 六轴 自动统调
        public static final int ENUM_UAV_MODE_HEXAROTOR_POSHOLD      = 316;  // 六轴 保持模式
        public static final int ENUM_UAV_MODE_HEXAROTOR_BRAKE        = 317;  // 六轴 制动模式
    }

    // 无人机系统状态
    public static class ENUM_UAV_STATE extends SdkStructure
    {
        public static final int ENUM_UAV_STATE_UNINIT                = 0;   // 未初始化, 状态未知
        public static final int ENUM_UAV_STATE_BOOT                  = 1;   // 正在启动
        public static final int ENUM_UAV_STATE_CALIBRATING           = 2;   // 正在校准,未准备好起飞.
        public static final int ENUM_UAV_STATE_STANDBY               = 3;   // 系统地面待命,随时可以起飞.
        public static final int ENUM_UAV_STATE_ACTIVE                = 4;   // 开车/开航. 发动机已经启动.
        public static final int ENUM_UAV_STATE_CRITICAL              = 5;   // 系统处于失常飞行状态,仍能导航.
        public static final int ENUM_UAV_STATE_EMERGENCY             = 6;   // 系统处于失常飞行状态,若干设备失灵,坠落状态.
        public static final int ENUM_UAV_STATE_POWEROFF              = 7;   // 系统刚执行了关机指令,正在关闭.
    }

    // UAV 系统当前模式
    public static class NET_UAV_SYS_MODE_STATE extends SdkStructure
    {
        public int                            bSafetyArmedEnabled;                  // 主发动机使能, 准备好起飞.
        public int                            bManualInputEnabled;                  // 遥控输入信号使能.
        public int                            bHILEnabled;                          // HIL硬件环在线模拟使能.所有发动机, 舵机及其他动作设备阻断, 但内部软件处于全部可操作状态.
        public int                            bStabilizeEnabled;                    // 高度/位置电子增稳使能.在此状态下,飞行器仍需要外部操作指令以实现操作
        public int                            bGuidedEnabled;                       // 导航使能.导航数据和指令来自导航/航点指令表文件
        public int                            bAutoEnabled;                         // 全自主航行模式使能.系统自行决定目的地.前一项“导航使能”可以设置为TURE或FLASE状态
        public int                            bTestEnabled;                         // 测试模式使能.本标识仅供临时的系统测试之用,不应该用于实际航行的应用中.
        public int                            bReserved;                            // 保留模式
    }

    // 心跳状态信息
    public static class NET_UAV_HEARTBEAT extends SdkStructure
    {
        public int                            emUAVMode;                            // 飞行模式和飞行器形态类型相关，详见ENUM_UAV_MODE
        public int                            emUAVType;                            // 飞行器形态类型，详见ENUM_UAV_TYPE
        public int                            emSystemStatus;                       // 系统状态，详见ENUM_UAV_STATE
        public NET_UAV_SYS_MODE_STATE         stuBaseMode;                          // 系统当前模式
        public byte[]                         byReserved = new byte[8];             // 保留字节
    }

    // 传感器
    public static class ENUM_UAV_SENSOR extends SdkStructure
    {
        public static final int ENUM_UAV_SENSOR_UNKNOWN              = 0;   // 未知类型
        public static final int ENUM_UAV_SENSOR_3D_GYRO              = 1;   // 三轴陀螺
        public static final int ENUM_UAV_SENSOR_3D_ACCEL             = 2;   // 三轴加速度/倾角仪
        public static final int ENUM_UAV_SENSOR_3D_MAG               = 3;   // 三轴磁罗盘
        public static final int ENUM_UAV_SENSOR_ABSOLUTE_PRESSURE    = 4;   // 绝对气压计
        public static final int ENUM_UAV_SENSOR_DIFFERENTIAL_PRESSURE = 5;   // 相对气压计
        public static final int ENUM_UAV_SENSOR_GPS                  = 6;   // GPS
        public static final int ENUM_UAV_SENSOR_OPTICAL_FLOW         = 7;   // 光测设备
        public static final int ENUM_UAV_SENSOR_VISION_POSITION      = 8;   // 计算机视觉定位仪
        public static final int ENUM_UAV_SENSOR_LASER_POSITION       = 9;   // 激光定位
        public static final int ENUM_UAV_SENSOR_EXTERNAL_GROUND_TRUTH = 10;  // 外部激光定位（Vicon 或徕卡）
        public static final int ENUM_UAV_SENSOR_ANGULAR_RATE_CONTROL = 11;  // 三轴角速度控制器
        public static final int ENUM_UAV_SENSOR_ATTITUDE_STABILIZATION = 12;  // 高度稳定器
        public static final int ENUM_UAV_SENSOR_YAW_POSITION         = 13;  // 方向稳定器（锁尾等）
        public static final int ENUM_UAV_SENSOR_Z_ALTITUDE_CONTROL   = 14;  // 高度控制器
        public static final int ENUM_UAV_SENSOR_XY_POSITION_CONTROL  = 15;  // X/Y位置控制器
        public static final int ENUM_UAV_SENSOR_MOTOR_OUTPUTS        = 16;  // 马达输出控制器
        public static final int ENUM_UAV_SENSOR_RC_RECEIVER          = 17;  // RC 接收器
        public static final int ENUM_UAV_SENSOR_3D_GYRO2             = 18;  // 2nd 三轴陀螺
        public static final int ENUM_UAV_SENSOR_3D_ACCEL2            = 19;  // 2nd 三轴加速度/倾角仪
        public static final int ENUM_UAV_SENSOR_3D_MAG2              = 20;  // 2nd 三轴磁罗盘
        public static final int ENUM_UAV_GEOFENCE                    = 21;  // 地理围栏
        public static final int ENUM_UAV_AHRS                        = 22;  // 姿态子系统运行状况
        public static final int ENUM_UAV_TERRAIN                     = 23;  // 地形子系统运行状况
        public static final int ENUM_UAV_REVERSE_MOTOR               = 24;  // 保留马达
    }

    public static final int UAV_MAX_SENSOR_NUM             = 32;   // 最大传感器个数
    // 传感器信息
    public static class NET_UAV_SENSOR extends SdkStructure
    {
        public int                            emType;                               // 传感器类型，详见ENUM_UAV_SENSOR
        public int                            bEnabled;                             // 使能状态
        public int                            bHealthy;                             // 传感器状态
    }

    // 系统状态信息
    public static class NET_UAV_SYS_STATUS extends SdkStructure
    {
        public int                            nPresentSensorNum;                    // 可见传感器个数, 最大支持32
        public NET_UAV_SENSOR[]               stuSensors = new NET_UAV_SENSOR[UAV_MAX_SENSOR_NUM];  // 传感器信息
        public int                            nBatteryVoltage;                      // 电池电压, 单位: 毫伏
        public int                            nBatteryCurrent;                      // 电池电流, 单位: 10毫安
        public int                            nChargeDischargeNum;                  // 电池充放电次数
        public int                            nHomeDistance;                        // 距离Home的距离, 单位: 米
        public int                            nRemainingFlightTime;                 // 剩余飞行时间, 单位: 秒
        public int                            nRemainingBattery;                    // 剩余电量百分比 -1: 正在估测剩余电量
        public byte[]                         byReserverd = new byte[16];           // 保留字节

        public NET_UAV_SYS_STATUS()
        {
            for (int i = 0; i < stuSensors.length; ++i) {
                stuSensors[i] = new NET_UAV_SENSOR();
            }
        }
    }

    public static final int UAV_MAX_SATELLITE_NUM          = 20;   // 最多支持卫星个数
    // 卫星信息
    public static class NET_SATELLITE_STATUS extends SdkStructure
    {
        public int                            bUsed;                                // 卫星使用状态 FLASE: 未使用 TURE: 使用
        public int                            nID;                                  // 卫星ID
        public int                            nElevation;                           // 卫星在天空中的仰角 单位: 度
        public int                            nDireciton;                           // 卫星方位角 单位: 度
        public int                            nSNR;                                 // 信噪比, 信号强度百分比
    }

    // GPS 可见卫星的状态信息
    public static class NET_UAV_GPS_STATUS extends SdkStructure
    {
        public int                            nVisibleNum;                          // 可见卫星个数, 最多支持20个
        public NET_SATELLITE_STATUS[]         stuSatellites = new NET_SATELLITE_STATUS[UAV_MAX_SATELLITE_NUM];  // 卫星信息

        public NET_UAV_GPS_STATUS()
        {
            for (int i = 0; i < stuSatellites.length; ++i) {
                stuSatellites[i] = new NET_SATELLITE_STATUS();
            }
        }
    }

    // 姿态信息
    public static class NET_UAV_ATTITUDE extends SdkStructure
    {
        public float                          fRollAngle;                           // 滚转角, 单位: 度
        public float                          fPitchAngle;                          // 俯仰角, 单位: 度
        public float                          fYawAngle;                            // 偏航角, 单位: 度
        public byte[]                         bReserved = new byte[16];             // 保留字节
    }

    // 遥控通道信息
    public static class NET_UAV_RC_CHANNELS extends SdkStructure
    {
        public int                            nControllerSignal;                    // 遥控器信号百分比, 255: 非法未知
        public byte[]                         byReserved = new byte[80];            // 保留字节
    }

    // 平视显示信息
    public static class NET_UAV_VFR_HUD extends SdkStructure
    {
        public float                          fGroundSpeed;                         // 水平速度, 单位: 米/秒
        public float                          fAltitude;                            // 高度, 单位: 米
        public float                          fClimbSpeed;                          // 垂直速度, 单位: 米/秒
        public byte[]                         byReserved = new byte[12];
    }

    // 故障等级
    public static class ENUM_UAV_SEVERITY extends SdkStructure
    {
        public static final int ENUM_UAV_SEVERITY_EMERGENCY          = 0;   // 系统不可用, 最紧急状态
        public static final int ENUM_UAV_SEVERITY_ALERT              = 1;   // 警报. 非致命性系统故障, 应立即应对.
        public static final int ENUM_UAV_SEVERITY_CRITICAL           = 2;   // 警报: 主要系统故障, 应立即应对
        public static final int ENUM_UAV_SEVERITY_ERROR              = 3;   // 故障: 次系统故障/备份系统故障
        public static final int ENUM_UAV_SEVERITY_WARNING            = 4;   // 警告
        public static final int ENUM_UAV_SEVERITY_NOTICE             = 5;   // 注意: 出现失常现象, 单非错误故障. 应该排查其现象根源
        public static final int ENUM_UAV_SEVERITY_INFO               = 6;   // 提示: 一般性操作消息, 可用于日志. 此消息不需要应对行动
        public static final int ENUM_UAV_SEVERITY_DEBUG              = 7;   // 调试信息。正常操作的时候不该出现
    }

    // 报警文本信息
    public static class NET_UAV_STATUSTEXT extends SdkStructure
    {
        public int                            emSeverity;                           // 故障等级，详见ENUM_UAV_SEVERITY
        public byte[]                         szText = new byte[60];                // 文本信息
        public byte[]                         byReserved = new byte[4];             // 保留字节
    }

    // 全球定位数据
    public static class NET_UAV_GLOBAL_POSITION extends SdkStructure
    {
        public float                          fLatitude;                            // 纬度, 单位: 角度
        public float                          fLongitude;                           // 经度, 单位: 角度
        public int                            nAltitude;                            // 海拔高度, 单位: 厘米
        public int                            nRelativeAltitude;                    // 相对高度, 单位: 厘米
        public int                            nXSpeed;                              // X速度（绝对速度、北东地坐标系）, 单位: 厘米每秒
        public int                            nYSpeed;                              // Y速度（绝对速度、北东地坐标系）, 单位: 厘米每秒
        public int                            nZSpeed;                              // Z速度（绝对速度、北东地坐标系）, 单位: 厘米每秒
        public byte[]                         byReserved = new byte[12];
    }

    //  GPS原始数据
    public static class NET_UAV_GPS_RAW extends SdkStructure
    {
        public int                            nDHOP;                                // GPS水平定位经度因子, 单位厘米. 65535 表示未知
        public int                            nGroudSpeed;                          // GPS地速, 厘米每秒. 65535 表示未知
        public int                            nVisibleStatellites;                  // 卫星数, 255 表示未知
        public int                            nVDOP;                                // GPS 垂直定位因子，单位厘米。65535表示未知
        public int                            nCourseOverGround;                    // 整体移动方向, 非机头移动方向. 单位: 100*度
        public int                            nFixType;                             // 定位类型.  0 或 1 尚未定位, 2: 2D 定位, 3: 3D 定位
        public byte[]                         byReserved = new byte[20];
    }

    // 系统时间
    public static class NET_UAV_SYS_TIME extends SdkStructure
    {
        public NET_TIME_EX                    UTC;                                  // UTC 时间
        public int                            dwBootTime;                           // 启动时间, 单位毫秒
    }

    // 当前航点
    public static class NET_UAV_MISSION_CURRENT extends SdkStructure
    {
        public int                            nSequence;                            // 序号 0 ~ 700
        public byte[]                         byReserved = new byte[16];            // 保留字节
    }

    // 到达航点
    public static class NET_UAV_MISSION_REACHED extends SdkStructure
    {
        public int                            nSequence;                            // 序号 0 ~ 700
        public byte[]                         byReserved = new byte[16];            // 保留字节
    }

    // 云台姿态
    public static class NET_UAV_MOUNT_STATUS extends SdkStructure
    {
        public float                          fRollAngle;                           // 滚转角, 单位: 度
        public float                          fPitchAngle;                          // 俯仰角, 单位: 度
        public float                          fYawAngle;                            // 偏航角, 单位: 度
        public int                            nTargetSystem;                        // 目标系统
        public int                            nTargetComponent;                     // 目标部件
        public int                            nMountMode;                           // 云台模式, 参照 NET_UAVCMD_MOUNT_CONFIGURE
        public byte[]                         byReserved = new byte[8];             // 保留字节
    }

    // Home点位置信息
    public static class NET_UAV_HOME_POSITION extends SdkStructure
    {
        public float                          fLatitude;                            // 纬度, 单位: 角度
        public float                          fLongitude;                           // 经度, 单位: 角度
        public int                            nAltitude;                            // 海拔高度, 单位: 厘米
        public float                          fLocalX;                              // X 点
        public float                          fLocalY;                              // Y 点
        public float                          fLocalZ;                              // Z 点
        public float                          fApproachX;                           // 本地 x 矢量点
        public float                          fApproachY;
        public float                          fApproachZ;
        public byte[]                         byReserved = new byte[16];
    }

    // 无人机实时消息类型
    public static class EM_UAVINFO_TYPE extends SdkStructure
    {
        public static final int EM_UAVINFO_TYPE_UNKNOWN              = 0;   // 未知类型
        public static final int EM_UAVINFO_TYPE_HEARTBEAT            = 1;   // 心跳状态 *pInfo = NET_UAV_HEARTBEAT
        public static final int EM_UAVINFO_TYPE_SYS_STATUS           = 2;   // 系统状态 *pInfo = NET_UAV_SYS_STATUS
        public static final int EM_UAVINFO_TYPE_GPS_STATUS           = 3;   // GPS状态 *pInfo = NET_UAV_GPS_STATUS
        public static final int EM_UAVINFO_TYPE_ATTITUDE             = 4;   // 姿态信息 *pInfo = NET_UAV_ATTITUDE
        public static final int EM_UAVINFO_TYPE_RC_CHANNELS          = 5;   // 遥控通道信息 *pInfo = NET_UAV_RC_CHANNELS
        public static final int EM_UAVINFO_TYPE_VFR_HUD              = 6;   // 平视显示信息 *pInfo = NET_UAV_VFR_HUD
        public static final int EM_UAVINFO_TYPE_STATUSTEXT           = 7;   // 报警文本信息 *pInfo = NET_UAV_STATUSTEXT
        public static final int EM_UAVINFO_TYPE_GLOBAL_POSITION      = 8;   // 全球定位数据 *pInfo = NET_UAV_GLOBAL_POSITION
        public static final int EM_UAVINFO_TYPE_GPS_RAW              = 9;   // GPS原始数据 *pInfo = NET_UAV_GPS_RAW
        public static final int EM_UAVINFO_TYPE_SYS_TIME             = 10;  // 系统时间 *pInfo = NET_UAV_SYS_TIME
        public static final int EM_UAVINFO_TYPE_MISSION_CURRENT      = 11;  // 当前航点 *pInfo = NET_UAV_MISSION_CURRENT
        public static final int EM_UAVINFO_TYPE_MOUNT_STATUS         = 12;  // 云台姿态 *pInfo = NET_UAV_MOUNT_STATUS
        public static final int EM_UAVINFO_TYPE_HOME_POSITION        = 13;  // Home点位置信息 *pInfo = NET_UAV_HOME_POSITION
        public static final int EM_UAVINFO_TYPE_MISSION_REACHED      = 14;  // 到达航点 *pInfo = NET_UAV_MISSION_REACHED
    }

    // 无人机实时回调数据
    public static class NET_UAVINFO extends SdkStructure
    {
        public int                            emType;                               // 消息类型，详见EM_UAVINFO_TYPE
        public Pointer                        pInfo;                                // 消息内容，指向void
        public int                            dwInfoSize;                           // 消息大小
        public byte[]                         byReserved = new byte[512];           // 保留字节
    }

    // 无人机实时数据回调
    public interface fUAVInfoCallBack extends StdCallCallback {
        public void invoke(LLong lAttachHandle, NET_UAVINFO pstuUAVInfo, int dwUAVInfoSize, Pointer dwUser);
    }

    // 订阅无人机实时消息入参
    public static class NET_IN_ATTACH_UAVINFO extends SdkStructure
    {
        public int                            dwSize;
        public Callback                		  cbNotify;                             // 实时回调函数，实现fUAVInfoCallBack
        public Pointer                        dwUser;                               // 用户信息

        public NET_IN_ATTACH_UAVINFO()
        {
            this.dwSize = this.size();
        }
    }

    // 订阅无人机实时消息入参
    public static class NET_OUT_ATTACH_UAVINFO extends SdkStructure
    {
        public int                            dwSize;

        public NET_OUT_ATTACH_UAVINFO()
        {
            this.dwSize = this.size();
        }
    }

    // 无人机通用设置命令类型 结构体大小与 NET_UAVCMD_PARAM_BUFFER 保持一致
    public static class ENUM_UAVCMD_TYPE extends SdkStructure
    {
        public static final int ENUM_UAVCMD_UNKNOWN                  = -1;
        public static final int ENUM_UAVCMD_NAV_TAKEOFF              = 0;   // 地面起飞或手抛起飞 NET_UAVCMD_TAKEOFF
        public static final int ENUM_UAVCMD_NAV_LOITER_UNLIM         = 1;   // 悬停 NET_UAVCMD_LOITER_UNLIMITED
        public static final int ENUM_UAVCMD_NAV_RETURN_TO_LAUNCH     = 2;   // 返航降落 NET_UAVCMD_RETURN_TO_LAUNCH
        public static final int ENUM_UAVCMD_NAV_LAND                 = 3;   // 设定点着陆  NET_UAVCMD_LAND
        public static final int ENUM_UAVCMD_CONDITION_YAW            = 4;   // 变换航向 NET_UAVCMD_CONDITION_YAW
        public static final int ENUM_UAVCMD_DO_CHANGE_SPEED          = 5;   // 改变速度 NET_UAVCMD_CHANGE_SPEED
        public static final int ENUM_UAVCMD_DO_SET_HOME              = 6;   // 设置返航点 NET_UAVCMD_SET_HOME
        public static final int ENUM_UAVCMD_DO_FLIGHTTERMINATION     = 7;   // 立即停转电机, 飞机锁定 NET_UAVCMD_FLIGHT_TERMINATION
        public static final int ENUM_UAVCMD_MISSION_START            = 8;   // 开始航点任务 NET_UAVCMD_MISSION_START
        public static final int ENUM_UAVCMD_COMPONENT_ARM_DISARM     = 9;   // 电调解锁, 电调锁定 NET_UAVCMD_COMPONENT_ARM_DISARM
        public static final int ENUM_UAVCMD_PREFLIGHT_REBOOT_SHUTDOWN = 10;  // 重启飞行器 NET_UAVCMD_REBOOT_SHUTDOWN
        public static final int ENUM_UAVCMD_DO_SET_RELAY             = 11;  // 继电器控制 NET_UAVCMD_SET_RELAY
        public static final int ENUM_UAVCMD_DO_REPEAT_RELAY          = 12;  // 继电器循环控制 NET_UAVCMD_REPEAT_RELAY
        public static final int ENUM_UAVCMD_DO_FENCE_ENABLE          = 13;  // 电子围栏启用禁用 NET_UAVCMD_FENCE_ENABLE
        public static final int ENUM_UAVCMD_MOUNT_CONFIGURE          = 14;  // 云台模式配置 NET_UAVCMD_MOUNT_CONFIGURE
        public static final int ENUM_UAVCMD_GET_HOME_POSITION        = 15;  // 异步获取Home点位置, 实时数据回调中返回 NET_UAVCMD_GET_HOME_POSITION
        public static final int ENUM_UAVCMD_IMAGE_START_CAPTURE      = 16;  // 开始抓拍 NET_UAVCMD_IMAGE_START_CAPTURE
        public static final int ENUM_UAVCMD_IMAGE_STOP_CAPTURE       = 17;  // 停止抓拍 NET_UAVCMD_IMAGE_STOP_CAPTURE
        public static final int ENUM_UAVCMD_VIDEO_START_CAPTURE      = 18;  // 开始录像 NET_UAVCMD_VIDEO_START_CAPTURE
        public static final int ENUM_UAVCMD_VIDEO_STOP_CAPTURE       = 19;  // 停止录像 NET_UAVCMD_VIDEO_STOP_CAPTURE
        public static final int ENUM_UAVCMD_NAV_WAYPOINT             = 20;  // 航点 NET_UAVCMD_NAV_WAYPOINT
        public static final int ENUM_UAVCMD_NAV_LOITER_TURNS         = 21;  // 循环绕圈 NET_UAVCMD_NAV_LOITER_TURNS
        public static final int ENUM_UAVCMD_NAV_LOITER_TIME          = 22;  // 固定时间等待航点 NET_UAVCMD_NAV_LOITER_TIME
        public static final int ENUM_UAVCMD_NAV_SPLINE_WAYPOINT      = 23;  // 曲线航点 NET_UAVCMD_NAV_SPLINE_WAYPOINT
        public static final int ENUM_UAVCMD_NAV_GUIDED_ENABLE        = 24;  // 引导模式开关 NET_UAVCMD_NAV_GUIDED_ENABLE
        public static final int ENUM_UAVCMD_DO_JUMP                  = 25;  // 跳转到任务单某个位置. 并执行N次 NET_UAVCMD_DO_JUMP
        public static final int ENUM_UAVCMD_DO_GUIDED_LIMITS         = 26;  // 引导模式执行控制限制 NET_UAVCMD_DO_GUIDED_LIMITS
        public static final int ENUM_UAVCMD_CONDITION_DELAY          = 27;  // 动作延时 NET_UAVCMD_CONDITION_DELAY
        public static final int ENUM_UAVCMD_CONDITION_DISTANCE       = 28;  // 动作距离. 前往设定距离(到下一航点),然后继续 NET_UAVCMD_CONDITION_DISTANCE
        public static final int ENUM_UAVCMD_DO_SET_ROI               = 29;  // 相机兴趣点 NET_UAVCMD_DO_SET_ROI
        public static final int ENUM_UAVCMD_DO_DIGICAM_CONTROL       = 30;  // 相机控制 NET_UAVCMD_DO_DIGICAM_CONTROL
        public static final int ENUM_UAVCMD_DO_MOUNT_CONTROL         = 31;  // 云台角度控制 NET_UAVCMD_DO_MOUNT_CONTROL
        public static final int ENUM_UAVCMD_DO_SET_CAM_TRIGG_DIST    = 32;  // 聚焦距离 NET_UAVCMD_DO_SET_CAM_TRIGG_DIST
        public static final int ENUM_UAVCMD_SET_MODE                 = 33;  // 设置模式 NET_UAVCMD_SET_MODE
        public static final int ENUM_UAVCMD_NAV_GUIDED               = 34;  // 设定引导点 NET_UAVCMD_NAV_GUIDED
        public static final int ENUM_UAVCMD_MISSION_PAUSE            = 35;  // 飞行任务暂停 NET_UAVCMD_MISSION_PAUSE
        public static final int ENUM_UAVCMD_MISSION_STOP             = 36;  // 飞行任务停止 NET_UAVCMD_MISSION_STOP
        public static final int ENUM_UAVCMD_LOAD_CONTROL             = 37;  // 负载控制 NET_UAVCMD_LOAD_CONTROL
        public static final int ENUM_UAVCMD_RC_CHANNELS_OVERRIDE     = 38;  // 模拟摇杆 NET_UAVCMD_RC_CHANNELS_OVERRIDE
        public static final int ENUM_UAVCMD_HEART_BEAT               = 39;  // 心跳 NET_UAVCMD_HEART_BEAT
    }

    // 无人机命令通用信息
    public static class NET_UAVCMD_COMMON extends SdkStructure
    {
        public int                            nTargetSystem;                        // 目标系统
        public int                            nTargetComponent;                     // 目标部件, 0 - 所有部件
        public int                            nConfirmation;                        // 确认次数, 0 - 为首次命令. 用于航点任务为0
        public byte[]                         byReserved = new byte[4];             // 保留
    }

    // 地面起飞命令 ENUM_UAVCMD_NAV_TAKEOFF
    public static class NET_UAVCMD_TAKEOFF extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public float                          fMinimumPitch;                        // 最小爬升率（有空速传感器时适用）设定的爬升率（无传感器）
        public float                          fYawAngle;                            // 指向设定.（有罗盘）如无罗盘, 则忽略此参数.
        public float                          fLatitude;                            // 纬度
        public float                          fLongitude;                           // 经度
        public float                          fAltitude;                            // 高度
        public byte[]                         byReserved = new byte[8];             // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 悬停命令 ENUM_UAVCMD_NAV_LOITER_UNLIM
    public static class NET_UAVCMD_LOITER_UNLIMITED extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public float                          fRadius;                              // 盘旋半径(m), 正值顺时针, 负值逆时针.
        public float                          fYawAngle;                            // 指向设定, 仅适用可悬停机型
        public float                          fLatitude;                            // 纬度
        public float                          fLongitude;                           // 经度
        public float                          fAltitude;                            // 高度
        public byte[]                         byReserved = new byte[8];             // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 返航降落 ENUM_UAVCMD_NAV_RETURN_TO_LAUNCH
    public static class NET_UAVCMD_RETURN_TO_LAUNCH extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public byte[]                         byReserved = new byte[28];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 设定点着陆 ENUM_UAVCMD_NAV_LAND
    public static class NET_UAVCMD_LAND extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public float                          fYawAngle;                            // 指向设定, 仅适用可悬停机型.
        public float                          fLatitude;                            // 纬度
        public float                          fLongitude;                           // 经度
        public float                          fAltitude;                            // 高度
        public byte[]                         byReserved = new byte[12];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 变换航向 ENUM_UAVCMD_CONDITION_YAW
    public static class NET_UAVCMD_CONDITION_YAW extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public float                          fTargetAngle;                         // 目标角度: [0-360], 0为北
        public float                          fSpeed;                               // 转向速率: [度/秒]
        public float                          fDirection;                           // 指向: 负值逆时针, 正值顺时针
        public float                          fRelativeOffset;                      // 相对偏置或绝对角[1,0]
        public byte[]                         byReserved = new byte[12];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 改变速度 ENUM_UAVCMD_DO_CHANGE_SPEED
    public static class NET_UAVCMD_CHANGE_SPEED extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public float                          fSpeedType;                           // 速度类型（0=空速, 1=地速）
        public float                          fSpeed;                               // 速度（米/秒, -1表示维持原来速度不变）
        public float                          fThrottle;                            // 油门开度, 百分比数据，-1表示维持原来数值不变
        public byte[]                         byReserved = new byte[16];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 设置返航点 ENUM_UAVCMD_DO_SET_HOME
    public static class NET_UAVCMD_SET_HOME extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nLocation;                            // 返航点: 1 = 使用当前点, 0 - 设定点
        public float                          fLatitude;                            // 纬度
        public float                          fLongitude;                           // 经度
        public float                          fAltitude;                            // 高度
        public byte[]                         byReserved = new byte[12];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 立即停转电机 ENUM_UAVCMD_DO_FLIGHTTERMINATION
    public static class NET_UAVCMD_FLIGHT_TERMINATION extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public float                          fActivated;                           // 触发值: 大于0.5 被触发
        public byte[]                         byReserved = new byte[24];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 开始航点任务  ENUM_UAVCMD_MISSION_START
    public static class NET_UAVCMD_MISSION_START extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nFirstItem;                           // 第一项 n, 起始点的任务号
        public int                            nLastItem;                            // 最后一项 m, 终点的任务号
        public byte[]                         byReserved = new byte[20];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 飞行任务暂停  ENUM_UAVCMD_MISSION_PAUSE
    public static class NET_UAVCMD_MISSION_PAUSE extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public byte[]                         byReserved = new byte[28];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 飞行任务停止  ENUM_UAVCMD_MISSION_STOP
    public static class NET_UAVCMD_MISSION_STOP extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public byte[]                         byReserved = new byte[28];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 负载类型
    public static class EM_LOAD_CONTROL_TYPE extends SdkStructure
    {
        public static final int EM_LOAD_CONTROL_COMMON               = 0;   // 通用设备 NET_LOAD_CONTROL_COMMON
        public static final int EM_LOAD_CONTROL_PHOTO                = 1;   // 拍照设备 NET_LOAD_CONTROL_PHOTO
        public static final int EM_LOAD_CONTROL_VIDEO                = 2;   // 视频设备 NET_LOAD_CONTROL_VIDEO
        public static final int EM_LOAD_CONTROL_AUDIO                = 3;   // 音频设备 NET_LOAD_CONTROL_AUDIO
        public static final int EM_LOAD_CONTROL_LIGHT                = 4;   // 灯光设备 NET_LOAD_CONTROL_LIGHT
        public static final int EM_LOAD_CONTROL_RELAY                = 5;   // 继电器设备NET_LOAD_CONTROL_RELAY
        public static final int EM_LOAD_CONTROL_TIMING               = 6;   // 定时拍照设备NET_LOAD_CONTROL_TIMING
        public static final int EM_LOAD_CONTROL_DISTANCE             = 7;   // 定距拍照设备NET_LOAD_CONTROL_DISTANCE
    }

    // 通用设备
    public static class NET_LOAD_CONTROL_COMMON extends SdkStructure
    {
        public byte[]                         byReserved = new byte[24];            // 实际请使用对应负载填入
    }

    // 拍照设备
    public static class NET_LOAD_CONTROL_PHOTO extends SdkStructure
    {
        public float                          fCycle;                               // 拍照周期 单位s
        public byte[]                         byReserved = new byte[20];            // 对齐 NET_MISSION_ITEM_COMMON
    }

    // 视频设备
    public static class NET_LOAD_CONTROL_VIDEO extends SdkStructure
    {
        public int                            nSwitch;                              // 开关 0-结束录像 1-开始录像
        public byte[]                         byReserved = new byte[20];            // 对齐 NET_LOAD_CONTROL_COMMON
    }

    // 音频设备
    public static class NET_LOAD_CONTROL_AUDIO extends SdkStructure
    {
        public byte[]                         byReserved = new byte[24];            // 对齐 NET_LOAD_CONTROL_COMMON
    }

    // 灯光设备
    public static class NET_LOAD_CONTROL_LIGHT extends SdkStructure
    {
        public int                            nSwitch;                              // 开关 0-关闭 1-打开
        public byte[]                         byReserved = new byte[20];            // 对齐 NET_LOAD_CONTROL_COMMON
    }

    // 继电器设备
    public static class NET_LOAD_CONTROL_RELAY extends SdkStructure
    {
        public int                            nSwitch;                              // 开关 0-关闭 1-打开
        public byte[]                         byReserved = new byte[20];            // 对齐 NET_LOAD_CONTROL_COMMON
    }

    // 定时拍照设备
    public static class NET_LOAD_CONTROL_TIMING extends SdkStructure
    {
        public int                            nInterval;                            // 拍照时间间隔 单位:s
        public int                            nSwitch;                              // 起停控制 0-停止 1-启用
        public byte[]                         byReserved = new byte[16];            // 对齐 NET_LOAD_CONTROL_COMMON
    }

    // 定距拍照设备
    public static class NET_LOAD_CONTROL_DISTANCE extends SdkStructure
    {
        public int                            nInterval;                            // 拍照距离间隔 单位:m
        public int                            nSwitch;                              // 起停控制 0-停止 1-启用
        public byte[]                         byReserved = new byte[16];            // 对齐 NET_LOAD_CONTROL_COMMON
    }

    // 负载控制
    public static class NET_UAVCMD_LOAD_CONTROL extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            emLoadType;                           // 负载类型，详见EM_LOAD_CONTROL_TYPE
        public NET_LOAD_CONTROL_COMMON        stuLoadInfo;                          // 负载控制信息
    }

    // 电调解锁/锁定 ENUM_UAVCMD_COMPONENT_ARM_DISARM,
    public static class NET_UAVCMD_COMPONENT_ARM_DISARM extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            bArm;                                 // TRUE - 解锁, FALSE - 锁定
        public byte[]                         byReserved = new byte[24];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 重启飞行器 ENUM_UAVCMD_PREFLIGHT_REBOOT_SHUTDOWN
    public static class NET_UAVCMD_REBOOT_SHUTDOWN extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nCtrlAutopilot;                       // 控制飞控 0 - 空 1 - 重启 2 - 关机
        public int                            nCtrlOnboardComputer;                 // 控制机载计算机 0 - 空 1 - 机载计算机重启 2 - 机载计算机关机
        public byte[]                         byReserved = new byte[20];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 继电器控制 ENUM_UAVCMD_DO_SET_RELAY
    public static class NET_UAVCMD_SET_RELAY extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nRelayNumber;                         // 继电器号
        public int                            nCtrlRelay;                           // 0=关，1=开。
        public byte[]                         byReserved = new byte[20];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 继电器循环控制 ENUM_UAVCMD_DO_REPEAT_RELAY
    public static class NET_UAVCMD_REPEAT_RELAY extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nRelayNumber;                         // 继电器号
        public int                            nCycleCount;                          // 循环次数
        public int                            nCycleTime;                           // 周期（十进制，秒）
        public byte[]                         byReserved = new byte[16];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 电子围栏启用禁用 ENUM_UAVCMD_DO_FENCE_ENABLE
    public static class NET_UAVCMD_FENCE_ENABLE extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nEnableState;                         // 启用状态 0 - 禁用 1 - 启用 2 - 仅地面禁用
        public byte[]                         byReserved = new byte[24];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 云台模式设置 ENUM_UAVCMD_MOUNT_CONFIGURE
    public static class NET_UAVCMD_MOUNT_CONFIGURE extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nMountMode;                           // 云台模式
        // 0 - 预留; 1 - 水平模式, RC 不可控; 2 - UAV模式, RC 不可控 ;
        // 3 - 航向锁定模式, RC可控; 4 - 预留; 5-垂直90度模式, RC不可控 6 - 航向跟随模式, RC可控
        public byte[]                         byReserved = new byte[24];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 异步获取Home点位置 ENUM_UAVCMD_GET_HOME_POSITION
    public static class NET_UAVCMD_GET_HOME_POSITION extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public byte[]                         byReserved = new byte[28];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 开始抓拍 ENUM_UAVCMD_IMAGE_START_CAPTURE Start image capture sequence
    public static class NET_UAVCMD_IMAGE_START_CAPTURE extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nDurationTime;                        // 连拍持续时间
        public int                            nTatolNumber;                         // 抓拍数量 0 - 表示无限制
        public int							  emResolution;                         // 分辨率为 CAPTURE_SIZE_NR时, 表示自定义。目前仅支持 CAPTURE_SIZE_VGA 和 CAPTURE_SIZE_720
        public int                            nCustomWidth;                         // 自定义水平分辨率 单位: 像素 pixel
        public int                            nCustomHeight;                        // 自定义垂直分辨率 单位: 像素 pixel
        public int                            nCameraID;                            // 相机ID
        public byte[]                         byReserved = new byte[4];             // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 分辨率枚举
    public static class CAPTURE_SIZE extends SdkStructure
    {
        public static final int CAPTURE_SIZE_D1                      = 0;   // 704*576(PAL)  704*480(NTSC),兼容WWxHH,下同
        public static final int CAPTURE_SIZE_HD1                     = 1;   // 352*576(PAL)  352*480(NTSC)
        public static final int CAPTURE_SIZE_BCIF                    = 2;   // 704*288(PAL)  704*240(NTSC)
        public static final int CAPTURE_SIZE_CIF                     = 3;   // 352*288(PAL)  352*240(NTSC)
        public static final int CAPTURE_SIZE_QCIF                    = 4;   // 176*144(PAL)  176*120(NTSC)
        public static final int CAPTURE_SIZE_VGA                     = 5;   // 640*480
        public static final int CAPTURE_SIZE_QVGA                    = 6;   // 320*240
        public static final int CAPTURE_SIZE_SVCD                    = 7;   // 480*480
        public static final int CAPTURE_SIZE_QQVGA                   = 8;   // 160*128
        public static final int CAPTURE_SIZE_SVGA                    = 9;   // 800*592
        public static final int CAPTURE_SIZE_XVGA                    = 10;  // 1024*768
        public static final int CAPTURE_SIZE_WXGA                    = 11;  // 1280*800
        public static final int CAPTURE_SIZE_SXGA                    = 12;  // 1280*1024
        public static final int CAPTURE_SIZE_WSXGA                   = 13;  // 1600*1024
        public static final int CAPTURE_SIZE_UXGA                    = 14;  // 1600*1200
        public static final int CAPTURE_SIZE_WUXGA                   = 15;  // 1920*1200
        public static final int CAPTURE_SIZE_LTF                     = 16;  // 240*192,ND1
        public static final int CAPTURE_SIZE_720                     = 17;  // 1280*720
        public static final int CAPTURE_SIZE_1080                    = 18;  // 1920*1080
        public static final int CAPTURE_SIZE_1_3M                    = 19;  // 1280*960
        public static final int CAPTURE_SIZE_2M                      = 20;  // 1872*1408,2_5M
        public static final int CAPTURE_SIZE_5M                      = 21;  // 3744*1408
        public static final int CAPTURE_SIZE_3M                      = 22;  // 2048*1536
        public static final int CAPTURE_SIZE_5_0M                    = 23;  // 2432*2050
        public static final int CPTRUTE_SIZE_1_2M                    = 24;  // 1216*1024
        public static final int CPTRUTE_SIZE_1408_1024               = 25;  // 1408*1024
        public static final int CPTRUTE_SIZE_8M                      = 26;  // 3296*2472
        public static final int CPTRUTE_SIZE_2560_1920               = 27;  // 2560*1920(5_1M)
        public static final int CAPTURE_SIZE_960H                    = 28;  // 960*576(PAL) 960*480(NTSC)
        public static final int CAPTURE_SIZE_960_720                 = 29;  // 960*720
        public static final int CAPTURE_SIZE_NHD                     = 30;  // 640*360
        public static final int CAPTURE_SIZE_QNHD                    = 31;  // 320*180
        public static final int CAPTURE_SIZE_QQNHD                   = 32;  // 160*90
        public static final int CAPTURE_SIZE_960_540                 = 33;  // 960*540
        public static final int CAPTURE_SIZE_640_352                 = 34;  // 640*352
        public static final int CAPTURE_SIZE_640_400                 = 35;  // 640*400
        public static final int CAPTURE_SIZE_320_192                 = 36;  // 320*192
        public static final int CAPTURE_SIZE_320_176                 = 37;  // 320*176
        public static final int CAPTURE_SIZE_SVGA1                   = 38;  // 800*600
        public static final int CAPTURE_SIZE_NR                      = 255;
    }

    // 停止抓拍 ENUM_UAVCMD_IMAGE_STOP_CAPTURE
    public static class NET_UAVCMD_IMAGE_STOP_CAPTURE extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nCameraID;                            // 相机ID
        public byte[]                         byReserved = new byte[24];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 开始录像 ENUM_UAVCMD_VIDEO_START_CAPTURE
    public static class NET_UAVCMD_VIDEO_START_CAPTURE extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nCameraID;                            // 相机ID 0 - 表示所有相机
        public int                            nFrameSpeed;                          // 帧率 单位: 秒 -1 表示: 最高帧率
        public int                   		  emResolution;                         // 分辨率 为 CAPTURE_SIZE_NR时, 表示自定义。目前仅支持 CAPTURE_SIZE_VGA 和 CAPTURE_SIZE_720
        public int                            nCustomWidth;                         // 自定义水平分辨率 单位: 像素 pixel
        public int                            nCustomHeight;                        // 自定义垂直分辨率 单位: 像素 pixel
        public byte[]                         byReserved = new byte[8];             // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 停止录像 ENUM_UAVCMD_VIDEO_STOP_CAPTURE
    public static class NET_UAVCMD_VIDEO_STOP_CAPTURE extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nCameraID;                            // 相机ID
        public byte[]                         byReserved = new byte[24];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 航点 ENUM_UAVCMD_NAV_WAYPOINT
    public static class NET_UAVCMD_NAV_WAYPOINT extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nHoldTime;                            // 驻留时间. 单位: 秒
        public float                          fAcceptanceRadius;                    // 触发半径. 单位: 米. 进入此半径, 认为该航点结束.
        public float                          fLatitude;                            // 纬度
        public float                          fLongitude;                           // 经度
        public float                          fAltitude;                            // 高度
        public byte[]                         byReserved = new byte[8];             // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 循环绕圈 ENUM_UAVCMD_NAV_LOITER_TURNS
    public static class NET_UAVCMD_NAV_LOITER_TURNS extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nTurnNumber;                          // 圈数.
        public float                          fRadius;                              // 盘旋半径(m), 正值顺时针, 负值逆时针.
        public float                          fLatitude;                            // 纬度
        public float                          fLongitude;                           // 经度
        public float                          fAltitude;                            // 高度
        public byte[]                         byReserved = new byte[8];             // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 在航点盘旋N秒  ENUM_UAVCMD_NAV_LOITER_TIME
    public static class NET_UAVCMD_NAV_LOITER_TIME extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nTime;                                // 时间. 单位: 秒
        public float                          fRadius;                              // 盘旋半径(m), 正值顺时针, 负值逆时针.
        public float                          fLatitude;                            // 纬度
        public float                          fLongitude;                           // 经度
        public float                          fAltitude;                            // 高度
        public byte[]                         byReserved = new byte[8];             // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 曲线航点 ENUM_UAVCMD_NAV_SPLINE_WAYPOINT
    public static class NET_UAVCMD_NAV_SPLINE_WAYPOINT extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nHoldTime;                            // 驻留时间 Hold time in decimal seconds.
        public float                          fLatitude;                            // 纬度
        public float                          fLongitude;                           // 经度
        public float                          fAltitude;                            // 高度
        public byte[]                         byReserved = new byte[12];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 引导模式开关 ENUM_UAVCMD_NAV_GUIDED_ENABLE
    public static class NET_UAVCMD_NAV_GUIDED_ENABLE extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            bEnable;                              // 使能
        public byte[]                         byReserved = new byte[24];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 跳转 ENUM_UAVCMD_DO_JUMP
    public static class NET_UAVCMD_DO_JUMP extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nSequenceNumber;                      // 任务序号
        public int                            nRepeatCount;                         // 重复次数
        public byte[]                         byReserved = new byte[20];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 引导模式执行控制限制 ENUM_UAVCMD_DO_GUIDED_LIMITS
    public static class NET_UAVCMD_DO_GUIDED_LIMITS extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nMaxTime;                             // 最大时间. 单位: 秒
        public float                          fMinAltitude;                         // 最低限制高度. 单位: 米
        public float                          fMaxAltitude;                         // 最大限制高度. 单位: 米
        public float                          fHorizontalDistance;                  // 水平限制距离. 单位: 米
        public byte[]                         byReserved = new byte[12];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 动作延时 ENUM_UAVCMD_CONDITION_DELAY
    public static class NET_UAVCMD_CONDITION_DELAY extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            nDelay;                               // 延迟时间. 单位: 秒
        public byte[]                         byReserved = new byte[24];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 动作距离 ENUM_UAVCMD_CONDITION_DISTANCE
    public static class NET_UAVCMD_CONDITION_DISTANCE extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public float                          fDistance;                            // 距离. 单位: 米
        public byte[]                         byReserved = new byte[24];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 无人机兴趣点类型
    public static class ENUM_UAV_ROI_MODE extends SdkStructure
    {
        public static final int ENUM_UAV_ROI_MODE_NONE               = 0;   // 无兴趣点
        public static final int ENUM_UAV_ROI_MODE_WPNEXT             = 1;   // 面向下一航点
        public static final int ENUM_UAV_ROI_MODE_WPINDEX            = 2;   // 面向指定兴趣点
        public static final int ENUM_UAV_ROI_MODE_LOCATION           = 3;   // 当前航点
    }

    // 相机兴趣点 ENUM_UAVCMD_DO_SET_ROI
    public static class NET_UAVCMD_DO_SET_ROI extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            emROIMode;                            // 兴趣点模式，详见ENUM_UAV_ROI_MODE
        public int                            nId;                                  // 指定航点或编号, 根据emROIMode而定
        public int                            nROIIndex;                            // ROI 编号
        public byte[]                         byReserved = new byte[16];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 相机控制 ENUM_UAVCMD_DO_DIGICAM_CONTROL
    public static class NET_UAVCMD_DO_DIGICAM_CONTROL extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public byte[]                         byReserved = new byte[28];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 云台角度控制 ENUM_UAVCMD_DO_MOUNT_CONTROL
    public static class NET_UAVCMD_DO_MOUNT_CONTROL extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public float                          fPitchAngle;                          // 俯仰角, 单位: 度. 0: 一键回中, -90 : 一键置90度
        public float                          fYawAngle;                            // 航向角, 单位: 度. 0: 一键回中, -90 : 一键置90度
        public byte[]                         byReserved = new byte[20];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 聚焦距离 ENUM_UAVCMD_DO_SET_CAM_TRIGG_DIST
    public static class NET_UAVCMD_DO_SET_CAM_TRIGG_DIST extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public float                          fDistance;                            // 聚焦距离
        public byte[]                         byReserved = new byte[24];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 设置模式 ENUM_UAVCMD_SET_MODE
    public static class NET_UAVCMD_SET_MODE extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public int                            emUAVMode;                            // 飞行模式，详见ENUM_UAV_MODE
        public byte[]                         byReserved = new byte[24];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 设定引导点 ENUM_UAVCMD_NAV_GUIDED
    public static class NET_UAVCMD_NAV_GUIDED extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 通用信息
        public float                          fLatitude;                            // 纬度
        public float                          fLongitude;                           // 经度
        public float                          fAltitude;                            // 高度
        public byte[]                         byReserved = new byte[16];            // 对齐 NET_UAVCMD_PARAM_BUFFER
    }

    // 航点命令对应的通用参数, 需要转换成 ENUM_UAVCMD_TYPE 对应的结构体
    public static class NET_UAVCMD_PARAM_BUFFER extends SdkStructure
    {
        public NET_UAVCMD_COMMON              stuCommon;                            // 命令通用信息
        public byte[]                         byParamBuffer = new byte[28];         // 参数缓存
    }

    // 摇杆模拟：输入参数
    public static class NET_UAVCMD_RC_CHANNELS_OVERRIDE extends SdkStructure
    {
        public short                          nChan1;                               // 滚转角，范围[1091, 1937]，如果未改变，填 UINT16_MAX
        public short                          nChan2;                               // 俯仰角，范围[1091, 1937]，如果未改变，填 UINT16_MAX
        public short                          nChan3;                               // 油门，范围[1091, 1937]，如果未改变，填 UINT16_MAX
        public short                          nChan4;                               // 偏航角，[1091, 1937]，如果未改变，填 UINT16_MAX
        public short                          nChan5;                               // 模式切换：取值1091,1514，1937，如果未改变，填 UINT16_MAX
        public short                          nChan6;                               // 云台航向，范围[1091,1937]，如果未改变，填 UINT16_MAX
        public short                          nChan7;                               // 云台俯仰，范围[1091,1937]，如果未改变，填 UINT16_MAX
        public short                          nChan8;                               // 起落架，取值1091，1937，如果未改变，填 UINT16_MAX
        public short                          nChan9;                               // 云台模式， 取值1091,1514，1937，如果未改变，填 UINT16_MAX
        public short                          nChan10;                              // 一键返航，取值1091,1937，如果未改变，填 UINT16_MAX
        public short                          nChan11;                              // 一键起降，取值1091,1937，如果未改变，填 UINT16_MAX
        public short                          nChan12;                              // 当前没有用到，填 UINT16_MAX
        public short                          nChan13;                              // 当前没有用到，填 UINT16_MAX
        public short                          nChan14;                              // 当前没有用到，填 UINT16_MAX
        public short                          nChan15;                              // 当前没有用到，填 UINT16_MAX
        public short                          nChan16;                              // 当前没有用到，填 UINT16_MAX
        public short                          nChan17;                              // 当前没有用到，填 UINT16_MAX
        public short                          nChan18;                              // 当前没有用到，填 UINT16_MAX
        public byte                           nTargetSystem;                        // 目标系统
        public byte                           nTargetComponent;                     // 目标组件
        public byte[]                         szReserved = new byte[6];             // 保留字段，对齐NET_UAVCMD_PARAM_BUFFER
    }

    // 心跳结构体
    public static class NET_UAVCMD_HEART_BEAT extends SdkStructure
    {
        public int                            nCustomMode;                          // 自动驾驶仪用户自定义模式
        public byte                           nType;                                // MAV 类型
        public byte                           nAutoPilot;                           // 自动驾驶仪类型
        public byte                           nBaseMode;                            // 系统模式
        public byte                           nSystemStatus;                        // 系统状态值
        public byte                           nMavlinkVersion;                      // MAVLink 版本信息
        public byte[]                         szReserved = new byte[35];            // 保留字段，对齐NET_UAVCMD_PARAM_BUFFER
    }

    // 订阅无人机实时消息 pstuInParam 和 pstuOutParam 由设备申请释放
    public LLong CLIENT_AttachUAVInfo(LLong lLoginID, NET_IN_ATTACH_UAVINFO pstuInParam, NET_OUT_ATTACH_UAVINFO pstuOutParam, int nWaitTime);

    // 退订无人机实时消息 lAttachHandle 是 CLIENT_AttachUAVInfo 返回值
    public boolean CLIENT_DetachUAVInfo(LLong lAttachHandle);

    // 警戒区入侵方向
    public static class NET_CROSSREGION_DIRECTION_INFO extends SdkStructure
    {
        public static final int EM_CROSSREGION_DIRECTION_UNKNOW      = 0;
        public static final int EM_CROSSREGION_DIRECTION_ENTER       = 1;   // 进入
        public static final int EM_CROSSREGION_DIRECTION_LEAVE       = 2;   // 离开
        public static final int EM_CROSSREGION_DIRECTION_APPEAR      = 3;   // 出现
        public static final int EM_CROSSREGION_DIRECTION_DISAPPEAR   = 4;   // 消失
    }

    // 电源类型
    public static class EM_POWER_TYPE extends SdkStructure
    {
        public static final int EM_POWER_TYPE_MAIN                   = 0;   // 主电源
        public static final int EM_POWER_TYPE_BACKUP                 = 1;   // 备用电源
    }

    // 电源故障事件类型
    public static class EM_POWERFAULT_EVENT_TYPE extends SdkStructure
    {
        public static final int EM_POWERFAULT_EVENT_UNKNOWN          = -1;  // 未知
        public static final int EM_POWERFAULT_EVENT_LOST             = 0;   // 掉电、电池不在位
        public static final int EM_POWERFAULT_EVENT_LOST_ADAPTER     = 1;   // 适配器不在位
        public static final int EM_POWERFAULT_EVENT_LOW_BATTERY      = 2;   // 电池欠压
        public static final int EM_POWERFAULT_EVENT_LOW_ADAPTER      = 3;   // 适配器欠压
    }

    // 电源故障事件
    public static class ALARM_POWERFAULT_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            emPowerType;                          // 电源类型，详见EM_POWER_TYPE
        public int                            emPowerFaultEvent;                    // 电源故障事件，详见EM_POWERFAULT_EVENT_TYPE
        public NET_TIME                       stuTime;                              // 报警事件发生的时间
        public int                            nAction;                              // 0:开始 1:停止

        public ALARM_POWERFAULT_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 防拆报警事件
    public static class ALARM_CHASSISINTRUDED_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            nAction;                              // 0:开始 1:停止
        public NET_TIME                       stuTime;                              // 报警事件发生的时间
        public int                            nChannelID;                           // 通道号
        public byte[]                         szReaderID = new byte[NET_COMMON_STRING_32];  // 读卡器ID
        public int                            nEventID;                             // 事件ID
        public byte[]                         szSN = new byte[32];                  // 无线设备序列号
        public boolean				          bRealUTC;							// RealUTC 是否有效，bRealUTC 为 TRUE 时，用 RealUTC，否则用 stuTime 字段
        public NET_TIME_EX                    RealUTC;                            // 事件发生的时间（标准UTC）
        public ALARM_CHASSISINTRUDED_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 传感器感应方式枚举类型
    public static class NET_SENSE_METHOD extends SdkStructure
    {
        public static final int NET_SENSE_UNKNOWN                    = -1;  // 未知类型
        public static final int NET_SENSE_DOOR                       = 0;   // 门磁
        public static final int NET_SENSE_PASSIVEINFRA               = 1;   // 被动红外
        public static final int NET_SENSE_GAS                        = 2;   // 气感
        public static final int NET_SENSE_SMOKING                    = 3;   // 烟感
        public static final int NET_SENSE_WATER                      = 4;   // 水感
        public static final int NET_SENSE_ACTIVEFRA                  = 5;   // 主动红外
        public static final int NET_SENSE_GLASS                      = 6;   // 玻璃破碎
        public static final int NET_SENSE_EMERGENCYSWITCH            = 7;   // 紧急开关
        public static final int NET_SENSE_SHOCK                      = 8;   // 震动
        public static final int NET_SENSE_DOUBLEMETHOD               = 9;   // 双鉴(红外+微波)
        public static final int NET_SENSE_THREEMETHOD                = 10;  // 三技术
        public static final int NET_SENSE_TEMP                       = 11;  // 温度
        public static final int NET_SENSE_HUMIDITY                   = 12;  // 湿度
        public static final int NET_SENSE_WIND                       = 13;  // 风速
        public static final int NET_SENSE_CALLBUTTON                 = 14;  // 呼叫按钮
        public static final int NET_SENSE_GASPRESSURE                = 15;  // 气体压力
        public static final int NET_SENSE_GASCONCENTRATION           = 16;  // 燃气浓度
        public static final int NET_SENSE_GASFLOW                    = 17;  // 气体流量
        public static final int NET_SENSE_OTHER                      = 18;  // 其他
        public static final int NET_SENSE_OIL                        = 19;  // 油量检测,汽油、柴油等车辆用油检测
        public static final int NET_SENSE_MILEAGE                    = 20;  // 里程数检测
        public static final int NET_SENSE_URGENCYBUTTON              = 21;  // 紧急按钮
        public static final int NET_SENSE_STEAL                      = 22;  // 盗窃
        public static final int NET_SENSE_PERIMETER                  = 23;  // 周界
        public static final int NET_SENSE_PREVENTREMOVE              = 24;  // 防拆
        public static final int NET_SENSE_DOORBELL                   = 25;  // 门铃
        public static final int NET_SENSE_ALTERVOLT                  = 26;  // 交流电压传感器
        public static final int NET_SENSE_DIRECTVOLT                 = 27;  // 直流电压传感器
        public static final int NET_SENSE_ALTERCUR                   = 28;  // 交流电流传感器
        public static final int NET_SENSE_DIRECTCUR                  = 29;  // 直流电流传感器
        public static final int NET_SENSE_RSUGENERAL                 = 30;  // 高新兴通用模拟量	4~20mA或0~5V
        public static final int NET_SENSE_RSUDOOR                    = 31;  // 高新兴门禁感应
        public static final int NET_SENSE_RSUPOWEROFF                = 32;  // 高新兴断电感应
        public static final int NET_SENSE_TEMP1500                   = 33;  // 1500温度传感器
        public static final int NET_SENSE_TEMPDS18B20                = 34;  // DS18B20温度传感器
        public static final int NET_SENSE_HUMIDITY1500               = 35;  // 1500湿度传感器
        public static final int NET_SENSE_INFRARED                   = 36;  // 红外报警
        public static final int NET_SENSE_FIREALARM                  = 37;  // 火警
        public static final int NET_SENSE_CO2                        = 38;  // CO2浓度检测,典型值:0~5000ppm
        public static final int NET_SNESE_SOUND                      = 39;  // 噪音检测,典型值:30~130dB
        public static final int NET_SENSE_PM25                       = 40;  // PM2.5检测,典型值:0~1000ug/m3
        public static final int NET_SENSE_SF6                        = 41;  // SF6浓度检测,典型值:0~3000ppm
        public static final int NET_SENSE_O3                         = 42;  // 臭氧浓度检测,典型值:0~100ppm
        public static final int NET_SENSE_AMBIENTLIGHT               = 43;  // 环境光照检测,典型值:0~20000Lux
        public static final int NET_SENSE_SIGNINBUTTON               = 44;  // 签入按钮
        public static final int NET_SENSE_LIQUIDLEVEL                = 45;  // 液位
        public static final int NET_SENSE_DISTANCE                   = 46;  // 测距
        public static final int NET_SENSE_WATERFLOW                  = 47;  // 水流量



        public static final int NET_SENSE_NUM                        = 48;  // 枚举类型总数
    }

    // 防区类型
    public static class NET_DEFENCEAREA_TYPE extends SdkStructure
    {
        public static final int NET_DEFENCEAREA_TYPE_UNKNOWN         = 0;   // 未知类型防区
        public static final int NET_DEFENCEAREA_TYPE_ALARM           = 1;   // 开关量防区
    }

    // 旁路状态类型
    public static class NET_BYPASS_MODE extends SdkStructure
    {
        public static final int NET_BYPASS_MODE_UNKNOW               = 0;   // 未知状态
        public static final int NET_BYPASS_MODE_BYPASS               = 1;   // 旁路
        public static final int NET_BYPASS_MODE_NORMAL               = 2;   // 正常
        public static final int NET_BYPASS_MODE_ISOLATED             = 3;   // 隔离
    }

    // 旁路状态变化事件的信息
    public static class ALARM_BYPASSMODE_CHANGE_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            nChannelID;                           // 通道号
        public NET_TIME                       stuTime;                              // 报警事件发生的时间
        public int                            emDefenceType;                        // 防区类型，详见NET_DEFENCEAREA_TYPE
        public int                            nIsExtend;                            // 是否为扩展(通道)防区, 1:扩展通道, 0: 非扩展通道
        public int                            emMode;                               // 变化后的模式，详见NET_BYPASS_MODE
        public int                            dwID;                                 // ID号, 遥控器编号或键盘地址, emTriggerMode为NET_EM_TRIGGER_MODE_NET类型时为0
        public int                            emTriggerMode;                        // 触发方式，详见NET_EM_TRIGGER_MODE

        public ALARM_BYPASSMODE_CHANGE_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 报警输入源事件详情(只要有输入就会产生改事件,不论防区当前的模式,无法屏蔽)
    public static class ALARM_INPUT_SOURCE_SIGNAL_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            nChannelID;                           // 通道号
        public int                            nAction;                              // 0:开始 1:停止
        public NET_TIME                       stuTime;                              // 报警事件发生的时间

        public ALARM_INPUT_SOURCE_SIGNAL_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 门禁状态类型
    public static class NET_ACCESS_CTL_STATUS_TYPE extends SdkStructure
    {
        public static final int NET_ACCESS_CTL_STATUS_TYPE_UNKNOWN   = 0;
        public static final int NET_ACCESS_CTL_STATUS_TYPE_OPEN      = 1;   // 开门
        public static final int NET_ACCESS_CTL_STATUS_TYPE_CLOSE     = 2;   // 关门
        public static final int NET_ACCESS_CTL_STATUS_TYPE_ABNORMAL  = 3;   // 异常
        public static final int NET_ACCESS_CTL_STATUS_TYPE_FAKELOCKED = 4;   // 假锁
        public static final int NET_ACCESS_CTL_STATUS_TYPE_CLOSEALWAYS = 5;   // 常闭
        public static final int NET_ACCESS_CTL_STATUS_TYPE_OPENALWAYS = 6;   // 常开
    }

    // 多人组合开门事件(对应NET_ALARM_OPENDOORGROUP类型)
    public static class ALARM_OPEN_DOOR_GROUP_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            nChannelID;                           // 门通道号(从0开始)
        public NET_TIME                       stuTime;                              // 事件时间

        public ALARM_OPEN_DOOR_GROUP_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 获取指纹事件(对应NET_ALARM_FINGER_PRINT类型)
    public static class ALARM_CAPTURE_FINGER_PRINT_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            nChannelID;                           // 门通道号(从0开始)
        public NET_TIME                       stuTime;                              // 事件时间
        public byte[]                         szReaderID = new byte[NET_COMMON_STRING_32];  // 门读卡器ID
        public int                            nPacketLen;                           // 单个指纹数据包长度
        public int                            nPacketNum;                           // 指纹数据包个数
        public Pointer                        szFingerPrintInfo;                    // 指纹数据(数据总长度即nPacketLen*nPacketNum)，指向byte
        public int                            bCollectResult;                       // 采集结果
        public byte[]			              szCardNo=new byte[32];				// 指纹所属人员卡号（定制）
        public byte[]			              szUserID=new byte[32];				// 指纹所属人员ID（定制）

        public ALARM_CAPTURE_FINGER_PRINT_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 子系统状态类型
    public static class EM_SUBSYSTEM_STATE_TYPE extends SdkStructure
    {
        public static final int EM_SUBSYSTEM_STATE_UNKNOWN           = 0;   // 未知
        public static final int EM_SUBSYSTEM_STATE_ACTIVE            = 1;   // 已激活
        public static final int EM_SUBSYSTEM_STATE_INACTIVE          = 2;   // 未激活
    }

    // 子系统状态改变事件
    public static class ALARM_SUBSYSTEM_STATE_CHANGE_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            nChannelID;                           // 子系统序号(从0开始)
        public NET_TIME                       stuTime;                              // 事件发生的时间
        public int                            emState;                              // 变化后的状态，详见EM_SUBSYSTEM_STATE_TYPE

        public ALARM_SUBSYSTEM_STATE_CHANGE_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // PSTN掉线事件
    public static class ALARM_PSTN_BREAK_LINE_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            nChannelID;                           // 电话线序号(从0开始)
        public int                            nAction;                              // 0:开始 1:停止
        public NET_TIME                       stuTime;                              // 事件发生的时间

        public ALARM_PSTN_BREAK_LINE_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 反复进入事件详细信息
    public static class ALARM_ACCESS_CTL_REPEAT_ENTER_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            nDoor;                                // 门通道号
        public byte[]                         szDoorName = new byte[NET_MAX_DOORNAME_LEN];  // 门禁名称
        public NET_TIME                       stuTime;                              // 报警事件发生的时间
        public byte[]                         szCardNo = new byte[NET_MAX_CARDNO_LEN];  // 卡号
        public int                            nEventID;                             // 事件ID

        public ALARM_ACCESS_CTL_REPEAT_ENTER_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 胁迫卡刷卡事件详细信息
    public static class ALARM_ACCESS_CTL_DURESS_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            nDoor;                                // 门通道号
        public byte[]                         szDoorName = new byte[NET_MAX_DOORNAME_LEN];  // 门禁名称
        public byte[]                         szCardNo = new byte[NET_MAX_CARDNO_LEN];  // 胁迫卡号
        public NET_TIME                       stuTime;                              // 报警事件发生的时间
        public int                            nEventID;                             // 事件ID
        public byte[]                         szSN = new byte[32];                  // 无线设备序列号
        public byte[]			              szUserID=new byte[12];				// 用户ID
        public boolean			              bRealUTC;								// RealUTC 是否有效，bRealUTC 为 TRUE 时，用 RealUTC，否则用 stuTime 字段
        public NET_TIME_EX                    RealUTC;								// 事件发生的时间（标准UTC）
        public ALARM_ACCESS_CTL_DURESS_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 区域检测事件动作
    public static class NET_CROSSREGION_ACTION_INFO extends SdkStructure
    {
        public static final int EM_CROSSREGION_ACTION_UNKNOW         = 0;
        public static final int EM_CROSSREGION_ACTION_INSIDE         = 1;   // 在区域内
        public static final int EM_CROSSREGION_ACTION_CROSS          = 2;   // 穿越区域
        public static final int EM_CROSSREGION_ACTION_APPEAR         = 3;   // 出现
        public static final int EM_CROSSREGION_ACTION_DISAPPEAR      = 4;   // 消失
    }

    // 警戒线入侵方向
    public static class NET_CROSSLINE_DIRECTION_INFO extends SdkStructure
    {
        public static final int EM_CROSSLINE_DIRECTION_UNKNOW        = 0;
        public static final int EM_CROSSLINE_DIRECTION_LEFT2RIGHT    = 1;   // 左到右
        public static final int EM_CROSSLINE_DIRECTION_RIGHT2LEFT    = 2;   // 右到左
        public static final int EM_CROSSLINE_DIRECTION_ANY           = 3;
    }

    // 警戒线事件(对应事件 NET_EVENT_CROSSLINE_DETECTION)
    public static class ALARM_EVENT_CROSSLINE_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            nChannelID;                           // 通道号
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID
        public int                            nEventAction;                         // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;

        public int                            emCrossDirection;                     // 入侵方向，详见NET_CROSSLINE_DIRECTION_INFO
        public int                            nOccurrenceCount;                     // 规则被触发生次数
        public int                            nLevel;                               // 事件级别,GB30147需求项
        public int                            bIsObjectInfo;                        // 是否检测到物体信息
        public NET_MSG_OBJECT                 stuObject;                            // 检测到的物体信息
        public int                            nRetObjectNum;                        // 实际返回多个检测到的物体信息
        public NET_MSG_OBJECT[]               stuObjects = new NET_MSG_OBJECT[MAX_TARGET_OBJECT_NUM];  // 多个检测到的物体信息

        public ALARM_EVENT_CROSSLINE_INFO()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuObjects.length; ++i) {
                stuObjects[i] = new NET_MSG_OBJECT();
            }
        }
    }

    //警戒区事件(对应事件 NET_EVENT_CROSSREGION_DETECTION)
    public static class ALARM_EVENT_CROSSREGION_INFO extends SdkStructure
    {
        public int                            dwSize;
        public int                            nChannelID;                           // 通道号
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID
        public int                            nEventAction;                         // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;

        public int                            emDirection;                          // 警戒区入侵方向，详见NET_CROSSREGION_DIRECTION_INFO
        public int                            emActionType;                         // 警戒区检测动作类型，详见NET_CROSSREGION_ACTION_INFO
        public int                            nOccurrenceCount;                     // 规则被触发生次数
        public int                            nLevel;                               // 事件级别,GB30147需求项
        public byte[]                         szName = new byte[NET_COMMON_STRING_128];  // 名称
        public int                            bIsObjectInfo;                        // 是否检测到物体信息
        public NET_MSG_OBJECT                 stuObject;                            // 检测到的物体信息
        public int                            nRetObjectNum;                        // 实际返回多个检测到的物体信息
        public NET_MSG_OBJECT[]               stuObjects = new NET_MSG_OBJECT[MAX_TARGET_OBJECT_NUM];  // 多个检测到的物体信息

        public ALARM_EVENT_CROSSREGION_INFO()
        {
            this.dwSize = this.size();

            for (int i = 0; i < stuObjects.length; ++i) {
                stuObjects[i] = new NET_MSG_OBJECT();
            }
        }
    }

    // 探测器状态
    public static class EM_SENSOR_ABNORMAL_STATUS extends SdkStructure
    {
        public static final int NET_SENSOR_ABNORMAL_STATUS_UNKNOWN   = 0;
        public static final int NET_SENSOR_ABNORMAL_STATUS_SHORT     = 1;   // 短路
        public static final int NET_SENSOR_ABNORMAL_STATUS_BREAK     = 2;   // 断路
        public static final int NET_SENSOR_ABNORMAL_STATUS_INTRIDED  = 3;   // 被拆开
    }

    //事件类型(NET_ALARM_SENSOR_ABNORMAL) 探测器状态异常报警
    public static class ALARM_SENSOR_ABNORMAL_INFO extends SdkStructure
    {
        public int                            nAction;                              // 0:开始 1:停止
        public int                            nChannelID;                           // 视频通道号
        public NET_TIME_EX                    stuTime;                              // 事件发生的时间
        public int                            emStatus;                             // 探测器状态，详见EM_SENSOR_ABNORMAL_STATUS
        public byte[]                         byReserved = new byte[128];           // 预留字段
    }

    // 防区布防撤防状态类型
    public static class EM_DEFENCEMODE extends SdkStructure
    {
        public static final int EM_DEFENCEMODE_UNKNOWN               = 0;   // "unknown"   未知
        public static final int EM_DEFENCEMODE_ARMING                = 1;   // "Arming"    布防
        public static final int EM_DEFENCEMODE_DISARMING             = 2;   // "Disarming" 撤防
    }

    //触发方式
    public static class EM_ARMMODECHANGE_TRIGGERMODE extends SdkStructure
    {
        public static final int EM_ARMMODECHANGE_TRIGGERMODE_UNKNOWN = 0;   // 未知
        public static final int EM_ARMMODECHANGE_TRIGGERMODE_NET     = 1;   // 网络用户
        public static final int EM_ARMMODECHANGE_TRIGGERMODE_KEYBOARD = 2;   // 键盘
        public static final int EM_ARMMODECHANGE_TRIGGERMODE_REMOTECONTROL = 3;   // 遥控器
    }

    //防区类型
    public static class EM_ARMMODECHANGE_DEFENCEAREATYPE extends SdkStructure
    {
        public static final int EM_ARMMODECHANGE_DEFENCEAREATYPE_UNKNOWN = 0;   // 未知
        public static final int EM_ARMMODECHANGE_DEFENCEAREATYPE_INTIME = 1;   // 及时
        public static final int EM_ARMMODECHANGE_DEFENCEAREATYPE_DELAY = 2;   // 延时
        public static final int EM_ARMMODECHANGE_DEFENCEAREATYPE_FULLDAY = 3;   // 全天
        public static final int EM_ARMMODECHANGE_DEFENCEAREATYPE_FOLLOW = 4;   // 跟随
        public static final int EM_ARMMODECHANGE_DEFENCEAREATYPE_MEDICAL = 5;   // 医疗紧急
        public static final int EM_ARMMODECHANGE_DEFENCEAREATYPE_PANIC = 6;   // 恐慌
        public static final int EM_ARMMODECHANGE_DEFENCEAREATYPE_FIRE = 7;   // 火警
        public static final int EM_ARMMODECHANGE_DEFENCEAREATYPE_FULLDAYSOUND = 8;   // 全天有声
        public static final int EM_ARMMODECHANGE_DEFENCEAREATYPE_FULLDAYSILENT = 9;   // 全天无声
        public static final int EM_ARMMODECHANGE_DEFENCEAREATYPE_ENTRANCE1 = 10;  // 出入防区1
        public static final int EM_ARMMODECHANGE_DEFENCEAREATYPE_ENTRANCE2 = 11;  // 出入防区2
        public static final int EM_ARMMODECHANGE_DEFENCEAREATYPE_INSIDE = 12;  // 内部防区
        public static final int EM_ARMMODECHANGE_DEFENCEAREATYPE_OUTSIDE = 13;  // 外部防区
        public static final int EM_ARMMODECHANGE_DEFENCEAREATYPE_PEOPLEDETECT = 14;  // 人员检测
    }

    // 事件类型NET_ALARM_DEFENCE_ARMMODECHANGE (防区布撤防状态改变事件)
    public static class ALARM_DEFENCE_ARMMODECHANGE_INFO extends SdkStructure
    {
        public int                            emDefenceStatus;                      // 布撤防状态，详见EM_DEFENCEMODE
        public int                            nDefenceID;                           // 防区号
        public NET_TIME_EX                    stuTime;                              // 时间

        public int                            emTriggerMode;                        // 触发方式，详见EM_ARMMODECHANGE_TRIGGERMODE
        public int                            emDefenceAreaType;                    // 防区类型，详见EM_ARMMODECHANGE_DEFENCEAREATYPE
        public int                            nID;                                  // 遥控器编号或键盘地址
        public int                            nAlarmSubSystem;                      // 子系统号
        public byte[]                         szName = new byte[64];                // 防区名称
        public byte[]                         szNetClientAddr = new byte[64];       // 用户IP或网络地址

        public byte[]                         reserved = new byte[368];             // 预留
    }

    // 工作状态
    public static class EM_SUBSYSTEMMODE extends SdkStructure
    {
        public static final int EM_SUBSYSTEMMODE_UNKNOWN             = 0;   // "unknown"   未知
        public static final int EM_SUBSYSTEMMODE_ACTIVE              = 1;   // "active"    激活
        public static final int EM_SUBSYSTEMMODE_INACTIVE            = 2;   // "inactive"  未激活
        public static final int EM_SUBSYSTEMMODE_UNDISTRIBUTED       = 3;   // "undistributed" 未分配
        public static final int EM_SUBSYSTEMMODE_ALLARMING           = 4;   // "AllArming" 全部布防
        public static final int EM_SUBSYSTEMMODE_ALLDISARMING        = 5;   // "AllDisarming" 全部撤防
        public static final int EM_SUBSYSTEMMODE_PARTARMING          = 6;   // "PartArming" 部分布防
    }

    //触发方式
    public static class EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE extends SdkStructure
    {
        public static final int EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE_UNKNOWN = 0;   // 未知
        public static final int EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE_NET = 1;   // 网络用户
        public static final int EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE_KEYBOARD = 2;   // 键盘
        public static final int EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE_REMOTECONTROL = 3;   // 遥控器
    }

    // 事件类型 NET_ALARM_SUBSYSTEM_ARMMODECHANGE (子系统布撤防状态改变事件)
    public static class ALARM_SUBSYSTEM_ARMMODECHANGE_INFO extends SdkStructure
    {
        public int                            emSubsystemMode;                      // 布撤防状态 (只支持AllArming，AllDisarming，PartArming三种状态)，详见EM_SUBSYSTEMMODE
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public byte[]                         szSubSystemname = new byte[64];       // 子系统名称
        public int                            nSubSystemID;                         // 子系统编号

        public int                            emTriggerMode;                        // 触发方式，详见EM_SUBSYSTEM_ARMMODECHANGE_TRIGGERMODE
        public int                            nID;                                  // 键盘或遥控器地址
        public byte[]                         szNetClientAddr = new byte[64];       // 网络用户IP地址或网络地址

        public byte[]                         reserved = new byte[440];             // 预留
    }

    // 立体视觉站立事件区域内人员列表
    public static class MAN_STAND_LIST_INFO extends SdkStructure
    {
        public NET_POINT                      stuCenter;                            // 站立人员所在位置,8192坐标系
        public byte[]                szSerialUUID=new byte[22];   // 智能物体全局唯一物体标识
        // 有效数据位21位，包含’\0’
        // 前2位%d%d:01-视频片段, 02-图片, 03-文件, 99-其他
        // 中间14位YYYYMMDDhhmmss:年月日时分秒
        // 后5位%u%u%u%u%u：物体ID，如00001
        public DH_RECT             stuBoundingBox;     // 包围盒
        public byte[]              szReversed = new byte[90];           // 保留字节
    }

    // 事件类型EVENT_IVS_MAN_STAND_DETECTION(立体视觉站立事件)对应数据块描述信息
    public static class DEV_EVENT_MANSTAND_DETECTION_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public byte[]                         szName = new byte[NET_EVENT_NAME_LEN];  // 事件名称
        public byte[]                         bReserved1 = new byte[4];             // 字节对齐,非保留字节
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID
        ///////////////////////////////以上为公共字段，除nChannelID外的其他字段是为了预留公共字段空间//////////////////////////////
        public int                            nAction;                              // 0:脉冲 1:开始 2:停止
        public int                            nManListCount;                        // 区域人员列表数量
        public MAN_STAND_LIST_INFO[]          stuManList = new MAN_STAND_LIST_INFO[MAX_MAN_LIST_COUNT];  // 区域内人员列表
        public EVENT_INTELLI_COMM_INFO        stuIntelliCommInfo;                   // 智能事件公共信息
        public byte[]                         szReversed = new byte[2048];          // 保留字节

        public DEV_EVENT_MANSTAND_DETECTION_INFO()
        {
            for (int i = 0; i < stuManList.length; ++i) {
                stuManList[i] = new MAN_STAND_LIST_INFO();
            }
        }
    }

    // 课堂行为动作类型
    public static class EM_CLASSROOM_ACTION extends SdkStructure
    {
        public static final int EM_CLASSROOM_ACTION_UNKNOWN          = 0;   // 未知
        public static final int EM_CLASSROOM_ACTION_PLAY_PHONE       = 1;   // 玩手机
        public static final int EM_CLASSROOM_ACTION_HANDSUP          = 2;   // 举手
        public static final int EM_CLASSROOM_ACTION_LISTEN           = 3;   // 听讲
        public static final int EM_CLASSROOM_ACTION_READ_WRITE       = 4;   // 读写
        public static final int EM_CLASSROOM_ACTION_TABLE            = 5;   // 趴桌子
    }

    // 事件类型 EVENT_IVS_CLASSROOM_BEHAVIOR (课堂行为分析事件) 对应的数据块描述信息
    public static class DEV_EVENT_CLASSROOM_BEHAVIOR_INFO extends SdkStructure
    {
        public int                            nChannelID;                           // 通道号
        public int                            nAction;                              // 0:脉冲 1:开始 2:停止
        public byte[]                         szName = new byte[128];               // 事件名称
        public double                         PTS;                                  // 时间戳(单位是毫秒)
        public NET_TIME_EX                    UTC;                                  // 事件发生的时间
        public int                            nEventID;                             // 事件ID
        public NET_EVENT_FILE_INFO            stuFileInfo;                          // 事件对应文件信息

        public int                            emClassType;                          // 智能事件所属大类，详见EM_SCENE_CLASS_TYPE
        public int                            nRuleID;                              // 智能事件规则编号，用于标示哪个规则触发的事件
        public int                            nObjectID;                            // 物体ID
        public int                            nSequence;                            // 帧序号
        public int                            emClassroomAction;                    // 课堂行为动作，详见EM_CLASSROOM_ACTION
        public NET_POINT[]                    stuDetectRegion = new NET_POINT[NET_MAX_DETECT_REGION_NUM];  // 规则检测区域
        public int                            nDetectRegionNum;                     // 规则检测区域顶点数
        public int                            nPresetID;                            // 事件触发的预置点号
        public byte[]                         szPresetName = new byte[64];          // 事件触发的预置点名称
        public byte[]                         szSerialUUID = new byte[22];          // 智能物体全局唯一物体标识
        // 格式如下：前2位%d%d:01-视频片段,02-图片,03-文件,99-其他;
        //中间14位YYYYMMDDhhmmss:年月日时分秒;后5位%u%u%u%u%u：物体ID，如00001
        public byte[]                         byReserved1 = new byte[2];            // 用于字节对齐
        public NET_RECT                       stuBoundingBox;                       // 包围盒
        public NET_INTELLIGENCE_IMAGE_INFO    stuSceneImage;                        // 人脸底图信息
        public NET_INTELLIGENCE_IMAGE_INFO    stuFaceImage;                         // 人脸小图信息
        public NET_FACE_ATTRIBUTE_EX          stuFaceAttributes;                    // 人脸属性
        public byte[]                         byReserved = new byte[1024];          // 预留字节

        public DEV_EVENT_CLASSROOM_BEHAVIOR_INFO()
        {
            for (int i = 0; i < stuDetectRegion.length; ++i) {
                stuDetectRegion[i] = new NET_POINT();
            }
        }
    }

    // 抓拍类型
    public static class NET_EM_SNAP_SHOT_TYPE extends SdkStructure
    {
        public static final int NET_EM_SNAP_SHOT_TYPE_UNKNOWN        = 0;   // 未知
        public static final int NET_EM_SNAP_SHOT_TYPE_NEAR           = 1;   // 近景
        public static final int NET_EM_SNAP_SHOT_TYPE_MEDIUM         = 2;   // 中景
        public static final int NET_EM_SNAP_SHOT_TYPE_FAR            = 3;   // 远景
        public static final int NET_EM_SNAP_SHOT_TYPE_FEATURE        = 4;   // 车牌特写
    }

    // 抓拍间隔模式
    public static class NET_EM_SNAP_SHOT_INTERVAL_MODE extends SdkStructure
    {
        public static final int NET_EM_SNAP_SHOT_INTERVAL_UNKNOWN    = 0;   // 未知
        public static final int NET_EM_SNAP_SHOT_INTERVAL_TIME       = 1;   // 按固定时间间隔，该模式下nSingleInterval有效
        public static final int NET_EM_SNAP_SHOT_INTERVAL_FRAMEADAPTSPEED = 2;   // 速度自适应帧间隔
        public static final int NET_EM_SNAP_SHOT_INTERVAL_FRAME      = 3;   // 固定帧间隔
    }

    // 规则集抓拍参数
    public static class NET_SNAP_SHOT_WITH_RULE_INFO extends SdkStructure
    {
        public int                            nRuleId;
        public int                            dwRuleType;                           // 规则类型，详见dhnetsdk.h中"智能分析事件类型"
        public int                            nSnapShotNum;                         // 抓拍图片张数
        public int[]                          emSnapShotType = new int[MAX_SNAP_SHOT_NUM];  // 抓拍图片类型数组，详见NET_EM_SNAP_SHOT_TYPE
        public int[]                          nSingleInterval = new int[MAX_SNAP_SHOT_NUM];  // 抓图时间间隔数组,单位秒，数组第一个时间:5~180 默认10， 其余时间(N张抓拍有N-1个间隔时):1~3600 默认20
        public int                            emIntervalMode;                       // 抓拍间隔模式，详见NET_EM_SNAP_SHOT_INTERVAL_MODE
        public byte[]                         byReserved = new byte[1024];          // 预留
    }

    // 抓拍参数
    public static class NET_SCENE_SNAP_SHOT_WITH_RULE2_INFO extends SdkStructure
    {
        public int                            nPresetID;                            // 场景预置点号
        public int                            nRetSnapShotRuleNum;                  // stuSnapShotWithRule中有效数据个数
        public NET_SNAP_SHOT_WITH_RULE_INFO[] stuSnapShotWithRule = new NET_SNAP_SHOT_WITH_RULE_INFO[32];  // 规则集抓拍参数
        public byte[]                         byReserved = new byte[1024];          // 预留

        public NET_SCENE_SNAP_SHOT_WITH_RULE2_INFO()
        {
            for (int i = 0; i < stuSnapShotWithRule.length; ++i) {
                stuSnapShotWithRule[i] = new NET_SNAP_SHOT_WITH_RULE_INFO();
            }
        }
    }

    // 场景抓拍设置 对应枚举 NET_EM_CFG_SCENE_SNAP_SHOT_WITH_RULE2
    public static class NET_CFG_SCENE_SNAP_SHOT_WITH_RULE2_INFO extends SdkStructure
    {
        public int                            dwSize;                               // 结构体大小
        public int                            nMaxRuleNum;                          // pstuSnapShotWithRule中用户分配的内存个数
        public int                            nRetRuleNum;                          // pstuSnapShotWithRule中实际有效的数据个数
        public Pointer                        pstuSceneSnapShotWithRule;            // 抓拍参数,由用户分配和释放内存，大小为nMaxRuleNum * sizeof(NET_SCENE_SNAP_SHOT_WITH_RULE2_INFO)，指向NET_SCENE_SNAP_SHOT_WITH_RULE2_INFO

        public NET_CFG_SCENE_SNAP_SHOT_WITH_RULE2_INFO()
        {
            this.dwSize = this.size();
        }
    }

    // 车辆动作
    public static class EM_VEHICLE_ACTION extends Structure{
        public static final int EM_VEHICLE_ACTION_UNKNOWN=0;          // 未知
        public static final int EM_VEHICLE_ACTION_APPEAR=1;           // "Appear"在检测区域内
        public static final int EM_VEHICLE_ACTION_DISAPPEAR=2;        // "Disappear"离开检测区域
    }

    // 检测到的车辆信息
    public static class NET_DETECT_VEHICLE_INFO extends SdkStructure{
        public int                     emAction;               // 检测车辆动作
        public int /*UINT*/            nObjectID;              // 物体ID
        public int                     emCategoryType;         // 车辆类型
        public EVENT_PIC_INFO          stuVehicleImage;        // 车辆抓图信息
        public NET_COLOR_RGBA          stuColor;               // 车身主要颜色
        public int /*UINT*/            nFrameSequence;         // 帧序号
        public int /*UINT*/            nCarLogoIndex;          // 车辆车标
        public int /*UINT*/            nSubBrand;              // 车辆子品牌
        public int /*UINT*/            nBrandYear;             // 车辆品牌年款
        public int /*UINT*/            nConfidence;            // 置信度,值越大表示置信度越高, 范围 0~255
        public NET_RECT                stuBoundingBox;         // 包围盒, 0-8191相对坐标
        public byte[]                  szText=new byte[128];   // 车标
        public int /*UINT*/            nSpeed;                 // 车速,单位为km/h
        public int /*UINT*/            nDirection;             // 车辆行驶方向, 0:未知, 1:上行方向, 2:下行方向
        public byte[]                  bReserved=new byte[512];// 保留字节
    }

    // 检测的车牌信息
    public static class NET_DETECT_PLATE_INFO extends SdkStructure{
        public int /*UINT*/            nObjectID;              // 车牌ID
        public int /*UINT*/            nRelativeID;            // 关联的车辆ID
        public int                     emPlateType;            // 车牌类型
        public EVENT_PIC_INFO          stuPlateImage;          // 车牌图片信息
        public int                     emPlateColor;           // 车牌颜色
        public int /*UINT*/            nConfidence;            // 置信度,值越大表示置信度越高, 范围 0~255
        public byte[]                  szCountry=new byte[3];  // 车牌国家
        public byte[]                  szPlateNumber=new byte[128];    // 车牌号码
        public byte[]                  bReserved=new byte[512];// 保留字节
    }

    // 加油站车辆检测事件 (对应 DEV_EVENT_GASSTATION_VEHICLE_DETECT_INFO)
    public static class DEV_EVENT_GASSTATION_VEHICLE_DETECT_INFO extends SdkStructure
    {
        public int						nChannelID;									// 通道号
        public int						nAction;									// 0:脉冲1:开始 2:停止
        public byte[]					szName = new byte[NET_EVENT_NAME_LEN];      // 事件名称
        public double				    PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX		        UTC;								        // 事件发生的时间
        public int						nEventID;									// 事件ID
        public int						nRuleID;									// 智能事件规则编号，用于标示哪个规则触发的事件
        public int					    emClassType;				                // 智能事件所属大类
        public NET_DETECT_VEHICLE_INFO  stuDetectVehicleInfo;                       // 检测到的车辆信息
        public NET_DETECT_PLATE_INFO    stuDetectPlateInfo;                         // 检测到的车牌信息
        public boolean                  bIsGlobalScene;                             // 是否有场景图
        public EVENT_PIC_INFO           stuSceneImage;                              // 场景图信息, bIsGlobalScene 为 TRUE 时有效
        public int                      nCarCandidateNum;                           // 候选车辆数量
        public NET_CAR_CANDIDATE_INFO[] stuCarCandidate = (NET_CAR_CANDIDATE_INFO[])new NET_CAR_CANDIDATE_INFO().toArray(MAX_CAR_CANDIDATE_NUM);  // 候选车辆数据
        /*public boolean                  bIsEmptyPlace;                              // 是否是空车位报警*/
        public byte[]                   bReserved=new byte[1024];                   // 保留字节
    }

    // 事件级别，GB30147需求
    public static class EM_EVENT_LEVEL extends Structure
    {
        public static final int EM_EVENT_LEVEL_HINT = 0;										// 提示
        public static final int EM_EVENT_LEVEL_GENERAL=1;										// 普通
        public static final int EM_EVENT_LEVEL_WARNING=2;										// 警告
    }

    // 事件类型EVENT_IVS_SHOPPRESENCE(商铺占道经营事件)对应的数据块描述信息
    public static class DEV_EVENT_SHOPPRESENCE_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName=new byte[128];                       // 事件名称
        public byte[]              bReserved1=new byte[4];                     // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_MSG_OBJECT      stuObject;                                  // 检测到的物体，推荐使用字段stuObjects获取物体信息
        public int                 nDetectRegionNum;                           // 规则检测区域顶点数
        public NET_POINT[] DetectRegion = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM);     // 规则检测区域
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public byte                 bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved=new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public int                 nSourceIndex;                               // 事件源设备上的index,-1表示数据无效
        public byte[]              szSourceDevice = new byte[MAX_PATH];        // 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int                 nOccurrenceCount;                           // 事件触发累计次数
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
        public byte[]			   szPresetName=new byte[64];                  // 事件触发的预置点名称
        public int		           emEventLevel;							   // 事件级别，GB30147需求
        public byte[]			   szShopAddress=new byte[256];		           // 商铺地址
        public int                 nViolationDuration;                         // 违法持续时长，单位：秒，缺省值0表示无意义
        public int				   nObjectNum;								   // 检测到的物体个数
        public NET_MSG_OBJECT[]    stuObjects = (NET_MSG_OBJECT[]) new NET_MSG_OBJECT().toArray(HDBJ_MAX_OBJECTS_NUM);// 检测到的物体
        public byte[]			   szSourceID=new byte[32];					   // 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
        public byte[]              byReserved2=new byte[2048];				   // 保留字节
    }

    // 事件类型 EVENT_IVS_FLOWBUSINESS (流动摊贩事件) 对应的数据块描述信息
    public static class DEV_EVENT_FLOWBUSINESS_INFO extends SdkStructure
    {
        public int                 nChannelID;									// 通道号
        public int                 nAction;										// 0:脉冲 1:开始 2:停止
        public byte[]              szName=new byte[128];						// 事件名称
        public double              PTS;											// 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;											// 事件发生的时间
        public int                 nEventID;									// 事件ID
        public NET_EVENT_FILE_INFO stuFileInfo;							        // 事件对应文件信息
        public int                 nDetectRegionNum;                   			// 检测区域顶点数
        public NET_POINT[]         DetectRegion = (NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM);// 检测区域
        public byte[]			   szPresetName=new byte[64];					// 事件触发的预置名称
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;					// 智能事件公共信息
        public int                 nViolationDuration;                          // 违法持续时长，单位：秒 缺省值0表示无意义
        public int				   nObjectNum;									// 检测到的物体个数
        public NET_MSG_OBJECT[]    stuObjects = (NET_MSG_OBJECT[]) new NET_MSG_OBJECT().toArray(HDBJ_MAX_OBJECTS_NUM);// 检测到的物体
        public byte[]			   szSourceID=new byte[32];						// 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
        public int                 dwSnapFlagMask;								// 抓图标志(按位),具体见NET_RESERVED_COMMON
        public byte[]              byReserved=new byte[2044];					// 保留字节
    }

    // 立体视觉区域内人数统计事件区域人员列表
    public static class MAN_NUM_LIST_INFO extends SdkStructure
    {
        public DH_RECT				stuBoudingBox;			                     // 人员包围盒,8192坐标系
        public int					nStature;				                     // 人员身高，单位cm
        public byte[]               szReversed=new byte[128];    	             // 保留字节
    }

    // 事件类型EVENT_IVS_MAN_NUM_DETECTION(立体视觉区域内人数统计事件)对应数据块描述信息
    public static class DEV_EVENT_MANNUM_DETECTION_INFO extends SdkStructure
    {
        public int                 		nChannelID;                               // 通道号
        public byte[]                	szName=new byte[128];                     // 事件名称
        public byte[]                	bReserved1=new byte[4];                   // 字节对齐, 非保留字节
        public double              		PTS;                                      // 时间戳(单位是毫秒)
        public NET_TIME_EX         		UTC;                                      // 事件发生的时间
        public int                 		nEventID;                                 // 事件ID
        ///////////////////////////////以上为公共字段，除nChannelID外的其他字段是为了预留公共字段空间//////////////////////////////
        public int                 		nAction;                                  // 0:脉冲 1:开始 2:停止
        public int						nManListCount;				              // 区域人员列表数量
        public MAN_NUM_LIST_INFO[]		stuManList=new MAN_NUM_LIST_INFO[MAX_MAN_LIST_COUNT];	// 区域内人员列表
        public EVENT_INTELLI_COMM_INFO  stuIntelliCommInfo;                       // 智能事件公共信息
        public int						nAreaID;					              // 区域ID(一个预置点可以对应多个区域ID)
        public int                      nPrevNumber;                              // 变化前人数
        public int                      nCurrentNumber;                           // 当前人数
        public byte[]                   szSourceID =new byte[32];                 // 事件关联ID。应用场景是同一个物体或者同一张图片做不同分析，产生的多个事件的SourceID相同
    															                  // 缺省时为空字符串，表示无此信息
    															                  // 格式：类型+时间+序列号，其中类型2位，时间14位，序列号5位
        public byte[]                   szRuleName =new byte[128];                // 规则名称
        public byte[]                	szReversed=new byte[1876];                // 保留字节
    }

    public static class EM_ALARM_TYPE extends SdkStructure
    {
        public static final int EM_ALARM_TYPE_UNKNOWN = 0;								// 未知类型
        public static final int EM_ALARM_TYPE_CROWD_DENSITY = 1;						// 拥挤人群密度报警
        public static final int EM_ALARM_TYPE_NUMBER_EXCEED = 2;						// 人数超限报警
        public static final int EM_ALARM_TYPE_CROWD_DENSITY_AND_NUMBER_EXCEED = 3;		// 拥挤人群密度报警和人数超限报警
    };

    // 全局拥挤人群密度列表(圆形)信息
    public static class NET_CROWD_LIST_INFO extends SdkStructure
    {
        public NET_POINT			stuCenterPoint;				// 中心点坐标,8192坐标系
        public int		nRadiusNum;					// 半径像素点个数
        public byte[]				byReserved=new byte[1024];			// 保留字节
    };

    // 人数超限的报警区域ID列表信息
    public static class NET_REGION_LIST_INFO extends SdkStructure
    {
        public int		nRegionID;				// 配置的区域下标
        public int		nPeopleNum;				// 区域内人数统计值
        public byte[]				byReserved=new byte[1024];		// 保留字节
    };

    // 全局拥挤人群密度列表(矩形)信息
    public static class NET_CROWD_RECT_LIST_INFO  extends SdkStructure
    {
        public NET_POINT[]   stuRectPoint = (NET_POINT[])new NET_POINT().toArray(RECT_POINT);   // 矩形的左上角点与右下角点,8192坐标系，表示矩形的人群密度矩形框
        public byte[]				byReserved=new byte[32];			    // 保留字节
    };
    // 事件类型 EVENT_IVS_CROWDDETECTION(人群密度检测事件）对应的数据块描述信息
    public static class DEV_EVENT_CROWD_DETECTION_INFO extends SdkStructure
    {
        public int					  nChannelID;							// 通道号
        public int					  nEventID;								// 事件ID
        public double				  PTS;									// 时间戳(单位是毫秒)
        public NET_TIME_EX			  UTC;									// 事件发生的时间
        public int                    nEventAction;							// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
        public int		              emAlarmType;							// 报警业务类型
        public byte[]				  szName=new byte[MAX_CROWD_DETECTION_NAME_LEN];	// 事件名称
        public int					  nCrowdListNum;						// 返回的全局拥挤人群密度列表个数 （圆形描述）
        public int					  nRegionListNum;						// 返回的人数超限的报警区域ID列表个数
        public NET_CROWD_LIST_INFO[]	  stuCrowdList=new NET_CROWD_LIST_INFO[MAX_CROWD_LIST_NUM];		// 全局拥挤人群密度列表信息（圆形描述）
        public NET_REGION_LIST_INFO[]   stuRegionList=new NET_REGION_LIST_INFO[MAX_REGION_LIST_NUM];	// 人数超限的报警区域ID列表信息
        public NET_EXTENSION_INFO    stuExtensionInfo;					    // 扩展信息
        public int					  nCrowdRectListNum;					// 返回的全局拥挤人群密度列表个数 (矩形描述)
        public NET_CROWD_RECT_LIST_INFO[] stuCrowdRectList=new NET_CROWD_RECT_LIST_INFO[MAX_CROWD_RECT_LIST];  // 全局拥挤人群密度列表信息(矩形描述)
        public int					  nGlobalPeopleNum;						// 检测区全局总人数
        public byte[]				  byReserved=new byte[692];						// 保留扩展字节
    };

    // 人群密度检测事件(对应事件NET_ALARM_CROWD_DETECTION)
    public static class ALARM_CROWD_DETECTION_INFO extends SdkStructure
    {
        public int					  nChannelID;							// 通道号
        public int					  nEventID;								// 事件ID
        public double				  PTS;									// 时间戳(单位是毫秒)
        public NET_TIME_EX			  UTC;									// 事件发生的时间
        public int                   nEventAction;							// 事件动作,1表示持续性事件开始,2表示持续性事件结束;
        public int		             emAlarmType;							// 报警业务类型
        public byte[]				  szName=new byte[MAX_CROWD_DETECTION_NAME_LEN];	// 事件名称
        public int					  nCrowdListNum;						// 返回的全局拥挤人群密度列表个数
        public int					  nRegionListNum;						// 返回的人数超限的报警区域ID列表个数
        public NET_CROWD_LIST_INFO[]	  stuCrowdList=new NET_CROWD_LIST_INFO[MAX_CROWD_LIST_NUM];		// 全局拥挤人群密度列表信息
        public NET_REGION_LIST_INFO[]  stuRegionList=new NET_REGION_LIST_INFO[MAX_REGION_LIST_NUM];	// 人数超限的报警区域ID列表信息
        public NET_EXTENSION_INFO    stuExtensionInfo;				        // 扩展信息
        public byte[]				  byReserved=new byte[896];						// 保留扩展字节
    };

    // 对象目标类型
    public static class EM_OBJECT_TYPE extends SdkStructure
    {
        public static final int  EM_OBJECT_TYPE_UNKNOWN    = -1;                    // 未知
        public static final int EM_OBJECT_TYPE_FACE        =  0;                    // 人脸
        public static final int EM_OBJECT_TYPE_HUMAN       =  1;                    // 人体
        public static final int EM_OBJECT_TYPE_VECHILE     =  2;                    // 机动车
        public static final int EM_OBJECT_TYPE_NOMOTOR     =  3;                    // 非机动车
        public static final int EM_OBJECT_TYPE_ALL         =  4;                    // 所有类型
    };

    // CLIENT_StartMultiFindFaceRecognition 接口输入参数
    public static class NET_IN_STARTMULTIFIND_FACERECONGNITION extends SdkStructure
    {
        public int                          dwSize;
        public Pointer                      pChannelID;                        // 通道号
        public int                          nChannelCount;                     //  通道申请个数
        public int                          bPersonEnable;                     // 人员信息查询条件是否有效
        public FACERECOGNITION_PERSON_INFO  stPerson;                          // 人员信息查询条件
        public NET_FACE_MATCH_OPTIONS       stMatchOptions;                    // 人脸匹配选项
        public NET_FACE_FILTER_CONDTION     stFilterInfo;                      // 查询过滤条件

        // 图片二进制数据
        public Pointer                       pBuffer;                          // 缓冲地址
        public int                           nBufferLen;                       // 缓冲数据长度
        public int                           bPersonExEnable;                  // 人员信息查询条件是否有效, 并使用人员信息扩展结构体
        public FACERECOGNITION_PERSON_INFOEX stPersonInfoEx;                   // 人员信息扩展
        public int                           emObjectType;                     // 搜索的目标类型

        public NET_IN_STARTMULTIFIND_FACERECONGNITION() {
            this.dwSize = this.size();
        }
    };

    // CLIENT_StartMultiFindFaceRecognition 接口输出参数
    public static class NET_OUT_STARTMULTIFIND_FACERECONGNITION extends SdkStructure
    {
        public int                           dwSize;
        public int                           nTotalCount;                       // 返回的符合查询条件的记录个数
        // -1表示总条数未生成,要推迟获取
        // 使用CLIENT_AttachFaceFindState接口状态
        public LLong                         lFindHandle;                       // 查询句柄
        public int                           nToken;                            // 获取到的查询令牌

        public NET_OUT_STARTMULTIFIND_FACERECONGNITION() {
            this.dwSize = this.size();
        }
    };

    // 开始人脸检测/注册库的多通道查询
    public Boolean  CLIENT_StartMultiFindFaceRecognition(LLong lLoginID, NET_IN_STARTMULTIFIND_FACERECONGNITION pstInParam, NET_OUT_STARTMULTIFIND_FACERECONGNITION pstOutParam, int nWaitTime);

    // 事件类型 EVENT_IVS_PEDESTRIAN_JUNCTION (行人卡口事件) 对应的数据块描述信息
    public static class DEV_EVENT_PEDESTRIAN_JUNCTION_INFO extends SdkStructure
    {
        public int					nChannelID;									// 通道号
        public byte[]				szName=new byte[NET_EVENT_NAME_LEN];		// 事件名称
        public int					nGroupID;									// 事件组ID, 同一个人抓拍过程内nGroupID相同
        public int					nCountInGroup;								// 一个事件组内的抓拍张数
        public int					nIndexInGroup;								// 一个事件组内的抓拍序号，从1开始
        public double				PTS;										// 事件戳(单位是毫秒)
        public NET_TIME_EX			UTC;										// 事件发生的时间
        public int					UTCMS;										// UTC时间对应的毫秒数
        public int					nEventID;									// 事件ID
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public NET_MSG_OBJECT		stuObject;									// 人脸信息
        public int					nLane;										// 人行道号
        public int					nSequence;									// 表示抓拍序号,如3/2/1,1表示抓拍结束,0表示异常结束
        public byte[]				byReserved=new byte[1024];					// 保留字节
    };

    // 多人多开门方式组合(对应 CFG_CMD_OPEN_DOOR_GROUP 命令),表示每个通道的组合信息，
    // 第一个通道的组合的开门优先级最高，后面依次递减
    public static class CFG_OPEN_DOOR_GROUP_INFO extends SdkStructure {
        public int nGroup; // 有效组合数
        public CFG_OPEN_DOOR_GROUP[] stuGroupInfo = new CFG_OPEN_DOOR_GROUP[CFG_MAX_OPEN_DOOR_GROUP_NUM];// 多人开门组合信息
    };

    // 多人组合开门组信息
    public static class CFG_OPEN_DOOR_GROUP extends SdkStructure {
        public int nUserCount; // 用户数目，表示需要组合才能开门的人数
        public int nGroupNum; // 有效组数目
        public CFG_OPEN_DOOR_GROUP_DETAIL[] stuGroupDetail = new CFG_OPEN_DOOR_GROUP_DETAIL[CFG_MAX_OPEN_DOOR_GROUP_DETAIL_NUM];// 多人组合开门组的详细信息
        public Boolean bGroupDetailEx; // TRUE: stuGroupDetail
        // 字段无效、pstuGroupDetailEx字段有效, FALSE:
        // stuGroupDetail
        // 字段有效、pstuGroupDetailEx字段无效
        public int nMaxGroupDetailNum; // 多人组合开门组的详细信息最大个数
        public Pointer pstuGroupDetailEx; /*
         * 多人组合开门组的详细信息扩展, 由用户申请内存,
         * 大小为sizeof(CFG_OPEN_DOOR_GROUP_DETAIL
         * )*nMaxUserCount, 当多人组合开门组的详细信息个数大于
         * CFG_MAX_OPEN_DOOR_GROUP_DETAIL_NUM
         * 时使用此字段
         */
    };

    // 多人组合开门组详细信息
    public static class CFG_OPEN_DOOR_GROUP_DETAIL extends SdkStructure {
        public byte[] szUserID = new byte[CFG_MAX_USER_ID_LEN]; // 用户ID
        public int emMethod; // 开门方式
        public int nMethodExNum; // 开门方式扩展个数
        public int[] emMethodEx = new int[CFG_MAX_METHODEX_NUM]; // 开门方式扩展
    };

    public static class EM_CFG_OPEN_DOOR_GROUP_METHOD extends SdkStructure {
        public static final int EM_CFG_OPEN_DOOR_GROUP_METHOD_UNKNOWN = 0;
        public static final int EM_CFG_OPEN_DOOR_GROUP_METHOD_CARD = 1; // 刷卡
        public static final int EM_CFG_OPEN_DOOR_GROUP_METHOD_PWD = 2; // 密码
        public static final int EM_CFG_OPEN_DOOR_GROUP_METHOD_FINGERPRINT = 3; // 指纹
        public static final int EM_CFG_OPEN_DOOR_GROUP_METHOD_ANY = 4; // 任意组合方式开门
        public static final int EM_CFG_OPEN_DOOR_GROUP_METHOD_FACE = 5; // 人脸
    };

    public static final int CFG_MAX_USER_ID_LEN = 32; // 门禁卡用户ID最大长度
    public static final int CFG_MAX_METHODEX_NUM = 4; // 开门方式扩展最大个数
    public static final int CFG_MAX_OPEN_DOOR_GROUP_DETAIL_NUM = 64; // 每一组多人开门组合的最大人数
    public static final int CFG_MAX_OPEN_DOOR_GROUP_NUM = 4; // 多人开门组合的最大组合数

    // 开始查找X光机包裹信息
    public  LLong  CLIENT_StartFindXRayPkg(LLong lLoginID, NET_IN_START_FIND_XRAY_PKG pInParam, NET_OUT_START_FIND_XRAY_PIC pOutParam, int nWaitTime);

    // 查询X光机包裹的信息
    public  Boolean  CLIENT_DoFindXRayPkg(LLong lFindID, NET_IN_DO_FIND_XRAY_PKG pInParam, NET_OUT_DO_FIND_XRAY_PKG pOutParam, int nWaitTime);

    // 结束查询X光机包裹的信息
    public  Boolean  CLIENT_StopFindXRayPkg(LLong lFindID);

    // 物品类型
    public static class EM_INSIDE_OBJECT_TYPE
    {
        public static final int EM_INSIDE_OBJECT_UNKNOWN=0;										// 算法未识别物品
        public static final int EM_INSIDE_OBJECT_KNIFE=1;											// 刀具
        public static final int 	EM_INSIDE_OBJECT_BOTTLELIQUID=2;									// 瓶装液体
        public static final int EM_INSIDE_OBJECT_GUN=3;											// 枪支
        public static final int 	EM_INSIDE_OBJECT_UMBRELLA=4;										// 雨伞
        public static final int EM_INSIDE_OBJECT_PHONE=5;											// 手机
        public static final int EM_INSIDE_OBJECT_NOTEBOOK=6;										// 笔记本
        public static final int EM_INSIDE_OBJECT_POWERBANK=7;										// 充电宝
        public static final int EM_INSIDE_OBJECT_SHOES=8;											// 鞋子
        public static final int EM_INSIDE_OBJECT_ROD=9;											// 杠子
        public static final int EM_INSIDE_OBJECT_METAL=10;											// 金属
        public static final int EM_INSIDE_OBJECT_EXPLOSIVE=11;										// 爆炸物
        public static final int EM_INSIDE_OBJECT_CONTAINERSPRAY=12;								// 喷雾喷灌
        public static final int  EM_INSIDE_OBJECT_EXPLOSIVE_FIREWORKS=13;							// 烟花爆竹
        public static final int EM_INSIDE_OBJECT_LIGHTER=14;										// 打火机
        public static final int EM_INSIDE_OBJECT_STICK=15;										    // 警棍
        public static final int EM_INSIDE_OBJECT_BRASSKNUCKLE=16;									// 指虎
        public static final int EM_INSIDE_OBJECT_HANDCUFFS=17;										// 手铐
        public static final int  EM_INSIDE_OBJECT_IVORY=18;										    // 象牙
        public static final int  EM_INSIDE_OBJECT_BOOK=19;										    // 书籍
        public static final int   EM_INSIDE_OBJECT_CD=20;										    // 光盘
        public static final int  EM_INSIDE_OBJECT_HAMMERS=21;										// 锤子
        public static final int EM_INSIDE_OBJECT_PLIERS=22;										// 钳子
        public static final int   EM_INSIDE_OBJECT_AXE=23;										    // 斧头
        public static final int  EM_INSIDE_OBJECT_SCREW_DRIVER=24;									// 螺丝刀
        public static final int  EM_INSIDE_OBJECT_WRENCH=25;										// 扳手
        public static final int  EM_INSIDE_OBJECT_ELECTRICS_SHOCK_STICK=26;							// 电击棍
    } ;

    // 危险等级
    public static class EM_DANGER_GRADE_TYPE extends SdkStructure
    {
        public static final int EM_DANGER_GRADE_UNKNOWN  = -1;								// 未知
        public static final int EM_DANGER_GRADE_NORMAL=1;											// 普通级别
        public static final int EM_DANGER_GRADE_WARN=2;											// 警示级别
        public static final int EM_DANGER_GRADE_DANGER=3;											// 危险级别
    } ;


    // CLIENT_StartFindXRayPkg 接口输入参数
    public static class NET_IN_START_FIND_XRAY_PKG extends SdkStructure
    {
        public int                   dwSize;                 // 结构体大小
        public int    emTimeOrder;            // 查询结果按时间排序
        public NET_TIME			    stuStartTime;		    // 查询的开始时间
        public NET_TIME			    stuEndTime;			    // 查询的结束时间
        public int[]                    nSimilarityRange=new int[2];    // 相似度范围,下标0:表示最小值, 下标1:表示最大值
        public int                      nObjTypeNum;            // 物体类型的数量
        public int[]	emObjType=new int[32];		    // 物品类型

        public NET_IN_START_FIND_XRAY_PKG()
        {
            this.dwSize = this.size();
        }
    } ;
    // X光机物体信息
    public static class NET_PKG_OBJECT_INFO extends SdkStructure
    {
        public int	emObjType;		    	// 物品类型
        public int	emDangerGrade;			// 物品危险等级
        public int                    nSimilarity;	    	// 相似度,0~100
        public byte[]                    byReserved=new byte[132];    	// 保留字节
    };

    // CLIENT_StartFindXRayPkg 接口输出参数
    public static class NET_OUT_START_FIND_XRAY_PIC extends SdkStructure
    {
        public int                   dwSize;                 // 结构体大小
        public int                     nTotal;                 // 包裹总数
        public NET_OUT_START_FIND_XRAY_PIC()
        {
            this.dwSize = this.size();
        }
    } ;

    // CLIENT_DoFindXRayPkg 接口输入参数
    public static class NET_IN_DO_FIND_XRAY_PKG extends SdkStructure
    {
        public int                    dwSize;                 // 结构体大小
        public int                    nOffset;                // 查询偏移
        public int                    nCount;                 // 需要查找的数目
        public NET_IN_DO_FIND_XRAY_PKG()
        {
            this.dwSize = this.size();
        }
    };

    // 视角信息数
    public static class NET_PKG_VIEW_INFO extends SdkStructure
    {
        public int                        emViewType;				                    // 视图类型
        public int                        nEnergyImageLength;                          // 能量图大小 单位字节
        public byte[]                     szEnergyImagePath=new byte[128];             // 能量图绝对路径
        public int                        nColorImageLength;                           // 彩图大小单位字节
        public byte[]                     szColorImagePath=new byte[128];              // 彩图绝对路径
        public int                        nColorOverlayImageLength;                    // 彩图叠加图大小单位字节
        public byte[]                     szColorOverlayImagePath=new byte[128];       // 彩图叠加图绝对路径
        public NET_PKG_OBJECT_INFO[]      stuObject=new NET_PKG_OBJECT_INFO[32];       // 物体数组
        public int                        nObjectCount;                                // 物体数量
        public byte[]                     byReserved=new byte[1024];                   // 保留字节
    } ;
    // X光机的包裹信息
    public static class NET_XRAY_PKG_INFO extends SdkStructure
    {
        public NET_TIME			    	stuTime;		    	// 包裹产生时间(含时区)
        public int                     	nChannelIn;             // 关联的进口IPC通道号,从0开始,-1表示无效
        public int                     	nChannelOut;            // 关联的出口IPC通道号,从0开始,-1表示无效
        public byte[]                    	szUser=new byte[128];            // 用户名
        public NET_PKG_VIEW_INFO[]       	stuViewInfo= new NET_PKG_VIEW_INFO[2];         // 视角信息数组
        public byte[]                    	byReserved=new byte[1024];        // 保留字节

        public NET_XRAY_PKG_INFO() {
            for (int i = 0; i < stuViewInfo.length; i ++) {
                stuViewInfo[i] = new NET_PKG_VIEW_INFO();
            }
        }
    };

    // CLIENT_DoFindXRayPkg 接口输出参数
    public static class NET_OUT_DO_FIND_XRAY_PKG extends SdkStructure
    {
        public int                     dwSize;                 // 结构体大小
        public int                     nMaxCount;              // 用户指定分配结构体个数,需大于等于NET_IN_DO_FIND_XRAY_PKG的nCount
        public int                     nRetCount;              // 实际返回的查询数量
        public Pointer                 pstuXRayPkgInfo;        // X光机的包裹信息,缓存大小由用户指定
        public NET_OUT_DO_FIND_XRAY_PKG()
        {
            this.dwSize = this.size();
        }
    }
    //事件类型	EVENT_IVS_TRAFFIC_PARKINGSPACEPARKING(车位有车事件)对应的规则配置
    public static class CFG_TRAFFIC_PARKINGSPACEPARKING_INFO extends SdkStructure
    {
        public byte[]				szRuleName=new byte[MAX_NAME_LEN];								// 规则名称,不同规则不能重名
        public byte				bRuleEnable;											// 规则使能
        public byte[]              bReserved=new byte[3];                                           // 保留字段
        public int					nObjectTypeNum;											// 相应物体类型个数
        public byte[]				szObjectTypes=new byte[MAX_OBJECT_LIST_SIZE*MAX_NAME_LEN];		// 相应物体类型列表
        public int                 nPtzPresetId;											// 云台预置点编号	0~65535
        public CFG_ALARM_MSG_HANDLE stuEventHandler;										// 报警联动
        // public CFG_TIME_SECTION[]	stuTimeSection=new CFG_TIME_SECTION[WEEK_DAY_NUM*MAX_REC_TSECT_EX];			// 事件响应时间段
        public CFG_TIME_SECTION[] stuTimeSection =
                (CFG_TIME_SECTION[])new CFG_TIME_SECTION().toArray(WEEK_DAY_NUM*MAX_REC_TSECT_EX);   // 事件响应时间段
        public int					nLane;													// 车位号
        public int                 nDelayTime;                                             // 检测到报警发生到开始上报的时间, 单位：秒，范围1~65535
        public int					nDetectRegionPoint;										// 检测区域顶点数
        public CFG_POLYGON[]		stuDetectRegion=(CFG_POLYGON[]) new CFG_POLYGON().toArray(MAX_POLYGON_NUM);						// 检测区域
        public int                 nPlateSensitivity;                                      // 有牌检测灵敏度(控制抓拍)
        public int                 nNoPlateSensitivity;                                    // 无牌检测灵敏度（控制抓拍）
        public int                 nLightPlateSensitivity;                                 // 有牌检测灵敏度（控制车位状态灯）
        public int                 nLightNoPlateSensitivity;                               // 无牌检测灵敏度（控制车位状态灯）
        public boolean             bForbidParkingEnable;									// 禁止停车使能 TRUE:禁止 FALSE:未禁止
    };

    //事件类型	EVENT_IVS_TRAFFIC_PARKINGSPACENOPARKING(车位无车事件)对应的规则配置
    public static class CFG_TRAFFIC_PARKINGSPACENOPARKING_INFO extends SdkStructure
    {
        public byte[]				szRuleName=new byte[MAX_NAME_LEN];								// 规则名称,不同规则不能重名
        public byte				bRuleEnable;											// 规则使能
        public byte[]                bReserved=new byte[3];                                           // 保留字段
        public int					nObjectTypeNum;											// 相应物体类型个数
        public byte[]				szObjectTypes=new byte[MAX_OBJECT_LIST_SIZE*MAX_NAME_LEN];		// 相应物体类型列表
        public int                 nPtzPresetId;											// 云台预置点编号	0~65535
        public CFG_ALARM_MSG_HANDLE stuEventHandler;										// 报警联动
        public CFG_TIME_SECTION[] stuTimeSection =
                (CFG_TIME_SECTION[])new CFG_TIME_SECTION().toArray(WEEK_DAY_NUM*MAX_REC_TSECT_EX);   // 事件响应时间段

        public int					nLane;													// 车位号
        public int                 nDelayTime;                                             // 检测到报警发生到开始上报的时间, 单位：秒，范围1~65535
        public int					nDetectRegionPoint;										// 检测区域顶点数
        public CFG_POLYGON[]		stuDetectRegion=(CFG_POLYGON[]) new CFG_POLYGON().toArray(MAX_POLYGON_NUM);						// 检测区域
        public int                 nPlateSensitivity;                                      // 有牌检测灵敏度(控制抓拍)
        public int                 nNoPlateSensitivity;                                    // 无牌检测灵敏度（控制抓拍）
        public int                 nLightPlateSensitivity;                                 // 有牌检测灵敏度（控制车位状态灯）
        public int                 nLightNoPlateSensitivity;                               // 无牌检测灵敏度（控制车位状态灯）
    };
    // 事件类型 EVENT_IVS_CITY_MOTORPARKING (城市机动车违停事件) 对应的数据块描述信息
    public static class DEV_EVENT_CITY_MOTORPARKING_INFO extends SdkStructure
    {
        public int                 nChannelID;										// 通道号
        public int                 nAction;										// 0:脉冲 1:开始 2:停止
        public byte[]                szName=new byte[128];									// 事件名称
        public double              PTS;											// 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;											// 事件发生的时间
        public int                 nEventID;										// 事件ID

        public NET_EVENT_FILE_INFO	stuFileInfo;									// 事件对应文件信息
        public int					nObjectNum;										// 检测到的物体个数
        public NET_MSG_OBJECT[]		stuObjects=new NET_MSG_OBJECT[32];						// 检测到的物体
        public int                 nDetectRegionNum;                   			// 检测区域顶点数
        public NET_POINT[]            DetectRegion=new NET_POINT[NET_MAX_DETECT_REGION_NUM]; 		// 检测区域
        public byte[]				szPresetName=new byte[64];								// 事件触发的预置名称
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;						// 智能事件公共信息
        public int                nParkingDuration;                               // 违停持续时长，单位：秒 缺省值0表示无意义
        public byte[]				szSourceID=new byte[32];								    // 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
        public int               dwSnapFlagMask;									// 抓图标志(按位),具体见NET_RESERVED_COMMON
        public boolean			bPtzPosition;					// stuPtzPosition 是否有效
        public PTZ_NORMALIZED_POSITION_UNIT	stuPtzPosition;					// 云台信息
        public byte[]						byReserved=new byte[3096];				// 保留字节
    };
    // 事件类型 EVENT_IVS_CITY_NONMOTORPARKING (城市非机动车违停事件) 对应的数据块描述信息
    public static class DEV_EVENT_CITY_NONMOTORPARKING_INFO extends SdkStructure
    {
        public int                 nChannelID;										// 通道号
        public int                 nAction;										// 0:脉冲 1:开始 2:停止
        public byte[]                szName=new byte[128];									// 事件名称
        public double              PTS;											// 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;											// 事件发生的时间
        public int                 nEventID;										// 事件ID

        public NET_EVENT_FILE_INFO	stuFileInfo;									// 事件对应文件信息
        public int                 nDetectRegionNum;                   			// 检测区域顶点数
        public NET_POINT[]            DetectRegion=new NET_POINT[NET_MAX_DETECT_REGION_NUM]; 		// 检测区域
        public int					nAlarmNum;										// 报警阈值
        public int					nNoMotorNum;									// 非机动车的个数
        public byte[]				szPresetName=new byte[64];								// 事件触发的预置名称
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;						// 智能事件公共信息
        public int                nViolationDuration;                             // 违法持续时长，单位：秒 缺省值0表示无意义
        public int					nObjectNum;										// 检测到的物体个数
        public NET_MSG_OBJECT[]		stuObjects=new NET_MSG_OBJECT[HDBJ_MAX_OBJECTS_NUM];				// 检测到的物体
        public byte[]				szSourceID=new byte[32];								    // 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
        public int               dwSnapFlagMask;									// 抓图标志(按位),具体见NET_RESERVED_COMMON
        public byte[]                byReserved=new byte[2044];								// 保留字节
    };
    // 事件类型 EVENT_IVS_HOLD_UMBRELLA (违规撑伞检测事件) 对应的数据块描述信息
    public static class DEV_EVENT_HOLD_UMBRELLA_INFO extends SdkStructure
    {
        public int                 nChannelID;                         // 通道号
        public int					nAction;						    // 0:脉冲 1:开始 2:停止
        public byte[]                szName=new byte[128];                        // 事件名称
        public double              PTS;                                // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                // 事件发生的时间
        public int                nEventID;                           // 事件ID
        public NET_EVENT_FILE_INFO	stuFileInfo;						// 事件对应文件信息
        public NET_POINT[]           DetectRegion=new NET_POINT[NET_MAX_DETECT_REGION_NUM]; // 规则检测区域
        public int                 nDetectRegionNum;                   // 规则检测区域顶点数
        public NET_MSG_OBJECT[]       stuObjects=new NET_MSG_OBJECT[HDBJ_MAX_OBJECTS_NUM];	// 检测到的物体
        public int                 nObjectNum;                         // 检测到的物体个数
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
        public byte[]				szPresetName=new byte[64];					// 事件触发的预置名称
        public int                nViolationDuration;                 // 违法持续时长，单位：秒 缺省值0表示无意义
        public byte[]				szSourceID=new byte[32];						// 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
        public int               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public byte[]                bReserved=new byte[4092];                    // 保留字节,留待扩展.
    };
    // 事件类型 EVENT_IVS_GARBAGE_EXPOSURE (垃圾暴露检测事件) 对应的数据块描述信息
    public static class DEV_EVENT_GARBAGE_EXPOSURE_INFO extends SdkStructure
    {
        public int                 nChannelID;                         // 通道号
        public int					nAction;							// 0:脉冲 1:开始 2:停止
        public byte[]                szName=new byte[128];                        // 事件名称
        public double              PTS;                                // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                // 事件发生的时间
        public int                nEventID;                           // 事件ID
        public NET_EVENT_FILE_INFO	stuFileInfo;						// 事件对应文件信息
        public NET_POINT[]           DetectRegion=new NET_POINT[NET_MAX_DETECT_REGION_NUM]; // 规则检测区域
        public int                 nDetectRegionNum;                   // 规则检测区域顶点数
        public NET_MSG_OBJECT[]       stuObjects=new NET_MSG_OBJECT[HDBJ_MAX_OBJECTS_NUM];	// 检测到的物体
        public int                 nObjectNum;                         // 检测到的物体个数
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
        public byte[]				szPresetName=new byte[64];					// 事件触发的预置名称
        public int                nViolationDuration;                 // 违法持续时长，单位：秒 缺省值0表示无意义
        public byte[]				szSourceID=new byte[32];						// 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
        public int               dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public byte[]                bReserved=new byte[4092];                    // 保留字节,留待扩展.
    } ;
    // 事件类型 EVENT_IVS_DUSTBIN_OVER_FLOW (垃圾桶满溢检测事件) 对应的数据块描述信息
    public static class DEV_EVENT_DUSTBIN_OVER_FLOW_INFO extends SdkStructure
    {
        public int                         nChannelID;                         // 通道号
        public int					        nAction;							// 0:脉冲 1:开始 2:停止
        public byte[]                      szName=new byte[128];                        // 事件名称
        public double                      PTS;                                // 时间戳(单位是毫秒)
        public NET_TIME_EX                 UTC;                                // 事件发生的时间
        public int                         nEventID;                           // 事件ID
        public NET_EVENT_FILE_INFO	        stuFileInfo;						// 事件对应文件信息
        public NET_POINT[]                 DetectRegion=new NET_POINT[NET_MAX_DETECT_REGION_NUM]; // 规则检测区域
        public int                         nDetectRegionNum;                   // 规则检测区域顶点数
        public NET_MSG_OBJECT[]            stuObjects=new NET_MSG_OBJECT[HDBJ_MAX_OBJECTS_NUM];	// 检测到的物体
        public int                         nObjectNum;                         // 检测到的物体个数
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;         // 智能事件公共信息
        public byte[]				        szPresetName=new byte[64];					// 事件触发的预置名称
        public int                         nViolationDuration;                 // 违法持续时长，单位：秒 缺省值0表示无意义
        public byte[]				        szSourceID=new byte[32];						// 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
        public int                         dwSnapFlagMask;                     // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public byte[]                      bReserved=new byte[4092];                    // 保留字节,留待扩展.
    } ;
    // 事件类型 EVENT_IVS_DOOR_FRONT_DIRTY (门前脏乱检测事件) 对应的数据块描述信息
    public static class DEV_EVENT_DOOR_FRONT_DIRTY_INFO extends SdkStructure
    {
        public int                         nChannelID;                                              // 通道号
        public int					        nAction;							                     // 0:脉冲 1:开始 2:停止
        public byte[]                      szName=new byte[128];                                    // 事件名称
        public double                      PTS;                                                     // 时间戳(单位是毫秒)
        public NET_TIME_EX                 UTC;                                                     // 事件发生的时间
        public int                         nEventID;                                                // 事件ID
        public NET_EVENT_FILE_INFO	        stuFileInfo;						                     // 事件对应文件信息
        public NET_POINT[]                 DetectRegion=new NET_POINT[NET_MAX_DETECT_REGION_NUM];   // 规则检测区域
        public int                         nDetectRegionNum;                                        // 规则检测区域顶点数
        public NET_MSG_OBJECT[]            stuObjects=new NET_MSG_OBJECT[HDBJ_MAX_OBJECTS_NUM];	 // 检测到的物体
        public int                         nObjectNum;                                              // 检测到的物体个数
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                                      // 智能事件公共信息
        public byte[]				        szPresetName=new byte[64];					             // 事件触发的预置名称
        public byte[]				        szShopAddress=new byte[256];					         // 商铺地址名称
        public int                         nViolationDuration;                                      // 违法持续时长，单位：秒，缺省值0表示无意义
        public byte[]				        szSourceID=new byte[32];						         // 事件关联ID,同一个物体或图片生成多个事件时SourceID相同
        public int                         dwSnapFlagMask;                                          // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public byte[]                      bReserved=new byte[4092];                                // 保留字节,留待扩展.
    } ;

    // CLIENT_StartRemoteUpgrade-输入参数
    public static class NET_IN_START_REMOTE_UPGRADE_INFO extends SdkStructure
    {
        public int							    dwSize;						// 此结构体大小
        public int							    nListNum;					// 需要升级的远程通道个数
        public Pointer                         pstuList;					// 需要升级的远程通道信息
        public Pointer							pReserved;					// 字节对齐
        public byte[]							szFileName=new byte[256];	// 升级文件名称
        public Callback			            cbRemoteUpgrade;			// 升级进度回调函数
        public Pointer							dwUser;						// 用户数据

        public NET_IN_START_REMOTE_UPGRADE_INFO()
        {
            this.dwSize = this.size();
        }
    };

    // CLIENT_StartRemoteUpgrade-输出参数
    public static class NET_OUT_START_REMOTE_UPGRADE_INFO extends SdkStructure
    {
        public int							dwSize;

        public NET_OUT_START_REMOTE_UPGRADE_INFO()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    // CLIENT_AttachRemoteUpgradeState-输入参数
    public static class NET_IN_ATTACH_REMOTEUPGRADE_STATE extends SdkStructure
    {
        public int							dwSize;						// 此结构体大小
        public Callback	                cbCallback;					// 回调
        public Pointer					    dwUser;						// 用户数据

        public NET_IN_ATTACH_REMOTEUPGRADE_STATE()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    // CLIENT_AttachRemoteUpgradeState-输出参数
    public static class NET_OUT_ATTACH_REMOTEUPGRADE_STATE extends SdkStructure
    {
        public int							dwSize;						// 此结构体大小

        public NET_OUT_ATTACH_REMOTEUPGRADE_STATE()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    // 远程通道信息
    public static class NET_REMOTE_UPGRADE_CHNL_INFO extends SdkStructure
    {
        public int					nChannel;					// 远程通道号
        public byte[]				byReserved=new byte[512];			// 预留字段
    };

    // 升级远程设备程序回调函数
    public interface  fRemoteUpgradeCallBack extends StdCallCallback{
        public void invoke(LLong lLoginID, LLong lUpgradeID, int emState, int nParam1, int nParam2, Pointer dwUser);
    }

    // 远程升级回调类型
    public static class EM_REMOTE_UPGRADE_CB_TYPE extends SdkStructure
    {
        public static final int EM_REMOTE_UPGRADE_CB_TYPE_APPENDING=1;				    // 推送回调	nParam1 文件总大小 nParam2 已发送大小
        public static final int EM_REMOTE_UPGRADE_CB_TYPE_EXECUTE=2;					// 执行回调	nParam1 执行execute的结果
        public static final int EM_REMOTE_UPGRADE_CB_TYPE_FAILED=3;					// 失败回调  nParam1 错误码
        public static final int EM_REMOTE_UPGRADE_CB_TYPE_CANCEL=4;					// 取消回调
    };

    // 升级状态回调函数
    public interface  fRemoteUpgraderStateCallback extends StdCallCallback{
        public void invoke(LLong lLoginId, LLong lAttachHandle, NET_REMOTE_UPGRADER_NOTIFY_INFO pBuf, int dwBufLen, Pointer pReserved, Pointer dwUser);
    }

    // 远程设备升级消息上报
    public static class NET_REMOTE_UPGRADER_NOTIFY_INFO extends SdkStructure
    {
        public int							nStateNum;					// 状态数
        public Pointer		                pstuStates;					// 状态列表
        public byte[]					    byReserved=new byte[1024];			// 预留
    };

    // 远程设备升级状态
    public static class NET_REMOTE_UPGRADER_STATE extends SdkStructure
    {
        public int								nChannel;					// 通道号
        public int			                    emState;					// 状态(对应的枚举值EM_REMOTE_UPGRADE_STATE)
        public int								nProgress;					// 进度
        public byte[]                           szDeviceID=new byte[128];            // 远程设备ID
    };

    // 远程设备升级状态
    public static class EM_REMOTE_UPGRADE_STATE extends SdkStructure
    {
        public static final int EM_REMOTE_UPGRADE_STATE_UNKNOWN=0;							    // 未知
        public static final int EM_REMOTE_UPGRADE_STATE_INIT=1;								// 初始状态(未升级)
        public static final int EM_REMOTE_UPGRADE_STATE_DOWNLOADING=2;						    // 正在下载数据
        public static final int EM_REMOTE_UPGRADE_STATE_UPGRADING=3;							// 正在升级
        public static final int EM_REMOTE_UPGRADE_STATE_FAILED=4;								// 升级失败
        public static final int EM_REMOTE_UPGRADE_STATE_SUCCEEDED=5;							// 升级成功
        public static final int EM_REMOTE_UPGRADE_STATE_CANCELLED=6;							// 取消升级
        public static final int EM_REMOTE_UPGRADE_STATE_PREPARING=7;							// 准备升级中
    };

    //开始升级远程设备程序
    public LLong  CLIENT_StartRemoteUpgrade(LLong lLoginID, NET_IN_START_REMOTE_UPGRADE_INFO pInParam, NET_OUT_START_REMOTE_UPGRADE_INFO pOutParam, int nWaitTime);

    //结束升级远程设备程序
    public Boolean  CLIENT_StopRemoteUpgrade(LLong lUpgradeID);

    // 订阅ipc升级状态观察接口
    public LLong  CLIENT_AttachRemoteUpgradeState(LLong lLoginID, NET_IN_ATTACH_REMOTEUPGRADE_STATE pInParam, NET_OUT_ATTACH_REMOTEUPGRADE_STATE pOutParam, int nWaitTime);

    // 取消订阅升级状态接口
    public Boolean  CLIENT_DetachRemoteUpgradeState(LLong lAttachHandle);

    // 设置子连接网络参数, pSubConnectNetParam 资源由用户申请和释放
    public Boolean CLIENT_SetSubConnectNetworkParam(LLong lLoginID, NET_SUBCONNECT_NETPARAM pSubConnectNetParam);

    // 设置子链接网络参数
    public static class NET_SUBCONNECT_NETPARAM extends SdkStructure
    {
        public int                 dwSize;                                             // 结构体大小
        public int				    nNetPort;								            // 网络映射端口号
        public byte[]				szNetIP=new byte[NET_MAX_IPADDR_EX_LEN];			// 网络映射IP地址
        public NET_SUBCONNECT_NETPARAM()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };
    public static class EM_ANALYSE_TASK_START_RULE extends SdkStructure
    {
        public static final int  EM_ANALYSE_TASK_START_NOW=0;          // 立刻启动
        public static final int  EM_ANALYSE_TASK_START_LATER=1;        // 稍候手动启动
    };

    // 视频分析支持的对象类型
    public static class EM_ANALYSE_OBJECT_TYPE extends SdkStructure
    {
        public static final int  EM_ANALYSE_OBJECT_TYPE_UNKNOWN=0;           // 未知的
        public static final int  EM_ANALYSE_OBJECT_TYPE_HUMAN=1;             // 人
        public static final int  EM_ANALYSE_OBJECT_TYPE_VEHICLE=2;           // 车辆
        public static final int  EM_ANALYSE_OBJECT_TYPE_FIRE=3;              // 火
        public static final int  EM_ANALYSE_OBJECT_TYPE_SMOKE=4;             // 烟雾
        public static final int  EM_ANALYSE_OBJECT_TYPE_PLATE=5;             // 片状物体
        public static final int  EM_ANALYSE_OBJECT_TYPE_HUMANFACE=6;         // 人脸
        public static final int  EM_ANALYSE_OBJECT_TYPE_CONTAINER=7;         // 货柜
        public static final int  EM_ANALYSE_OBJECT_TYPE_ANIMAL=8;            // 动物
        public static final int  EM_ANALYSE_OBJECT_TYPE_TRAFFICLIGHT=9;      // 红绿灯
        public static final int  EM_ANALYSE_OBJECT_TYPE_PASTEPAPER=10;        // 贴纸 贴片
        public static final int  EM_ANALYSE_OBJECT_TYPE_HUMANHEAD=11;         // 人的头部
        public static final int  EM_ANALYSE_OBJECT_TYPE_ENTITY=12;            // 普通物体
    };

    // 事件类型 EVENT_IVS_SMART_KITCHEN_CLOTHES_DETECTION(智慧厨房穿着检测事件)对应的数据块描述信息
    public static class DEV_EVENT_SMART_KITCHEN_CLOTHES_DETECTION_INFO extends SdkStructure
    {
        public int                         nChannelID;									// 通道号
        public int                         nAction;									// 0:脉冲 1:开始 2:停止
        public byte[]                      szName=new byte[128];						// 事件名称
        public double                      PTS;										// 时间戳(单位是毫秒)
        public NET_TIME_EX                 UTC;										// 事件发生的时间
        public int                         nEventID;									// 事件ID
        public int							nRuleID;									// 用于
        public int                         emClassType;								// 智能事件所属大类
        public byte[]						szClassAlias=new byte[16];					// 智能事件所属大类别名
        public HUMAN_IMAGE_INFO			stuHumanImage;								// 人体图片信息
        public SCENE_IMAGE_INFO			stuSceneImage;								// 全景广角图片信息
        public FACE_IMAGE_INFO				stuFaceImage;								// 人脸图片信息
        public int						    nObjectID;									// 目标ID
        public int	                        emHasMask;									// 检测是否有戴口罩（对应枚举值EM_NONMOTOR_OBJECT_STATUS）
        public int	                        emHasChefHat;								// 检测是否有戴厨师帽（对应枚举值EM_NONMOTOR_OBJECT_STATUS）
        public int	                        emHasChefClothes;							// 检测是否有穿厨师服（对应枚举值EM_NONMOTOR_OBJECT_STATUS）
        public int		                    emChefClothesColor;							// 厨师服颜色（对应枚举值EM_OBJECT_COLOR_TYPE）
        public byte[]						bReserved=new byte[1020];					// 预留字节
    };


    // 事件类型EVENT_IVS_BANNER_DETECTION(拉横幅事件)对应数据块描述信息
    public static class DEV_EVENT_BANNER_DETECTION_INFO extends SdkStructure
    {
        public int					nChannelID;									  // 通道号
        public int                 nEventID;                                     // 事件ID
        public byte[]				szName=new byte[NET_EVENT_NAME_LEN];		  // 事件名称
        public double              PTS;                                          // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                          // 事件发生的时间
        public int                 nAction;                                      // 1:开始 2:停止

        public int		            emClassType;								  // 智能事件所属大类(对应EM_CLASS_TYPE枚举)
        public NET_EVENT_FILE_INFO	stuFileInfo;								  // 事件对应文件信息
        public int					nObjectNum;									  // 检测到的物体个数
        public NET_MSG_OBJECT []      stuObjects=new NET_MSG_OBJECT[32];         // 检测到的物体
        public int                 nDetectRegionNum;                   		  // 检测区域顶点数
        public NET_POINT []           DetectRegion=new NET_POINT[NET_MAX_DETECT_REGION_NUM]; 	  // 检测区域
        public int					nCount;										  // 事件触发次数
        public int				    nPresetID;									  // 预置点
        public NET_EXTENSION_INFO  stuExtensionInfo;                             // 扩展信息
        public byte[]				byReserved=new byte[1028];					  // 保留字节,留待扩展.
    } ;

    // 事件类型EVENT_IVS_BANNER_DETECTION(拉横幅检测事件)对应的规则配置
    public static class NET_BANNER_DETECTION_RULE_INFO extends SdkStructure
    {
        public int                                     dwSize;                         // 结构体大小
        public int							            nDetectRegionPoint;             // 检测区顶点数
        public POINTCOORDINATE	[]			            stuDetectRegion=new POINTCOORDINATE[20];            // 检测区域

        public int										nMinDuration;					// 最短持续时间, 单位:秒，范围1-600, 默认30
        public int										nReportInterval;				// 重复报警间隔,单位:秒,范围0-600,默认30,为0表示不重复
        public int										nSensitivity;					// 检测灵敏度,范围1-10
        public int										nBannerPercent;					// 近景抓拍时横幅在画面的百分比，范围1~100，默认80
        public byte[]									bReserved=new byte[520]; 				// 保留字节

        public NET_BANNER_DETECTION_RULE_INFO()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    } ;


    public static class POINTCOORDINATE extends SdkStructure
    {
        public int                nX;								// 第一个元素表示景物点的x坐标(0~8191)
        public int                nY;								// 第二个元素表示景物点的y坐标(0~8191)
    } ;

    // 事件类型 EVENT_IVS_SMART_KITCHEN_CLOTHES_DETECTION(智慧类型衣着检测)对应的规则配置
    public static class NET_SMART_KITCHEN_CLOTHES_DETECTION_RULE_INFO extends SdkStructure
    {
        public int                                     dwSize;                         // 结构体大小
        public int									    bMaskEnable;					// 是否开启口罩检测  （TRUE:开启 FALSE:关闭）
        public int									    bChefHatEnable;					// 是否开启厨师帽检测（TRUE:开启 FALSE:关闭）
        public int									    bChefClothesEnable;				// 是否开启厨师服检测（TRUE:开启 FALSE:关闭）
        public int										nChefClothesColorNum;			// 配置检查允许的厨师服颜色个数
        public int	[]			                        emChefClothesColors=new int[8]; // 厨师衣服颜色(对应的枚举值EM_CFG_CHEF_CLOTHES_COLORS)
        public int										nReportInterval;				// 重复报警间隔,单位:秒,范围0-600,默认30,为0表示不重复
        public byte[]									byReserved=new byte[4096];		// 保留字节

        public NET_SMART_KITCHEN_CLOTHES_DETECTION_RULE_INFO()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    // 智能分析规则信息
    public static class NET_ANALYSE_RULE_INFO extends SdkStructure
    {
        public int             emClassType;                                // 分析大类类型(对应的枚举值EM_SCENE_CLASS_TYPE)
        public int             dwRuleType;                                 // 规则类型, 详见dhnetsdk.h中"智能分析事件类型"
        // EVENT_IVS_FACEANALYSIS(人脸分析)对应结构体 NET_FACEANALYSIS_RULE_INFO
        // EVENT_IVS_NONMOTORDETECT(非机动车)对应结构体 NET_NONMOTORDETECT_RULE_INFO
        // EVENT_IVS_VEHICLEDETECT(机动车) 对应结构体 NET_VEHICLEDETECT_RULE_INFO
        // EVENT_IVS_HUMANTRAIT(人体) 对应结构体NET_HUMANTRAIT_RULE_INFO
        // EVENT_IVS_XRAY_DETECT_BYOBJECT(X光按物体检测) 对应结构体 NET_XRAY_DETECT_BYPBJECT_RULE_INFO
        // EVENT_IVS_WORKCLOTHES_DETECT(工装检测)对应结构体NET_WORKCLOTHDETECT_RULE_INFO
        // EVENT_IVS_WORKSTATDETECTION(作业统计)对应结构体NET_WORKSTATDETECTION_RULE_INFO
        // EVENT_IVS_CROSSLINEDETECTION(警戒线)对应结构体NET_CROSSLINE_RULE_INFO
        // EVENT_IVS_CROSSREGIONDETECTION(警戒区)对应结构体 NET_CROSSREGION_RULE_INFO
        // EVENT_IVS_FEATURE_ABSTRACT(特征提取)对应结构体 NET_FEATURE_ABSTRACT_RULE_INFO
        // EVENT_IVS_BANNER_DETECTION（拉横幅检测事件）对应结构体NET_BANNER_DETECTION_RULE_INFO
        // EVENT_IVS_SMART_KITCHEN_CLOTHES_DETECTION(智慧厨房衣着检测事件)对应结构体NET_SMART_KITCHEN_CLOTHES_DETECTION_RULE_INFO
        // EVENT_IVS_WATER_STAGE_MONITOR(水位检测事件)对应结构体NET_WATER_STAGE_MONITOR_RULE_INFO
        // EVENT_IVS_FLOATINGOBJECT_DETECTION(漂浮物检测事件)对应结构体 NET_FLOATINGOBJECT_DETECTION_RULE_INFO
        // EVENT_IVS_RIOTERDETECTION (人群聚集) 对应结构体 NET_RIOTERDETECTION_RULE_INFO
        // EVENT_IVS_LEFTDETECTION (物品遗留事件) 对应结构体 NET_LEFTDETECTION_RULE_INFO
        // EVENT_IVS_PARKINGDETECTION (非法停车事件) 对应结构体 NET_PARKINGDETECTION_RULE_INFO
        // EVENT_IVS_WANDERDETECTION( 徘徊事件)对应结构体 NET_WANDERDETECTION_RULE_INFO
        // EVENT_IVS_VIDEOABNORMALDETECTION (视频异常)对应结构体 NET_VIDEOABNORMALDETECTION_RULE_INFO
        public Pointer			pReserved;							        // 规则配置, 具体结构体类型根据dwRuleType来确定, 具体信息见dwRuleType的注释
        public int				nObjectTypeNum;						        // 检测物体类型个数, 为0 表示不指定物体类型
        public int	[]		    emObjectTypes=new int[16];					// 检测物体类型列表(对应的枚举值EM_ANALYSE_OBJECT_TYPE)
        public byte[]          byReserved=new byte[956];                   // 保留字节
    } ;


    // 智能分析规则
    public static class NET_ANALYSE_RULE extends SdkStructure
    {
        public NET_ANALYSE_RULE_INFO []          stuRuleInfos=(NET_ANALYSE_RULE_INFO[]) new NET_ANALYSE_RULE_INFO().toArray(MAX_ANALYSE_RULE_COUNT);       // 分析规则信息
        public int                               nRuleCount;                                 // 分析规则条数
        public byte[]                            byReserved=new byte[1028];                           // 保留字节
    };

    // 推送图片文件信息
    public static class NET_PUSH_PICFILE_INFO extends SdkStructure
    {
        public int                           dwSize;                                 // 结构体大小
        public int                           emStartRule;                            // 智能任务启动规则(对应的枚举值EM_ANALYSE_TASK_START_RULE)
        public NET_ANALYSE_RULE              stuRuleInfo;                            // 分析规则信息
        public byte[]                        szTaskUserData=new byte[256];           // 任务数据
        public NET_PUSH_PICFILE_INFO()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    } ;


    // 智能分析数据源类型
    public static class EM_DATA_SOURCE_TYPE extends SdkStructure
    {
        public static final int  EM_DATA_SOURCE_REMOTE_REALTIME_STREAM = 1;  // 远程实时流 , 对应 NET_REMOTE_REALTIME_STREAM_INFO
        public static final int  EM_DATA_SOURCE_PUSH_PICFILE=2;                // 主动推送图片文件, 对应 NET_PUSH_PICFILE_INFO
    };

    // CLIENT_AddAnalyseTask 接口输出参数
    public static class NET_OUT_ADD_ANALYSE_TASK extends SdkStructure
    {
        public int                            dwSize;                                 // 结构体大小
        public int                            nTaskID;                                // 任务ID
        public int                            nVirtualChannel;                        // 任务对应的虚拟通道号

        public NET_OUT_ADD_ANALYSE_TASK()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    // 添加智能分析任务, 输入参数pInParam的结构体类型根据emDataSourceType的值来决定, pInParam 和 pOutParam 资源由用户申请和释放
    public Boolean CLIENT_AddAnalyseTask(LLong lLoginID, int emDataSourceType, Pointer pInParam, NET_OUT_ADD_ANALYSE_TASK pOutParam, int nWaitTime);

    // CLIENT_StartAnalyseTask 接口输入参数
    public static class NET_IN_START_ANALYSE_TASK extends SdkStructure
    {
        public int                           dwSize;                                 // 结构体大小
        public int                           nTaskID;                                // 任务ID

        public NET_IN_START_ANALYSE_TASK()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    } ;

    // CLIENT_StartAnalyseTask 接口输出参数
    public static class NET_OUT_START_ANALYSE_TASK extends SdkStructure
    {
        public int                           dwSize;                                 // 结构体大小

        public NET_OUT_START_ANALYSE_TASK()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    } ;

    // 视频流协议类型
    public static class EM_STREAM_PROTOCOL_TYPE extends SdkStructure
    {
        public static final int EM_STREAM_PROTOCOL_UNKNOWN=0;         // 未知
        public static final int EM_STREAM_PROTOCOL_PRIVATE_V2=1;      // 私有二代
        public static final int EM_STREAM_PROTOCOL_PRIVATE_V3=2;      // 私有三代
        public static final int EM_STREAM_PROTOCOL_RTSP=3;            // rtsp
        public static final int EM_STREAM_PROTOCOL_ONVIF=4;           // Onvif
        public static final int EM_STREAM_PROTOCOL_GB28181=5;         // GB28181
        public static final int EM_DEV_PROTOCOL_EHOME = 6;            // 海康ehome 协议
        public static final int EM_DEV_PROTOCOL_HIKVISION = 7;        // 海康私有协议
        public static final int EM_DEV_PROTOCOL_BSCP = 8;			   // 蓝星接入协议
        public static final int  EM_DEV_PROTOCOL_PRIVATE=9;           // 私有
    };

    // 远程实时视频源信息
    public static class NET_REMOTE_REALTIME_STREAM_INFO extends SdkStructure
    {
        public int                             dwSize;                                 // 结构体大小
        public int                             emStartRule;                            // 智能任务启动规则，Polling任务时无效(参考)EM_ANALYSE_TASK_START_RULE
        public NET_ANALYSE_RULE                stuRuleInfo;                            // 分析规则信息
        public int                             emStreamProtocolType;                   // 视频流协议类型(参考EM_STREAM_PROTOCOL_TYPE)
        public byte[]                          szPath=new byte[NET_COMMON_STRING_256]; // 视频流地址
        public byte[]                 	        szIp=new byte[NET_MAX_IPADDR_OR_DOMAIN_LEN];      // IP 地址
        public short                 	        wPort;                      		    // 端口号
        public byte[]                          byReserved=new byte[2];                 // 用于字节对齐
        public byte[]                  	    szUser=new byte[NET_COMMON_STRING_64];  // 用户名
        public byte[]                  	    szPwd=new byte[NET_COMMON_STRING_64];   // 密码
        public int                 	        nChannelID;                             // 通道号
        public int                             nStreamType;                            // 码流类型, 0:主码流; 1:辅1码流; 2:辅2码流;
        public byte[]                          szTaskUserData=new byte[256];                    // 任务数据
        //public NET_ANALYSE_TASK_GLOBAL			stuGlobal;								// 全局配置
        //public NET_ANALYSE_TASK_MODULE			stuModule;								// 模块配置
        public NET_REMOTE_REALTIME_STREAM_INFO()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    // 启动智能分析任务, pInParam 和 pOutParam 资源由用户申请和释放
    public Boolean CLIENT_StartAnalyseTask(LLong lLoginID, NET_IN_START_ANALYSE_TASK pInParam, NET_OUT_START_ANALYSE_TASK pOutParam, int nWaitTime);

    // CLIENT_RemoveAnalyseTask 接口输入参数
    public static class NET_IN_REMOVE_ANALYSE_TASK extends SdkStructure
    {
        public int                           dwSize;                                 // 结构体大小
        public int                            nTaskID;                                // 任务ID

        public NET_IN_REMOVE_ANALYSE_TASK()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };


    // CLIENT_RemoveAnalyseTask 接口输出参数
    public static class NET_OUT_REMOVE_ANALYSE_TASK extends SdkStructure
    {
        public int                           dwSize;                                 // 结构体大小

        public NET_OUT_REMOVE_ANALYSE_TASK()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    } ;

    // 删除(停止)智能分析任务, pInParam 和 pOutParam 资源由用户申请和释放
    public Boolean CLIENT_RemoveAnalyseTask(LLong lLoginID, NET_IN_REMOVE_ANALYSE_TASK pInParam, NET_OUT_REMOVE_ANALYSE_TASK pOutParam, int nWaitTime);

    /////////////////////////////////智能分析服务接口 开始/////////////////////////////////
    public static final int   MAX_ANALYSE_REMAIN_CAPACITY_NUM     =32;      // 智能分析最大剩余数量
    public static final int   MAX_ANALYSE_RULE_COUNT              =32;      // 最大分析规则条数
    public static final int   MAX_ANALYSE_PICTURE_FILE_NUM        =32;      // 图片文件最大数量
    public static final int   MAX_ANALYSE_TASK_NUM                =64;      // 最大智能分析任务个数
    public static final int   MAX_ANALYSE_FILTER_EVENT_NUM        =64;      // 最大支持过滤的事件个数
    public static final int   MAX_ANALYSE_ALGORITHM_NUM           =16;      // 最大算法数量
    public static final int   MAX_ANALYSE_TOTALCAPS_NUM           =32;      // 最大的智能分析总能力数量

    // CLIENT_FindAnalyseTask 接口输入参数
    public static class NET_IN_FIND_ANALYSE_TASK extends SdkStructure
    {
        public int                           dwSize;                                 // 结构体大小

        public NET_IN_FIND_ANALYSE_TASK()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    // CLIENT_FindAnalyseTask 接口输出参数
    public static class NET_OUT_FIND_ANALYSE_TASK extends SdkStructure
    {
        public int                           dwSize;                                 // 结构体大小
        public int                           nTaskNum;                               // 智能分析任务个数
        public NET_ANALYSE_TASKS_INFO []     stuTaskInfos=(NET_ANALYSE_TASKS_INFO [])new NET_ANALYSE_TASKS_INFO().toArray(MAX_ANALYSE_TASK_NUM);     // 智能分析任务信息

        public NET_OUT_FIND_ANALYSE_TASK()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    } ;

    // 智能分析任务信息
    public static class NET_ANALYSE_TASKS_INFO extends SdkStructure
    {
        public int                            nTaskID;                                // 任务ID
        public int                            emAnalyseState;                         // 分析状态(參考EM_ANALYSE_STATE)
        public byte []                        byReserved=new byte[1024];              // 保留字节
    };

    // 分析状态
    public static class EM_ANALYSE_STATE extends SdkStructure
    {
        public static final int  EM_ANALYSE_STATE_UNKNOWN=0;             // 未知
        public static final int  EM_ANALYSE_STATE_IDLE=1;                // 已创建但未运行
        public static final int  EM_ANALYSE_STATE_ANALYSING=2;           // 分析中
        public static final int  EM_ANALYSE_STATE_ANALYSING_WAITPUSH=3;  // 分析中并等待push数据
        public static final int  EM_ANALYSE_STATE_FINISH=4;              // 正常完成
        public static final int  EM_ANALYSE_STATE_ERROR=5;               // 执行异常
        public static final int  EM_ANALYSE_STATE_REMOVED=6;             // 被删除
        public static final int  EM_ANALYSE_STATE_ROUNDFINISH=7;         // 完成一轮视频源分析
    };

    // 查找智能分析任务信息, pInParam 和 pOutParam 资源由用户申请和释放
    public Boolean CLIENT_FindAnalyseTask(LLong lLoginID, NET_IN_FIND_ANALYSE_TASK pInParam, NET_OUT_FIND_ANALYSE_TASK pOutParam, int nWaitTime);

    // CLIENT_PushAnalysePictureFile 接口输入参数
    public static class NET_IN_PUSH_ANALYSE_PICTURE_FILE extends SdkStructure
    {
        public int                           dwSize;                                         // 结构体大小
        public int                           nTaskID;                                        // 任务ID
        public NET_PUSH_PICTURE_INFO []      stuPushPicInfos=(NET_PUSH_PICTURE_INFO[]) new NET_PUSH_PICTURE_INFO().toArray(MAX_ANALYSE_PICTURE_FILE_NUM);  // 推送图片信息
        public int                           nPicNum;                                        // 推送图片数量
        public int                           nBinBufLen;                                     // 数据缓冲区长度, 单位:字节
        public Pointer                       pBinBuf;                                        // 数据缓冲区, 由用户申请和释放

        public NET_IN_PUSH_ANALYSE_PICTURE_FILE()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    // X光机视角类型
    public static class EM_XRAY_VIEW_TYPE extends SdkStructure
    {
        public static final int EM_XRAY_VIEW_TYPE_UNKNOWN = -1;									// 未知
        public static final int EM_XRAY_VIEW_TYPE_MASTER=0;										// 主视角
        public static final int EM_XRAY_VIEW_TYPE_SLAVE=1;										// 从视角
    };

    // 客户自定义信息, X光机定制专用
    public static class NET_XRAY_CUSTOM_INFO extends SdkStructure
    {
        public int               emViewType;             // 视角类型
        public byte[]                            szSerialNumber=new byte[128];    // 流水号
        public byte[]                            byReserved=new byte[124];        // 保留字节
    } ;

    // 智能分析图片信息
    public static class NET_PUSH_PICTURE_INFO extends SdkStructure
    {
        public byte[]                            szFileID=new byte[NET_COMMON_STRING_128];// 文件ID
        public int                               nOffset;                                 // 文件数据在二进制数据中的偏移, 单位:字节
        public int                               nLength;                                 // 文件数据长度, 单位:字节
        public NET_XRAY_CUSTOM_INFO              stuXRayCustomInfo;                       // 客户自定义信息, X光机定制专用
        public byte[]                            szUrl=new byte[512];                     // 远程文件url地址  带访问所需必要信息 包含用户名 密码
        public byte[]                            byReserved=new byte[256];                // 保留字节
    } ;

    // CLIENT_PushAnalysePictureFile 接口输出参数
    public static class NET_OUT_PUSH_ANALYSE_PICTURE_FILE extends SdkStructure
    {
        public int                            dwSize;                                 // 结构体大小

        public NET_OUT_PUSH_ANALYSE_PICTURE_FILE()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    } ;

    // 推送智能分析图片文件，当CLIENT_AddAnalyseTask的数据源类型emDataSourceType为 EM_DATA_SOURCE_PUSH_PICFILE 时使用
    public Boolean CLIENT_PushAnalysePictureFile(LLong lLoginID, NET_IN_PUSH_ANALYSE_PICTURE_FILE pInParam, NET_OUT_PUSH_ANALYSE_PICTURE_FILE pOutParam, int nWaitTime);

    /*--------任务开始：  CLIENT_AttachAnalyseTaskState / CLIENT_DetachAnalyseTaskState --------*/


    // 智能分析任务状态回调信息
    public static class NET_CB_ANALYSE_TASK_STATE_INFO extends SdkStructure
    {
        public NET_ANALYSE_TASKS_INFO[]         stuTaskInfos =(NET_ANALYSE_TASKS_INFO[])new NET_ANALYSE_TASKS_INFO().toArray(MAX_ANALYSE_TASK_NUM);      // 智能分析任务信息
        public int               				 nTaskNum;                         									  // 任务个数
        public byte[]                         	 byReserved =new byte[1024];             						      // 保留字节
    };

    // 智能分析状态订阅函数原型, lAttachHandle 为 CLIENT_AttachAnalyseTaskState 函数的返回值
    public interface fAnalyseTaskStateCallBack extends StdCallCallback{
        public int invoke(LLong lAttachHandle, Pointer pstAnalyseTaskStateInfo, Pointer dwUser);
    };


    // CLIENT_AttachAnalyseTaskState 接口输入参数
    public static class NET_IN_ATTACH_ANALYSE_TASK_STATE extends SdkStructure
    {
        public int                              dwSize;                                           // 结构体大小
        public int[]                            nTaskIDs = new int[MAX_ANALYSE_TASK_NUM];         // 智能分析任务ID
        public int                              nTaskIdNum;                                       // 智能分析任务个数, 0表示订阅全部任务
        public fAnalyseTaskStateCallBack        cbAnalyseTaskState;                               // 智能分析任务状态订阅函数
        public Pointer                          dwUser;                 			               // 用户数据

        public NET_IN_ATTACH_ANALYSE_TASK_STATE()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };



    // 订阅智能分析任务状态, pInParam 资源由用户申请和释放
    public LLong CLIENT_AttachAnalyseTaskState(LLong lLoginID, NET_IN_ATTACH_ANALYSE_TASK_STATE pInParam, int nWaitTime);

    // 取消订阅智能分析任务状态, lAttachHandle 为 CLIENT_AttachAnalyseTaskState接口的返回值
    public Boolean CLIENT_DetachAnalyseTaskState(LLong lAttachHandle);



    /*--------任务结束：  CLIENT_AttachAnalyseTaskState / CLIENT_DetachAnalyseTaskState --------*/

    /*--------任务开始：  CLIENT_AttachAnalyseTaskResult / CLIENT_DetachAnalyseTaskResult --------*/
    // 事件类型
    public static class EM_ANALYSE_EVENT_TYPE extends SdkStructure
    {
        public static final int EM_ANALYSE_EVENT_UNKNOWN = 0;                    // 未知
        public static final int EM_ANALYSE_EVENT_ALL = 1;                        // 所有事件
        public static final int EM_ANALYSE_EVENT_FACE_DETECTION = 2;             // 人脸检测事件, 对应结构体 DEV_EVENT_FACEDETECT_INFO
        public static final int EM_ANALYSE_EVENT_FACE_RECOGNITION = 3;           // 人脸识别事件, 对应结构体 DEV_EVENT_FACERECOGNITION_INFO
        public static final int EM_ANALYSE_EVENT_TRAFFICJUNCTION = 4;            // 交通路口事件, 对应结构体 DEV_EVENT_TRAFFICJUNCTION_INFO
        public static final int EM_ANALYSE_EVENT_HUMANTRAIT = 5;                 // 人体特征事件, 对应结构体 DEV_EVENT_HUMANTRAIT_INFO
        public static final int EM_ANALYSE_EVENT_XRAY_DETECTION = 6;             // X光机检测事件, 对应结构体 DEV_EVENT_XRAY_DETECTION_INFO
        public static final int EM_ANALYSE_EVENT_WORKCLOTHESDETECT = 7;          // 工装(安全帽/工作服等)检测事件, 对应结构体 DEV_EVENT_WORKCLOTHESDETECT_INFO
        public static final int EM_ANALYSE_EVENT_WORKSTATDETECTION = 8;          // 作业检测事件, 对应结构体 DEV_EVENT_WORKSTATDETECTION_INFO
        public static final int EM_ANALYSE_EVENT_CORSSLINEDETECTION = 9;         // 警戒线事件, 对应结构体 DEV_EVENT_CROSSLINE_INFO
        public static final int EM_ANALYSE_EVENT_CROSSREGIONDETECTION = 10;      // 警戒区事件, 对应结构体 DEV_EVENT_CROSSREGION_INFO
        public static final int EM_ANALYSE_EVENT_FEATURE_ABSTRACT = 11;          // 特征提取事件 DEV_EVENT_FEATURE_ABSTRACT_INFO
        public static final int EM_ANALYSE_EVENT_ELECTRIC_GLOVE_DETECT = 12;     // 电力检测手套检测事件,  对应结构体 DEV_EVENT_ELECTRIC_GLOVE_DETECT_INFO
        public static final int EM_ANALYSE_EVENT_ELECTRIC_LADDER_DETECT = 13;    // 电力检测梯子检测事件,  对应结构体 DEV_EVENT_ELECTRIC_LADDER_DETECT_INFO
        public static final int EM_ANALYSE_EVENT_ELECTRIC_CURTAIN_DETECT = 14;   // 电力检测布幔检测事件,  对应结构体 DEV_EVENT_ELECTRIC_CURTAIN_DETECT_INFO
        public static final int EM_ANALYSE_EVENT_ELECTRIC_FENCE_DETECT = 15;     // 电力检测围栏检测事件,  对应结构体 DEV_EVENT_ELECTRIC_FENCE_DETECT_INFO
        public static final int EM_ANALYSE_EVENT_ELECTRIC_SIGNBOARD_DETECT = 16; // 电力检测标识牌检测事件,  对应结构体 DEV_EVENT_ELECTRIC_SIGNBOARD_DETECT_INFO
        public static final int EM_ANALYSE_EVENT_ELECTRIC_BELT_DETECT = 17;      // 电力检测安全带检测事件,  对应结构体 DEV_EVENT_ELECTRIC_BELT_DETECT_INFO
        public static final int EM_ANALYSE_EVENT_BANNER_DETECTION=18;			// 拉横幅检测事件,	对应的结构体 DEV_EVENT_BANNER_DETECTION_INFO
        public static final int EM_ANALYSE_EVENT_SMART_KITCHEN_CLOTHES_DETECTION=19; // 智慧厨房穿着检测事件, 对应结构体 DEV_EVENT_SMART_KITCHEN_CLOTHES_DETECTION_INFO
        public static final int EM_ANALYSE_EVENT_WATER_STAGE_MONITOR=20;       // 水位监测事件, 对应结构体DEV_EVENT_WATER_STAGE_MONITOR_INFO
        public static final int EM_ANALYSE_EVENT_FLOATINGOBJECT_DETECTION=21;  // 漂浮物检测事件,  对应结构体 DEV_EVENT_FLOATINGOBJECT_DETECTION_INFO
        public static final int EM_ANALYSE_EVENT_IVS_RIOTERDETECTION=22;       // 人群聚集对应结构体NET_RIOTERDETECTION_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_LEFTDETECTION=23;         // 物品遗留事件对应结构体NET_LEFTDETECTION_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_PARKINGDETECTION=24;      // 非法停车事件对应结构体NET_PARKINGDETECTION_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_WANDERDETECTION=25;       // 徘徊事件对应结构体NET_WANDERDETECTION_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_VIDEOABNORMALDETECTION=26;// 视频异常对应结构体NET_VIDEOABNORMALDETECTION_RULE_INFO
        public static final int EM_ANALYSE_EVENT_MOVEDETECTION=27;             // 运动检测事件, 对应结构体 DEV_EVENT_MOVE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_SMOKEDETECTION=28;		// 烟雾检测事件,对应结构体 NET_SMOKE_DETECTION_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_FIREDETECTION=29;			// 火焰检测事件,对应结构体 NET_FIRE_DETECTION_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_TRAFFIC_ROAD_BLOCK=30;	// 交通路障检测事件,对应结构体 NET_TRAFFIC_ROAD_BLOCK_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_TRAFFIC_ROAD_CONSTRUCTION=31;//交通道路施工检测事件,对应结构体 NET_TRAFFIC_ROAD_CONSTRUCTION_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_TRAFFIC_FLOWSTATE=32;		// 交通流量统计事件,对应结构体 NET_TRAFFIC_FLOWSTAT_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_TRAFFIC_OVERSPEED=33;		// 超速事件,对应结构体 NET_TRAFFIC_OVERSPEED_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_TRAFFIC_UNDERSPEED=34;	// 欠速事件,对应结构体 NET_TRAFFIC_UNDERSPEED_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_TRAFFIC_OVERYELLOWLINE=35;// 压黄线事件,对应结构体 NET_TRAFFIC_OVERYELLOWLINE_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_TRAFFIC_CROSSLANE=36;		// 违章变道事件, 对应结构体 NET_TRAFFIC_CROSSLANE_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_TRAFFICJAM=37;		// 交通拥堵事件, 对应结构体 NET_TRAFFIC_JAM_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_TRAFFIC_PEDESTRAIN=38;	// 交通行人事件, 对应结构体 NET_TRAFFIC_PEDESTRAIN_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_TRAFFIC_THROW=39;// 抛洒物事件, 对应结构体 NET_TRAFFIC_THROW_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_RETROGRADEDETECTION=40;	// 逆行检测事件, 对应结构体 NET_RETROGRADE_DETECTION_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_TRAFFICACCIDENT=41;		// 交通事故事件, 对应结构体 NET_TRAFFIC_ACCIDENT_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_TRAFFIC_BACKING=42;		// 倒车事件, 对应结构体 NET_TRAFFIC_BACKING_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_FOG_DETECTION=43;		// 起雾检测事件, 对应结构体 NET_FOG_DETECTION_RULE_INFO
        public static final int EM_ANALYSE_EVENT_IVS_CROSSREGIONDETECTION=44;	// 警戒区事件, 对应结构体 NET_CROSSREGION_RULE_INFO
        public static final int EM_ANALYSE_EVENT_CROSSLINEDETECTION_EX = 2000;   // 警戒线事件(扩展), 对应结构体 DEV_EVENT_CROSSLINE_INFO_EX


    };

    // 文件分析状态
    public static class EM_FILE_ANALYSE_STATE extends SdkStructure
    {
        public static final int EM_FILE_ANALYSE_UNKNOWN = -1;         // 未知
        public static final int EM_FILE_ANALYSE_EXECUTING = 0;        // 分析中
        public static final int EM_FILE_ANALYSE_FINISH = 1;           // 分析完成
        public static final int EM_FILE_ANALYSE_FAILED = 2;           // 分析失败
    };

    // 二次录像分析事件信息
    public static class NET_SECONDARY_ANALYSE_EVENT_INFO extends SdkStructure
    {
        public int							emEventType;					// 事件类型(对应的枚举值EM_ANALYSE_EVENT_TYPE)
        public byte[]						byReserved1 = new byte[4];		// 字节对齐
        public Pointer						pstEventInfo;					// 事件信息, 根据emEventType确定不同的结构体
        // EM_ANALYSE_EVENT_FACE_DETECTION (人脸检测事件), 对应结构体 DEV_EVENT_FACEDETECT_INFO
        // EM_ANALYSE_EVENT_FACE_RECOGNITION (人脸识别事件), 对应结构体 DEV_EVENT_FACERECOGNITION_INFO
        // EM_ANALYSE_EVENT_TRAFFICJUNCTION (交通路口事件), 对应结构体 DEV_EVENT_TRAFFICJUNCTION_INFO
        // EM_ANALYSE_EVENT_HUMANTRAIT (人体特征事件), 对应结构体 DEV_EVENT_HUMANTRAIT_INFO
        // EM_ANALYSE_EVENT_XRAY_DETECTION(X光机检测事件), 对应结构体 DEV_EVENT_XRAY_DETECTION_INFO
        // EM_ANALYSE_EVENT_WORKCLOTHESDETECT (工装(安全帽/工作服等)检测事件), 对应结构体 DEV_EVENT_WORKCLOTHES_DETECT_INFO
        // EM_ANALYSE_EVENT_WORKSTATDETECTION (作业检测事件), 对应结构体 DEV_EVENT_WORKSTATDETECTION_INFO
        // EM_ANALYSE_EVENT_CORSSLINEDETECTION (警戒线事件), 对应结构体 DEV_EVENT_CROSSLINE_INFO
        // EM_ANALYSE_EVENT_CROSSLINEDETECTION_EX (警戒线事件(扩展)), 对应结构体 DEV_EVENT_CROSSLINE_INFO_EX
        // EM_ANALYSE_EVENT_CROSSREGIONDETECTION (警戒区事件), 对应结构体 DEV_EVENT_CROSSREGION_INFO
        // EM_ANALYSE_EVENT_FEATURE_ABSTRACT(特征提取), 对应结构体 DEV_EVENT_FEATURE_ABSTRACT_INFO
        // EM_ANALYSE_EVENT_ELECTRIC_GLOVE_DETECT(电力检测手套检测事件),  对应结构体 DEV_EVENT_ELECTRIC_GLOVE_DETECT_INFO
        // EM_ANALYSE_EVENT_ELECTRIC_LADDER_DETECT(电力检测梯子检测事件),  对应结构体 DEV_EVENT_ELECTRIC_LADDER_DETECT_INFO
        // EM_ANALYSE_EVENT_ELECTRIC_CURTAIN_DETECT(电力检测布幔检测事件),  对应结构体 DEV_EVENT_ELECTRIC_CURTAIN_DETECT_INFO
        // EM_ANALYSE_EVENT_ELECTRIC_FENCE_DETECT(电力检测围栏检测事件),  对应结构体 DEV_EVENT_ELECTRIC_FENCE_DETECT_INFO
        // EM_ANALYSE_EVENT_ELECTRIC_SIGNBOARD_DETECT(电力检测标识牌检测事件),  对应结构体 DEV_EVENT_ELECTRIC_SIGNBOARD_DETECT_INFO
        // EM_ANALYSE_EVENT_ELECTRIC_BELT_DETECT(电力检测安全带检测事件),  对应结构体 DEV_EVENT_ELECTRIC_BELT_DETECT_INFO
        public byte[]						byReserved = new byte[1024];	// 保留字节
    };

    // 任务自定义数据
    public static class NET_TASK_CUSTOM_DATA extends SdkStructure
    {
        public byte[]                    szClientIP = new byte[128];            // 客户端IP
        public byte[]                    szDeviceID = new byte[128];            // 设备ID
        public byte[]                    byReserved = new byte[256];            // 保留字节
    };

    // 智能分析结果订阅的过滤条件
    public static class NET_ANALYSE_RESULT_FILTER extends SdkStructure
    {
        public int[]		    	           dwAlarmTypes = new int[MAX_ANALYSE_FILTER_EVENT_NUM];     	// 过滤事件, 详见dhnetsdk.h中"智能分析事件类型"
        public int                             nEventNum;                                      			    // 过滤事件数量
        public int                             nImageDataFlag;                                              // 是否包含图片, 0-包含,  1-不包含
        public byte[]                          byReserved1=new byte[4];                                 // 对齐
        public int                             nImageTypeNum;                                  // pImageType有效个数
        /**
         * 对应枚举类型为EM_FILTER_IMAGE_TYPE,int数组按位取值
         */
        public Pointer                         pImageType;                                    // 过滤上报的图片类型
        public byte[]                          byReserved =new byte[1004];                   				// 保留字节
    };

    // CLIENT_AttachAnalyseTaskResult 接口输入参数
    public static class NET_IN_ATTACH_ANALYSE_RESULT extends SdkStructure
    {
        public int                               dwSize;                                 			// 结构体大小
        public int[]                             nTaskIDs = new int[MAX_ANALYSE_TASK_NUM];         // 智能分析任务ID
        public int                               nTaskIdNum;                             			// 智能分析任务个数, 0表示订阅全部任务
        public NET_ANALYSE_RESULT_FILTER         stuFilter;                              			// 过滤条件
        public byte[]                            byReserved = new byte[4];                         // 字节对齐
        public fAnalyseTaskResultCallBack        cbAnalyseTaskResult;                    			// 智能分析任务结果订阅函数
        public Pointer                           dwUser;                                 			// 用户数据

        public NET_IN_ATTACH_ANALYSE_RESULT()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    // 智能分析任务结果信息
    public static class NET_ANALYSE_TASK_RESULT extends SdkStructure
    {
        public int                                  nTaskID;                                													// 任务ID
        public byte[]                               szFileID = new byte [NET_COMMON_STRING_128];         										// 文件ID, 分析文件时有效
        public int             					    emFileAnalyseState;                     													// 文件分析状态(对应的枚举值EM_FILE_ANALYSE_STATE)
        public byte[]                            	szFileAnalyseMsg = new byte[NET_COMMON_STRING_256]; 										// 文件分析额外信息, 一般都是分析失败的原因
        public NET_SECONDARY_ANALYSE_EVENT_INFO[]   stuEventInfos = (NET_SECONDARY_ANALYSE_EVENT_INFO[]) new NET_SECONDARY_ANALYSE_EVENT_INFO().toArray(MAX_SECONDARY_ANALYSE_EVENT_NUM);		// 事件信息
        public int                             	    nEventCount;                            													// 实际的事件个数
        public NET_TASK_CUSTOM_DATA            	    stuCustomData;                          													// 自定义数据
        public byte[]                               szUserData=new byte[64];                                                                    // 频源数据，标示视频源信息，对应addPollingTask中UserData字段。
        public byte[]                            	byReserved =new byte[448];                        											// 保留字节
    };


    // 智能分析任务结果回调信息
    public static class NET_CB_ANALYSE_TASK_RESULT_INFO extends SdkStructure
    {
        public NET_ANALYSE_TASK_RESULT[]         	stuTaskResultInfos = new NET_ANALYSE_TASK_RESULT[MAX_ANALYSE_TASK_NUM];   	// 智能分析任务结果信息
        public int                             	    nTaskResultNum;                             								// 任务个数
        public byte[]                            	byReserved =new byte[1028];                           						// 保留字节
    };

    // 智能分析状态订阅函数原型, lAttachHandle 是 CLIENT_AttachAnalyseTaskResult接口的返回值,pstAnalyseTaskResult对应结构体NET_CB_ANALYSE_TASK_RESULT_INFO
    public interface fAnalyseTaskResultCallBack extends StdCallCallback{
        public int invoke(LLong lAttachHandle, Pointer pstAnalyseTaskResult, Pointer pBuf, int dwBufSize, Pointer dwUser);
    };

    // 取消订阅智能分析结果, lAttachHandle 为 CLIENT_AttachAnalyseTaskResult接口的返回值@@
    public Boolean CLIENT_DetachAnalyseTaskResult(LLong lAttachHandle);


    // 订阅智能分析结果, pInParam 资源由用户申请和释放
    public LLong CLIENT_AttachAnalyseTaskResult(LLong lLoginID, NET_IN_ATTACH_ANALYSE_RESULT pInParam, int nWaitTime);

    /*--------任务结束：  CLIENT_AttachAnalyseTaskResult / CLIENT_DetachAnalyseTaskResult --------*/

    /*--------任务开始：  T0058223ERR191213010-TASK1  停留事件：DEV_EVENT_STAY_INFO--------*/
    // 视频分析物体信息结构体
    public static class DH_MSG_OBJECT extends SdkStructure
    {
        public int                 nObjectID;                          											// 物体ID,每个ID表示一个唯一的物体
        public byte[]              szObjectType = new byte[128];                  								// 物体类型
        public int                 nConfidence;                        											// 置信度(0~255),值越大表示置信度越高
        public int                 nAction;                            											// 物体动作:1:Appear 2:Move 3:Stay 4:Remove 5:Disappear 6:Split 7:Merge 8:Rename
        public DH_RECT             BoundingBox;                        											// 包围盒
        public NET_POINT           Center;                             											// 物体型心
        public int                 nPolygonNum;                        											// 多边形顶点个数
        public NET_POINT[]         Contour = (NET_POINT[])new NET_POINT().toArray(NET_MAX_POLYGON_NUM); 		// 较精确的轮廓多边形
        public int                 rgbaMainColor;                      										    // 表示车牌、车身等物体主要颜色；按字节表示,分别为红、绿、蓝和透明度,例如:RGB值为(0,255,0),透明度为0时, 其值为0x00ff0000.
        public byte[]              szText = new byte[128];                        								// 物体上相关的带0结束符文本,比如车牌,集装箱号等等

        public byte[]              szObjectSubType = new byte[62];              								// 物体子类别,根据不同的物体类型,可以取以下子类型：
        // Vehicle Category:"Unknown"  未知,"Motor" 机动车,"Non-Motor":非机动车,"Bus": 公交车,"Bicycle" 自行车,"Motorcycle":摩托车,"PassengerCar":客车,
        // "LargeTruck":大货车,    "MidTruck":中货车,"SaloonCar":轿车,"Microbus":面包车,"MicroTruck":小货车,"Tricycle":三轮车,    "Passerby":行人
        // "DregsCar":渣土车, "Excavator":挖掘车, "Bulldozer":推土车, "Crane":吊车, "PumpTruck":泵车, "MachineshopTruck":工程车
        //  Plate Category："Unknown" 未知,"Normal" 蓝牌黑牌,"Yellow" 黄牌,"DoubleYellow" 双层黄尾牌,"Police" 警牌"Armed" 武警牌,
        // "Military" BD号牌,"DoubleMilitary" BD双层,"SAR" 港澳特区号牌,"Trainning" 教练车号牌
        // "Personal" 个性号牌,"Agri" 农用牌,"Embassy" 使馆号牌,"Moto" 摩托车号牌,"Tractor" 拖拉机号牌,"Other" 其他号牌
        // "Civilaviation"民航号牌,"Black"黑牌
        // "PureNewEnergyMicroCar"纯电动新能源小车,"MixedNewEnergyMicroCar,"混合新能源小车,"PureNewEnergyLargeCar",纯电动新能源大车
        // "MixedNewEnergyLargeCar"混合新能源大车
        // HumanFace Category:"Normal" 普通人脸,"HideEye" 眼部遮挡,"HideNose" 鼻子遮挡,"HideMouth" 嘴部遮挡,"TankCar"槽罐车(装化学药品、危险品)
        public short               wColorLogoIndex;                    											// 车标索引
        public short               wSubBrand;                          											// 车辆子品牌 需要通过映射表得到真正的子品牌 映射表详见开发手册
        public byte                byReserved1;
        public byte                bPicEnble;                          											// 是否有物体对应图片文件信息
        public NET_PIC_INFO stPicInfo;                         											// 物体对应图片信息
        public byte                bShotFrame;                         											// 是否是抓拍张的识别结果
        public byte                bColor;                             											// 物体颜色(rgbaMainColor)是否可用
        public byte                byReserved2;																	// 保留字节,留待扩展
        public byte                byTimeType;                         											// 时间表示类型,详见EM_TIME_TYPE说明
        public NET_TIME_EX         stuCurrentTime;                     											// 针对视频浓缩,当前时间戳（物体抓拍或识别时,会将此识别智能帧附在一个视频帧或jpeg图片中,此帧所在原始视频中的出现时间）
        public NET_TIME_EX         stuStartTime;                       											// 开始时间戳（物体开始出现时）
        public NET_TIME_EX         stuEndTime;                         											// 结束时间戳（物体最后出现时）
        public DH_RECT             stuOriginalBoundingBox;             											// 包围盒(绝对坐标)
        public DH_RECT             stuSignBoundingBox;                 											// 车标坐标包围盒
        public int                 dwCurrentSequence;                  											// 当前帧序号（抓下这个物体时的帧）
        public int                 dwBeginSequence;                    											// 开始帧序号（物体开始出现时的帧序号）
        public int                 dwEndSequence;                      											// 结束帧序号（物体消逝时的帧序号）
        public long                nBeginFileOffset;                   											// 开始时文件偏移, 单位: 字节（物体开始出现时,视频帧在原始视频文件中相对于文件起始处的偏移）
        public long                nEndFileOffset;                     											// 结束时文件偏移, 单位: 字节（物体消逝时,视频帧在原始视频文件中相对于文件起始处的偏移）
        public byte[]              byColorSimilar = new byte[EM_COLOR_TYPE.NET_COLOR_TYPE_MAX]; 				// 物体颜色相似度,取值范围：0-100,数组下标值代表某种颜色,详见EM_COLOR_TYPE
        public byte[] 			   byUpperBodyColorSimilar = new byte[EM_COLOR_TYPE.NET_COLOR_TYPE_MAX];		//上半身物体颜色相似度(物体类型为人时有效)
        public byte[] 		       byLowerBodyColorSimilar = new byte[EM_COLOR_TYPE.NET_COLOR_TYPE_MAX];		//下半身物体颜色相似度(物体类型为人时有效)
        public int                 nRelativeID;                        											// 相关物体ID
        public byte[]              szSubText = new byte[20];                      								// "ObjectType"为"Vehicle"或者"Logo"时,表示车标下的某一车系,比如奥迪A6L,由于车系较多,SDK实现时透传此字段,设备如实填写。
        public short               wBrandYear;                         											// 车辆品牌年款 需要通过映射表得到真正的年款 映射表详见开发手册
        protected int getNativeAlignment(Class<?> type, Object value, boolean isFirstElement) {
            int alignment = super.getNativeAlignment(type, value, isFirstElement);
            return Math.min(4, alignment);
        }
    };

    // 事件类型EVENT_IVS_STAYDETECTION(停留事件)对应的数据块描述信息
    public static class DEV_EVENT_STAY_INFO extends SdkStructure
    {
        public int                   		nChannelID;                         								// 通道号
        public byte[]                		szName = new byte[128];                    							// 事件名称
        public byte[]                		bReserved1 = new byte[4];                  							// 字节对齐
        public double              			PTS;                                								// 时间戳(单位是毫秒)
        public NET_TIME_EX         			UTC;                                								// 事件发生的时间
        public int                 			nEventID;                           								// 事件ID
        public DH_MSG_OBJECT       			stuObject;                          								// 检测到的物体
        public NET_EVENT_FILE_INFO  		stuFileInfo;                        								// 事件对应文件信息
        public byte                			bEventAction;                       								// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]                		byReserved = new byte[2];											// 保留字节
        public byte                			byImageIndex;                       								// 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从 0 开始
        public int                 			nDetectRegionNum;   //较精确的轮廓多边形                								// 规则检测区域顶点数
        public DH_POINT[]            		DetectRegion = (DH_POINT[])new DH_POINT().toArray(NET_MAX_DETECT_REGION_NUM);// 规则检测区域
        public int               			dwSnapFlagMask;                     								// 抓图标志(按位),具体见NET_RESERVED_COMMON
        public int                 			nSourceIndex;                       								// 事件源设备上的index,-1表示数据无效
        public byte[]                		szSourceDevice = new byte[MAX_PATH];           						// 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int        					nOccurrenceCount;                   								// 事件触发累计次数
        public EVENT_INTELLI_COMM_INFO     	stuIntelliCommInfo;         										// 智能事件公共信息
        public int                 			nObjectNum;                         								// 检测到的物体个数
        public DH_MSG_OBJECT[]       		stuObjectIDs =(DH_MSG_OBJECT[])new DH_MSG_OBJECT().toArray(DH_MAX_OBJECT_NUM);    				// 检测到的物体
        public int							nAreaID;															// 区域ID(一个预置点可以对应多个区域ID)
        public Boolean                		bIsCompliant;                       								// 该场景下是否合规
        public byte[]                		bReserved = new byte[1016];                    						// 保留字节,留待扩展.
    };
    /*--------任务结束：  T0058223ERR191213010-TASK1  停留事件：DEV_EVENT_STAY_INFO--------*/


    /*--------任务开始：  ERR191213083-TASK1  发动机数据上报：DH_ALARM_ENGINE_FAILURE_STATUS --------*/
    // 发动机故障状态
    public static class EM_ENGINE_FAILURE_STATUS extends SdkStructure
    {
        public static final int EM_ENGINE_FAILURE_UNKNOWN = 0;											// 未知
        public static final int EM_ENGINE_FAILURE_NOTACTIVE = 1;										// "Not active"
        public static final int EM_ENGINE_FAILURE_ACTIVE = 2;											// "Active"
        public static final int EM_ENGINE_FAILURE_BLINK = 3;											// "Blink"
        public static final int EM_ENGINE_FAILURE_NOTAVAILABLE = 4;										// "Not Available"
    }

    // 发动机故障状态上报事件( DH_ALARM_ENGINE_FAILURE_STATUS )
    public static class ALARM_ENGINE_FAILURE_STATUS_INFO extends SdkStructure
    {
        public int							nChannelID;									// 通道号
        public int							nAction;									// 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public NET_TIME_EX					UTC;										// 事件发生的时间
        public int							emStatus;									// 发动机故障状态 详见 EM_ENGINE_FAILURE_STATUS
        public NET_GPS_STATUS_INFO			stuGPS;										// GPS信息(车载需求)
        public byte[]						byReserved =new byte[1024];					// 保留字节
    };
    /*--------任务开始：  ERR191213083-TASK1  发动机数据上报：DH_ALARM_ENGINE_FAILURE_STATUS--------*/




    /************************************************************************/
    /*  辽宁高速视频云平台项目_DH-DSS-J9100_G1视频上传交通运输部需求   从这往下                                 */
    /************************************************************************/
    // 获取转码虚拟通道号(虚拟通道号用于预览与回放), pInParam 和pOutParam 由用户申请和释放
    public boolean CLIENT_GetVirtualChannelOfTransCode(LLong lLoginID,
                                                       NET_IN_GET_VIRTUALCHANNEL_OF_TRANSCODE pInParam, NET_OUT_GET_VIRTUALCHANNEL_OF_TRANSCODE pOutParam, int nWaitTime);

    // 虚拟通道转码策略
    public static class NET_VIRTUALCHANNEL_POLICY extends SdkStructure
    {
        public int                     bDeleteByCaller;        // 是否由用户管理虚拟通道, TRUE:由用户管理  FALSE:由设备管理
        public int                     bContinuous;            // 是否持续转码
        public byte[]			       byReserved=new byte[512];		   // 保留字节
    } ;

    //CLIENT_GetVirtualChannelOfTransCode 接口输入参数
    public static class NET_IN_GET_VIRTUALCHANNEL_OF_TRANSCODE extends SdkStructure{
        public int       	dwSize;                                 // 结构体大小
        public NET_VIDEO_SOURCE_INFO		stuVideoSourceInfo;		// 视频源信息
        public NET_TRANSCODE_VIDEO_FORMAT	stuTransVideoFormat;	// 转码视频格式
        public NET_TRANSCODE_AUDIO_FORMAT	stuTransAudioFormat;	// 转码音频格式
        public NET_VIRTUALCHANNEL_POLICY	stuVirtualChnPolicy;	// 虚拟通道转码策略
        public NET_IN_GET_VIRTUALCHANNEL_OF_TRANSCODE(){
            this.dwSize = this.size();
        }
    }
    // 视频源信息
    public static class NET_VIDEO_SOURCE_INFO extends SdkStructure{
        public int				emProtocolType;		  		  // 设备协议类型,枚举值参考EM_DEV_PROTOCOL_TYPE
        public byte[]          szIp = new byte[64];          // 前端设备IP地址
        public int             nPort; 					      // 前端设备端口号
        public byte[] 			szUser = new byte[128];       // 前端设备用户名
        public byte[] 			szPwd = new byte[128];        // 前端设备密码
        public int             nChannelID;                   // 前端设备通道号
        public byte[] 			szStreamUrl = new byte[256];  // 视频源url地址, emProtocolType为EM_DEV_PROTOCOL_GENERAL 时有效
        public byte[] 			byReserved = new byte[512];   // 保留字节
    }
    // 设备协议类型
    public static class EM_DEV_PROTOCOL_TYPE extends SdkStructure
    {
        public static final int	EM_DEV_PROTOCOL_UNKNOWN = 0;		   // 未知
        public static final int EM_DEV_PROTOCOL_V2 = 1; 		       // 私有二代
        public static final int EM_DEV_PROTOCOL_V3 = 2; 			   // 私有三代
        public static final int EM_DEV_PROTOCOL_ONVIF = 3;			   // onvif
        public static final int EM_DEV_PROTOCOL_GENERAL = 4;		   // general
        public static final int EM_DEV_PROTOCOL_GB28181 = 5;	       // 国标GB28181
        public static final int EM_DEV_PROTOCOL_EHOME = 6;             // 海康ehome 协议
        public static final int EM_DEV_PROTOCOL_HIKVISION = 7;         // 海康私有协议
        public static final int EM_DEV_PROTOCOL_BSCP = 8;			   // 蓝星接入协议
    }

    // 转码视频格式
    public static class NET_TRANSCODE_VIDEO_FORMAT extends SdkStructure{
        public int emCompression;									// 视频压缩格式,枚举值参考EM_TRANSCODE_VIDEO_COMPRESSION
        public int nWidth;											// 视频宽度
        public int nHeight;											// 视频高度
        public int emBitRateControl;								// 码流控制模式,枚举值参考NET_EM_BITRATE_CONTROL
        public int nBitRate;										// 视频码流(kbps)
        public float fFrameRate;                                    // 视频帧率
        public int nIFrameInterval;	                                // I帧间隔(1-100)，比如50表示每49个B帧或P帧，设置一个I帧。
        public int emImageQuality;									// 图像质量,枚举值参考EM_TRANSCODE_IMAGE_QUALITY
        public byte[]                byReserved=new byte[512];		// 保留字节
    }
    // 视频压缩格式
    public static class EM_TRANSCODE_VIDEO_COMPRESSION extends SdkStructure{
        public static final int EM_TRANSCODE_VIDEO_AUTO = 0;		// auto
        public static final int EM_TRANSCODE_VIDEO_MPEG4 = 1;		// MPEG4
        public static final int EM_TRANSCODE_VIDEO_MPEG2 = 2;		// MPEG2
        public static final int EM_TRANSCODE_VIDEO_MPEG1 = 3;		// MPEG1
        public static final int EM_TRANSCODE_VIDEO_MJPG = 4;		// MJPG
        public static final int EM_TRANSCODE_VIDEO_H263 = 5;		// H.263
        public static final int EM_TRANSCODE_VIDEO_H264 = 6;		// H.264
        public static final int EM_TRANSCODE_VIDEO_H265 = 7;		// H.265
    }
    // 码流控制模式
    public static class NET_EM_BITRATE_CONTROL extends SdkStructure{
        public static final int EM_BITRATE_CBR = 0;					// 固定码流
        public static final int EM_BITRATE_VBR = 1;					// 可变码流
    }
    // 图像质量
    public static class EM_TRANSCODE_IMAGE_QUALITY extends SdkStructure{
        public static final int EM_TRANSCODE_IMAGE_QUALITY_SELFADAPT = 0;      // 自适应
        public static final int EM_TRANSCODE_IMAGE_QUALITY_Q10 = 1;            // 10%
        public static final int EM_TRANSCODE_IMAGE_QUALITY_Q30 = 2;            // 30%
        public static final int EM_TRANSCODE_IMAGE_QUALITY_Q50 = 3;            // 50%
        public static final int EM_TRANSCODE_IMAGE_QUALITY_Q60 = 4;            // 60%
        public static final int EM_TRANSCODE_IMAGE_QUALITY_Q80 = 5;            // 80%
        public static final int EM_TRANSCODE_IMAGE_QUALITY_Q100 = 6;           // 100%
    }

    // 转码音频格式
    public static class NET_TRANSCODE_AUDIO_FORMAT extends SdkStructure{
        public int emCompression;		// 音频压缩模式,枚举值参考NET_EM_AUDIO_FORMAT
        public int nFrequency;							// 音频采样频率
        public byte[]	byReserved = new byte[512];		// 保留字节
    }
    public static class NET_EM_AUDIO_FORMAT extends SdkStructure{
        public static final int EM_AUDIO_FORMAT_UNKNOWN = 0;							// unknown
        public static final int EM_AUDIO_FORMAT_G711A = 1;                              // G711a
        public static final int EM_AUDIO_FORMAT_PCM = 2;                                // PCM
        public static final int EM_AUDIO_FORMAT_G711U = 3;                              // G711u
        public static final int EM_AUDIO_FORMAT_AMR = 4;                                // AMR
        public static final int EM_AUDIO_FORMAT_AAC = 5;                                // AAC

        public static final int EM_AUDIO_FORMAT_G726 = 6;								// G.726
        public static final int EM_AUDIO_FORMAT_G729 = 7;								// G.729
        public static final int EM_AUDIO_FORMAT_ADPCM = 8;								// ADPCM
        public static final int EM_AUDIO_FORMAT_MPEG2 = 9;								// MPEG2
        public static final int EM_AUDIO_FORMAT_MPEG2L2 = 10;							// MPEG2-Layer2
        public static final int EM_AUDIO_FORMAT_OGG = 11;								// OGG
        public static final int EM_AUDIO_FORMAT_MP3 = 12;								// MP3
        public static final int EM_AUDIO_FORMAT_G7221 = 13;								// G.722.1
    }

    //CLIENT_GetVirtualChannelOfTransCode 接口输出参数
    public static class NET_OUT_GET_VIRTUALCHANNEL_OF_TRANSCODE extends SdkStructure{
        public int       	dwSize;						// 结构体大小
        public int			nVirtualChannel;			// 虚拟通道号
        public NET_OUT_GET_VIRTUALCHANNEL_OF_TRANSCODE(){
            this.dwSize = this.size();
        }
    }




    // 获取转码能力集, pInParam 和pOutParam 由用户申请和释放
    public boolean CLIENT_GetCapsOfTransCode(LLong lLoginID,
                                             NET_IN_TRANDCODE_GET_CAPS pInParam, NET_OUT_TRANSCODE_GET_CAPS pOutParam, int nWaitTime);
    // 删除转码虚拟通道号
    public boolean CLIENT_DelVirtualChannelOfTransCode(LLong lLoginID,
                                                       NET_IN_DEL_VIRTUALCHANNEL_OF_TRANSCODE pInParam, NET_OUT_DEL_VIRTUALCHANNEL_OF_TRANSCODE pOutParam, int nWaitTime);

    // CLIENT_DelVirtualChannelOfTransCode 接口输入参数
    public static class NET_IN_DEL_VIRTUALCHANNEL_OF_TRANSCODE extends SdkStructure{
        public int						    dwSize;							// 结构体大小
        public int                         nVirtualChannel;                // 虚拟通道号, -1 表示删除所有虚拟通道
        public NET_IN_DEL_VIRTUALCHANNEL_OF_TRANSCODE(){
            this.dwSize = this.size();
        }
    };

    // CLIENT_DelVirtualChannelOfTransCode 接口输出参数
    public static class NET_OUT_DEL_VIRTUALCHANNEL_OF_TRANSCODE extends SdkStructure{
        public int						    dwSize;							// 结构体大小
        public NET_OUT_DEL_VIRTUALCHANNEL_OF_TRANSCODE(){
            this.dwSize = this.size();
        }
    };

    // CLIENT_GetCapsOfTransCode 接口输入参数
    public static class NET_IN_TRANDCODE_GET_CAPS extends SdkStructure{
        public int       	dwSize;						// 结构体大小
        public NET_IN_TRANDCODE_GET_CAPS(){
            this.dwSize = this.size();
        }
    }
    // CLIENT_GetCapsOfTransCode 接口输出参数
    public static class NET_OUT_TRANSCODE_GET_CAPS extends SdkStructure{
        public int       	dwSize;						// 结构体大小
        public int         nMinVirtualChannel;             // 最小虚拟通道号
        public int         nMaxVirtualChannel;             // 最大虚拟通道号
        public boolean     bSupportErrorCode;              // 是否支持压缩错误码实时上报
        public boolean     bSupportContinuous;             // 是否支持持续转码
        public boolean     bSupportDelByCaller;            // 是否支持由用户管理虚拟通道
        public NET_OUT_TRANSCODE_GET_CAPS(){
            this.dwSize = this.size();
        }
    }




    // 订阅虚拟转码通道状态, pInParam 由用户申请和释放
    public LLong CLIENT_AttachVirtualChannelStatus(LLong lLoginID,
                                                   NET_IN_ATTACH_VIRTUALCHANNEL_STATUS pInParam, int nWaitTime);
    //CLIENT_AttachVirtualChannelStatus 接口输入参数
    public static class NET_IN_ATTACH_VIRTUALCHANNEL_STATUS extends SdkStructure{
        public int       	dwSize;						// 结构体大小
        public byte[]	byReserved = new byte[4];		// 用于字节对齐
        public fVirtualChannelStatusCallBack cbVirtualChannelStatus;  // 虚拟转码通道状态订阅函数
        public Pointer dwUser;// 用户数据
        public NET_IN_ATTACH_VIRTUALCHANNEL_STATUS(){
            this.dwSize = this.size();
        }
    }
    public interface fVirtualChannelStatusCallBack extends StdCallCallback {
        public void invoke(LLong lAttachHandle, NET_CB_VIRTUALCHANNEL_STATUS_INFO pstVirChnStatusInfo, Pointer dwUser);}

    // 虚拟转码通道状态信息
    public class NET_CB_VIRTUALCHANNEL_STATUS_INFO extends SdkStructure{
        public int        nVirChannelID;                  // 虚拟转码通道号
        public int        emVirChannelStatus;  		   // 虚拟转码通道状态,枚举值参考EM_VIRCHANNEL_STATUS
        public byte[]	byReserved = new byte[1024];	   // 保留字节
// 		 public static class ByValue extends NET_CB_VIRTUALCHANNEL_STATUS_INFO implements SdkStructure.ByValue { }
    }
    public class EM_VIRCHANNEL_STATUS extends SdkStructure {
        public static final int	EM_VIRCHANNEL_STATUS_UNKNOWN    		= -1;   // 未知
        public static final int	EM_VIRCHANNEL_STATUS_OVER_DECODE        = 0;    // 超出解码
        public static final int	EM_VIRCHANNEL_STATUS_OVER_COMPRESS      = 1;    // 超出压缩
        public static final int	EM_VIRCHANNEL_STATUS_NO_ORIGI_STREAM    = 2;    // 无原始码流
        public static final int	EM_VIRCHANNEL_STATUS_SLAVE_OFFLINE      = 3;	// 压缩通道所在的从片掉线
        public static final int	EM_VIRCHANNEL_STATUS_UNKNOWN_FAILURE 	= 255;	// 未知的失败原因
    }



    // 取消订阅虚拟转码通道状态, lAttachHandle 为 CLIENT_AttachVirtualChannelStatus 函数的返回值
    public boolean CLIENT_DetachVirtualChannelStatus(LLong lAttachHandle);


    /************************************************************************/
    /*  辽宁高速视频云平台项目_DH-DSS-J9100_G1视频上传交通运输部需求           从这往上                        */
    /************************************************************************/

    // 设置动态子连接断线回调函数,目前SVR设备的监视和回放是短连接的。
    public void CLIENT_SetSubconnCallBack(Callback cbSubDisConnect, Pointer dwUser);

    // 动态子连接断开回调函数原形
    public interface fSubDisConnect extends StdCallCallback{
        public void invoke(int emInterfaceType, Boolean bOnline, LLong lOperateHandle, LLong lLoginID, Pointer dwUser);
    }
    // 接口类型,对应CLIENT_SetSubconnCallBack接口
    public static class EM_INTERFACE_TYPE extends SdkStructure
    {
        public static final int DH_INTERFACE_OTHER = 0;            // 未知接口
        public static final int DH_INTERFACE_REALPLAY = 1;                     // 实时监视接口
        public static final int DH_INTERFACE_PREVIEW = 2;                       // 多画面预览接口
        public static final int DH_INTERFACE_PLAYBACK =3;                      // 回放接口
        public static final int DH_INTERFACE_DOWNLOAD =4;                      // 下载接口
        public static final int DH_INTERFACE_REALLOADPIC =5;                   // 下载智能图片接口
    };
    //人脸开门输入参数
    public static class NET_IN_FACE_OPEN_DOOR extends SdkStructure
    {
        public int                  dwSize;
        public int                  nChannel;     //门通道号
        public int                  emCompareResult;//比对结果
        public NET_OPENDOOR_MATCHINFO stuMatchInfo;   //匹配信息
        public NET_OPENDOOR_IMAGEINFO stuImageInfo;   //图片信息

        public NET_IN_FACE_OPEN_DOOR(){
            this.dwSize = this.size();
        }
    };

    //匹配信息
    public static class NET_OPENDOOR_MATCHINFO extends SdkStructure
    {
        public byte[]                                szUserID=new byte[32];     //远程用户ID
        public byte[]                                szUserName=new byte[32];   //用户名
        public int                                   emUserType;       //用户类型
        public byte[]                                szName=new byte[64];       //门禁名称
        public int                                   nMatchRate;       //匹配度，范围为0-100
        public int                                   emOpenDoorType;   //开门方式
        public NET_TIME                              stuActivationTime;                         //(卡、头像)生效日期
        public NET_TIME                              stuExpiryTime;                             //(卡、头像)截止日期
        public int                                   nScore;                                    // 信用积分
        public byte[]                                szCompanyName=new byte[MAX_COMPANY_NAME_LEN];       //单位名称
        public byte[]                                szCompanionName=new byte[120];                      //陪同人员姓名
        public byte[]                                szCompanionCompany=new byte[MAX_COMPANY_NAME_LEN];  //陪同人员单位名称
        public byte[]                                szPermissibleArea=new byte[MAX_COMMON_STRING_128];  //准许通行区域
        public byte[]								  szSection=new byte[200];		//部门名称
        public Pointer                               pstuCustomEducationInfo;      // 教育信息(两个教育定制使用),参考NET_CUSTOM_EDUCATION_INFO
        public Pointer                               pstuHealthCodeInfo;//健康码信息,NET_HEALTH_CODE_INFO
        public byte[]                                szRoomNo=new byte[32];//房间号
        public Pointer                               pstuIDCardInfo;//身份证信息,NET_IDCARD_INFO
        public byte[]                                byReserved=new byte[64];
    };

    // 教育信息
    public static class NET_CUSTOM_EDUCATION_INFO extends SdkStructure
    {
        public int                                   emInfoType;                      // 信息类型
        public int                                   nStudentSeatNumber;              // 座位号,最小值为1
        public byte[]                                szInfoContent=new byte[128];     // 消息内容
        public int			emVoiceType;					 // 语音类型,EM_CUSTOM_EDUCATION_VOICE_TYPE
    };

    //图片信息
    public static class NET_OPENDOOR_IMAGEINFO extends SdkStructure
    {
        public int nLibImageLen;    //人脸库照片长度，限制为150k
        public int nSnapImageLen;   //抓拍照片长度，限制为150k
        public Pointer pLibImage;     //人脸库照片，内存由用户申请
        public Pointer pSnapImage;    //抓拍照片，内存由用户申请
        public byte[] byReserved=new byte[1024];
    };

    //人脸开门输出参数
    public static class NET_OUT_FACE_OPEN_DOOR extends SdkStructure
    {
        public int dwSize;

        public NET_OUT_FACE_OPEN_DOOR(){
            this.dwSize = this.size();
        }
    };

    //人脸开门
    public boolean  CLIENT_FaceOpenDoor(LLong lLoginID, NET_IN_FACE_OPEN_DOOR pInParam, NET_OUT_FACE_OPEN_DOOR pOutParam, int nWaitTime);

    // 水位场景类型
    public static class EM_WATERSTAGE_SCENE_TYPE extends SdkStructure
    {
        public static final int  EM_WATERMONITOR_SCENE_UNKNOWN=0;                  // 未知
        public static final int  EM_WATERMONITOR_SCENE_WATERSTAGE_RULE=1;          // 水位检测, 有水位尺
        public static final int  EM_WATERMONITOR_SCENE_WATERSTAGE_NO_RULE=2;       // 水位检测, 无水位尺
        public static final int  EM_WATERMONITOR_SCENE_WATERLOGG_RULE=3;           // 内涝检测, 有水位尺
        public static final int  EM_WATERMONITOR_SCENE_WATERLOGG_NO_RULE=4;        // 内涝检测, 无水位尺
    };

    // 水面分割掩膜信息
    public static class NET_WATER_SURFACE_MASK_INFO extends SdkStructure
    {
        public int            nColNum;            // 水面分割掩膜列数
        public int            nOffset;            // 偏移
        public int            nLength;            // 长度
        public byte[]		   byReserved=new byte[1020];   // 预留字段
    };

    // 水位监测事件, 目前仅用于任务型智能分析
    public static class DEV_EVENT_WATER_STAGE_MONITOR_INFO extends SdkStructure
    {
        public int                         nChannelID;				// 通道号
        public int                         nAction;				// 1:开始 2:停止
        public byte[]                      szName=new byte[128];	// 事件名称
        public double                      PTS;					// 时间戳(单位是毫秒)
        public NET_TIME_EX                 UTC;					// 事件发生的时间
        public int                         nEventID;				// 事件ID
        public int                         nRuleID;				// 智能事件规则编号，用于标示哪个规则触发的事件
        public int                         emClassType;			// 智能事件所属大类
        public int                         emSceneType;            // 水位场景类型
        public double                      dbMark;                 // 水尺读数
        public NET_POINT                   stuCrossPoint;          // 水尺与水面交点
        public NET_WATER_SURFACE_MASK_INFO stuWaterSurfaceMask;    // 水面分割掩膜信息, emSceneType 为EM_WATERMONITOR_SCENE_WATERSTAGE_NO_RULE 或者EM_WATERMONITOR_SCENE_WATERLOGG_NO_RULE有效
        public byte[]						byReserved=new byte[1020];		// 预留字段
    } ;

    // 标定线
    public static class NET_CALIBRATE_LINE_INFO extends SdkStructure
    {
        public NET_POINT           stuStartPoint;          // 起点
        public NET_POINT           stuEndPoint;            // 终点
    };

    // 事件类型EVENT_IVS_WATER_STAGE_MONITOR(水位检测事件)对应的规则配置
    public static class NET_WATER_STAGE_MONITOR_RULE_INFO extends SdkStructure
    {
        public int						              nDetectRegionPoint;             // 检测区顶点数
        public POINTCOORDINATE[]		              stuDetectRegion=(POINTCOORDINATE[]) new POINTCOORDINATE().toArray(20);            // 检测区域
        public int                                   dwSceneMask;                    // 使能检测的场景掩码	                                                                             // bit2：内涝检测，有水位尺, bit3：内涝检测，无水位尺
        public NET_CALIBRATE_LINE_INFO               stuCalibrateLine;               // 标定线, 仅在人物分析模式下有效
        public byte[]                                byReserved=new byte[4096];//保留字节

    }

    // 事件类型EVENT_IVS_VIOLENT_THROW_DETECTION(暴力抛物检测)对应的数据块描述信息
    public static class DEV_EVENT_VIOLENT_THROW_DETECTION_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public int					nAction;									// 0:脉冲 1:开始 2:停止
        public byte[]              szName=new byte[128];                       // 事件名称
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_EVENT_FILE_INFO stuFileInfo;                               // 事件对应文件信息

        public int                 nFrameSequence;                             // 视频分析帧序号
        public byte[]              szRegionName=new byte[64];                  // 暴力抛物检测区域名称
        public SCENE_IMAGE_INFO_EX stuSceneImage;                              // 大图信息
        public byte[]				byReserver=new byte[1028];					// 保留字节
    };

    // CLIENT_GetHumanRadioCaps 接口输入参数
    public static class NET_IN_GET_HUMAN_RADIO_CAPS extends SdkStructure
    {
        public int				dwSize;
        public int				nChannel;

        public NET_IN_GET_HUMAN_RADIO_CAPS(){
            this.dwSize = this.size();
        }
    };

    // CLIENT_GetHumanRadioCaps 接口输出参数
    public static class NET_OUT_GET_HUMAN_RADIO_CAPS extends SdkStructure
    {
        public int				dwSize;
        public int			bSupportRegulatorAlarm;

        public NET_OUT_GET_HUMAN_RADIO_CAPS(){
            this.dwSize = this.size();
        }
    };
    // 获取能力级
    public Boolean CLIENT_GetHumanRadioCaps(LLong lLoginID, NET_IN_GET_HUMAN_RADIO_CAPS pInParam, NET_OUT_GET_HUMAN_RADIO_CAPS pOutParam, int nWaitTime);

    // 区域内人员体温信息
    public static class NET_MAN_TEMP_INFO extends SdkStructure
    {
        public int						nObjectID;				// 物体ID
        public NET_RECT					stRect;					// 人员头肩信息, 8192坐标系
        public double					dbHighTemp;				// 最高温度
        public int						nTempUnit;				// 温度单位(0摄氏度 1华氏度 2开尔文)
        public boolean					bIsOverTemp;			// 是否超温
        public boolean					bIsUnderTemp;			// 是否低温
        public int						nOffset;				// 人脸小图特征值在二进制数据块中的偏移
        public int						nLength;				// 人脸小图特征值长度, 单位:字节
        public int	                    emMaskDetectResult;		// 口罩检测结果(参考EM_MASK_DETECT_RESULT_TYPE)
        public NET_RECT					stThermalRect;			// 热成像检测人员头肩坐标信息(坐标系：8192)
        public int						nAge;					// 年龄
        public int                      emSex;				    // 性别(参考EM_DEV_EVENT_FACEDETECT_SEX_TYPE)
        public byte[]					byReserved=new byte[36];			// 预留字段
    } ;

    // 全景图
    public static class NET_VIS_SCENE_IMAGE extends SdkStructure
    {
        public int						nOffset;				// 在二进制数据块中的偏移
        public int						nLength;				// 图片大小, 单位字节
        public int						nWidth;					// 图片宽度, 像素
        public int						nHeight;				// 图片高度, 像素
        public byte[]					byReserved=new byte[64];			// 预留字段
    } ;

    // 热成像全景图
    public static class NET_THERMAL_SCENE_IMAGE extends SdkStructure
    {
        public int						nOffset;				// 在二进制数据块中的偏移
        public int						nLength;				// 图片大小, 单位字节
        public int						nWidth;					// 图片宽度, 像素
        public int						nHeight;				// 图片高度, 像素
        public byte[]					byReserved=new byte[64];			// 预留字段
    } ;

    // 事件类型EVENT_IVS_ANATOMY_TEMP_DETECT(人体测温检测事件)对应的数据块描述信息
    public static class DEV_EVENT_ANATOMY_TEMP_DETECT_INFO extends SdkStructure
    {
        public int                      nChannelID;				// 通道号
        public int                      nAction;				// 1:开始 2:停止
        public byte[]                   szName=new byte[128];	// 事件名称
        public double                   PTS;					// 时间戳(单位是毫秒)
        public NET_TIME_EX              UTC;					// 事件发生的时间
        public int                      nEventID;				// 事件ID

        public int                      emClassType;			// 智能事件所属大类(对应枚举类型EM_CLASS_TYPE)
        public int						nPresetID;				// 事件触发的预置点号, 从1开始, 没有该字段,表示预置点未知
        public NET_MAN_TEMP_INFO		stManTempInfo;          // 区域内人员体温信息
        public NET_VIS_SCENE_IMAGE		stVisSceneImage;		// 可见光全景图
        public NET_THERMAL_SCENE_IMAGE	stThermalSceneImage;	// 热成像全景图
        public int						nSequence;				// 帧序号
        public int						nEventRelevanceID;		// 事件关联ID
        public boolean					bIsFaceRecognition;		// 是否做过后智能的人脸识别
        public byte[]					byReserved=new byte[1016];		// 预留字段
    } ;

    // 事件类型 ALARM_ANATOMY_TEMP_DETECT_INFO(人体温智能检测事件)对应的数据块描述信息
    public static class ALARM_ANATOMY_TEMP_DETECT_INFO extends SdkStructure
    {
        public int                 		nChannelID;                         	// 通道号
        public int						nAction;								// 0:脉冲 1:开始 2:停止
        public byte[]                	szName=new byte[128];                   // 事件名称
        public double              		PTS;                                	// 时间戳(单位是毫秒)
        public NET_TIME_EX         		UTC;                                	// 事件发生的时间
        public int                		nEventID;                           	// 事件ID

        public int						nPresetID;								// 事件触发的预置点号, 从1开始, 没有该字段,表示预置点未知
        public NET_MAN_TEMP_INFO		stManTempInfo;							// 区域内人员体温信息
        public int						nSequence;								// 帧序号
        public int						nEventRelevanceID;						// 事件关联ID
        public boolean					bIsFaceRecognition;						// 是否做过后智能的人脸识别
        public byte[]		    		byReserved=new byte[1020];			    // 预留字节
    } ;

    // 人体测温规则配置
    public static class CFG_ANATOMY_TEMP_DETECT_INFO extends SdkStructure
    {
        // 信息
        public byte[]				szRuleName=new byte[MAX_NAME_LEN];						// 规则名称,不同规则不能重名
        public int				    bRuleEnable;											// 规则使能
        public int					nObjectTypeNum;											// 相应物体类型个数
        public byte[]				szObjectTypes=new byte[MAX_OBJECT_LIST_SIZE*MAX_NAME_LEN];		// 相应物体类型列表
        public int                  nPtzPresetId;                                           // 云台预置点编号	0~65535
        public CFG_ALARM_MSG_HANDLE stuEventHandler;										// 报警联动
        public CFG_TIME_SECTION[]	stuTimeSection=(CFG_TIME_SECTION[])new CFG_TIME_SECTION().toArray(WEEK_DAY_NUM*MAX_REC_TSECT_EX);			// 事件响应时间段
        public byte                 bTrackEnable;                                           // 触发跟踪使能,仅对警戒线事件,警戒区规则有效
        public int					nDetectRegionPoint;							// 多边形顶点数
        public CFG_POLYGON[]		stuDetectRegion=(CFG_POLYGON[])new CFG_POLYGON().toArray(MAX_POLYGON_NUM);			// 检测区域，多边形
        public boolean				bHighEnable;								// 高温异常报警是否开启
        public boolean				bLowEnable;									// 低温异常报警是否开启
        public float				fHighThresholdTemp;							// 高温异常阈值
        public float				fLowThresholdTemp;							// 低温异常阈值
        public boolean				bIsAutoStudy;								// 是否自动学习
        public float				fHighAutoOffset;							// 高温自动学习偏差值
        public float				fLowAutoOffset;								// 低温自动学习偏差值
        public int					nSensitivity;								// 灵敏度 范围[1, 10]
        public boolean				bSizeFileter;								// 规则特定的尺寸过滤器是否有效
        public CFG_SIZEFILTER_INFO	stuSizeFileter;								// 规则特定的尺寸过滤器
        public boolean				bIsCaptureNormal;							// 是否上报正常体温信息

        public byte[]				byReserved=new byte[1024]; 					// 保留字节
    };

    // 事件类型 ALARM_REGULATOR_ABNORMAL_INFO(标准黑体源异常报警事件)对应的数据块描述信息
    public static class ALARM_REGULATOR_ABNORMAL_INFO extends SdkStructure
    {
        public int                 		nChannelID;                         	// 通道号
        public int						nAction;								// 0:脉冲 1:开始 2:停止
        public byte[]                	szName=new byte[128];                         	// 事件名称
        public double              		PTS;                                	// 时间戳(单位是毫秒)
        public NET_TIME_EX         		UTC;                                	// 事件发生的时间
        public int                		nEventID;                           	// 事件ID

        public byte[]					szTypes=new byte[MAX_COMMON_STRING_32];	// 异常类型
        public byte[]			    	byReserved=new byte[1024];			    // 预留字节
    } ;

    // 校准源信息
    public static class NET_REGULATOR_INFO extends SdkStructure
    {
        public int						nDistance;				// 校准源距离, 单位cm
        public int						nTemperature;			// 校准源温度, 精度0.1, 放大10倍
        public NET_RECT					stRect;					// 校准源矩形位置取值0-8191
        public int						nHeight;				// 校准源高度, 单位cm
        public int						nDiffTemperature;		// 温度偏差值, 精度0.01, 放大100倍
        public byte[]                   byReserve=new byte[32]; // 保留字节，用于字节对齐
    } ;

    // 人体测温标准黑体配置, 对应枚举 NET_EM_CFG_RADIO_REGULATOR
    public static class NET_CFG_RADIO_REGULATOR extends SdkStructure
    {
        public int                      dwSize;                 // 结构体大小
        public int					    bEnable;				// 标准黑体配置使能
        public int						nPresetId;				// 预置点编号, 对于无预置点设备为0
        public int						nCamerHeight;			// 热成像相机安装高度, 单位cm
        public int						nCamerAngle;			// 相机安装角度, 精度0.1, 放大10倍
        public NET_REGULATOR_INFO		stRegulatorInfo;		// 校准源信息

        public NET_CFG_RADIO_REGULATOR(){
            this.dwSize = this.size();
        }
    } ;

    // CLIENT_BatchAppendFaceRecognition 接口输入参数
    public static class NET_IN_BATCH_APPEND_FACERECONGNITION extends SdkStructure
    {
        public int                            dwSize;                      // 结构体大小
        public int                            nPersonNum;                  // 需要添加的人员数量
        public Pointer                        pstPersonInfo;               // 人员信息，内存由用户申请，大小为nPersonNum * sizeof(FACERECOGNITION_PERSON_INFOEX)

        // 图片二进制数据
        public Pointer                        pBuffer;                     // 缓冲地址
        public int                            nBufferLen;                  // 缓冲数据长度
        public byte[]                         bReserved=new byte[4];       // 字节对齐
        public NET_IN_BATCH_APPEND_FACERECONGNITION(){
            this.dwSize = this.size();
        }
    };

    // 批量添加人员结果信息
    public static class NET_BATCH_APPEND_PERSON_RESULT extends SdkStructure
    {
        public int               nUID;                                     // 人员UID
        public int               dwErrorCode;                              // 错误码信息
        public byte[]            bReserved=new byte[512];                  // 保留字段
    } ;

    // CLIENT_BatchAppendFaceRecognition 接口输出参数
    public static class NET_OUT_BATCH_APPEND_FACERECONGNITION extends SdkStructure
    {
        public int                             dwSize;                     // 结构体大小
        public int                             nResultNum;                 // 批量添加结果个数，由用户指定，数值与NET_IN_BATCH_APPEND_FACERECONGNITION中的nPersonNum一致
        /**
         * 内存大小为结构体数组的大小,对应结构体为{@link NET_BATCH_APPEND_PERSON_RESULT}
         */
        public Pointer                         pstResultInfo;              // 批量添加结果信息
        public NET_OUT_BATCH_APPEND_FACERECONGNITION(){
            this.dwSize = this.size();
        }
    };

    // 添加多个人员信息和人脸样本
    public Boolean CLIENT_BatchAppendFaceRecognition(LLong lLoginID, NET_IN_BATCH_APPEND_FACERECONGNITION pstInParam, NET_OUT_BATCH_APPEND_FACERECONGNITION pstOutParam, int nWaitTime);

    // CLIENT_FindFileEx+DH_FILE_QUERY_SNAPSHOT_WITH_MARK  对应查询参数
    public static class MEDIAFILE_SNAPSHORT_WITH_MARK_PARAM extends SdkStructure
    {
        public int               			dwSize;                			// 结构体大小
        public NET_TIME            			stuStartTime;           		// 开始时间
        public NET_TIME            			stuEndTime;             		// 结束时间
        public MEDIAFILE_SNAPSHORT_WITH_MARK_PARAM(){
            this.dwSize = this.size();
        }
    };

    // 抓图标记信息
    public static class NET_SNAPSHOT_MARK_INFO extends SdkStructure
    {
        public NET_POINT                       stuPosition;                    // 标记的坐标位置, 绝对坐标系
        public byte[]						   byReserved=new byte[1020];	   // 预留字段
    };

    // DH_FILE_QUERY_SNAPSHOT_WITH_MARK 对应 FINDNEXT 查询返回结果
    public static class MEDIAFILE_SNAPSHORT_WITH_MARK_INFO extends SdkStructure
    {
        public int               			dwSize;                			// 结构体大小
        public int                 			nChannelID;             		// 通道号从0开始,-1表示查询所有通道
        public NET_TIME            			stuStartTime;           		// 开始时间
        public NET_TIME            			stuEndTime;             		// 结束时间
        public int        					nFileSize;              		// 文件长度
        public byte[]                		szFilePath=new byte[MAX_PATH];  // 文件路径

        public NET_SNAPSHOT_MARK_INFO       stuMarkInfo;                    // 抓图标记信息
        public MEDIAFILE_SNAPSHORT_WITH_MARK_INFO(){
            this.dwSize = this.size();
        }
    } ;
    //////////////////////////////////////无人机航点功能开始///////////////////////////////////////////////////////////////////
    // 获取无人机航点入参
    public static class NET_IN_UAVMISSION_COUNT extends SdkStructure
    {
        public int               dwSize;
        public NET_IN_UAVMISSION_COUNT(){
            this.dwSize = this.size();
        }
    };

    // 获取无人机航点出参
    public static class NET_OUT_UAVMISSION_COUNT extends SdkStructure
    {
        public int               dwSize;
        public int               nCount; // 航点总数
        public NET_OUT_UAVMISSION_COUNT(){
            this.dwSize = this.size();
        }
    };

    // 获取任务入参
    public static class NET_IN_READ_UAVMISSION extends SdkStructure
    {
        public int                dwSize;
        public NET_IN_READ_UAVMISSION(){
            this.dwSize = this.size();
        }
    };

    // 航点任务
    public static class NET_UAVMISSION_ITEM extends SdkStructure
    {
        public int                     nCurrentMode;   // 使能状态 0-未使能; 1-使能;
        public int                     bAutoContinue;  // 自动执行下一个航点
        public int                     nSequence;      // 航点序号
        public int                     emCommand;      // 航点指令(参考ENUM_UAVCMD_TYPE)
        public NET_UAVCMD_PARAM_BUFFER stuCmdParam;    // 指令参数
        public byte[]                  byReserved=new byte[8];  // 保留字段
    };

    // 获取任务出参
    public static class NET_OUT_READ_UAVMISSION extends SdkStructure
    {
        public int                  dwSize;
        public int                  nItemCount;  // 有效任务个数
        public Pointer              pstuItems;   // 任务列表(参考NET_UAVMISSION_ITEM)
        public NET_OUT_READ_UAVMISSION(){
            this.dwSize = this.size();
        }
    };

    // 设置任务入参
    public static class NET_IN_WRITE_UAVMISSION extends SdkStructure
    {
        public int                 dwSize;
        public int                 nItemCount; // 有效任务个数
        public Pointer             pstuItems;  // 任务列表(参考NET_UAVMISSION_ITEM)
        public NET_IN_WRITE_UAVMISSION(){
            this.dwSize = this.size();
        }
    };

    // 设置任务出参
    public static class NET_OUT_WRITE_UAVMISSION extends SdkStructure
    {
        public int               dwSize;
        public NET_OUT_WRITE_UAVMISSION(){
            this.dwSize = this.size();
        }
    };

    // 订阅任务消息入参
    public static class NET_IN_ATTACH_UAVMISSION_STATE extends SdkStructure
    {
        public int                        dwSize;
        public fUAVMissionStateCallBack   cbNotify;	// 任务状态回调函数
        public Pointer                    dwUser;		// 用户信息
        public NET_IN_ATTACH_UAVMISSION_STATE(){
            this.dwSize = this.size();
        }
    };

    // 订阅任务消息出参
    public static class NET_OUT_ATTACH_UAVMISSION_STATE extends SdkStructure
    {
        public int					dwSize;							// 赋值为结构体大小
        public NET_OUT_ATTACH_UAVMISSION_STATE(){
            this.dwSize = this.size();
        }
    };

    // 任务状态类型
    public static class ENUM_UAVMISSION_TYPE extends SdkStructure
    {
        public static final int ENUM_UAVMISSION_TYPE_UNKNOWN=0;     // 未知类型
        public static final int ENUM_UAVMISSION_TYPE_WP_UPLOAD=1;   // 航点上传
        public static final int ENUM_UAVMISSION_TYPE_WP_DOWNLOAD=2; // 航点下载
    };

    // 任务状态
    public static class ENUM_UAVMISSION_STATE extends SdkStructure
    {
        public static final int ENUM_UAVMISSION_STATE_UNKNOWN=0;  // 未知类型
        public static final int ENUM_UAVMISSION_STATE_BEGIN=1;    // 开始
        public static final int ENUM_UAVMISSION_STATE_UNDERWAY=2; // 进行
        public static final int ENUM_UAVMISSION_STATE_SUCCESS=3;  // 成功
        public static final int ENUM_UAVMISSION_STATE_FAIL=4;     // 失败
    };

    // 任务状态信息
    public static class NET_UAVMISSION_STATE extends SdkStructure
    {
        public int                     emType;     // 类型(参见ENUM_UAVMISSION_TYPE枚举类型)
        public int                     emState;    // 状态(参见ENUM_UAVMISSION_STATE)
        public int                     nTotalCount; // 总数
        public int                     nSequence;  // 当前航点编号
    };

    // 无人机任务状态回调
    public interface fUAVMissionStateCallBack extends StdCallCallback {
        public void invoke(LLong lAttachHandle, NET_UAVMISSION_STATE pstuState, int dwStateInfoSize, Pointer dwUser);
    }

    // 无人机通用设置接口
    //emCmdType(参考ENUM_UAVCMD_TYPE枚举)
    //pParam对应ENUM_UAVCMD_TYPE所对应的结构体
    public boolean CLIENT_SendCommandToUAV(LLong lLoginID, int emCmdType, Pointer pParam, int nWaitTime);
    // 获取航点总数
    public boolean CLIENT_GetUAVMissonCount(LLong lLoginID, NET_IN_UAVMISSION_COUNT pstuInParam, NET_OUT_UAVMISSION_COUNT pstuOutParam, int nWaitTime);

    // 获取UAV航点信息
    public boolean CLIENT_ReadUAVMissions(LLong lLoginID, NET_IN_READ_UAVMISSION pstuInParam, NET_OUT_READ_UAVMISSION pstuOutParam, int nWaitTime);

    // 设置UAV航点信息
    public boolean CLIENT_WriteUAVMissions(LLong lLoginID, NET_IN_WRITE_UAVMISSION pstuInParam, NET_OUT_WRITE_UAVMISSION pstuOutParam, int nWaitTime);

    // 订阅UAV航点任务 pstuInParam 和 pstuOutParam 由设备申请释放
    public LLong CLIENT_AttachUAVMissonState(LLong lLoginID, NET_IN_ATTACH_UAVMISSION_STATE pstuInParam, NET_OUT_ATTACH_UAVMISSION_STATE pstuOutParam, int nWaitTime);

    // 退订UAV航点任务 lAttachHandle 是 CLIENT_AttachUAVMissonState 返回值
    public boolean CLIENT_DettachUAVMissonState(LLong lAttachHandle);
//////////////////////////////////////无人机航点功能结束///////////////////////////////////////////////////////////////////


    ////////////////////////////////////云上高速抓图起雾事件开始//////////////////////////////////////////
    // 起雾检测事件数据类型
    public static class EM_FOG_DETECTION_EVENT_TYPE
    {
        public static final int EM_FOG_DETECTION_EVENT_TYPE_UNKNOWN=0;					// 未知
        public static final int EM_FOG_DETECTION_EVENT_TYPE_REAL=1;						// 实时数据
        public static final int EM_FOG_DETECTION_EVENT_TYPE_ALARM=2;					// 报警数据
    };

    // 雾值
    public static class EM_FOG_LEVEL extends SdkStructure
    {
        public static final int EM_FOG_LEVEL_UNKNOWN=0;									// 未知
        public static final int EM_FOG_LEVEL_NO=1;										// 无
        public static final int EM_FOG_LEVEL_BLUE=2;									// 蓝色预警
        public static final int EM_FOG_LEVEL_YELLOW=3;									// 黄色预警
        public static final int EM_FOG_LEVEL_ORANGE=4;									// 橙色预警
        public static final int EM_FOG_LEVEL_RED=5;										// 红色预警
    };

    // 起雾检测事件雾信息
    public static class FOG_DETECTION_FOG_INFO extends SdkStructure
    {
        public int						emFogLevel;				   // 雾等级，参考EM_FOG_LEVEL
        public byte[]					byReserved=new byte[508];  // 预留字段
    };


    // 事件类型EVENT_IVS_FOG_DETECTION(起雾检测事件)对应的数据块描述信息
    public static class DEV_EVENT_FOG_DETECTION extends SdkStructure
    {
        public int									nChannelID;				// 通道号
        public int									nAction;				// 0:脉冲 1:开始 2:停止
        public byte[]								szName=new byte[128];	// 事件名称
        public double								PTS;					// 时间戳(单位是毫秒)
        public NET_TIME_EX							UTC;					// 事件发生的时间
        public int									nEventID;				// 事件ID
        public int						            emClassType;			// 智能事件所属大类，参考EM_CLASS_TYPE
        public int									nGroupID;				// 事件组ID，同一辆车抓拍过程内GroupID相同
        public int									nCountInGroup;			// 一个事件组内的抓拍张数
        public int									nIndexInGroup;			// 一个事件组内的抓拍序号
        public int									nPresetID;				// 预置点号，从1开始有效
        public byte[]								szPresetName=new byte[128];		// 阈值点名称
        public int			                        emEventType;			// 事件数据类型，参考EM_FOG_DETECTION_EVENT_TYPE
        public FOG_DETECTION_FOG_INFO				stuFogInfo;				// 雾信息
        public NET_EVENT_FILE_INFO					stFileInfo;				// 事件对应文件信息
        public byte[]								byReserved=new byte[1024];// 预留字段
    };
    ////////////////////////////////////云上高速抓图起雾事件开始//////////////////////////////////////////



    ////////////////////////////////////云上高速抓图开始//////////////////////////////////////////、

    // CLIENT_ManualSnap 接口输入参数
    public static class NET_IN_MANUAL_SNAP extends SdkStructure
    {
        public int            dwSize;             // 结构体大小
        public int            nChannel;           // 抓图通道号
        public int            nCmdSerial;         // 请求序列号
        public byte[]         szFilePath=new byte[260];    // 抓图保存路径

        public NET_IN_MANUAL_SNAP(){
            this.dwSize = this.size();
        }
    } ;

    // 抓图图片编码格式
    public static class EM_SNAP_ENCODE_TYPE extends SdkStructure
    {
        public static final int  EM_SNAP_ENCODE_TYPE_UNKNOWN=0;       // 未知
        public static final int  EM_SNAP_ENCODE_TYPE_JPEG=1;          // jpeg图片
        public static final int  EM_SNAP_ENCODE_TYPE_MPEG4_I=2;       // mpeg4的i 帧
    };

    // CLIENT_ManualSnap 接口输出参数
    public static class NET_OUT_MANUAL_SNAP extends SdkStructure
    {
        public int                     dwSize;             // 结构体大小
        public int                     nMaxBufLen;         // pRcvBuf的长度,由用户指定
        public Pointer                 pRcvBuf;            // 接收图片缓冲, 用于存放抓图数据, 空间由用户申请和释放, 申请大小为nMaxBufLen
        public int                     nRetBufLen;         // 实际接收到的图片大小
        public int                     emEncodeType;       // 图片编码格式,参考EM_SNAP_ENCODE_TYPE
        public int                     nCmdSerial;         // 请求序列号
        public byte[]                  bReserved=new byte[4];// 字节对齐
        public NET_OUT_MANUAL_SNAP(){
            this.dwSize = this.size();
        }
    } ;

    // 手动抓图, 支持并发调用
    public boolean CLIENT_ManualSnap(LLong lLoginID, NET_IN_MANUAL_SNAP pInParam, NET_OUT_MANUAL_SNAP pOutParam, int nWaitTime);

    // 订阅抓图回调信息
    public static class NET_CB_ATTACH_SNAP_INFO extends SdkStructure
    {
        public Pointer                pRcvBuf;                // 接收到的图片数据
        public int                    nBufLen;                // 图片数据长度
        public int                    emEncodeType;           // 图片编码格式,参考EM_SNAP_ENCODE_TYPE
        public int                    nCmdSerial;             // 抓图请求序列号
        public byte[]                 byReserved=new byte[1028];// 保留字节
    } ;

    // 订阅抓图回调函数原形
    public interface fAttachSnapRev extends StdCallCallback{
        public void invoke(LLong lAttachHandle, NET_CB_ATTACH_SNAP_INFO pstAttachCbInfo, Pointer dwUser);
    };

    // CLIENT_AttachSnap 接口输入参数
    public static class NET_IN_ATTACH_INTER_SNAP extends SdkStructure
    {
        public int            dwSize;             // 结构体大小
        public int            nChannel;           // 抓图通道号
        public int            nCmdSerial;         // 请求序列号
        public int            nIntervalSnap;      // 定时抓图时间间隔
        public fAttachSnapRev cbAttachSnapRev;    // 回调函数
        public Pointer        dwUser;             // 用户数据
        public NET_IN_ATTACH_INTER_SNAP(){
            this.dwSize = this.size();
        }
    } ;

    // CLIENT_AttachSnap 接口输出参数
    public static class NET_OUT_ATTACH_INTER_SNAP extends SdkStructure
    {
        public int           dwSize;             // 结构体大小
        public NET_OUT_ATTACH_INTER_SNAP(){
            this.dwSize = this.size();
        }
    } ;

    // 订阅抓图
    public LLong CLIENT_AttachSnap(LLong lLoginID, NET_IN_ATTACH_INTER_SNAP pInParam, NET_OUT_ATTACH_INTER_SNAP pOutParam);

    // 取消订阅抓图
    public boolean CLIENT_DetachSnap(LLong lAttachHandle);

    ////////////////////////////////////云上高速抓图结束//////////////////////////////////////////

    // 二维码上报事件信息( DH_ALARM_QR_CODE_CHECK )
    public static class ALARM_QR_CODE_CHECK_INFO extends SdkStructure
    {
        public int						nEventID;						// 事件ID
        public NET_TIME_EX		        UTC;							// 事件发生的时间
        public double					dbPTS;							// 时间戳(单位是毫秒)
        public byte[]                   szQRCode=new byte[256];         // 二维码字符串
        public byte[] 					byReserved=new byte[1024];	    // 预留字节
    };

    /************************************************************************/
    /*                            录像备份回传                                */
    /************************************************************************/

    // 录像备份恢复任务信息
    public static class NET_REC_BAK_RST_TASK extends SdkStructure
    {
        public int                 dwSize;
        public int                 nTaskID;                        // 任务ID
        public byte[]              szDeviceID=new byte[NET_DEV_ID_LEN_EX];   // 设备ID
        public int                 nChannelID;                     // 通道号
        public NET_TIME            stuStartTime;                   // 开始时间
        public NET_TIME            stuEndTime;                     // 结束时间
        public int                 nState;                         // 当前备份状态, 0-等待, 1-进行中, 2-完成, 3-失败

        public NET_REC_BAK_RST_TASK(){
            this.dwSize = this.size();
        }
    } ;


    // CLIENT_AddRecordBackupRestoreTask接口输入参数
    public static class NET_IN_ADD_REC_BAK_RST_TASK extends SdkStructure
    {
        public int                 dwSize;
        public Pointer             pszDeviceID;                    // 设备ID
        public Pointer             pnChannels;                     // 通道数组
        public int                 nChannelCount;                  // 通道数组大小,由用户申请内存,大小为sizeof(int)*nChannelCount
        public NET_TIME            stuStartTime;                   // 起始时间
        public NET_TIME            stuEndTime;                     // 结束时间

        public NET_IN_ADD_REC_BAK_RST_TASK(){
            this.dwSize = this.size();
        }
    } ;

    // CLIENT_RemoveRecordBackupRestoreTask接口输入参数
    public static class NET_IN_REMOVE_REC_BAK_RST_TASK extends SdkStructure
    {
        public int                 dwSize;
        public Pointer             pnTaskIDs;                      // 任务ID数组,由用户申请内存，大小为sizeof(int)*nTaskCount
        public int                 nTaskCount;                     // 任务数量

        public NET_IN_REMOVE_REC_BAK_RST_TASK(){
            this.dwSize = this.size();
        }
    } ;

    // CLIENT_QueryRecordBackupRestoreTask接口输入参数
    public static class NET_IN_QUERY_REC_BAK_RST_TASK extends SdkStructure
    {
        public int               dwSize;

        public NET_IN_QUERY_REC_BAK_RST_TASK(){
            this.dwSize = this.size();
        }
    } ;


    // CLIENT_QueryRecordBackupRestoreTask接口输出参数
    public static class NET_OUT_QUERY_REC_BAK_RST_TASK extends SdkStructure
    {
        public int                     dwSize;
        public Pointer                 pTasks;                     // 任务数组,由用户申请内存，大小为sizeof(NET_REC_BAK_RST_TASK)*nMaxCount
        public int                     nMaxCount;                  // 数组大小
        public int                     nReturnCount;               // 返回的任务数量
        public NET_OUT_QUERY_REC_BAK_RST_TASK(){
            this.dwSize = this.size();
        }
    } ;

    // 开始录像备份恢复
    public LLong  CLIENT_StartRecordBackupRestore(LLong lLoginID);

    // 停止录像备份恢复
    public void  CLIENT_StopRecordBackupRestore(LLong lRestoreID);

    // 添加录像备份恢复任务,pInParam内存由用户申请释放
    public boolean  CLIENT_AddRecordBackupRestoreTask(LLong lRestoreID, NET_IN_ADD_REC_BAK_RST_TASK pInParam, int nWaitTime);

    // 删除录像备份恢复任务,pInParam内存由用户申请释放
    public boolean  CLIENT_RemoveRecordBackupRestoreTask(LLong lRestoreID, NET_IN_REMOVE_REC_BAK_RST_TASK pInParam, int nWaitTime);

    // 获取录像备份恢复任务信息,pInParam与pOutParam内存由用户申请释放
    public boolean  CLIENT_QueryRecordBackupRestoreTask(LLong lRestoreID, NET_IN_QUERY_REC_BAK_RST_TASK pInParam, NET_OUT_QUERY_REC_BAK_RST_TASK pOutParam, int nWaitTime);

    // 导入配置文件(以JSON格式) pSendBuf: 待发送数据,用户分配内存, nSendBufLen: 待发送长度, reserved: 保留参数
    public boolean  CLIENT_ImportConfigFileJson(LLong lLoginID, Pointer pSendBuf, int nSendBufLen, Pointer reserved, int nWaitTime);

    // 导出配置文件(以JSON格式) pOutBuffer: 接收缓冲,用户分配内存, maxlen: 接收缓冲长度, nRetlen: 实际导出长度, reserved: 保留参数
    public boolean  CLIENT_ExportConfigFileJson(LLong lLoginID, Pointer pOutBuffer, int maxlen, IntByReference nRetlen, Pointer reserved, int nWaitTime);

    // web信息上传接口
    public boolean  CLIENT_TransmitInfoForWeb(LLong lLoginID, Pointer szInBuffer, int dwInBufferSize, Pointer szOutBuffer, int dwOutBufferSize, Pointer pExtData, int waittime);


    //================================================GIP200413016开始============================================
    // 线圈信息（主要是里面的车辆信息）
    public static class COILS_INFO extends SdkStructure
    {
        public int					nCarId;			//  车辆Id（不是车牌号，ID是设备检测到物体记录的编号)
        public byte[]				PlateNum=new byte[64];	//  车牌号
        public int			        emCarType;		//  车辆类型(參考EM_NET_CARTYPE)
        public byte[]				byReserved=new byte[1024];// 预留字节
    } ;

    // 车道信息
    public static class LANE_INFO extends SdkStructure
    {
        public int					nLane;					// 物理车道号（范围0~4）
        public int						nLaneType;				// 车道类型，虚线车道：0， 实线车道：1
        public double					dbLaneOcc;				// 车道空间占有率,范围[0.0~1.0]
        public int					nRoadwayNumber;			// 自定义车道号（范围0~128）
        public int						nCurrentLaneVehicleNum;	// 当前车道车的数量
        public int						nVehicleNum;			// 从上次统计结束到现在，通过车的辆数(设备0.5秒下发一次)
        public int					nCarId;					// 保留最近有效过车的ID（不是车牌号），CarId是设备检测到物体记录的编号
        public double					dbCarEnterTime;			// 编号CarId车辆进入虚线车道的时间
        public double					dbCarLeaveTime;			// 编号CarId车辆离开实线车道的时间
        public int					nCarDistance;			// 编号CarId车辆行驶的距离，单位：米
        public int						nQueueLen;				// 车辆等待时的排队长度，单位：米
        public double					dbCarSpeed;				// 编号CarId车辆平均车速，单位：米/秒
        public int						nCoilsInfoNum;			// 实际返回线圈信息个数
        public COILS_INFO[]				stuCoilsInfo=(COILS_INFO[])new COILS_INFO().toArray(70*2);	// 线圈信息（主要是线圈内的车辆信息）
        public int						nRetSolidLanNum;		// 实际返回虚线车道个数
        public int[]						nSolidLaneNum=new int[6];		// 虚线车道对应的实线车道自定义车道号
        public int						nVehicleNumByTypeNum;	// 实际返回车辆类型统计个数
        public int[]					nVehicleNumByType=new int[64];	// 类型车辆统计,数组下标对应不同车型（车型参考 EM_NET_CARTYPE），下标值对应车辆类型统计的数量
        public int						nEndLen;				// 车辆运行时，尾部车辆位置距离停车线的距离 ，单位：米
        public byte[]					byReserved=new byte[1024];		// 预留字节
    } ;

    // 交通态势事件（NET_ALARM_TRAFFIC_XINKONG）
    public static class ALARM_TRAFFIC_XINKONG_INFO extends SdkStructure
    {
        public int						nChannelID;				// 通道号
        public int						nAction;				// 只有一个事件动作0，表示脉冲事件
        public double                   dbPTS;					// 时间戳(单位是毫秒)
        public NET_TIME_EX              UTC;					// 事件发生的时间
        public int						nEventID;				// 事件ID

        public byte[]					szName=new byte[128];			// 事件名称
        public byte[]					byReserved1=new byte[4];			// 字节对齐
        public int						nLaneInfoNum;			// 实际上报多少车道信息
        public LANE_INFO[]				stuLaneInfo=(LANE_INFO[])new LANE_INFO().toArray(6);			// 车道信息
        public byte[]					byReserved=new byte[1024];		// 预留字节
    } ;

    //================================================GIP200413016结束============================================

    //================================================ERR200412034金鹰小学开始============================================

    // 同轴IO控制类型
    public static class EM_COAXIAL_CONTROL_IO_TYPE extends SdkStructure
    {
        public static final int EM_COAXIAL_CONTROL_IO_TYPE_UNKNOWN=0;				// 未知
        public static final int EM_COAXIAL_CONTROL_IO_TYPE_LIGHT=1;				// 白光灯
        public static final int EM_COAXIAL_CONTROL_IO_TYPE_SPEAKER=2;				// speak音频
    } ;

    // 同轴IO控制开关
    public static class EM_COAXIAL_CONTROL_IO_SWITCH extends SdkStructure
    {
        public static final int EM_COAXIAL_CONTROL_IO_SWITCH_UNKNOWN=0;			// 未知
        public static final int EM_COAXIAL_CONTROL_IO_SWITCH_OPEN=1;				// 开
        public static final int EM_COAXIAL_CONTROL_IO_SWITCH_CLOSE=2;				// 关
    } ;

    // 同轴IO触发方式
    public static class EM_COAXIAL_CONTROL_IO_TRIGGER_MODE extends SdkStructure
    {
        public static final int EM_COAXIAL_CONTROL_IO_TRIGGER_MODE_UNKNOWN=0;			// 未知
        public static final int EM_COAXIAL_CONTROL_IO_TRIGGER_MODE_LINKAGE_TRIGGER=1;	// 联动触发
        public static final int EM_COAXIAL_CONTROL_IO_TRIGGER_MODE_MANUAL_TRIGGER=2;	// 手动触发
    } ;


    // 同轴IO信息结构体
    public static class NET_COAXIAL_CONTROL_IO_INFO extends SdkStructure
    {
        public int			emType;				// 同轴IO控制类型参考EM_COAXIAL_CONTROL_IO_TYPE
        public int		    emSwicth;			// 同轴IO控制开关参考EM_COAXIAL_CONTROL_IO_SWITCH
        public int	        emMode;				// 同轴IO触发方式参考EM_COAXIAL_CONTROL_IO_TRIGGER_MODE
        public byte[]		byReserved=new byte[128];	// 保留字节
    } ;

    // 同轴IO信息最大个数
    public static final int  MAX_COAXIAL_CONTROL_IO_COUNT	=8;

    // 发送同轴IO控制命令, CLIENT_ControlDeviceEx 入参 对应 CTRLTYPE_CTRL_COAXIAL_CONTROL_IO
    public static class NET_IN_CONTROL_COAXIAL_CONTROL_IO extends SdkStructure
    {
        public int							    dwSize;									// 结构体大小
        public int								nChannel;								// 通道号
        public int								nInfoCount;								// 同轴IO信息个数
        public NET_COAXIAL_CONTROL_IO_INFO[]	stInfo=(NET_COAXIAL_CONTROL_IO_INFO[])new NET_COAXIAL_CONTROL_IO_INFO().toArray(MAX_COAXIAL_CONTROL_IO_COUNT);	// 同轴IO信息

        public NET_IN_CONTROL_COAXIAL_CONTROL_IO(){
            this.dwSize = this.size();
        }
    } ;

    // 发送同轴IO控制命令, CLIENT_ControlDeviceEx 出参 对应 CTRLTYPE_CTRL_COAXIAL_CONTROL_IO
    public static class NET_OUT_CONTROL_COAXIAL_CONTROL_IO extends SdkStructure
    {
        public int							dwSize;									// 结构体大小

        public NET_OUT_CONTROL_COAXIAL_CONTROL_IO(){
            this.dwSize = this.size();
        }
    } ;

    //================================================ERR200412034金鹰小学结束============================================

    //================================================ERR200410078-TASK1上海电科-智慧工地项目-DH-TPC-BF2221开始============================================

    // 火灾配置类型
    public static class NET_EM_FIREWARNING_MODE_TYPE extends SdkStructure
    {
        public static final int NET_EM_FIREWARNING_TYPE_PTZPRESET=0;		// 云台预置点模式（默认）
        public static final int NET_EM_FIREWARNING_TYPE_SPACEEXCLUDE=1;	    // 空间排除模式
    } ;

    // 火灾预警模式配置 NET_EM_CFG_FIRE_WARNINGMODE
    public static class NET_FIREWARNING_MODE_INFO extends SdkStructure
    {
        public int							dwSize;								// 结构体大小
        public int                         	emFireWarningMode;					// 火灾预警模式 参考NET_EM_FIREWARNING_MODE_TYPE

        public NET_FIREWARNING_MODE_INFO(){
            this.dwSize = this.size();
        }
    } ;

    public static final int  MAX_FIREWARNING_DETECTRGN_NUM			=32;			// 最大火警区域检测的个数
    public static final int  MAX_FIREWARNING_RULE_NUM				=32;			// 最大火警规则
    public static final int  MAX_FIREWARNING_DETECTWND_NUM			=8;			    // 最大火警检测窗口个数

    // 时间表信息
    public static class NET_CFG_TIME_SCHEDULE extends SdkStructure
    {
        public int                    bEnableHoliday;                                                 // 是否支持节假日配置，默认为不支持，除非获取配置后返回为TRUE，不要使能假日配置
        public NET_TSECT[]            stuTimeSection=(NET_TSECT[])new NET_TSECT().toArray(NET_N_SCHEDULE_TSECT*NET_N_REC_TSECT);            // 第一维前7个元素对应每周7天，第8个元素对应节假日，每天最多6个时间段
    } ;

    // 火灾预警联动项
    public static class NET_FIREWARN_EVENTHANDLE_INFO extends SdkStructure
    {
        public NET_CFG_TIME_SCHEDULE    stuTimeSection;										            // 报警时间段
        public int					    bRecordEnable;													// 录像使能，必须同时有RecordChannels。使能为TRUE，且事件action为start开始录像，stop停止录像。如果FALSE，则不做录像
        public int						nRecordChannelNum;												// 录像通道个数
        public int[]					nRecordChannels=new int[32];									// 录像通道号列表
        public int						nRecordLatch;													// 录像延时时间（单位：秒）范围[10,300]
        public int					    bAlarmOutEnable;												// 报警输出使能
        public int						nAlarmOutChannelNum;											// 报警输出通道个数
        public int[]					nAlarmOutChannels=new int[32];									// 报警输出通道号列表
        public int						nAlarmOutLatch;													// 报警输入停止后，输出延时时间（单位：秒）范围[10, 300]
        public int						nPtzLinkNum;													// 云台配置数
        public SDK_PTZ_LINK[]			struPtzLink=(SDK_PTZ_LINK[])new SDK_PTZ_LINK().toArray(16);												// 云台联动
        public int					    bPtzLinkEnable;													// 云台联动使能
        public int					    bSnapshotEnable;												// 快照使能
        public int						nSnapshotChannelNum;											// 快照通道个数
        public int[]					nSnapshotChannels=new int[32];									// 快照通道号列表
        public int					    bMailEnable;													// 发送邮件，如果有图片，作为附件
        public byte[]					byReserved=new byte[1024];										// 保留字节
    } ;

    public static class NET_POSTIONF extends SdkStructure
    {
        public float                fHorizontalAngle;               // 水平角度 [-1,1]
        public float                fVerticalAngle;                 // 垂直角度 [-1,1]
        public float                fMagnification;                 // 放大倍数 [-1,1]
    } ;

    // 火警检测窗口
    public static class NET_FIREWARN_DETECTWND_INFO extends SdkStructure
    {
        public int				nRgnNum;												// 检测区域的个数
        public byte[]           byReservedAlign=new byte[4];							// 保留字节
        public long[]			nRegions=new long[MAX_FIREWARNING_DETECTRGN_NUM];		// 检测区域
        public NET_POSTIONF	    stuPostion;												// 空间排除信息
        public int				nTargetSize;											// 目标的尺寸(火警配置为:Normal有效,单位：像素)
        public int				nSensitivity;											// 检测灵敏度（火警配置为:Normal有效）
        public int				nWindowsID;												// 窗口ID
        public byte[]			szName=new byte[32];									// 窗口名称
        public byte[]			byReserved=new byte[256];								// 保留字节
    } ;

    // 火灾预警规则信息
    public static class NET_FIREWARN_RULE_INFO extends SdkStructure
    {
        public int							    bEnable;								// 火灾预警功能是否开启
        public int								nPresetId;								// 预置点编号,火灾预警模式为预置点模式生效
        public int								nRow;									// 火灾检测区域的行数
        public int								nCol;									// 火灾检测区域的列数
        public int		                        emFireWarningDetectMode;		        // 火警检测模式 参考NET_EM_FIREWARNING_DETECTMODE_TYPE
        public int	                            emFireWarningDetectTragetType;	        // 火警检测目标类型 参考NET_EM_FIREWARNING_DETECTTARGET_TYPE
        public int 							    bTimeDurationEnable;					// 是否启用持续时间
        public int								nFireDuration;							// 观察火情持续时间，单位秒。水平旋转组检测火点时，为避免同一点重复检测，
        // 设置超时时间，超过此时间，跳过此点

        public NET_FIREWARN_EVENTHANDLE_INFO	stuEventHandler;						// 火警联动信息
        public int								nDetectWindowNum;						// 窗口个数
        public NET_FIREWARN_DETECTWND_INFO[]	stuDetectWnd=(NET_FIREWARN_DETECTWND_INFO[])new NET_FIREWARN_DETECTWND_INFO().toArray(MAX_FIREWARNING_DETECTWND_NUM); // 火警检测窗口
        public byte[]							byReserved=new byte[256];				// 保留字节
    } ;

    // 火灾预警配置(结构体较大，建议用New分配内存) NET_EM_CFG_FIRE_WARNING
    public static class NET_FIRE_WARNING_INFO extends SdkStructure
    {
        public int   							dwSize;																// 结构体大小
        public int								nFireWarnRuleNum;													// 火灾预警配置个数
        public NET_FIREWARN_RULE_INFO[]			stuFireWarnRule=(NET_FIREWARN_RULE_INFO[])new NET_FIREWARN_RULE_INFO().toArray(MAX_FIREWARNING_RULE_NUM);							// 火灾预警配置规则

        public NET_FIRE_WARNING_INFO(){
            this.dwSize = this.size();
        }
    } ;
    //================================================ERR200410078-TASK1上海电科-智慧工地项目-DH-TPC-BF2221结束============================================

    //================================================ERR200420018-TASK1IP8000-A事件Java接口封装开始============================================

    // 事件类型 EVENT_IVS_VIDEOABNORMALDETECTION(视频异常事件)对应的数据块描述信息
    public static class DEV_EVENT_VIDEOABNORMALDETECTION_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName=new byte[128];                       // 事件名称
        public byte[]              bReserved1=new byte[4];                     // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public NET_EVENT_FILE_INFO  stuFileInfo;                                // 事件对应文件信息
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte                bType;                                      // 异常类型, 255-无意义（通常是设备了返回错误值）0-视频丢失, 1-视频冻结, 2-摄像头遮挡, 3-摄像头移动, 4-过暗, 5-过亮, 6-图像偏色, 7-噪声干扰, 8-条纹检测
        public byte[]              byReserved=new byte[1];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public int                 nSourceIndex;                               // 事件源设备上的index,-1表示数据无效
        public byte[]              szSourceDevice=new byte[MAX_PATH];          // 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int                 nOccurrenceCount;                           // 事件触发累计次数
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
        public byte[]              bReserved=new byte[620];                    // 保留字节,留待扩展.
    } ;

    // 人员信息
    public static class NET_HUMAN extends SdkStructure
    {
        public NET_RECT            stuBoundingBox;				// 包围盒(8192坐标系)
        public int                 nObjectID;                   // 物体ID
        public byte[]              szSerialUUID=new byte[22];   // 智能物体全局唯一物体标识
        // 有效数据位21位，包含’\0’
        // 前2位%d%d:01-视频片段, 02-图片, 03-文件, 99-其他
        // 中间14位YYYYMMDDhhmmss:年月日时分秒
        // 后5位%u%u%u%u%u：物体ID，如00001
        public byte[]              bReserved=new byte[230];     // 保留字节
    };

    // 事件类型 EVENT_IVS_STAY_ALONE_DETECTION (单人独处事件) 对应的数据块描述信息
    public static class DEV_EVENT_STAY_ALONE_DETECTION_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public int				   nAction;							           // 0:脉冲 1:开始 2:停止
        public byte[]              szName=new byte[NET_EVENT_NAME_LEN];        // 事件名称
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public int	               emClassType;						           // 智能事件所属大类参考EM_CLASS_TYPE
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 UTCMS;                                      // UTC时间对应的毫秒数
        public int                 nEventID;                                   // 事件ID
        public NET_HUMAN           stuHuman;                                   // 人员信息
        public SCENE_IMAGE_INFO_EX stuSceneImage;                              // 全景图
        public int                 nDetectRegionNum;                           // 检测区域顶点数
        public DH_POINT[]          stuDetectRegion=(DH_POINT[])new DH_POINT().toArray(NET_MAX_DETECT_REGION_NUM);  // 检测区域
        public byte[]              byReserved=new byte[1024];                  // 保留字节
    };

    // 事件类型 EVENT_IVS_PRISONERRISEDETECTION (看守所囚犯起身事件) 对应的数据块描述信息
    public static class DEV_EVENT_PRISONERRISEDETECTION_INFO extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName=new byte[128];                       // 事件名称
        public byte[]              bReserved1=new byte[4];                     // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
        public int                 nDetectRegionNum;                           // 规则检测区域顶点数
        public DH_POINT[]          DetectRegion=(DH_POINT[])new DH_POINT().toArray(NET_MAX_DETECT_REGION_NUM);     // 规则检测区域
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public double              dInitialUTC;                                // 事件初始UTC时间    UTC为事件的UTC (1970-1-1 00:00:00)秒数。
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved=new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public int                 nSourceIndex;                               // 事件源设备上的index,-1表示数据无效
        public byte[]              szSourceDevice=new byte[MAX_PATH];          // 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int                 nOccurrenceCount;                           // 事件触发累计次数
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
        public byte[]              szSerialUUID=new byte[22];                  // 智能物体全局唯一物体标识
        // 有效数据位21位，包含’\0’
        // 前2位%d%d:01-视频片段, 02-图片, 03-文件, 99-其他
        // 中间14位YYYYMMDDhhmmss:年月日时分秒
        // 后5位%u%u%u%u%u：物体ID，如00001
        public byte[]              bReserved=new byte[594];                    // 保留字节,留待扩展.
    };
    //--------------------------------------------------------ERR200420018-TASK1IP8000-A事件Java接口封装结束------------------------------------------------------------------------//

    //--------------------------------------------------------ERR200424047吉利杭州1号站充换电站------------------------------------------------------------------------//

    // 逻辑屏显示内容
    public static class NET_TRAFFIC_LATTICE_SCREEN_SHOW_CONTENTS extends SdkStructure
    {
        public int	                        emContents;				        // 逻辑屏显示的内容：参考NET_EM_SCREEN_SHOW_CONTENTS
        public byte[]						byReserved1=new byte[4];		// 字节对齐
        public byte[]						szCustomStr=new byte[32];		// 自定义内容，emContents为	EM_TRAFFIC_LATTICE_SCREEN_CUSTOM 时有效
        public byte[]						byReserved=new byte[32];		// 预留
    };

    // 点阵屏显示信息
    public static class NET_TRAFFIC_LATTICE_SCREEN_SHOW_INFO extends SdkStructure
    {
        public NET_TRAFFIC_LATTICE_SCREEN_SHOW_CONTENTS[]	stuContents=(NET_TRAFFIC_LATTICE_SCREEN_SHOW_CONTENTS[])
                new NET_TRAFFIC_LATTICE_SCREEN_SHOW_CONTENTS().toArray(64);		            // 逻辑屏显示内容
        public int											nContentsNum;			        // 逻辑屏个数
        public byte[]										byReserved=new byte[1020];		// 预留
    };

    // 点阵屏显示信息配置, 对应枚举 NET_EM_CFG_TRAFFIC_LATTICE_SCREEN
    public static class NET_CFG_TRAFFIC_LATTICE_SCREEN_INFO extends SdkStructure
    {
        public int									dwSize;						// 结构体大小
        public int									nStatusChangeTime;			// 状态切换间隔，单位：秒,取值10 ~ 60
        public NET_TRAFFIC_LATTICE_SCREEN_SHOW_INFO	stuNormal;					// 常态下
        public NET_TRAFFIC_LATTICE_SCREEN_SHOW_INFO	stuCarPass;					// 过车时

        public NET_CFG_TRAFFIC_LATTICE_SCREEN_INFO(){
            this.dwSize = this.size();
        }
    };

    // 车位灯色
    public static class NET_PARKINGSPACELIGHT_INFO extends SdkStructure
    {
        public int						nRed;					// 红灯: -1:无效, 0/灭, 1/亮, 2/闪烁
        public int						nYellow;				// 黄灯: -1:无效, 0/灭, 1/亮, 2/闪烁
        public int						nBlue;					// 蓝灯: -1:无效, 0/灭, 1/亮, 2/闪烁
        public int						nGreen;					// 绿灯: -1:无效, 0/灭, 1/亮, 2/闪烁
        public int						nPurple;				// 紫灯: -1:无效, 0/灭, 1/亮, 2/闪烁
        public int						nWhite;					// 白灯: -1:无效, 0/灭, 1/亮, 2/闪烁
        public int						nPink;					// 粉等: -1:无效, 0/灭, 1/亮, 2/闪烁
        public byte[]					byReserved=new byte[32];// 保留字节

        public void setInfo(int nRed, int nYellow, int nBlue, int nGreen, int nPurple, int nWhite,int nPink) {
            this.nRed = nRed;
            this.nYellow = nYellow;
            this.nBlue = nBlue;
            this.nGreen = nGreen;
            this.nPurple = nPurple;
            this.nWhite = nWhite;
            this.nPink = nPink;
        }
    } ;

    // 网络异常状态灯色
    public static class NET_NETWORK_EXCEPTION_INFO extends SdkStructure
    {
        public NET_PARKINGSPACELIGHT_INFO[]  stNetPortAbortInfo=(NET_PARKINGSPACELIGHT_INFO[])
                new NET_PARKINGSPACELIGHT_INFO().toArray(5);	// 网口断开状态灯色
        public int							nRetNetPortAbortNum;					// 实际返回的个数
        public NET_PARKINGSPACELIGHT_INFO	stuSpaceSpecialInfo;					// 车位专用状态灯色
        public NET_PARKINGSPACELIGHT_INFO	stuSpaceChargingInfo;					// 充电车位状态灯色
        public byte[]						byReserved=new byte[256];						// 保留字节
    } ;


    // 车位状态对应的车位指示灯色 对应 NET_EM_CFG_PARKINGSPACELIGHT_STATE
    public static class NET_PARKINGSPACELIGHT_STATE_INFO extends SdkStructure
    {
        public int								    dwSize;
        public NET_PARKINGSPACELIGHT_INFO			stuSpaceFreeInfo;			// 车位空闲状态灯色
        public NET_PARKINGSPACELIGHT_INFO			stuSpaceFullInfo;			// 车位占满状态灯色
        public NET_PARKINGSPACELIGHT_INFO			stuSpaceOverLineInfo;		// 车位压线状态灯色
        public NET_PARKINGSPACELIGHT_INFO			stuSpaceOrderInfo;			// 车位预定状态灯色
        public NET_NETWORK_EXCEPTION_INFO			stuNetWorkExceptionInfo;	// 网络异常状态灯色

        public NET_PARKINGSPACELIGHT_STATE_INFO(){
            this.dwSize = this.size();
        }
    } ;

    // 车位监管状态
    public static class EM_CFG_LANE_STATUS extends SdkStructure
    {
        public static final int EM_CFG_LANE_STATUS_UNKOWN = -1;                     // 状态未知
        public static final int EM_CFG_LANE_STATUS_UNSUPERVISE = 0;                 // 不监管
        public static final int EM_CFG_LANE_STATUS_SUPERVISE = 1;                   // 监管
    };

    public static final int MAX_LANES_NUM               = 64 ;                  // 灯组监管车位的最多个数

    // 单个车位指示灯本机配置
    public static class CFG_PARKING_SPACE_LIGHT_GROUP_INFO extends SdkStructure
    {
        public int                 bEnable;                            // 为TRUE时该配置生效，为FALSE时该配置无效
        public int[]               emLaneStatus=new int[MAX_LANES_NUM];// 灯组监管的车位，下标表示车位号；参考EM_CFG_LANE_STATUS
        public int                 nLanesNum;                          // 有效的车位数量（可以设为监管或不监管的车位数量）
        public int                 bAcceptNetCtrl;                     // 是否接受远程控制
    };

    public static final int MAX_LIGHT_GROUP_INFO_NUM        = 8 ;                  // 车位指示灯本机配置的最多个数

    // 车位指示灯本机配置 CFG_CMD_PARKING_SPACE_LIGHT_GROUP
    public static class CFG_PARKING_SPACE_LIGHT_GROUP_INFO_ALL extends SdkStructure
    {
        public int                                         nCfgNum;                                // 获取到的配置个数
        public CFG_PARKING_SPACE_LIGHT_GROUP_INFO[]        stuLightGroupInfo=(CFG_PARKING_SPACE_LIGHT_GROUP_INFO[])
                new CFG_PARKING_SPACE_LIGHT_GROUP_INFO().toArray(MAX_LIGHT_GROUP_INFO_NUM);        // 车位指示灯本机配置
    };
    //--------------------------------------------------------ERR200424047吉利杭州1号站充换电站结束------------------------------------------------------------------------//

    //--------------------------------------------------------ERR200426006热成像相机SDK定制------------------------------------------------------------------------//
    // 灯光设备类型
    public static class EM_LIGHT_TYPE extends SdkStructure
    {
        public static final int EM_LIGHT_TYPE_UNKNOWN=0;                                      // 未知类型
        public static final int EM_LIGHT_TYPE_COMMLIGHT=1;                                    // 普通灯光
        public static final int EM_LIGHT_TYPE_LEVELLIGHT=2;                                   // 可调光
    };

    // 串口地址
    public static class CFG_COMMADDR_INFO extends SdkStructure
    {
        public int                 nAddressNum;                            // 串口地址个数
        public int[] 			   nAddress=new int[MAX_ADDRESS_NUM];      // 地址描述,不同厂商地址位不同，用数组表示
    };

    public static final int  MAX_ADDRESS_NUM                         =16;              // 最大串口地址个数
    public static final int  MAX_DEVICE_ID_LEN                       =48;              // 最大设备编码长度
    public static final int  MAX_DEVICE_MARK_LEN                     =64;              // 最大设备描述长度
    public static final int  MAX_BRAND_NAME_LEN                      =64;              // 最大设备品牌长度
    // 灯光设备配置信息 (对应 CFG_CMD_LIGHT )
    public static class CFG_LIGHT_INFO extends SdkStructure
    {
        public byte[]              szDeviceID=new byte[MAX_DEVICE_ID_LEN];          // 设备编码,惟一标识符
        public byte[]              szName=new byte[MAX_DEVICE_MARK_LEN];            // 设备描述
        public byte[]              szBrand=new byte[MAX_BRAND_NAME_LEN];            // 设备品牌
        public CFG_COMMADDR_INFO   stuCommAddr;                            // 串口地址
        public int                 nPositionID;                            // 设备在区域中编号
        public CFG_POLYGON         stuPosition;                            // 坐标
        public int                 nState;                                 // 设备状态: 1-打开,0-关闭
        public int                 nRange;                                 // 灯亮度幅度值 0-7 , emType 为 EM_LIGHT_TYPE_ADJUSTABLE 有意义
        public int                 emType;                                 // 灯光设备类型;参考EM_LIGHT_TYPE
    };

    // 近光灯信息
    public static class CFG_NEARLIGHT_INFO extends SdkStructure
    {
        public int                bEnable;                // 是否使能，TRUE使能，FALSE不使能
        public int               dwLightPercent;         // 灯光亮度百分比值(0~100)
        public int               dwAnglePercent;         // 灯光角度百分比值(0~100)
    };

    // 远光灯信息
    public static class CFG_FARLIGHT_INFO  extends SdkStructure
    {
        public int                bEnable;                // 是否使能，TRUE使能，FALSE不使能
        public int               dwLightPercent;         // 灯光亮度百分比值(0~100)
        public int               dwAnglePercent;         // 灯光角度百分比值(0~100)
    };

    public static final int  MAX_LIGHTING_NUM         =16;

    // 灯光设置详情
    public static class CFG_LIGHTING_DETAIL extends SdkStructure
    {
        public int                                 nCorrection;                     // 灯光补偿 (0~4) 倍率优先时有效
        public int                                 nSensitive;                      // 灯光灵敏度(0~5)倍率优先时有效，默认为3
        public int                                 emMode;                          // 灯光模式,参考EM_CFG_LIGHTING_MODE
        public int                                 nNearLight;                      // 近光灯有效个数
        public CFG_NEARLIGHT_INFO[]                stuNearLights=(CFG_NEARLIGHT_INFO[])
                new CFG_NEARLIGHT_INFO().toArray(MAX_LIGHTING_NUM);                 // 近光灯列表
        public int                                 nFarLight;                       // 远光灯有效个数
        public CFG_FARLIGHT_INFO[]                 stuFarLights=(CFG_FARLIGHT_INFO[])
                new CFG_FARLIGHT_INFO().toArray(MAX_LIGHTING_NUM);                  // 远光灯列表
    };


    // 灯光模式
    public static class EM_CFG_LIGHTING_MODE extends SdkStructure
    {
        public static final int EM_CFG_LIGHTING_MODE_UNKNOWN=0;               // 未知
        public static final int EM_CFG_LIGHTING_MODE_MANUAL=1;                // 手动
        public static final int EM_CFG_LIGHTING_MODE_ZOOMPRIO=2;              // 倍率优先
        public static final int EM_CFG_LIGHTING_MODE_TIMING=3;                // 定时模式
        public static final int EM_CFG_LIGHTING_MODE_AUTO=4;                  // 自动
        public static final int EM_CFG_LIGHTING_MODE_OFF=5;                   // 关闭模式
    };

    public static final int  MAX_LIGHTING_DETAIL_NUM  =16;

    // 灯光设置(对应 CFG_CMD_LIGHTING 命令)
    public static class CFG_LIGHTING_INFO extends SdkStructure
    {
        public int                         nLightingDetailNum;                         // 灯光设置有效个数
        public CFG_LIGHTING_DETAIL[]       stuLightingDetail=(CFG_LIGHTING_DETAIL[])
                new CFG_LIGHTING_DETAIL().toArray(MAX_LIGHTING_DETAIL_NUM); // 灯光设置信息列表
    };
    //--------------------------------------------------------ERR200426006热成像相机SDK定制结束------------------------------------------------------------------------//

    //--------------------------------------------------------ERR200427081SDK集成高空抛物功能开始------------------------------------------------------------------------//



    // 事件类型EVENT_IVS_HIGH_TOSS_DETECT(高空抛物检测事件)对应的数据块描述信息
    public static class DEV_EVENT_HIGH_TOSS_DETECT_INFO extends SdkStructure
    {
        /**
         *通道号
         */
        public int                         nChannelID;
        /**
         * 0:脉冲
         * 1:开始
         * 2:停止
         */
        public int                         nAction;
        /**
         * 事件名称
         */
        public byte[]                      szName=new byte[128];
        /**
         * 时间戳(单位是毫秒)
         */
        public double                      PTS;
        /**
         * 事件发生的时间
         */
        public NET_TIME_EX                 UTC;
        /**
         * 事件ID
         */
        public int                         nEventID;
        /**
         * 智能事件规则编号，用于标示哪个规则触发的事件
         */
        public int                         nRuleID;
        /**
         * 智能事件所属大类,枚举值参考{@link EM_CLASS_TYPE}
         */
        public int                         emClassType;
        /**
         * 物体信息
         */
        public NET_HIGHTOSS_OBJECT_INFO[]  stuObjInfos=(NET_HIGHTOSS_OBJECT_INFO[])
                new NET_HIGHTOSS_OBJECT_INFO().toArray(50);
        /**
         * 物体个数
         */
        public int                         nObjNum;
        /**
         * 检测区域顶点数
         */
        public int                         nDetectRegionNum;
        /**
         * 检测区域,[0,8192)
         */
        public NET_POINT[]                  stuDetectRegion=(NET_POINT[])new NET_POINT().toArray(NET_MAX_DETECT_REGION_NUM);
        /**
         * 视频分析帧序号
         */
        public int                         nFrameSequence;
        /**
         * 事件组ID, 同一物体抓拍过程内GroupID相同
         */
        public int                         nGroupID;
        /**
         * 抓拍序号，从1开始
         */
        public int                         nIndexInGroup;
        /**
         * 抓拍张数
         */
        public int                         nCountInGroup;
        /**
         * 图片信息
         */
        public NET_EVENT_IMAGE_OFFSET_INFO stuImageInfo;
        /**
         * 是否上传大图, true表示第一个图片为全景大图，信息由ImageInfo来表示
         */
        public boolean                        bIsGlobalScene;
        /**
         * 用于标记抓拍帧
         */
        public int                            nMark;
        /**
         * 预留字节
         */
        public byte[]                         byReserved=new byte[384];

        @Override
        public String toString() {
            return "DEV_EVENT_HIGH_TOSS_DETECT_INFO{" +
                    "通道号=" + nChannelID +
                    ", nAction=" + nAction +
                    ", 事件名称=" + new String(szName, Charset.forName("GBK")).trim() +
                    ", s事件戳=" + PTS +
                    ", 事件发生时间=" + UTC.toString() +
                    ", nEventID=" + nEventID +
                    ", 智能事件规则编号=" + nRuleID +
                    ", 智能事件所属大类=" + emClassType +
                    ", stuObjInfos=" + Arrays.toString(stuObjInfos) +
                    ", 物体个数=" + nObjNum +
                    ", 检测区域顶点数=" + nDetectRegionNum +
                    ", stuDetectRegion=" + Arrays.toString(stuDetectRegion) +
                    ", 帧序号=" + nFrameSequence +
                    ", 事件组ID=" + nGroupID +
                    ", 抓拍序号=" + nIndexInGroup +
                    ", 抓拍张数=" + nCountInGroup +
                    ", 图片信息=" + stuImageInfo +
                    ", 是否大图=" + bIsGlobalScene +
                    ", 标记抓拍帧=" + nMark +
                    '}';
        }
    }
    public static class NET_EVENT_IMAGE_OFFSET_INFO extends SdkStructure{
        /**
         * 偏移
         */
        public int     nOffSet;
        /**
         * 图片大小,单位字节
         */
        public int	   nLength;
        /**
         * 图片宽度
         */
        public int	   nWidth;
        /**
         * 图片高度
         */
        public int	   nHeight;
        /**
         * 图片路径
         */
        public byte[]  szPath=new byte[260];
        /**
         * 保留字节
         */
        public byte[]  byReserved=new byte[252];

        @Override
        public String toString() {
            return "NET_EVENT_IMAGE_OFFSET_INFO{" +
                    "nOffSet=" + nOffSet +
                    ", nLength=" + nLength +
                    ", nWidth=" + nWidth +
                    ", nHeight=" + nHeight +
                    ", szPath=" + new String(szPath,Charset.forName("GBK")) +
                    '}';
        }
    }

    // 高空抛物物体信息
    public static class NET_HIGHTOSS_OBJECT_INFO extends SdkStructure
    {
        public int                             nObjectID;              // 物体ID
        public int                             emObjAction;            // 物体动作类型;参考EM_HIGHTOSS_ACTION_TYPE
        public NET_RECT                        stuBoundingBox;         // 包围盒
        public int                             nConfidence;            // 置信度
        public int                             emObjectType;           // 物体类型;参考EM_ANALYSE_OBJECT_TYPE
        public NET_POINT                       stuCenter;              // 物体型心
        public NET_EVENT_IMAGE_OFFSET_INFO     stuImageInfo;           // 抓拍小图
        public byte[]                          byReserved=new byte[1516];// 预留字节 		// 预留字节

        @Override
        public String toString() {
            return "NET_HIGHTOSS_OBJECT_INFO{" +
                    "nObjectID=" + nObjectID +
                    ", 动作类型=" + emObjAction +
                    ", stuBoundingBox=" + stuBoundingBox +
                    ", 置信度=" + nConfidence +
                    ", 物体类型=" + emObjectType +
                    ",物体型心="+stuCenter +
                    ",抓拍小图="+stuImageInfo.toString()+
                    '}';
        }
    } ;

    // CLIENT_LoginWithHighLevelSecurity 输入参数
    public static class NET_IN_LOGIN_WITH_HIGHLEVEL_SECURITY extends SdkStructure
    {
        public int						    dwSize;				            // 结构体大小
        public byte[]						szIP=new byte[64];	            // IP
        public int							nPort;				            // 端口
        public byte[]						szUserName=new byte[64];		// 用户名
        public byte[]						szPassword=new byte[64];		// 密码
        public int		                    emSpecCap;			            // 登录模式
        public byte[]						byReserved=new byte[4];		    // 字节对齐
        public Pointer pCapParam;			            // 见 CLIENT_LoginEx 接口 pCapParam 与 nSpecCap 关系

        public NET_IN_LOGIN_WITH_HIGHLEVEL_SECURITY()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    // CLIENT_LoginWithHighLevelSecurity 输出参数
    public static class NET_OUT_LOGIN_WITH_HIGHLEVEL_SECURITY extends SdkStructure
    {
        public int						    dwSize;				            // 结构体大小
        public NET_DEVICEINFO_Ex			stuDeviceInfo;		            // 设备信息
        public int							nError;				            // 错误码，见 CLIENT_Login 接口错误码
        public byte[]						byReserved=new byte[132];	    // 预留字段

        public NET_OUT_LOGIN_WITH_HIGHLEVEL_SECURITY()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    // 高安全级别登陆
    public LLong CLIENT_LoginWithHighLevelSecurity(NET_IN_LOGIN_WITH_HIGHLEVEL_SECURITY pstInParam, NET_OUT_LOGIN_WITH_HIGHLEVEL_SECURITY pstOutParam);

    // GDPR使能全局开关
    public void	 CLIENT_SetGDPREnable(boolean bEnable);

    // 合成通道配置(对应CFG_CMD_COMPOSE_CHANNEL)
    public static class CFG_COMPOSE_CHANNEL extends SdkStructure
    {
        public int emSplitMode;			                                    // 分割模式,写入枚举值 枚举值在 CFG_SPLITMODE 类中定义，不要自己写
        public int[] nChannelCombination = new int[MAX_VIDEO_CHANNEL_NUM];  // 割模式下的各子窗口显示内容  最大 MAX_VIDEO_CHANNEL_NUM
        public int	 nChannelCount;		                                    // 分割窗口数量
    }

    // 画中画方案
    public static class CFG_PICINPIC_INFO extends SdkStructure
    {

        public      int        nMaxSplit;          // 内存申请的CFG_SPLIT_INFO个数,最大值通过CLIENT_GetSplitCaps接口获取，见nModeCount
        public      int        nReturnSplit;       // 解析得到实际使用的或封装发送的CFG_SPLIT_INFO个数
        public      Pointer    pSplits;           // 分割方案，指向 CFG_SPLIT_INFO
    }

    // 分割方案
    public static class CFG_SPLIT_INFO extends SdkStructure
    {
        public int        emSplitMode;        // CFG_SPLITMODE分割模式，通过CLIENT_GetSplitCaps接口获取，见emSplitMode
        public int        nMaxChannels;       // 申请内存CFG_SPLIT_CHANNEL_INFO个数, 比如有16个通道，nMaxChannels就是16，SPLITMODE_4模式，则按顺序依次分为4组
        public int        nReturnChannels;    // 解析返回通道个数,要封装发送的通道个数
        public Pointer    pSplitChannels;     // 分割通道信息,指向 CFG_SPLIT_CHANNEL_INFO
    }

    // 分割通道
    public static class CFG_SPLIT_CHANNEL_INFO extends SdkStructure
    {
        public int        bEnable;                      // 使能
        public byte[]     szDeviceID      =    new byte[AV_CFG_Device_ID_Len];    // 设备ID
        public int        nChannelID;					// 通道号(0开始)
        public int        nMaxSmallChannels;            // 小画面通道个数，每个通道一个CFG_SMALLPIC_INFO,这里最大应该是设备通道数减一
        public int        nReturnSmallChannels;         // 解析返回的或封装发送的小画面通道个数
        public Pointer    pPicInfo;                     // 小画面信息 CFG_SMALLPIC_INFO
    }

    // 司法审讯画中画需求
    // 小画面窗口信息
    public static class CFG_SMALLPIC_INFO extends SdkStructure
    {
        public byte[]              szDeviceID     =   new byte[AV_CFG_Device_ID_Len];   // 设备ID
        public int                 nChannelID;						   // 通道号(0开始)
        public int                 bAudio;                             // 大画面是否混合小画面音频
        public CFG_RECT            stuPosition;                        // 使用相对坐标体系，取值均为0-8192,在整个屏幕上的位置
    }

    //--------------------------------------------------------ERR200507125深圳交警-SDK增加java版本球机的空闲动作开始------------------------------------------------------------------------//
    // 空闲动作配置信息
    public static class CFG_IDLE_MOTION_INFO extends SdkStructure
    {
        public int                         bEnable;         // 使能
        public int                         nTime;           // 启动空闲动作的时间1~60分钟
        public int                         emFunction;      // 空闲动作功能,见枚举 EM_CFG_IDLEMOTION_FUNCTION
        public int                         nPresetId;       // 预置点编号,   范围参照CFG_PTZ_PROTOCOL_CAPS_INFO的wPresetMin和wPresetMax
        public int                         nScanId;         // 自动线扫编号, 范围参照CFG_PTZ_PROTOCOL_CAPS_INFO的wAutoScanMin和wAutoScanMax
        public int                         nTourId;         // 巡航编号,     范围参照CFG_PTZ_PROTOCOL_CAPS_INFO的wTourMin和wTourMax
        public int                         nPatternId;      // 自动巡迹编号, 范围参照CFG_PTZ_PROTOCOL_CAPS_INFO的wPatternMin和wPatternMax
        public int						   nSecond;		    // 启动空闲动作的时长（秒数）范围0-59秒,总时长为nTime * 60 + nSecond
    };

    //--------------------------------------------------------ERR200507125深圳交警-SDK增加java版本球机的空闲动作结束------------------------------------------------------------------------//

    //--------------------------------------------------------ERR200513038-TASK1相机RTMP对接腾讯云平台需求开始------------------------------------------------------------------------//


    // 每个通道的RTMP信息
    public static class NET_CHANNEL_RTMP_INFO extends SdkStructure
    {
        public int						    bEnable;				        // 是否使能
        public int							nChannel;				        // 通道号（URL中的Channel）
        public byte[]						szUrl=new byte[512];			// RTMP连接URL
        public byte[]						byReserved=new byte[1024];		// 预留字段
    };

    // RTMP 配置
    public static class NET_CFG_RTMP_INFO extends SdkStructure
    {
        public int 						dwSize;					// 结构体大小，赋值为sizeof(NET_CFG_RTMP_INFO)
        public int						bEnable;				// RTMP配置是否开启
        public byte[]					szAddr=new byte[256];	// RTMP服务器地址
        public int						nPort;					// RTMP服务器端口
        public byte[]					szCustomPath=new byte[256];		// 定制路径名
        public byte[]					szStreamPath=new byte[256];		// 码流路径前缀:不同通道以后缀数字区分
        public byte[]					szKey=new byte[128];	// 获取RTMP地址时的Key（定制）
        public Pointer           		pstuMainStream;			// 主码流信息，用户分配内存，内存大小为 sizeof(NET_CHANNEL_RTMP_INFO) * nMainStream
        public int						nMainStream;			// pstuMainStream 个数
        public int 						nMainStreamRet;			// 返回的 pstuMainStream 个数（获取配置时有效）
        public Pointer	             	pstuExtra1Stream;		// 辅码流1信息，用户分配内存，内存大小为 sizeof(NET_CHANNEL_RTMP_INFO) * nExtra1Stream
        public int						nExtra1Stream;			// pstuExtra1Stream 个数
        public int						nExtra1StreamRet;		// 返回的 nExtra1StreamRet 个数（获取配置时有效）
        public Pointer           		pstuExtra2Stream;		// 辅码流2信息，用户分配内存，内存大小为 sizeof(NET_CHANNEL_RTMP_INFO) * nExtra2Stream
        public int						nExtra2Stream;			// pstuExtra2Stream 个数
        public int						nExtra2StreamRet;		// 返回的 nExtra2StreamRet 个数（获取配置时有效）

        public NET_CFG_RTMP_INFO()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };
    //--------------------------------------------------------ERR200513038-TASK1相机RTMP对接腾讯云平台需求开始------------------------------------------------------------------------//
    //--------------------------------------------------------GIP200520016NETSDK 高速一体机视频质量诊断协议实现------------------------------------------------------------------------//



    // 轮询任务对象
    public static class NET_POLLING_INFO extends SdkStructure
    {
        public int                   emSourceType;                           // 数据源类型 参考EM_DATA_SOURCE_TYPE
        public Pointer               pSourceData;                            // 数据源信息, 根据emSouceType对应不一样的结构体
        public byte[]                szUserData=new byte[64];                // 视频源数据，标示视频源信息。在返回结果时，原封不动的带上。当任务的包含多个视频源时，attachResult每个视频源单独上报结果
        public byte[]                byReserved=new byte[256];               // 保留字节
    };

    // 接口输出参数
    public static class NET_IN_ADD_POLLING_ANALYSE_TASK extends SdkStructure
    {
        public int                  dwSize;                                 // 结构体大小
        public int                  nIntervalTime;                          // 每个视频源的检测执行时间，单位为秒，1~65535
        public int                  nLoopCount;                             // 诊断轮询次数, 0代表永久轮询
        public int                  nInfoCount;                             // 任务对象个数
        public Pointer              pInfoList;                              // 任务对象列表(参考NET_POLLING_INFO)

        public NET_IN_ADD_POLLING_ANALYSE_TASK()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    // 接口输出参数
    public static class NET_OUT_ADD_POLLING_ANALYSE_TASK extends SdkStructure
    {
        public int                           dwSize;                                 // 结构体大小
        public int                           nTaskID;                                // 任务ID

        public NET_OUT_ADD_POLLING_ANALYSE_TASK()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    public static class NET_IN_UPDATE_POLLING_ANALYSE_TASK extends SdkStructure
    {
        public int                             dwSize;                                 // 结构体大小
        public int                             nTaskID;                                // 任务ID
        public int                             nIntervalTime;                          // 每个视频源的检测执行时间，单位为秒，1~65535
        public int                             nLoopCount;                             // 诊断轮询次数, 0代表永久轮询
        public int                             nInfoCount;                             // 任务对象个数
        public int                             nReserved;                              // 字节对齐
        public Pointer                         pInfoList;                              // 任务对象列表(参考NET_POLLING_INFO)


        public NET_IN_UPDATE_POLLING_ANALYSE_TASK()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    // 接口输出参数
    public static class NET_OUT_UPDATE_POLLING_ANALYSE_TASK extends SdkStructure
    {
        public int                           dwSize;                                 // 结构体大小

        public NET_OUT_UPDATE_POLLING_ANALYSE_TASK()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };


    //获取剩余智能分析资源入参
    public static class NET_IN_REMAIN_ANAYLSE_RESOURCE extends SdkStructure
    {
        public int                           dwSize;                                         // 结构体大小

        public NET_IN_REMAIN_ANAYLSE_RESOURCE()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    //智能分析剩余能力具体信息
    public static class NET_REMAIN_ANALYSE_CAPACITY extends SdkStructure
    {
        public int                    nMaxStreamNum;                // 剩余能分析的视频流数目
        public int                    emClassType;                  // 大类业务方案(参考EM_SCENE_CLASS_TYPE)
        public byte[]                 byReserved=new byte[1024];    // 保留字节
    } ;

    //获取剩余智能分析资源出参
    public static class NET_OUT_REMAIN_ANAYLSE_RESOURCE extends SdkStructure
    {
        public int                             dwSize;                                          // 结构体大小
        public int                             nRetRemainCapNum;                                // 返回的能力格式
        public NET_REMAIN_ANALYSE_CAPACITY[]   stuRemainCapacities=
                (NET_REMAIN_ANALYSE_CAPACITY[])new NET_REMAIN_ANALYSE_CAPACITY().toArray(32);   // 智能分析剩余能力
        public NET_REMAIN_ANALYSE_TOTAL_CAPACITY[]    stuTotalCapacity=
                (NET_REMAIN_ANALYSE_TOTAL_CAPACITY[])new NET_REMAIN_ANALYSE_TOTAL_CAPACITY().toArray(32);                            //
        // 可供任务调度的总的智能能力

        public int                                 nTotalCapacityNum;
        public NET_OUT_REMAIN_ANAYLSE_RESOURCE()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    public static class NET_IN_REMOTEDEVICE_CAPS extends SdkStructure
    {
        public int						dwSize;															// 结构体大小
        //public byte[]                   szSubClassID=new byte[32];                                      // 空表示管理远程通道的设备列表                                                                                                // "EmbeddedPlatform": 表示管理嵌入式管理平台的设备管理器

        public NET_IN_REMOTEDEVICE_CAPS()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };

    public static class NET_OUT_REMOTEDEVICE_CAP extends SdkStructure
    {
        public int						dwSize;												       // 结构体大小
        public int                      nRetCount;                                                 // 返回的pnProtocal 有效个数
        public int[]                    snProtocal=new int[512];                                   // 协议类型 值同 EM_STREAM_PROTOCOL_TYPE

        public NET_OUT_REMOTEDEVICE_CAP()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };


    //算法独立升级能力
    public static class NET_ANALYSE_CAPS_SUPPORT_ALGORITHM_UPGRADE extends SdkStructure
    {
        public int                           dwSize;                                         // 结构体大小
        public int                           bSupportOnlyAlgorithmUpgrade;                   // 是否支持算法独立升级能力
        public int                           nMaxUpgradeAINum;                               // AI 方案最大个数, 由用户指定,  最大支持128
        public int                           nRetUpgradeAINum;                               // 实际返回的AI 方案个数, 即pstUpgradeAIInfo 数组的有效元素个数
        /**
         * 指针内传入结构体数组,结构体为{@link NET_ALGORITHM_UPGRADE_AI_INFO}
         */
        public Pointer                       pstUpgradeAIInfo;                              // 独立算法升级支持的AI方案信息, 内存由用户申请和释放, 申请大小sizeof(NET_ALGORITHM_UPGRADE_AI_INFO)*nMaxUpgradeAINum
        public int                            nRetStorageNum;                                 // 实际返回的设备分区个数, 即stuStorageInfo 数组的有效元素个数
        public NET_ALGORITHM_DEV_STORAGE_INFO[]  stuStorageInfos=(NET_ALGORITHM_DEV_STORAGE_INFO[])new NET_ALGORITHM_DEV_STORAGE_INFO().toArray(16);                            // 设备的分区信息
        public NET_ALGORITHM_BUILD_INFO        stuBuildInfo;                                   // 算法构建信息
        public NET_ANALYSE_CAPS_SUPPORT_ALGORITHM_UPGRADE()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    } ;

    //智能分析总能力
    public static class NET_TOTAL_CAP extends SdkStructure
    {
        public int             emClassType;                                // 业务大类(参考EM_SCENE_CLASS_TYPE)
        public int[]           dwRuleTypes=new int[MAX_ANALYSE_RULE_COUNT];        // 规则类型, 详见dhnetsdk.h中"智能分析事件类型"
        public int             nRuleNum;                                   // 规则数量
        public int             nMaxStreamNum;                              // 最多支持同时分析的视频流数目
        public byte[]          byReserved=new byte[1024];                           // 保留字节
    } ;

    //智能分析的总能力
    public static class NET_ANALYSE_CAPS_TOTAL extends SdkStructure
    {
        public int                           dwSize;                                         // 结构体大小
        public NET_TOTAL_CAP[]               stuTotalCaps=(NET_TOTAL_CAP[])new NET_TOTAL_CAP().toArray(MAX_ANALYSE_TOTALCAPS_NUM);        // 智能分析总能力
        public int                           nTotalCapsNum;                                  // 智能分析总能力个数

        public NET_ANALYSE_CAPS_TOTAL()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    } ;

    // 算法版本信息
    public static class NET_ALGORITHM_INFO extends SdkStructure
    {
        public int             emClassType;                        // 业务大类(参考EM_SCENE_CLASS_TYPE)
        public byte[]          szVersion=new byte[NET_COMMON_STRING_32];     // 算法版本
        public int             emAlgorithmVendor;                  // 算法厂商(参考EM_ALGORITHM_VENDOR)
        public byte[]          szAlgorithmLibVersion=new byte[NET_COMMON_STRING_32];  // 算法库文件版本
        public byte[]          byReserved=new byte[992];                   // 保留字节
    } ;

    //智能分析的算法版本信息
    public static class NET_ANALYSE_CAPS_ALGORITHM extends SdkStructure
    {
        public int                           dwSize;                                         // 结构体大小
        public NET_ALGORITHM_INFO[]          stuAlgorithmInfos=(NET_ALGORITHM_INFO[])new NET_ALGORITHM_INFO().toArray(MAX_ANALYSE_ALGORITHM_NUM);   // 算法版本信息
        public int                           nAlgorithmNum;                                  // 算法个数

        public NET_ANALYSE_CAPS_ALGORITHM()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    } ;

    // 智能分析服务能力类型
    public static class EM_ANALYSE_CAPS_TYPE extends SdkStructure
    {
        public static final int  EM_ANALYSE_CAPS_ALGORITHM = 1;         // 算法版本, 对应输出结构体 NET_ANALYSE_CAPS_ALGORITHM
        public static final int  EM_ANALYSE_CAPS_TOTALCAPS = 2;          // 智能分析总能力, 对应输出结构体 NET_ANALYSE_CAPS_TOTAL
        public static final int  EM_ANALYSE_CAPS_SUPPORT_ALGORITHM_UPGRADE = 3;  // 算法独立升级能力, 对应输出结构体 NET_ANALYSE_CAPS_SUPPORT_ALGORITHM_UPGRADE
    };

    //CLIENT_SetAnalyseTaskCustomData 接口输入参数
    public static class NET_IN_SET_ANALYSE_TASK_CUSTOM_DATA extends SdkStructure
    {
        public int                           dwSize;                                 // 结构体大小
        public int                            nTaskID;                                // 任务ID
        public NET_TASK_CUSTOM_DATA            stuTaskCustomData;                      // 自定义数据

        public NET_IN_SET_ANALYSE_TASK_CUSTOM_DATA()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    } ;


    //CLIENT_SetAnalyseTaskCustomData 接口输出参数
    public static class NET_OUT_SET_ANALYSE_TASK_CUSTOM_DATA extends SdkStructure
    {
        public int                           dwSize;                                 // 结构体大小


        public NET_OUT_SET_ANALYSE_TASK_CUSTOM_DATA()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    } ;

    // 获取视频分析服务智能能力集, pstOutParam根据emCapsType的值取对应的结构体(参考EM_ANALYSE_CAPS_TYPE), pstOutParam 资源由用户申请和释放
    public boolean  CLIENT_GetAnalyseCaps(LLong lLoginID, int emCapsType, Pointer pOutParam, int nWaitTime);

    // 添加轮询检测任务 (入参NET_IN_ADD_POLLING_ANALYSE_TASK，出参NET_OUT_ADD_POLLING_ANALYSE_TASK)
    public boolean  CLIENT_AddPollingAnalyseTask(LLong lLoginID, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    // 更新轮询检测任务规则(入参NET_IN_UPDATE_POLLING_ANALYSE_TASK，出参NET_OUT_UPDATE_POLLING_ANALYSE_TASK)
    public boolean  CLIENT_UpdatePollingAnalyseTask(LLong lLoginID, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    // 获取剩余智能分析资源(入参NET_IN_REMAIN_ANAYLSE_RESOURCE，出参NET_OUT_REMAIN_ANAYLSE_RESOURCE)
    public boolean  CLIENT_GetRemainAnalyseResource(LLong lLoginID, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    // 设置任务的自定义数据(入参NET_IN_SET_ANALYSE_TASK_CUSTOM_DATA,出参NET_OUT_SET_ANALYSE_TASK_CUSTOM_DATA)
    public boolean  CLIENT_SetAnalyseTaskCustomData(LLong lLoginID, Pointer pInParam, Pointer pOutParam,  int nWaitTime);

    public static class NET_VIDEOABNORMALDETECTION_RULE_INFO extends SdkStructure {
        /**
         * 最短持续时间	单位：秒，0~65535
         */
        public int					    nMinDuration;
        /**
         * 灵敏度, 取值1-10，值越小灵敏度越低(只对检测类型视频遮挡，过亮，过暗，场景变化有效)
         */
        public int                     nSensitivity;

        /**
         * 检测类型数
         */
        public int                     nDetectType;
        public int                     nReserved;
        /**
         * 异常检测阈值,范围1~100
         */
        public int[]					nThreshold=new int[32];
        /**
         * 检测类型,0-视频丢失, 1-视频遮挡, 2-画面冻结, 3-过亮, 4-过暗, 5-场景变化
         * 6-条纹检测 , 7-噪声检测 , 8-偏色检测 , 9-视频模糊检测 , 10-对比度异常检测
         * 11-视频运动 , 12-视频闪烁 , 13-视频颜色 , 14-虚焦检测 , 15-过曝检测, 16-场景巨变
         */

        public byte[]                  bDetectType=new byte[32];
        /**
         * 保留字节
         */
        public byte[]				    byReserved=new byte[4096];

    }
    //--------------------------------------------------------ERR200529144浙江石油智慧加油站项目------------------------------------------------------------------------//
    // 热度图灰度数据
    public static class NET_CB_HEATMAP_GRAY_INFO extends SdkStructure
    {
        public int                    nWidth;                 // 图片宽度
        public int                    nHeight;                // 图片高度
        public NET_TIME                stuStartTime;           // 开始时间
        public NET_TIME                stuEndTime;             // 结束时间
        public int                    nMax;                   // 最大值
        public int                    nMin;                   // 最小值
        public int                    nAverage;               // 平均值
        public int                    nLength;                // 灰度图数据长度
        public Pointer                   pGrayInfo;              // 灰度图数据
        public byte[]                    byReserved=new byte[512];        // 保留字节
    } ;


    // 热度图灰度数据回调函数, lAttachHandle 为 CLIENT_AttachHeatMapGrayInfo 返回的结果(pstGrayInfo参考NET_CB_HEATMAP_GRAY_INFO)
    public interface fHeatMapGrayCallBack extends StdCallCallback{
        public void invoke(LLong lAttachHandle, Pointer pstGrayInfo, Pointer dwUser);
    }
    // CLIENT_AttachHeatMapGrayInfo 接口输入参数
    public static class NET_IN_GRAY_ATTACH_INFO extends SdkStructure
    {
        public int                   dwSize;                         // 结构体大小
        public int                    nChannelID;                    // 通道号
        public fHeatMapGrayCallBack    cbHeatMapGray;                  // 热度图灰度数据回调函数
        public Pointer                  dwUser;                         // 用户信息

        public NET_IN_GRAY_ATTACH_INFO()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    } ;

    // CLIENT_AttachHeatMapGrayInfo接口输出参数
    public static class NET_OUT_GRAY_ATTACH_INFO extends SdkStructure
    {
        public int                   dwSize;                            // 结构体大小

        public NET_OUT_GRAY_ATTACH_INFO()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    } ;


    // 订阅热度图灰度数据接口,pInParam与pOutParam内存由用户申请释放(pInParam参考NET_IN_GRAY_ATTACH_INFO,pOutParam参考NET_OUT_GRAY_ATTACH_INFO)
    public LLong  CLIENT_AttachHeatMapGrayInfo(LLong lLoginID, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    // 退订热度图灰度数据
    public boolean  CLIENT_DetachHeatMapGrayInfo(LLong lAttachHandle);

    // 事件类型EVENT_IVS_RETROGRADEDETECTION(人员逆行事件)对应的数据块描述信息
    public static class DEV_EVENT_RETROGRADEDETECTION_INFO  extends SdkStructure
    {
        public int                 nChannelID;                                 // 通道号
        public byte[]              szName=new byte[128];                       // 事件名称
        public byte[]              bReserved1=new byte[4];                     // 字节对齐
        public double              PTS;                                        // 时间戳(单位是毫秒)
        public NET_TIME_EX         UTC;                                        // 事件发生的时间
        public int                 nEventID;                                   // 事件ID
        public DH_MSG_OBJECT       stuObject;                                  // 检测到的物体
        public int                 nTrackLineNum;                              // 物体运动轨迹顶点数
        public DH_POINT[]          TrackLine=(DH_POINT[])new DH_POINT().toArray(NET_MAX_TRACK_LINE_NUM);           // 物体运动轨迹
        public int                 nDirectionPointNum;                         // 规则里规定的方向顶点数
        public DH_POINT[]          stuDirections=(DH_POINT[])new DH_POINT().toArray(NET_MAX_DETECT_LINE_NUM);      // 规则里规定的方向
        public int                 nDetectRegionNum;                           // 规则检测区域顶点数
        public DH_POINT[]          DetectRegion=(DH_POINT[])new DH_POINT().toArray(NET_MAX_DETECT_REGION_NUM);     // 规则检测区域
        public NET_EVENT_FILE_INFO stuFileInfo;                                // 事件对应文件信息
        public byte                bEventAction;                               // 事件动作,0表示脉冲事件,1表示持续性事件开始,2表示持续性事件结束;
        public byte[]              byReserved=new byte[2];
        public byte                byImageIndex;                               // 图片的序号, 同一时间内(精确到秒)可能有多张图片, 从0开始
        public int                 dwSnapFlagMask;                             // 抓图标志(按位),具体见NET_RESERVED_COMMON
        public int                 nSourceIndex;                               // 事件源设备上的index,-1表示数据无效
        public byte[]              szSourceDevice=new byte[MAX_PATH];          // 事件源设备唯一标识,字段不存在或者为空表示本地设备
        public int                 nOccurrenceCount;                           // 事件触发累计次数
        public EVENT_INTELLI_COMM_INFO     stuIntelliCommInfo;                 // 智能事件公共信息
        public byte[]              bReserved=new byte[616];                    // 保留字节,留待扩展.
    } ;

    public static final int  NET_MAX_PLATEENABLE_NUM		= 16;      // 最大使能过车车牌播报个数
    public static final int  NET_MAX_BROADCAST_ELEMENT_NUM	= 64;      // 最大语音播报元素个数

    // 智能交通语音播报配置 对应枚举 NET_EM_CFG_TRAFFIC_VOICE_BROADCAST
    public static class NET_CFG_TRAFFIC_VOICE_BROADCAST_INFO  extends SdkStructure
    {
        public int									dwSize;								         // 结构体大小
        public int									nEnableCount;                                // 使能播报个数
        public int[]			                    emEnable=new int[NET_MAX_PLATEENABLE_NUM];   // 使能过车车牌播报,见枚举 NET_EM_PLATEENABLE_TYPE
        public byte[]								szNormalCar=new byte[MAX_PATH];              // 普通车辆过车播报内容,例如:播报语音文件"欢迎光临.wav"
        public byte[]								szTrustCar=new byte[MAX_PATH];               // 信任车辆过车播报内容,例如:播报语音文件"欢迎光临.wav"
        public byte[]								szSuspiciousCar=new byte[MAX_PATH];          // 嫌疑车辆过车播报内容,例如:播报语音文件"非注册车辆.wav"
        public NET_TRAFFIC_VOICE_BROADCAST_ELEMENT[] stuElement=(NET_TRAFFIC_VOICE_BROADCAST_ELEMENT[])new  NET_TRAFFIC_VOICE_BROADCAST_ELEMENT().toArray(NET_MAX_BROADCAST_ELEMENT_NUM);	 // 播报元素
        public int									nElementNum;						         // stuElement中有效数据个数

        public NET_CFG_TRAFFIC_VOICE_BROADCAST_INFO()
        {
            this.dwSize = this.size();
        }// 此结构体大小
    };


    // 播报元素
    public static class NET_TRAFFIC_VOICE_BROADCAST_ELEMENT  extends SdkStructure
    {
        public int	                    emType;		                // 类型(参考NET_EM_VOICE_BROADCAST_ELEMENT_TYPE)
        public byte[]					byReserved1=new byte[4];	// 字节对齐
        public byte[]					szPrefix=new byte[512];		// 前缀字符串
        public byte[]					szPostfix=new byte[512];	// 后缀字符串
        public byte[]					byReserved=new byte[1024];	// 预留
    };


    // 485串口协议设备配置信息
    public static class NET_CFG_DHRS_INFO  extends SdkStructure
    {
        public int                             nDeviceNum;                     // 串口设备个数
        public NET_CFG_DHRS_DEVICE_INFO[]      stuDHRSDeviceInfo=(NET_CFG_DHRS_DEVICE_INFO[])new NET_CFG_DHRS_DEVICE_INFO().toArray(32);          // 串口设备信息
        
    };

    public static class NET_CFG_DHRS_DEVICE_INFO extends SdkStructure
    {
        public int                            bEnable;                        // 串口设备是否启用
        public int                            emType;                         // 串口设备类型(参考EM_DHRS_DEVICE_TYPE)
        public NET_CFG_LATTICE_SCREEN_CONFIG  stuLatticeScreenConfig;         // 485串口点阵屏配置
        public byte[]                         byReserved=new byte[4096];      //预留字节
    } ;

    // 485串口点阵屏配置
    public static class NET_CFG_LATTICE_SCREEN_CONFIG extends SdkStructure
    {
        public int                             nAddress;                       // 配置对应设备的地址, 范围[1,31]
        public int                             emRollSpeedLevel;               // 点阵屏滚动速度级别(参考EM_ROLL_SPEED_LEVEL)
        public int                             nLogicScreenNum;                // 逻辑屏个数
        public NET_LOGIC_SCREEN[]              stuLogicScreens=(NET_LOGIC_SCREEN[])new NET_LOGIC_SCREEN().toArray(8);             // 逻辑屏信息, 划分物理屏的某一区域为逻辑屏
        public int                             nOutPutVoiceVolume;             // 语音播报音量大小, 范围：[0 - 100]
        public int                             nOutPutVoiceSpeed;              // 语音播报速度， 范围：[0-100]
        public byte[]                          byReserved=new byte[1024];
    } ;

    // 串口设备类型
    public static class EM_DHRS_DEVICE_TYPE extends SdkStructure
    {
        public static final int  EM_DHRS_DEVICE_TYPE_UNKNOWN =0;                // 未知
        public static final int  EM_DHRS_DEVICE_TYPE_STEADYLIGHT =1;            // 常亮灯
        public static final int  EM_DHRS_DEVICE_TYPE_STROBELIGHT =2;            // 可以通过485控制的频闪灯
        public static final int  EM_DHRS_DEVICE_TYPE_POWERMODULE =3;            // 电源模块
        public static final int  EM_DHRS_DEVICE_TYPE_LATTICESCREEN =4;          // 点阵屏
        public static final int  EM_DHRS_DEVICE_TYPE_INDICATORLIGHT =5;         // 指示灯
        public static final int  EM_DHRS_DEVICE_TYPE_RAINBRUSH =6;              // 雨刷洗涤模块
        public static final int  EM_DHRS_DEVICE_TYPE_FLASHLAMP =7;              // 爆闪灯
        public static final int  EM_DHRS_DEVICE_TYPE_RFID =8;                   // 射频识别
        public static final int  EM_DHRS_DEVICE_TYPE_COMMON =9;                 // 通用485
    } ;

    // 逻辑屏信息
    public static class NET_LOGIC_SCREEN extends SdkStructure
    {
        public NET_RECT                         stuRegion;         // 逻辑屏区域, 实际点阵屏坐标
        public int                              emDisplayMode;     // 显示动作(参考EM_DISPLAY_MODE)
        public int                              emDisplayColor;    // 显示颜色(参考EM_DISPLAY_COLOR)
        public byte[]                           byReserved = new byte[512];   // 预留字节
    } ;

    // 点阵屏滚动速度级别
    public static class EM_ROLL_SPEED_LEVEL extends SdkStructure
    {
        public static final int  EM_ROLL_SPEED_LEVEL_UNKNOWN =0;                        // 未知
        public static final int  EM_ROLL_SPEED_LEVEL_SLOW =1;                           // 慢
        public static final int  EM_ROLL_SPEED_LEVEL_SLOWER =2;                         // 较慢
        public static final int  EM_ROLL_SPEED_LEVEL_MEDIUM =3;                         // 中等
        public static final int  EM_ROLL_SPEED_LEVEL_FASTER =4;                         // 较快
        public static final int  EM_ROLL_SPEED_LEVEL_FAST =5;                           // 快
    } ;

    // 显示动作
    public static class EM_DISPLAY_MODE extends SdkStructure
    {
        public static final int EM_DISPLAY_MODE_UNKNOWN =0;                            // 未知
        public static final int EM_DISPLAY_MODE_ROLL =1;                               // 滚动
        public static final int EM_DISPLAY_MODE_INTERCEPT =2;                          // 截取
    } ;

    // 显示颜色
    public static class EM_DISPLAY_COLOR extends SdkStructure
    {
        public static final int  EM_DISPLAY_COLOR_UNKNOWN =0;                           // 未知
        public static final int  EM_DISPLAY_COLOR_RED =1;                               // 红
        public static final int  EM_DISPLAY_COLOR_GREEN =2;                             // 绿
        public static final int  EM_DISPLAY_COLOR_YELLOW =3;                            // 黄
    }

    public static class NET_FACEANALYSIS_RULE_INFO extends SdkStructure {
        public int                          dwSize;                             	                // 结构体大小
        public int							nDetectRegionPoint;						                // 检测区顶点数
        public POINTCOORDINATE[]		    stuDetectRegion = new POINTCOORDINATE[20];              // 检测区
        public int                 		    nSensitivity;                                           // 灵敏度,范围[1,10],灵敏度越高越容易检测
        public int							nLinkGroupNum;							                // 联动布控个数
        public NET_CFG_LINKGROUP_INFO[]		stuLinkGroup = new NET_CFG_LINKGROUP_INFO[20];	        // 联动的布控组
        public NET_CFG_STRANGERMODE_INFO	stuStrangerMode;						                // 陌生人布防模式
        public boolean                		bSizeFileter;                                           // 规则特定的尺寸过滤器是否有效
        public NET_CFG_SIZEFILTER_INFO      stuSizeFileter;                                          // 规则特定的尺寸过滤器
        public boolean						bFeatureEnable;							                // 是否开启人脸属性识别, IPC增加
        public int							nFaceFeatureNum;						                // 需要检测的人脸属性个数
        public int[] 	                    emFaceFeatureType = new int[32];	                    // 需检测的人脸属性 NET_EM_FACEFEATURE_TYPE
        public boolean						bFeatureFilter;							                // 在人脸属性开启前提下，如果人脸图像质量太差，是否不上报属性
        // true-图像太差不上报属性 false-图像很差也上报属性(可能会非常不准，影响用户体验)
        public int							nMinQuality;							                // 人脸图片质量阈值,和bFeatureFilter一起使用 范围[1,100]

        public NET_FACEANALYSIS_RULE_INFO(){
            for(int i = 0; i < stuDetectRegion.length; i++ ){
                stuDetectRegion[i] = new POINTCOORDINATE();
            }
            for(int i = 0; i < stuLinkGroup.length; i++){
                stuLinkGroup[i] = new NET_CFG_LINKGROUP_INFO();
            }
            dwSize  =   this.size();
        }

    }

    // 联动的布控组
    public static class NET_CFG_LINKGROUP_INFO extends SdkStructure {
        public boolean 					bEnable;							// 布控组是否启用
        public byte[]					szGroupID = new byte[64];			// 布控组ID
        public byte                		bySimilarity;                       // 相似度阈值 1-100
        public byte[]					bReserved1 = new byte[3];			// 字节对齐
        public byte[]					szColorName = new byte[32];			// 事件触发时绘制人脸框的颜色
        public boolean 					bShowTitle;							// 事件触发时规则框上是否显示报警标题
        public boolean 					bShowPlate;							// 事件触发时是否显示比对面板
        public NET_ALARM_MSG_HANDLE 	stuEventHandler;					// 报警联动
        public byte[]					bReserved = new byte[512];			// 保留字段
    }

    // 陌生人布防模式
    public static class NET_CFG_STRANGERMODE_INFO extends SdkStructure {
        public boolean 					bEnable;							// 模式是否启用
        public byte[]					szColorHex = new byte[8];			// 事件触发时绘制人脸框的颜色
        public boolean 					bShowTitle;							// 事件触发时规则框上是否显示报警标题
        public boolean 					bShowPlate;							// 事件触发时是否显示比对面板
        public NET_ALARM_MSG_HANDLE 	stuEventHandler;					// 报警联动
        public byte[]					bReserved = new byte[512];			// 保留字段
    }

    // 人脸属性类型
    public static class NET_EM_FACEFEATURE_TYPE
    {
        public final static int NET_EM_FACEFEATURE_UNKNOWN = 0;		// 未知
        public final static int NET_EM_FACEFEATURE_SEX = 1;			// 性别
        public final static int NET_EM_FACEFEATURE_AGE = 2;			// 年龄
        public final static int NET_EM_FACEFEATURE_EMOTION = 3;		// 表情
        public final static int NET_EM_FACEFEATURE_GLASSES = 4;		// 眼镜状态
        public final static int NET_EM_FACEFEATURE_RACE = 5;
        public final static int NET_EM_FACEFEATURE_EYE = 6;			// 眼睛状态
        public final static int NET_EM_FACEFEATURE_MOUTH = 7;		    // 嘴巴状态
        public final static int NET_EM_FACEFEATURE_MASK = 8;		    // 口罩状态
        public final static int NET_EM_FACEFEATURE_BEARD = 9;		    // 胡子状态
        public final static int NET_EM_FACEFEATURE_ATTRACTIVE = 10;	// 魅力值
    }

    // 事件类型EM_ANALYSE_EVENT_FEATURE_ABSTRACT(特征提取)对应的数据块描述信息
    public static class DEV_EVENT_FEATURE_ABSTRACT_INFO extends SdkStructure
    {
        public int                 			nChannelID;                         		                // 通道号
        public int							nAction;									                // 0:脉冲 1:开始 2:停止
        public int                          emClassType;                           		                // 智能事件所属大类 EM_CLASS_TYPE
        public int                          nFeatureNum;                                                // 特征值数量
        public NET_FEATURE_VECTOR_INFO[]    stuFeatureVectorList = new NET_FEATURE_VECTOR_INFO[10];     // 特征值数组，同一个图片需要进行多个版本的特征向量提取，在一个事件中返回
        public byte[]			    		byReserved = new byte[1024];			        		    // 预留字节

        public DEV_EVENT_FEATURE_ABSTRACT_INFO(){
            for(int i=0;i<stuFeatureVectorList.length;i++){
                stuFeatureVectorList[i] = new NET_FEATURE_VECTOR_INFO();
            }
        }
    }

    // 特征值信息
    public static class NET_FEATURE_VECTOR_INFO extends SdkStructure
    {
        public byte[]                          szFeatureVersion = new byte[32];   // 特征版本版本号
        public int                             emFeatureErrCode;                  // 特征建模失败错误码 EM_FEATURE_ERROR_CODE
        public NET_FEATURE_VECTOR              stuFeatureVector;                  // 特征值的偏移和大小信息
        public NET_FACE_ATTRIBUTES             stuFaceAttribute;                  // 人脸属性 ,当提取人脸特征向量成功时上报
        public byte[]			    		   byReserved = new byte[968];	       // 预留字节
    }

    // 特征建模失败错误码
    public static class EM_FEATURE_ERROR_CODE
    {
        public final static int EM_FEATURE_ERROR_SUCCESS = 0;		                // 成功
        public final static int EM_FEATURE_ERROR_UNKNOWN = 1;		                // 未知
        public final static int EM_FEATURE_ERROR_IMAGE_FORMAT_ERROR = 2;		    // 图片格式问题
        public final static int EM_FEATURE_ERROR_NOFACE_OR_NOTCLEAR =3;	            // 无人脸或不够清晰
        public final static int EM_FEATURE_ERROR_MULT_FACES = 4;            		// 多个人脸
        public final static int EM_FEATURE_ERROR_IMAGH_DECODE_FAILED = 5;	    	// 图片解码失败
        public final static int EM_FEATURE_ERROR_NOT_SUGGEST_STORAGE = 6;	        // 不推荐入库
        public final static int EM_FEATURE_ERROR_DATABASE_OPERATE_FAILED = 7;		// 数据库操作失败
        public final static int EM_FEATURE_ERROR_GET_IMAGE_FAILED = 8;		        // 获取图片失败
        public final static int EM_FEATURE_ERROR_SYSTEM_EXCEPTION = 9;	            // 系统异常（如Licence失效、建模分析器未启动导致的失败）
    }

    // 人脸属性
    public static class NET_FACE_ATTRIBUTES  extends SdkStructure
    {
        public int[]                           nAngle = new int[3];                // 人脸抓拍角度,三个角度分别是：仰俯角,偏航角,翻滚角；默认值[999,999,999]表示无此数据
        public int                             nFaceQuality;                       // 人脸抓拍质量分数,取值范围 0~10000
        public int                             nFaceAlignScore;                    // 人脸对齐得分分数,取值范围 0~10000，-1为无效值
        public byte[]			    		   byReserved = new byte[36];	        // 预留字节
    }

    // 事件类型EVENT_IVS_FEATURE_ABSTRACT(提取特征)对应的规则配置
    public static class NET_FEATURE_ABSTRACT_RULE_INFO  extends SdkStructure
    {
        public int                     dwSize;                     // 结构体大小
        public int                     nFeature;                   // 特征的数量
        public NET_FEATURE_ABSTRACT_VERSION[]                szFeatureVersions = new NET_FEATURE_ABSTRACT_VERSION[10];  // 对图片进行特征向量提取时使用，需要对图片进行同一种特征向量多个版本进行提取,最大是10个版本
        public int                     emAbstractType;            // 进行特征提取的类型 EM_FEATURE_ABSTRACT_TYPE
        public NET_FEATURE_ABSTRACT_RULE_INFO(){
            for(int i = 0;i<szFeatureVersions.length;i++){
                szFeatureVersions[i] = new NET_FEATURE_ABSTRACT_VERSION();
            }
            this.dwSize = this.size();
        }
    }

    public static class NET_FEATURE_ABSTRACT_VERSION extends SdkStructure
    {
        public byte[] szFeatureVersion = new byte[32];
    }

    // 进行特征提取的类型
    public static class EM_FEATURE_ABSTRACT_TYPE
    {
        public final static int EM_FEATURE_ABSTRACT_UNKNOWN = -1;      // 未知
        public final static int EM_FEATURE_ABSTRACT_FACE = 0;             // 人脸
        public final static int EM_FEATURE_ABSTRACT_HUMAN_TRAIT = 1;       // 人体
        public final static int EM_FEATURE_ABSTRACT_VEHICLE = 2;           // 机动车
        public final static int EM_FEATURE_ABSTRACT_NON_MOTOR_VEHICLE = 3; // 非机动车
    }

    public static class ALARM_TRAFFIC_PARKING_TIMEOUT_INFO extends SdkStructure
    {
        public int                 	nChannelID;                         	// 通道号
        public int					nAction;								// 0:脉冲 1:开始 2:停止
        public NET_TIME_EX         	UTC;                                	// 事件发生的时间
        public NET_TIME				stuInParkTime;							// 进场时间
        public NET_TIME				stuOutParkTime;							// 出场时间
        public int					nParkingTime;							// 停车时长，单位秒
        public byte[]			    byReserved = new byte[1024];			// 预留字节
        public DEV_EVENT_TRAFFIC_TRAFFICCAR_INFO	stuTrafficCar;			// 交通车辆的数据库记录
    }

    // 嫌疑车辆上报事件, 对应事件类型 DH_ALARM_TRAFFIC_SUSPICIOUSCAR
    public static class ALARM_TRAFFIC_SUSPICIOUSCAR_INFO extends SdkStructure
    {
        public int                     dwSize;
        public int                     nAction;                        // 事件动作, -1:未知,0:Start, 1:Stop, 2:Pulse
        public DH_MSG_OBJECT           stuVehicle;                     // 车身信息
        public NET_TRAFFIC_LIST_RECORD stuCarInfo;                     // 车辆的黑名单信息
        public EVENT_COMM_INFO         stCommInfo;                     // 公共信息
        public ALARM_TRAFFIC_SUSPICIOUSCAR_INFO(){
            this.dwSize = this.size();
        }
    }

    // 事件类型 DH_ALARM_PARKING_LOT_STATUS_DETECTION (室外停车位状态检测事件) 对应的数据块描述信息
    public static class ALARM_PARKING_LOT_STATUS_DETECTION extends SdkStructure
    {
        public int                         nChannelID;                                 // 通道号
        public int                         nAction;                                    // 1:开始 2:停止
        public byte[]                      szName = new byte[128];                     // 事件名称
        public int                         emClassType;                                // 智能事件所属大类 EM_CLASS_TYPE
        public NET_TIME_EX                 UTC;                                        // 事件发生的时间
        public double                      PTS;                                        // 时间戳(单位是毫秒)
        public int                         nEventID;                                   // 事件ID
        public int                         nRuleID;                                    // 智能事件规则编号，用于标示哪个规则触发的事件
        public int                         nSequence;                                  // 帧序号
        public int                         nParkingStatusNum;                          // 室外停车位个数
        public NET_PARKING_STATUS[]        stuParkingStatus = new NET_PARKING_STATUS[100]; // 室外停车位状态
        public byte[]                      byReserved = new byte[1020];                 // 预留字节
        public ALARM_PARKING_LOT_STATUS_DETECTION(){
            for(int i = 0;i<stuParkingStatus.length;i++){
                stuParkingStatus[i] = new NET_PARKING_STATUS();
            }
        }
    }

    // 室外停车位状态
    public static class NET_PARKING_STATUS extends SdkStructure
    {
        public byte[]                             szName = new byte[32];                                               // 车位名称
        public int                                nID;                                                      // 车位ID，范围:[0,99]
        public int                                nParkedNumber;                                            // 车位内已停车位数量，范围:[0,255]
        public int                                emChangeStatus;                                           // 车位内已停车位数量相对上次上报的变化状态 EM_PARKING_NUMBER_CHANGE_STATUS
        public byte[]                             reserved = new byte[252];                                            // 预留字节
    }

    // 车位内已停车位数量相对上次上报的变化状态
    public static class EM_PARKING_NUMBER_CHANGE_STATUS
    {
        public final static int EM_PARKING_NUMBER_CHANGE_STATUS_UNKNOWN = -1;               // 未知
        public final static int EM_PARKING_NUMBER_CHANGE_STATUS_NO_CHANGE = 0;              // 无变化
        public final static int EM_PARKING_NUMBER_CHANGE_STATUS_INCREASE = 1;               // 数量增加
        public final static int EM_PARKING_NUMBER_CHANGE_STATUS_DECREASE = 2;               // 数量减少
    }

    // 停车超时检测配置
    public static class NET_CFG_PARKING_TIMEOUT_DETECT extends SdkStructure
    {
        public int            dwSize;                 // 结构体大小
        public int            bEnable;                // 是否使能停车超时检测
        public int            nParkingTime;           // 可停车时长, 单位为秒, 默认值为604800. 范围:3600-604800, 超过指定时长则判断为超时停车
        public NET_CFG_PARKING_TIMEOUT_DETECT(){
            this.dwSize = this.size();
        }
    }

    // CLIENT_RemoveParkingCarInfo 接口输入参数
    public static class NET_IN_REMOVE_PARKING_CAR_INFO extends SdkStructure
    {
        public int                        dwSize;                                    // 结构体大小
        public DEV_OCCUPIED_WARNING_INFO  stuParkingCarInfo;                         // 车位信息
        public NET_IN_REMOVE_PARKING_CAR_INFO(){
            this.dwSize = this.size();
        }
    }

    // CLIENT_RemoveParkingCarInfo 接口输出参数
    public static class NET_OUT_REMOVE_PARKING_CAR_INFO extends SdkStructure
    {
        public int                      dwSize;                                    // 结构体大小
        public NET_OUT_REMOVE_PARKING_CAR_INFO(){
            this.dwSize = this.size();
        }
    }

  //对应CLIENT_StartSearchDevicesEx接口
    public static class DEVICE_NET_INFO_EX2 extends SdkStructure
    {
    	public DEVICE_NET_INFO_EX  stuDevInfo;                             // 设备信息结构体						
    	public byte[]                szLocalIP=new byte[64];            // 搜索到设备的本地IP地址
    	public byte[]                cReserved=new byte[2048];                        // 扩展字段
    };
    
    // 异步搜索设备回调(pDevNetInfo内存由SDK内部申请释放, 参考DEVICE_NET_INFO_EX2)
    public interface fSearchDevicesCBEx extends StdCallCallback {
        public void invoke(LLong lSearchHandle, Pointer pDevNetInfo, Pointer pUserData);
    }

    // 异步搜索设备(参考NET_IN_STARTSERACH_DEVICE,NET_OUT_STARTSERACH_DEVICE)
    public LLong  CLIENT_StartSearchDevicesEx(Pointer pInBuf, Pointer pOutBuf);

    // 同步跨网段搜索设备IP (pIpSearchInfo内存由用户申请释放)
    // szLocalIp为本地IP，可不做输入, fSearchDevicesCB回调
    // 接口调用1次只发送搜索信令1次
    public boolean CLIENT_SearchDevicesByIPs(DEVICE_IP_SEARCH_INFO pIpSearchInfo, Callback cbSearchDevices, Pointer dwUserData, String szLocalIp, int dwWaitTime);

    
    /**
     *
     * @param lLoginID
     * @param pInParam
     * @param pOutParam
     * @param nWaitTime
     * @return boolean
     */
    public boolean CLIENT_AsyncAddCustomDevice(LLong lLoginID, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    /***
     *
     * @param lLoginID
     * @param nChannelID
     * @param dwFocusCommand
     * @param nFocus
     * @param nZoom
     * @param reserved
     * @param waittime
     * @return
     * 镜头聚焦控制  dwFocusCommand = 0
     * 为聚焦调节dwFocusCommand = 1
     * 为连续聚焦调节dwFocusCommand = 2,为自动聚焦调节,调节焦点至最佳位置。nFocus和nZoom无效。
     */
    public boolean CLIENT_FocusControl(LLong lLoginID, int nChannelID, int dwFocusCommand, double nFocus, double nZoom, Pointer reserved , int waittime);

    //事件类型 EVENT_IVS_TUMBLE_DETECTION(倒地报警事件)对应数据块描述信息
    public static class DEV_EVENT_TUMBLE_DETECTION_INFO extends SdkStructure
    {
        public int                     nChannelID;                             // 通道号
        public byte[]                  szName = new byte[NET_EVENT_NAME_LEN];  // 事件名称
        public int					   nAction;								   // 事件动作,1表示持续性事件开始,2表示持续性事件结束;
        public double                  PTS;                                    // 时间戳(单位是毫秒)
        public NET_TIME_EX             UTC;                                    // 事件发生的时间
        public int                     nEventID;                               // 事件ID
        public int					   UTCMS;								   // UTC时间对应的毫秒数

        public int		               emClassType;							    // 智能事件所属大类 EM_CLASS_TYPE
        public int					   nObjectID;								// 目标ID
        public byte[]				   szObjectType = new byte[NET_COMMON_STRING_16];// 物体类型,支持以下:
        //"Unknown", "Human", "Vehicle", "Fire", "Smoke", "Plate", "HumanFace",
        // "Container", "Animal", "TrafficLight", "PastePaper", "HumanHead", "BulletHole", "Entity"
        public NET_RECT				   stuBoundingBox;							// 物体包围盒
        public byte[]                  szSerialUUID = new byte[22];     // 智能物体全局唯一物体标识
        // 有效数据位21位，包含’\0’
        // 前2位%d%d:01-视频片段, 02-图片, 03-文件, 99-其他
        // 中间14位YYYYMMDDhhmmss:年月日时分秒
        // 后5位%u%u%u%u%u：物体ID，如00001
        public byte[]                  bReserved = new byte[1002];  // 保留字节
    }

    /**
     * 设置二维码信息
     * @param lLoginID 登录句柄
     * @param pInParam 入参,对应结构体{@link com.cf.forward.dh.lib.structure.NET_IN_SET_2DCODE}
     * @param pOutParam 出参,对应结构体{@link com.cf.forward.dh.lib.structure.NET_OUT_SET_2DCODE}
     * @param nWaitTime 超时时间
     * @return
     */
    public boolean CLIENT_Set2DCode(LLong lLoginID, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    /**
     * 订阅热度图数据,pInParam与pOutParam内存由用户申请释放
     * @param lLoginID 登录句柄
     * @param pInParam 入参,对应结构体 {@link com.cf.forward.dh.lib.structure.NET_IN_ATTACH_VIDEOSTAT_HEATMAP}
     * @Param pOutParam 出参,对应结构体{@link com.cf.forward.dh.lib.structure.NET_OUT_ATTACH_VIDEOSTAT_HEATMAP}
     * 也可使用{@link com.cf.forward.dh.lib.structure.EmptyStructure}
     * @param nWaitTime 超时时间
     * @return
     */
    public  LLong CLIENT_AttachVideoStatHeatMap(LLong lLoginID, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    /**
     * 获取热图数据,pInParam与pOutParam内存由用户申请释放
     * @param lAttachHandle 热度图订阅句柄
     * @param pInParam 入参,对应结构体 {@link com.cf.forward.dh.lib.structure.NET_IN_GET_VIDEOSTAT_HEATMAP}
     * @param pOutParam 出参,对应结构体{@link com.cf.forward.dh.lib.structure.NET_OUT_GET_VIDEOSTAT_HEATMAP}
     * @param nWaitTime 超时时间
     * @return
     */
    public boolean CLIENT_GetVideoStatHeatMap(LLong lAttachHandle, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    /**
     * 取消订阅热度图数据
     * @param lAttachHandle 订阅句柄
     * @return
     */
    public boolean CLIENT_DetachVideoStatHeatMap(LLong lAttachHandle);
    //

    /**
     *
     * @param lLoginID
     * @param pstInParam
     *
     * @param nWaitTime = NET_INTERFACE_DEFAULT_TIMEOUT
     * @return
     */
    /**
     * 计算两张人脸图片的相似度faceRecognitionServer.matchTwoFace,pstInParam与pstOutParam内存由用户申请释放
     * @param lLoginID 登录句柄
     * @param pstInParam 入参 {@link com.cf.forward.dh.lib.structure.NET_MATCH_TWO_FACE_IN}
     * @param pstOutParam 出参{@link com.cf.forward.dh.lib.structure.NET_MATCH_TWO_FACE_OUT}
     * @param nWaitTime 接口超时时间,默认超时时间为3000
     * @return
     */
    public boolean CLIENT_MatchTwoFaceImage(LLong lLoginID, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);



    /**
     * 设置相机参数, pInParam 和pOutParam 资源由用户申请和释放
     * @param lLoginID 登录句柄
     * @param pInParam 入参 {@link com.cf.forward.dh.lib.structure.NET_IN_SET_CAMERA_CFG}
     * @param pOutParam 出参{@link com.cf.forward.dh.lib.structure.NET_OUT_SET_CAMERA_CFG}
     * @param nWaitTime
     * @return
     */
    public boolean CLIENT_SetCameraCfg(LLong lLoginID, Pointer pInParam,Pointer pOutParam, int nWaitTime);


    /**
     * 获取相机参数, pInParam 和pOutParam 资源由用户申请和释放
     * @param lLoginID 登录句柄
     * @param pInParam 入参 {@link com.cf.forward.dh.lib.structure.NET_IN_GET_CAMERA_CFG}
     * @param pOutParam 出参{@link com.cf.forward.dh.lib.structure.NET_OUT_GET_CAMERA_CFG}
     * @param nWaitTime
     * @return
     */
    public boolean CLIENT_GetCameraCfg(LLong lLoginID, Pointer pInParam,Pointer pOutParam, int nWaitTime);


    /**
     * 设置通道参数, pInParam 和pOutParam 资源由用户申请和释放
     * @param lLoginID 登录句柄
     * @param pInParam 入参 {@link com.cf.forward.dh.lib.structure.NET_IN_SET_CHANNEL_CFG}
     * @param pOutParam 出参{@link com.cf.forward.dh.lib.structure.NET_OUT_SET_CHANNEL_CFG}
     * @param nWaitTime
     * @return
     */
    public boolean CLIENT_SetChannelCfg(LLong lLoginID, Pointer pInParam,Pointer pOutParam, int nWaitTime);


    /**
     * 获取通道参数, pInParam 和pOutParam 资源由用户申请和释放
     * @param lLoginID 登录句柄
     * @param pInParam 入参 {@link com.cf.forward.dh.lib.structure.NET_IN_GET_CHANNEL_CFG}
     * @param pOutParam 出参{@link com.cf.forward.dh.lib.structure.NET_OUT_GET_CHANNEL_CFG}
     * @param nWaitTime
     * @return
     */
    public boolean CLIENT_GetChannelCfg(LLong lLoginID, Pointer pInParam,Pointer pOutParam, int nWaitTime);


    /**
     * 交通灯信号检测-获取相机信息, pInParam 和pOutParam 资源由用户申请和释放
     * @param lLoginID 登录句柄
     * @param pInParam 入参 {@link com.cf.forward.dh.lib.structure.NET_IN_GET_CAMERA_INFO}
     * @param pOutParam 出参{@link com.cf.forward.dh.lib.structure.NET_OUT_GET_CAMERA_INFO}
     * @param nWaitTime
     * @return
     */
    public boolean CLIENT_GetCameraInfo(LLong lLoginID, Pointer pInParam, Pointer pOutParam, int nWaitTime);




    /**
     * 主动获取每个热成像点的像素温度
     * @param lLoginID 登录句柄
     * @param pstInParam 入参 {@link com.cf.forward.dh.lib.structure.NET_IN_GET_HEATMAPS_INFO}
     * @param pstOutParam 出参{@link com.cf.forward.dh.lib.structure.NET_OUT_GET_HEATMAPS_INFO}
     * @param nWaitTime 接口超时时间,默认超时时间为 3000
     * @return
     */
    public boolean CLIENT_GetHeatMapsDirectly(LLong lLoginID, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);
    
    
    /******************************************************************************
    功能描述	:	透传扩展接口,按透传类型走对应透传方式接口，目前支持F6纯透传, 同时兼容CLIENT_TransmitInfoForWeb接口
    参数定义	:	
        lLoginID:       登录接口返回的句柄
        pInParam:       透传扩展接口输入参数
        pOutParam       透传扩展接口输出参数
        nWaittime       接口超时时间

    返 回 值	：	BOOL  TRUE :成功; FALSE :失败
    ******************************************************************************/
    /**
     * 
     * @param lLoginID
     * @param pInParam NET_IN_TRANSMIT_INFO
     * @param pOutParam NET_OUT_TRANSMIT_INFO
     * @return
     */
    public boolean CLIENT_TransmitInfoForWebEx(LLong lLoginID, Pointer pInParam, Pointer pOutParam, int nWaittime);
    
    // CLIENT_TransmitInfoForWebEx输入参数
    public static class NET_IN_TRANSMIT_INFO extends SdkStructure
    {
    	public int						    dwSize;                         // 用户使用该结构体，dwSize需赋值为sizeof(NET_IN_TRANSMIT_INFO)
    	public int		                    emType;                         // 透传类型
    	public String						szInJsonBuffer;                 // Json请求数据,用户申请空间
    	public int						    dwInJsonBufferSize;             // Json请求数据长度
    	public Pointer				        szInBinBuffer;                  // 二进制请求数据，用户申请空间
    	public int						    dwInBinBufferSize;              // 二进制请求数据长度
    	public int	                        emEncryptType;					// 加密类型(参考EM_TRANSMIT_ENCRYPT_TYPE)
   	   
   	 public NET_IN_TRANSMIT_INFO()
	 {
	     this.dwSize = this.size();
	 }// 此结构体大小
    }
    
    // CLIENT_TransmitInfoForWebEx输出参数
    public static class NET_OUT_TRANSMIT_INFO extends SdkStructure
    {
    	public int                   dwSize;                         // 用户使用该结构体时，dwSize需赋值为sizeof(NET_OUT_TRANSMIT_INFO)
    	public Pointer               szOutBuffer;                    // 应答数据缓冲空间, 用户申请空间
    	public int                   dwOutBufferSize;                // 应答数据缓冲空间长度
    	public int                   dwOutJsonLen;                   // Json应答数据长度
    	public int                   dwOutBinLen;                    // 二进制应答数据长度
       
       public NET_OUT_TRANSMIT_INFO()
  	 {
  	     this.dwSize = this.size();
  	 }// 此结构体大小
    }
    
    
    // 透传类型
    public static class NET_TRANSMIT_INFO_TYPE
    {
    	public static final int  NET_TRANSMIT_INFO_TYPE_DEFAULT=0;                 // 默认类型，即CLIENT_TransmitInfoForWeb接口的兼容透传方式
    	public static final int  NET_TRANSMIT_INFO_TYPE_F6=1;                      // F6纯透传
    };

    // 透传加密类型
    public static class EM_TRANSMIT_ENCRYPT_TYPE
    {
    	public static final int 	EM_TRANSMIT_ENCRYPT_TYPE_UNKNOWN = -1;			// 未知
    	public static final int 	EM_TRANSMIT_ENCRYPT_TYPE_NORMAL= 0;				// SDK内部自行确定是否加密，默认
    	public static final int 	EM_TRANSMIT_ENCRYPT_TYPE_MULTISEC= 1;				// 设备支持加密的场景下，走multiSec加密
    	public static final int     EM_TRANSMIT_ENCRYPT_TYPE_BINARYSEC= 2;			// 设备支持加密的场景下，走binarySec加密，二进制部分不加密
    }

    /**
     * 批量下载文件,pstInParam与pstOutParam内存由用户申请释放
     * 入参 NET_IN_DOWNLOAD_MULTI_FILE 出参 NET_OUT_DOWNLOAD_MULTI_FILE
     */
    public boolean CLIENT_DownLoadMultiFile(LLong lLoginID, Pointer pstInParam, Pointer pstOutParam, int waittime);

    //JNA Callback方法定义,断线回调
    public interface fMultiFileDownLoadPosCB extends StdCallCallback {
        public void invoke(LLong lDownLoadHandle, int dwID, int dwFileTotalSize, int dwDownLoadSize, int nError, Pointer dwUser, Pointer pReserved);
    }

    /**
     * 订阅摄像头状态,pstInParam与pstOutParam内存由用户申请释放
     * pstInParam->NET_IN_CAMERASTATE ; pstOutParam->NET_OUT_CAMERASTATE
     */
    public LLong CLIENT_AttachCameraState(LLong lLoginID, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);

    /**
     * 停止订阅摄像头状态,lAttachHandle是CLIENT_AttachCameraState返回值
     */
    public boolean CLIENT_DetachCameraState(LLong lAttachHandle);

    // CLIENT_AttachCameraState()回调函数原形, 每次1条,pBuf->NET_CB_CAMERASTATE dwSize == nBufLen
     public interface fCameraStateCallBack extends StdCallCallback {
        public void invoke(LLong lLoginID, LLong lAttachHandle, Pointer pBuf, int nBufLen, Pointer dwUser);
    }
     
     /**
      * 获取IPC设备的存储信息
      * @param lLoginID 登录句柄
      * @param pstInParam 入参 {@link com.cf.forward.dh.lib.structure.NET_IN_GET_DEVICE_AII_INFO}
      * @param pstOutParam 出参{@link com.cf.forward.dh.lib.structure.NET_OUT_GET_DEVICE_AII_INFO}
      * @param nWaitTime
      * @return
      */
     public boolean CLIENT_GetDeviceAllInfo(LLong lLoginID, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);

    // 交通信号灯回调函数 lLoginID - 登录句柄 lAttchHandle - 订阅句柄
    public interface fTrafficLightState extends StdCallCallback {
        public void invoke(LLong lLoginID, LLong lAttachHandle, Pointer pBuf, long dwUser);
    }

    /**
     * 订阅交通信号灯状态 , pInParam 和pOutParam 资源由用户申请和释放
     * @param lLoginID 登录句柄
     * @param pInParam 入参 {@link com.cf.forward.dh.lib.structure.NET_IN_ATTACH_TRAFFICLIGHT_INFO}
     * @param pOutParam 出参{@link com.cf.forward.dh.lib.structure.NET_OUT_ATTACH_TRAFFICLIGHT_INFO}
     * @param nWaitTime
     * @return
     */
    public LLong CLIENT_AttachTrafficLightState(LLong lLoginID, Pointer pInParam, Pointer pOutParam, int nWaitTime);

    /**
     * 退订交通信号灯状态
     * @param lAttchHandle 订阅句柄
     * @return
     */
    public boolean CLIENT_DetachTrafficLightState(LLong lAttchHandle);
    
    /**
     * 订阅雷达的报警点信息 , pInParam 和pOutParam 资源由用户申请和释放
     * @param lLoginID 登录句柄
     * @param pstInParam 入参 {@link com.cf.forward.dh.lib.structure.NET_IN_RADAR_ALARMPOINTINFO}
     * @param pstOutParam 出参 {@link com.cf.forward.dh.lib.structure.NET_OUT_RADAR_ALARMPOINTINFO}
     * @param nWaitTime
     * @return
     */
    public LLong  CLIENT_AttachRadarAlarmPointInfo(LLong lLoginID, Pointer pstInParam, Pointer pstOutParam, int nWaitTime);

    /**
     * 取消订阅雷达的报警点信息
     * @param lAttachHandle 订阅句柄
     * @return
     */
    public boolean CLIENT_DetachRadarAlarmPointInfo(LLong lAttachHandle);
    
    /**
     * 雷达报警点信息回调函数指针
     * @param pBuf {@link com.cf.forward.dh.lib.structure.NET_RADAR_NOTIFY_ALARMPOINTINFO}
     */
    public interface fRadarAlarmPointInfoCallBack extends StdCallCallback {
    	 public void invoke (LLong lLoginId, LLong lAttachHandle, Pointer pBuf, int dwBufLen, Pointer pReserved, Pointer dwUser);
    }

    /**
     * 查询系统状态(pstuStatus内存由用户申请释放)
     * @param lLoginID
     * @param pstInParam NET_SYSTEM_STATUS
     * @param nWaitTime
     * @return
     */
    public boolean CLIENT_QuerySystemStatus(LLong lLoginID, Pointer pstInParam, int nWaitTime);
    
    /**
     * 订阅云台元数据接口,pstuInPtzStatusProc与pstuOutPtzStatusProc内存由用户申请释放
     * @param lLoginID 登录句柄
     * @param pstInParam 入参 {@link com.cf.forward.dh.lib.structure.NET_IN_PTZ_STATUS_PROC}
     * @param pstOutParam 出参{@link com.cf.forward.dh.lib.structure.NET_OUT_PTZ_STATUS_PROC}
     * @param nWaitTime
     * @return 
     */
    public LLong CLIENT_AttachPTZStatusProc(LLong lLoginID,Pointer pstInParam, Pointer pstOutParam, int nWaitTime);
    
    /**
     * 停止订阅云台元数据接口,lAttachHandle是CLIENT_AttachPTZStatusProc返回值
     * @param lAttachHandle 订阅句柄
     * @return
     */
    public boolean CLIENT_DetachPTZStatusProc(LLong lAttachHandle);
    
    
    /**
     * 订阅云台元数据接口回调函数原型
     * pBuf 现阶段主要为 NET_PTZ_LOCATION_INFO 类型 {@link NET_PTZ_LOCATION_INFO}  
     */
    public interface fPTZStatusProcCallBack extends StdCallCallback {
    	 public void invoke (LLong lLoginId, LLong lAttachHandle, Pointer pBuf, int dwBufLen, long dwUser);
    }

    /**
     * 查询某月的各天是否存在录像文件,
     *
     * @param lLoginID
     * @param nChannelId
     * @param nRecordFileType EM_QUERY_RECORD_TYPE 的枚举值
     *        nRecordFileType == EM_RECORD_TYPE_CARD，pchCardid输入卡号，限制字符长度 59 字节
     *        nRecordFileType == EM_RECORD_TYPE_FIELD，pchCardid输入自定义字段，限制字符长度 256 字节
     * @param tmMonth Pointer -> NET_TIME
     * @param pchCardid Pointer -> byte[]
     * @param pRecordStatus Poiter -> NET_RECORD_STATUS
     * @param waittime
     * @return boolean
     */
    public boolean CLIENT_QueryRecordStatus(LLong lLoginID, int nChannelId, int nRecordFileType, Pointer tmMonth, Pointer pchCardid, Pointer pRecordStatus, int waittime);
   //设置SDK本地参数,在CLIENT_Init之前调用，szInBuffer内存由用户申请释放，里面存放被设置的信息，具体见NET_EM_SDK_LOCAL_CFG_TYPE类型对应结构体
    boolean CLIENT_SetSDKLocalCfg(int emCfgType, Pointer szInBuffer);

    /**
     * 开启重定向服务扩展接口
     * @param pInParam {@link NET_IN_START_REDIRECT_SERVICE}
     * @param pOutParam NET_OUT_START_REDIRECT_SERVICE,空结构体,可使用{@link EmptyStructure}
     * @return
     */
    LLong CLIENT_StartRedirectServiceEx(Pointer pInParam,Pointer pOutParam);
    /**
     * 停止重定向服务
     * @param lServerHandle 服务句柄
     * @return
     */
   boolean CLIENT_StopRedirectService(LLong lServerHandle);

  /**
   * 设置重定向服务器的IP和Port
   * @param lDevHandle 重定向设备句柄
   * @param ARSIP 重定向设备IP
   * @param ARSPort 重定向设备端口
   * @param nRetry 设备主动注册尝试次数
   * @return
   */
  boolean CLIENT_SetAutoRegisterServerInfo(LLong lDevHandle, String ARSIP, short ARSPort, short nRetry);
  
  public boolean CLIENT_DownloadPieceFile(LLong lLoginID, Pointer pInParam, Pointer pOutParam,int nWaitTime);
  
  // 清除当前时间段内人数统计信息, 重新从0开始计算
  //CLIENT_ControlDevice接口的 DH_CTRL_CLEAR_SECTION_STAT命令参数
  public static class NET_CTRL_CLEAR_SECTION_STAT_INFO extends SdkStructure
  {
      public int                     dwSize;
      public int					   nChannel;		// 视频通道号
      public NET_CTRL_CLEAR_SECTION_STAT_INFO(){
          this.dwSize = this.size();
      }
  }

    /**
     * 获取设备点位信息
     * @param lLoginID 登录返回ID
     * @param pInParam NET_IN_SCADA_GET_ATTRIBUTE_INFO
     * @param pOutParam NET_OUT_SCADA_GET_ATTRIBUTE_INFO
     * @param nWaitTime 超时时间
     * @return
     */
    boolean  CLIENT_SCADAGetAttributeInfo(LLong lLoginID, Pointer pInParam, Pointer pOutParam, int nWaitTime);
}



